*************************************************************************
* >Redraw - Documentation for the ZapRedraw module v0.39		*
*************************************************************************

Summary:
--------

The module ZapRedraw provides the "ZapRedraw_" SWI's which are capable of
drawing a rectangle of text characters on screen. It offers the following
features:

* Redraw may be by direct screen access (henceforth DSA) where the
  data is poked into the screen memory or by the standard VDU redraw.
  
* Full colour provided (with your own definable palette). Supports up to 32
  bits per pixel in DSA mode and 24 bit colour in VDU mode.

* DSA redraw can handle any size of bitmap characters. Special optimised
  code is provided for 8 pixel wide characters in all modes.
  Also 8*8 and 8*16 character sizes are given priority.
  Up to 65536 characters can be defined.
  
* VDU redraw mode can handle any font, at any size and aspect ratio.

* Support is provided for cursors.

* Many extra SWIs perform all the work of creating cached bitmaps, updating
  them on a mode change etc. SWI's are also provided for creating palettes
  and other functions related to the redraw.

* An example program is provided which can be used as a template.
  
Limitations:

* All characters are equally spaced. Proportional spacing is not supported.

Copyright:
----------

The ZapRedraw module is copyright Dominic Symes 1994-1997. Please contact
him if you wish to use it in a program other than Zap. See the Zap Copyright
file for his address.

Definitions required for the SWI's
==================================

ZapRedraw chunk prefix: ZapRedraw
ZapRedraw chunk number: &48480

All SWI numbers below are given as offsets from the chunk number.

'DSA' means direct screen access mode (characters poked into the screen).
'VDU' means VDU mode (operating system called to draw characters).

Pixel co-ordinates are used wherever possible to prevent rounding errors when
OS co-ordinates are not pixel aligned (these errors DO mess things up!).
Pixel co-ordinates are from the top left of the screen with the y axis
descending. By a 'pixel' I mean a hardware pixel (this differs from an OS
pixel in double-pixel emulation modes - this only crops up in the RISC OS 2
MODE 2 wimp!).

Zap redraw block:
-----------------

For several SWI's, R1 points to a redraw block of the type described below.
The SWI documentation will mention which data in the block is actually used
by that SWI (so should be filled in). Each offset in the block is named with
a name beginning 'r_'. The BASIC program E-Library contains a procedure to
set these variables up should you be using the BASIC assembler. The contents
of some offsets depends on which redraw mode is being used (VDU or DSA), this
is indicated by 'VDU:' and 'DSA:'.

Offset	Name		Function

&00	r_flags		Flags word determining the type of redraw:
			b0 Clear for DSA mode. Set for VDU redraw mode.
			b1 Set for 'double height mode'. Only valid in DSA
			   mode. Draws each raster twice so actual character
			   height is 2*r_charh and spacing 2*r_linesp.
			b2 Extension routine provided.
			   Only valid in DSA mode. See ZapRedraw_RedrawArea.
			b3 Set if using the multiple font protocol.
			   See ZapRedraw_RedrawArea.
			b4 Set if it is OK to use the fast rectangle plot in
			   VDU redraw mode (i.e. output is not redirected
			   to a sprite or a printer.)
			b3-31 Reserved - set to zero.
&04	r_minx		Min x of redraw (pixels from lhs - inclusive)
&08	r_miny		Min y of redraw (pixels from top - inclusive)
&0C	r_maxx		Max x of redraw (pixels from lhs - exclusive)
&10	r_maxy		Max y of redraw (pixels from top - exclusive)
&14	r_screen	DSA: Address of screen to write to or 0 to read the
			     current screen address.
			VDU: ignored
&18	r_bpl		DSA: Bytes per raster line of the screen
			VDU: ignored
&1C	r_bpp		Log base 2 of number of bits per pixel
			(ie 0=2 cols 1=4 cols 2=16 cols 3=256 cols
			4=65536 cols 5=2^32 cols).
&20	r_charw		Width of a character in pixels
&24	r_charh		Height of a character in pixels
&28	r_caddr		DSA: Address of character cache (format below)
			VDU: Pointer to font name or 0 for system font
&2C	r_cbpl		DSA: Number of bytes per cached character line.
			VDU: x os offset of where to print the font char
			     in the character 'box'. (eg 0 for system font)
&30	r_cbpc		DSA: Number of bytes per cached character.
			VDU: y os offset of where to print the font char
			     in the character 'box'. (eg char height-1 for
			     system font as VDU5 plots char downwards).
&34	r_linesp	Line spacing in pixels.
&38	r_data		Address of data (rectangle of characters) to print
			on the screen (format below).
&3C	r_scrollx	Horizontal scroll offset in rectangle of characters
			given in r_data of top left of redraw rectangle.
			This is in pixels from the lhs of the characters.
			Thus it equals n*r_charw+m where n is the number of
			characters in and m is the number of pixels into
			the n'th character.
&40	r_scrolly	Vertical scroll offset in rectangle of characters
			given in r_data of top left of redraw rectangle.
			This is in pixels from the top of the characters.
			Note that in single height mode each line is
			r_charh+r_linesp pixels high and in double height
			mode each line is 2*(r_charh+r_linesp) pixels high.
&44	r_palette	Address of palette to be used for colour translation.
			(see below).
&48	r_for		Foreground colour to use at the start of a line as an
			offset in the palette table.
&4C	r_bac		Background colour to use at the start of a line as
			an offset in the palette table.
&50	r_workarea	Pointer to an area of workspace for the SWI to use.
			The size of this workspace depends on the SWI.
			(It must be word aligned).
&54	r_magx		Log base 2 of number of x os co-ords per pixel.
&58	r_magy  	Log base 2 of number of y os co-ords per pixel.
&5C	r_xsize		Width of screen in pixels.
&60	r_ysize		Height of screen in pixels.
&64	r_mode		Current screen mode.

Character cache format (r_caddr):
---------------------------------

When using VDU redraw, this should point to the name of the font to use, or
be zero for the system font.

When using direct screen access, the module will expect this block to contain
the bitmaps for all the characters it is asked to print. Each character has
size r_cbpc so it will expect to find the bitmap for ASCII character 'n' at
address char_start=(!r_caddr)+n*r_cbpc. The character definition then
consists of r_charh rows of r_cbpl each so r_cbpc=r_charh*r_cbpl. NB r_cbpl
need not be a multiple of 4 so this address need not be word aligned.

The format of a row is the same of that for a sprite file except there is
never any lhs wastage. Ie, the first pixel is aligned to the start of the
first word. Each character is r_charw pixels wide and thus requires
N=r_charw<<r_bpp bits of storage. There are special cases when N is small:

 If 0<N=<8  then r_cbpl=1 and the top 8-N bits of each byte are wasted.
 If 8<N=<16 then r_cbpl=2 and the top 16-N bits of each byte are wasted.
 If N>16    then r_cbpl is aligned to the next multiple of 4 bytes greater
  or equal to N. (eg 16<N=<32 => r_cbpl=4, 32<N=<64 => r_cbpl=8 etc).
  
The SWI ZapRedraw_CachedCharSize will calculate the values of r_cbpl and
r_cbpc for you from a given size of character.

Only TWO colours can be used in the defn of the character. Set all foreground
pixels to 1's and background pixels to 0's. Eg, in a 16 colour mode pixels
will be either 1111 or 0000. Unused bits at the end of the words (or bytes)
are ignored and so can contain rubbish. The real foreground and background
colours are masked in at run time.

 Examples:

 For 8*8 characters at 1 bit per pixel we have 1 byte per row. Eg "E" may be
 cached as:
				b0 .. b7
	row0	&7E		01111110
	row1	&06		01100000
	row2	&06		01100000
	row3	&7E		01111110
	row4	&06		01100000
	row5	&06		01100000
	row6	&7E		01111110
	row7	&00		00000000
 
 If it was in a 16 colour mode then there would be one word per row and the
 first rows would be:
				b0 ......................... b31
	row0	&01111110	00001111111111111111111111110000
	row1	&00000110	00001111111100000000000000000000
	...
	
 In general you have:
 
	Word 0					Word (N/4)-1
	b0 .... b31    ...................      b0 ..... b31
	pix0 pix1 ......................pix(r_charw-1) 00000
	
In practice you first cache the font at one bit per pixel (eg use
ZapRedraw_ReadSystemChars) and then convert it to 'n' bits per pixel (for the
current mode) by use of ZapRedraw_ConvertBitmap.

Although I have said that the foreground colour must be all 1's and the
background all 0's this is not strictly true. The data poked into the screen
memory is (foreground mask AND bitmap) OR (background mask BIC bitmap). Thus
if you have a foreground mask of &FFFFFFFF and a background mask of 0 then
the bitmap will be poked directly into the screen so can have any format you
like (though character merging and several other features may not work
properly). This idea can be used in conjunction with ZapRedraw_CacheFontChars
to create a fast redraw mode for anti aliased fonts (as used in Zap).

Format of text to display (r_data):
-----------------------------------

This block contains the text to be printed on the screen. There should be
sufficient text here to redraw the specified area of the screen (given its
size, the scroll offset, character sizes etc). Terminating each line with
the bytes 0,2 will ensure the redraw doesn't run out of text horizontally and
terminating the line list with a zero will ensure the same vertically. The
value in r_data points to a list of words. The n'th word in the list is the
offset (from the block data start) of the n'th line of text to be printed in
the window. This list can be terminated by a 0 offset in which case all
further lines will be cleared to background colour (r_bac).

The data for each line consists of a string of bytes giving the characters to
print. By character number 'n' will I mean the n'th (n starting from 0)
bitmap in your character cache in DSA mode or the character with ASCII code
'n' in VDU redraw mode. The Redraw module does not limit n to the range 0-255
but also allows higher values. Currently you can access 0-65535. Of course,
ASCII characters for the codes 0-31 and 256-65535 are not defined. Zap treats
these specially - see below.

The byte 0 in the data for a line introduces a control code. Bytes 1-255 just
print characters n=1-255 as normal so you will need to use control codes to
access characters > 256. The currently defined control sequences are:

 0,0		Prints character n=0.
 0,1,f,b	Switch colour to foreground f and background b. (f/b are
		palette offsets - see r_for/r_bac).
 0,2		End of line - the rest of the line is cleared to the current
		background colour.
 0,3,l,h	Print character n=l+h*256.
 0,4,f,b,x,y	Merges the characters x,y. If a pixel is clear in the bitmap
		for y then the pixel is drawn according to the bitmap for x
		and the current for/background colours. If the pixel is
		set for y then the colours f/b are used instead for the x
		pixel. Useful for laying a cursor on top of the character.
		This effect is simulated in VDU mode by using sprites and
		masks. This leaves the current foreground and background
		colours unaltered. NB x and y may contain control codes as
		well. Eg you could have x=0,0 and y=0,3,0,1. If you nest,
		0,4 codes (ie either x or y contain 0,4) then only the most
		deeply nested one will have effect.
 0,5		For internal use only. Restores the stacked values after a
		0,4 call. Putting this in your input string will probably
		cause a crash.
 0,6,f		Change foreground colour to f.
 0,7,b		Change background colour to b.
 0,8,f,b,x,y	Cursor merge of characters x,y. This is similar to 0,4 but
		only works for characters &7F,&100-&105. For &7F, it masks
		in the block simply by changing the for/bac cols of the
		current character being printed. For &100+, the square or
		line is plotted over the top of the character in the
		background colour b.
 0,9,F		Font change to font type F.
 0,10,f,b,F	Switch colour to foreground f and background b, and font
		to font type F.

Note that sequences with codes 0,3,4 evaluate to one 'screen printable
character', code 1 to none, and code 2 to as many as is required. Thus it is
not a simple matter to calculate the start of the n'th actual printable
character given a string containing control codes as above. The SWI
ZapRedraw_FindCharacter does this for you.

In DSA mode character 'n' just looks up the cached character at address
r_caddr+n*r_cbpc. Usually the bitmaps will correspond to the VDU list
below so that character &20 will be the bitmap for a space etc.
 
In VDU mode character 'n' is interpreted as below:

  &00		Prints a '0' (ASCII &30)
  &01-&1A	These print the letters A-Z (ie &40 is added)
  &1B-&1F	Prints "[ \ ] ^ _" respectively (ie &40 is added)
  &20-&7E	Usual ASCII characters printed.
  &7F		This draws a filled in block (useful for a cursor)
  &80-&FF	Usual ASCII characters printed.
  &100		This draws the top,bottom,left edges ie '['.
  &101		This draws the top,bottom edges.
  &102		This draws the top,bottom,right edges ie ']'.
  &103		This draws an empty square (useful for a cursor)
  &104		This draws the baseline ie '_' (useful for a cursor)
  &105		This draws the left edge giving a vertical bar.
  &106+		Undefined action (prints an @ for debugging purposes)
		(More codes may be added in future).
  
The characters are drawn using OS_WriteN/OS_WriteC/OS_Plot (or Font_Paint if
not using the system font).

Use ZapRedraw_FindCharacter to jump over the control codes. Use
ZapRedraw_PrepareDataLine to automatically generate the r_data lines from
normal text with foreground and background colour masks. Use
ZapRedraw_AddVduBitmaps to create the bitmaps for character codes 0-&1F,&7F
and >=&100.

When using font sub-styles, please note that VDU redraw mode currently only
supports sixteen sub-styles.  It expects bits 0, 5, 6 & 7 to be used for
strikethrough, bold, italic and underlined fonts respectively.
DSA mode doesn't use this convention: you need to change font in an
extension routine there.  DSA redraw allows up to 256 sub-styles to be used.

Rendering of bold, italic and bold italic sub-styles has some technical
difficulties associated with the fact that these fonts tend to have different
sized bounding boxes from the default font at the same point size and aspect
ratio.  No attempt is currently made to compensate for this.

Format of palette data (r_palette):
-----------------------------------

All colours are specified as offsets in the palette table. Thus if you set
r_for to 1 then the module will look up the word at offset 4*1 in the palette
table when it comes to printing a character.

DSA MODE: The palette consists of a list of words giving the colour 'mask' to
use for this colour. The mask is duplicated to fill the word out. For
example, in a 16 colour mode, the mask &AAAAAAAA would stand for actual
screen colour 10. The table:

		&33333333
		&66666666
		&AAAAAAAA
		&00000000

would cause 3 to be poked into the screen when in zap colour 0, 6 when in
zap colour 1 etc. The masks will usually correspond to the wimp colours. The
SWI ZapRedraw_CreatePalette is provided to set them up.

The actual value poked into the screen is: (Foreground mask AND bitmap) OR
(Background mask BIC bitmap) where the bitmap is as specified in r_caddr.

VDU MODE: The palette consists of a list of words giving the 24 bit colour
required. The word is in the form of a standard palette entry. Ie, &BBGGRRxx
where &BB is the amount of blue etc. These will usually be set up by reading
the wimp palette. The SWI ZapRedraw_CreatePalette will do this for you.
ColourTrans calls will be used during the redraw to find the closest
available GCOL colour.

*****************************************************************
* SWI Definitions						*
*****************************************************************

None of the SWI's are re-entrant unless explicitly mentioned. All the SWI's
corrupt R0 and flags and can produce errors.

ZapRedraw_RedrawArea (+&00)
---------------------------

This redraws a rectangle of characters on the screen.

Entry:	R1=redraw block (as described above).
	All defined offsets in the redraw block are used.
	
	In VDU mode r_workarea must be at least 64 bytes+the amount needed
	 for a sprite of one character - see ZapRedraw_SpriteSize.
	 If using fonts then the first word of the workarea should contain:
	     Lower 16 bits:font size to plot at (points)
	     Upper 16 bits:font aspect ratio to use (=Y/Xx100) (or 0)

	In DSA mode r_workarea must be at least 64+r_cbpl bytes (and a
	 whole number of words long).
	 If b2 of the r_flags word is set then you provide an extension
	 routine and:
	  R2=address of the routine
	  R3=private word value to pass to the routine.

Exit:	R0 and flags corrupted.

The extension routine is provided so you can trap unknown control codes and
add extra functionality to the ones that exist. For example, you may wish to
change font on a colour change. Zap's fast font redraw mode does this. If you
provide an extension routine then on entry to it R0=reason code R12=your
private word and:

 R0=0 => Starting a raster line:
	 R1=redraw block
	 R3=address of first character
	 R4=r_caddr+r_cbpl*row where row (0 ... r_charh-1) is the current
	    character row being drawn. Or, R4=0 if in line spacing.
	 R5=screen address of current word being written
	 R6=bit offset in current word being written
	 R7=current word being writen (bits >= R6 are clear)
	 R9=foreground/background colour numbers:
	    foreground:bottom sixteen bits, background: top sixteen bits.
	 R10=start foreground mask (eg &77777777)
	 R11=start background mask (eg &00000000)

 R0=1 => Foreground and background colours changing (control code 0,1)
	 Registers as above (except R9 not set up) with R3=next character
	 after the control code and R10,R11 new foreground/background masks
	 etc.

 R0=4 => About to merge characters (control code 0,4)
	 R1=redraw block
	 R2=character defn table to use for the mask character
	 R3=next character after the merge
	 R4=character defn table for the base character (as for R0=1)
	 R6=base char
	 R7=mask char (or these are -1 if invalid).
	 R8/R9=for/bac masks where mask character bits set.
	 R10/R11=current for/bac masks.
	 NB Any changes you make to these registers will be effective for
	 this one character only the normal values being stacked.

 R0=6 => Foreground colour changing (control code 0,6)
	 Registers as for R0=1.

 R0=7 => Background colour changing (control code 0,7)
	 Registers as for R0=1.

 R0=8 => About to cursor merge characters (control code 0,8)
	 Registers as for R0=4
	 If R7<&100 then R10/R11 will be set to R9/R8 and next char drawn
	 If R7>=&100 then the characters will be merged with R9
	 copied into R8.

 R0=9 => Font change
	 Registers as for R0=1

 R0=10=> Foreground colour, background colour and font change
	 Registers as for R0=1
	 
	 Note that if changing font during redraw, then this must be done
	 in an extension routine for DSA redraws.

 R0=2,3,5,>10	 Reserved - ignore.
 
 Exit:  You may corrupt R0 and R12 and alter the registers mentioned
	(except R1!) to new (sensible) values.
	All registers are reset at the start of a new raster line.
	You must not alter the redraw block itself.
	You CANNOT return errors from an extension call.

ZapRedraw_GetPaletteEntry (+&01)
--------------------------------

This SWI takes a colour bitmap and duplicates it to fill a word, creating
a mask as needed for r_palette in DSA mode. Eg if R0=7 and R1=2 on entry then
R0=&77777777 on exit.

Entry:	R0=The colour number to be poked into the screen. (0->num_of_cols-1)
	R1=r_bpp (0-5)

Exit:	R0=Mask to put in palette table (with colour duplicated to fill the
	word).

ZapRedraw_RedrawRaster (+&02)
-----------------------------

Redraws a single raster line. Only applies to non-vdu redraw. This is a low
level call used by ZapRedraw_RedrawArea and not of much use otherwise.

Entry:	R1=redraw block
           Offsets used are: r_flags,r_minx,r_maxx,r_bpp,r_charw,r_charh
            r_cbpl,r_cbpc,r_palette,r_workarea.
	R3=address of text to use for this line starting at the first
	   visible character.
	R4=address of character defn table with row offset added so redraw
	   uses first 'row' of each bitmap, or set to 0 if you want the
	   line to be cleared to the background colour (eg interline gap).
	R5=screen address of the start of the raster line.
	R6=b0-b15	= start foreground colour to use (eg r_for value)
	   b16-b24	= start background colour to use (eg r_bac value)
	   b24-b31	= starting font
	The initial words of r_workarea are set up as follows:
	#0 Pixel scroll offset within the first visible char (0->charw-1)
	#4 Number of pixels to do from the first character   (0->charw-1)
	#8 Number of whole characters to do after the first char
	#12 Number of pixels to do in the last visible char  (0->charw-1)
	#16 -
	#20 Address of extension sub if redraw flags bit 2 set
	#24 Extension sub private word pointer redraw flags bit 2 set

Exit:	R0 and flags corrupted.

ZapRedraw_ConvertBitmap (+&03)
------------------------------

This SWI takes a character bitmap of the form of 1 bit per pixel, (the bit
set for foreground/clear for background) and converts it into a bitmap for
use by the RedrawArea SWI, by changing each '1' to n '1's and each '0' to
n '0's where 'n' is the number of bits per pixel given. It uses the SWI
ZapRedraw_ConvBitmapChar to do this.

Entry:	R1=redraw block, offsets looked at are:
	r_bpp		To find the number of bits per pixel.
	r_charw		Width of char in pixels
	r_charh		Height of char in pixels
	r_caddr		Address to write the bitmap. Memory at offsets
			R2*r_cbpc to (R3+1)*r_bpc must be preserved
	r_cbpl		Cache line width in bytes (as defined under
			r_caddr help text)
	r_cbpc		Number of bytes per cached character (as defined
			under r_caddr help text)
	R2=First character to be converted (eg 0)
	R3=Last character to be converted (inclusive) (eg 255)
	R4=Address of source bitmap of the format described under r_caddr
	   but with 1 bit per pixel (ie 2 colour mode format)

Exit:	r_caddr block written to.
	R0 and flags corrupted.

ZapRedraw_PrepareDataLine (+&04)
--------------------------------

This SWI is to help prepare the 'r_data' field of the redraw block. It takes
as input the pointer to a line of text character (0-255) to be treated as
ordinary characters (0 is not a control code). It also takes as input a
pointer to a background mask and a foreground mask list, giving the
background and foreground colours of each character separately. The output is
a line of the format required by 'r_data' with control codes changing the
colours and specifying the line end. Control codes in the input string can
have their colour set automatically by setting R0 to the colour.

Eg: Input:

	Text input (characters): "HELLO WORLD         "
	Foreground (bytes list):  11111122222222222222
	Background (bytes list):  00000000000000000000
	Start background 0
	Start foreground 1
	Input length 20

    Output: "HELLO ",0,1,2,0,"WORLD",0,2 (highest letter used = "W").

Entry:	R0=foreground colour to use for control characters (0-&1F) or
	   set to -1 if you do not wish ctrl chars to be specially treated.
	R1=redraw block giving start foreground background colours in
	   r_for,r_bac - nothing else used.
	R2=pointer to text input string (length in R5)
	R3=pointer to foreground mask (length in R5)
	R4=pointer to background mask (length in R5)
	R5=length of inputs in bytes
	R6=destination buffer (length must be at least 6*R5+16 to ensure
	   it is big enough - colour change + 0 -> 0,0 + terminator).
        R7=font mask... (not supplied if b3 of r_flags is zero)

Exit:	R0=highest used character code used (ie &20-&FF). You may not
	want to cache all font characters as usually those >= 128 are not
	needed. This tells you the range you MUST cache.
	R5=length of output string (including 0,2 terminator)
	Only a subset of the the redraw codes available are used.
Note:   Bit 3 of any font data supplied is used to control the
	'Inverse video' effect.  While this bit is set, foreground and
	background colours are swapped over in all operations.

ZapRedraw_AddCursor (+&05)
--------------------------

This SWI takes a line of the same format used in 'r_data', eg the output from
the above SWI, and adds in the codes to place 'cursors' over some of the text
by using the code 0,4 (merge characters) or the code 0,8 (merge cursors).
Here, a cursor means a string of characters to be overlayed.

Note that there is now a more sophisticated version of this call,
ZapRedraw_AddCursorSmart, which can cope with selections containing characters
that have a different foreground colour (but the same background colour) to
the rest of the selection.

 Entry:	R0=destination string
	R1=redraw block giving initial r_for and r_bac.
	R2=offset in source string of first character to be in the cursor
	R3=cursor length (length in characters of string pointed to by R4)
	R4=pointer to string of cursor characters (usually &7Fs)
	R5=source string (0,2 terminated)
	R6=swap colour/-1 if none. If the character having the cursor placed
	   over it has this foreground colour then the cursor bac/foreground
	   cols are swapped over (eg in a selected region).
	R7=b0-b7   high byte to use for cursor characters in R4 string
	   b8-b15  control code to use when merging ie 4 or 8.
	   b16-b23 foreground colour of the cursor
	   b24-b31 background colour of the cursor
	Room should be reserved for the string to grow by 8*R3
	characters. (eg 0,4,f,b,old,0,3,l,h) If the indicated offset (R2)
	is off the end of the string then it will be lengthened with spaces
	(&20) so you should ensure R2+9*R3 characters extra are reserved.
	
 Exit:	R0=end of new destination string (after 0,2 terminator)
 
ZapRedraw_FindCharacter (+&06)
------------------------------

This SWI takes as input a line of the format required by 'r_data' (ie
containing ctrl sequences starting with 0) and a number 'n' and returns the
start of the (n+1)'th printable character within this line (ie it skips over
n printable characters), ignoring colour change control codes etc. Thus on
exit it points to a byte 1-255 or one of the control sequences 0,0 or 0,2 or
0,3,l,h or 0,4,f,b,c1,c2 each of which define one printable character. If the
offset n is off the end of the line then it will point to the 0,2 terminator.
It also keeps track of the colour changes that take place. NB If n=0 then it
may still be useful - as it will jump over any colour changes before the
first character. If R0>R1 on exit then the character was found, otherwise
there were R1-R0 characters left to skip.

Eg: Input:	"hello ",0,1,2,3,"goodbye",0,2
    Output:	If n=0 then it will point to the 'h'
		If n=6 then it will point to the 'g'
		If n=100 then it will point to the 0 of 0,2.
 
 Entry:		R0=n (number of characters to skip)
		     (or -1 to move to the end of the string - find its len)
		R1=pointer to the input string (terminated by 0,2)
		R2=current foreground colour
		R3=current background colour
		
 Exit:		R0=If the n'th character is in the string then this points
		    to the end of the n'th character (start in R1)
		   If the n'th 'character' is the terminator (0,2) then this
		    equals R1 (start of the terminator)
		   If it reached the string terminator before the n'th
		    character then this is R1-number of chars not skipped
		R1=start of the next printable character after skipping n.
		   (or string terminator if reached that first).
		R2-R3 updated by any colour change control codes.
		Flags corrupted.

ZapRedraw_MoveBytes (+&07)
--------------------------

This is a fast byte shifting SWI. Highly optimised and bytes are shifted
starting at the top or bottom depending on whether the destination address is
higher or lower than the start (respectively). Thus the data is always
preserved.

 Entry:		R1=source address (need not be word aligned)
		R2=destination address (need not be word aligned)
		R3=number of bytes to move (>=0)
 
 Exit:		R0-R3 and flags corrupted.

ZapRedraw_CachedCharSize (+&08)
-------------------------------

This SWI works out the values of r_cbpl,r_cbpc from r_charw,r_charh,r_bpp in
the manner defined under the help text on r_caddr. Ie, r_cbpl is either 1,2,
or a multiple of 4 and r_cbpc=r_charh*r_cbpl.

 Entry:		R0=r_bpp value
		R2=r_charw value
		R3=r_charh value
		
 Exit:		R2=number of bytes per cache line (r_cbpl)
		R3=number of bytes per cached character (r_cbpc)

ZapRedraw_ConvBitmapChar (+&09)
-------------------------------

This SWI is for the use of the ConvertBitmap SWI and performs the bitmap
conversion for one character. It takes a bit map of the one bit per pixel
format and expands it to have n=2^R7 bits per pixel by replacing each '0'
with n '0's and each '1' with the mask in R6 (usually n '1's). Thus for
standard conversion you should set R6 to be 2^n-1 (=2^(2^R7)-1). (NB if R7
(=r_bpp) is zero then all you have to do is copy the bitmap. R7=0 is not
supported by this call.

 Entry:		R1=redraw block (only r_charh is used to find the height of
		   the character in pixels).
		R2=bytes per cache line for the source character (1,2,*4)
		R3=bytes per cache line for the dest character (1,2,*4)
		R4=pointer to source character bitmap
		R5=address to place destination character bitmap
		R6=bit mask to insert in place of 1's (only bottom 2^R7 bits)
		R7=Log_2 of number of bits per pixel (1-5)
 
 Exit:		R4 and R5 updated to the start of the 'next' characters.
		R0 and flags corrupted.

ZapRedraw_CreatePalette (+&0A)
------------------------------

This SWI is used to create the r_palette data block. If R0=1 on entry then it
takes a palette consisting of a list of wimp colour numbers (one per word)
and converts it to entries of the form &BBGGRRxx, a 24 bit palette entry by
using the call Wimp_ReadPalette and duplicating the nibbles. If R0=2 on entry
then it takes a list of entries of the form &BBGGRRxx and converts them to
colour masks required for DSA redraw (see r_palette) using ColourTrans calls
and ZapRedraw_GetPaletteEntry. If R0=3 on entry then it does both, converting
wimp colour numbers to DSA redraw masks.

 Entry:		R0=reason code:
		     b0 Set to convert wimp cols to &BBGGRRxx
		     b1 Set to convert &bbggrrxx to DSA colour masks
		     b2+ reserved - set to 0
		R1=redraw block. The following are used:
		   r_bpp      = log_2 of bits per pixel
		   r_workarea = pointer to 128 byte work area to load wimp
		   		palette into.
		R2=address of source palette
		R3=address for dest palette (needs 4*R4 bytes preserved)
		   (source may equal destination)
		R4=number of palette entries (eg 16)

 Exit:		R0 and flags corrupted.

ZapRedraw_InsertChar (+&0B)
---------------------------

This inserts a single character into a string of r_data format. If R0=0 then
it inserts 0,0 and if R0>=&100 then it inserts 0,3,x,y where R0=&yyxx.
Otherwise it just inserts the byte as normal.

 Entry:		R0=character
		R1=string address
		
 Exit:		R1 updated 'till after the character
		R0 and flags corrupted.

ZapRedraw_ReadSystemChars (+&0C)
--------------------------------

This reads the standard system characters bitmaps via OS_Word calls. It reads
them in 1 bit per pixel (8 bytes per character) form suitable for
ZapRedraw_ConvertBitmap to convert it to a form usable for
ZapRedraw_RedrawArea. To do this, it just bit-reverses the information read
by OS_Word,10. It only reads characters &20-&FF, leaving 0-&1F untouched. The
bit reversing is done efficiently so this call is fairly fast.

 Entry:		R0=buffer for bitmap (size 8*256=&800=2k)
		R1=redraw block. r_workarea must be a 16 byte work area.
		
 Exit:		R0 and flags corrupted.

ZapRedraw_ReverseBitmaps (+&0D)
-------------------------------

This SWI takes a list of bytes and reverses the bits of each byte. This is
useful for reversing the bitmaps (flipping about the y axis) of 8*8 pixel
characters at one bit per pixel (ie r_cbpl=1 r_cbpc=8).

 Entry:		R1=source buffer
		R2=destination buffer (can equal source)
		R3=number of bytes (must be a multiple of 4)
 
 Exit:		R0 and flags corrupted.

ZapRedraw_ReadVduVars (+&0E)
----------------------------

This SWI is used to set up the Zap redraw block initially. It puts the value
0 in r_screen so the actual screen address is used when ZapRedraw_RedrawArea
is called (this can change quite often) and fills in r_bpl, r_bpp, r_magx,
r_magy, r_xsize, r_ysize by using the call OS_ReadVduVariables. It also fills
in r_mode by using OS_Byte 135. This call should be made after any mode
change. Compensation is made for double pixel modes by decreasing r_magx. A
pixel in Zap means a hardware pixel rather than an emulated double pixel.

 Entry:		R1=redraw block to update
		   r_workarea should point to a 64 byte scratch area.
 
 Exit:		R0 and flags corrupted.

ZapRedraw_GetRectangle (+&0F)
-----------------------------

This SWI should be used after calls to Wimp_GetRectangle. It takes the redraw
rectangle block as returned by Wimp_RedrawWindow or Wimp_GetRectangle and
uses it to fill in the ZapRedraw block. The scroll offsets of the update
rectangle are in pixels. The y scroll offset is the amount 'down' from the
work area origin (inclusive), so negating will get the 'upward' scroll
offset in pixels (exclusive), and the shifting by r_magy will give the
normal OS work area scroll offset (which is exclusive).

 Entry:		R0=block as returned by Wimp_RedrawWindow/Wimp_GetRectangle
		   ie: window handle,minx,miny,maxx,maxy,scrollx,scrolly etc
		R1=Zap redraw block with r_magx,r_magy,r_xsize,r_ysize
		   filled in.
 
 Exit:		r_minx,r_miny,r_maxx,r_maxy,r_scrollx,r_scrolly have been
		filled in in the redraw block pointed to by R1.
		R0 and flags corrupted.

ZapRedraw_AddVduBitmaps (+&10)
------------------------------

If you look at the VDU codes, you will see that characters 0-&1F,&7F,&100+
are treated specially during a VDU redraw, drawing blocks and squares. The
purpose of this SWI is to create bitmaps for these extra characters from a
standard bitmap of the normal characters, so you can also use these in a DSA
redraw. You specify an interval of characters, and in that interval, it
creates bitmaps for the following:

	&00	Creates bitmap for '0' by copying bitmap &30
	&01-&1F Creates bitmap for 'AB...' by copying bitmaps &41-&5F
	&7F	Creates a filled in square.
	&100	Top bottom and left edge filled [
	&101	Top and bottom edges
	&102	Top bottom and right edge filled ]
	&103	Empty square
	&104	Underscore _
	&105	Left edge (giving a bar)
	&106+	Undefined (currently copies the @ character).
	
This means that the bitmaps will then be consistent with the VDU characters
of these numbers. These bitmaps are also useful as cursors.

 Entry: R1=redraw block (uses r_charw and r_charh to find the char size)
	   r_workarea must have 64 bytes + room for a character sprite
	   (see ZapRedraw_SpriteSize) reserved.
        R2=first extra bitmap to create (eg 0)
        R3=last extra bitmap to create (inclusive eg &104)
        R4=address of bitmaps in 1 bit per pixel form.
           (space must be reserved for the characters to be created).

 Exit:	R0 and flags corrupted.

ZapRedraw_CacheFontChars (+&11)
-------------------------------

This SWI takes an anti-aliased font and caches a range of characters as
bitmaps (see r_caddr). The cacheing can be done in any colours or screen
resolution. Of course only those with foreground colour all bits set and
background colour all bits clear can be used directly by
ZapRedraw_RedrawArea. However, by giving a foreground colour mask of -1 and a
background mask of 0 any bitmap can be drawn (see r_caddr etc). An hourglass
is given with the % as the current character/256 if it takes a long time.

 Entry:	R0=reason code and other registers as below.
	      
  R0=1 => Cache font in current wimp mode (ie wimp palette used).
	  R1=redraw block with the following set up:
		r_bpp = number of bits per pixel to cache at
		r_caddr = address of cache with space reserved for the chars
		r_cbpl/cbpc/r_charw/r_charh setup
		r_for/r_bac = offset in r_palette of for and bac cols
		r_palette = palette of colours as for VDU redraw mode
			    (ie each entry of form &BBGGRRxx)
		r_workarea = room for 64 bytes + single sprite
			     (use ZapRedraw_SpriteSize).
		r_mode = mode to cache font in (ie mode sprite defined in).
	  R2=pointer to font name
	  R3=Lower 16 bits:font size to plot at (points)
	     Upper 16 bits:font aspect ratio to use (=Y/Xx100) (or 0)
	  R4=x os offset (from bottom left) to plot character in the box
	  R5=y os offset (from bottom left) to plot character in the box
	  R6=first character to cache (0 caches as &30 and 1-&1F have &40
	     added &7F is ignored).
	  R7=last character to cache (inclusive)

  R0=2 => Cache font in mode 0 with background 0 and foreground 1.
	  R1=redraw block with the following set up:
		r_caddr = address of cache with space reserved for the chars
		r_cbpl/cbpc/r_charw/r_charh setup
		r_workarea = as for R0=1
		r_magx,r_magy for mode used with reason code R0=1
	  R2-R7 as for reason code R0=1.
	  Font size is scaled up by 2^(1-r_magx) horizontally and
	  2^(2-r_magy) vertically so the characters are the same pixel
	  size as those cached with R0=1.
	  
 Exit: R0 and flags corrupted.

ZapRedraw_SpriteSize (+&12)
---------------------------

Several SWI's (eg ZapRedraw_RedrawArea - VDU mode, ZapRedraw_CacheFontChars)
need to create a sprite area the size of a single character. This call
returns the size required for this sprite (+palette+mask+save area etc), and
thus the amount of workarea that should be reserved. The sprite needs a save
area as it appears that Font_Paint redirects output to a sprite and thus
corrupts the graphics colours. This means that it takes two passes to read
the size required for the sprite - the first to read the size for the sprite
and the second to create the sprite (space now reserved for it) and calculate
the save area required via OS_SpriteOp,62.

 Example: SYS "ZapRedraw_SpriteSize",&01,redraw_block TO size%
	  PROCensure_workarea(size%)
	  SYS "ZapRedraw_SpriteSize",&81,redraw_block TO size%
	  PROCensure_workarea(size%)
 (NB In practice the SWI usually requires 64+size% bytes of workspace)

 Entry:	R0=reason code
	   b0-b6 1=return sprite size for sprite in current mode and r_bpp
	         2=return sprite size for a mode 0 sprite (ie assume r_bpp=0)
	   b7    Clear for first pass, set for second pass.
	R1=redraw block with r_bpp,r_charw,r_charh setup.
	   On the second pass r_workarea must be at least the size returned
	   by the first pass.
	
 Exit:  On first pass : R0=size required for sprite area (no save area).
	On second pass: R0=total size required for sprite + save area.

ZapRedraw_RedrawWindow (+&13)
-----------------------------

This SWI performs the calls to Wimp_RedrawWindow, Wimp_GetRectangle,
Zap_GetRectangle, and Zap_RedrawArea for you. It assumes that the redraw
block is already setup. This call is equivalent to the basic code:
	SYS "Wimp_RedrawWindow",,data% TO flag%
        WHILE flag%
         SYS "ZapRedraw_GetRectangle",data%,redraw%
         SYS "ZapRedraw_RedrawArea",,redraw%
         SYS "Wimp_GetRectangle",,data% TO flag%
        ENDWHILE
where redraw% is the address of the redraw block and data% the data block
returned by Wimp_Poll for event 1 (redraw window request).

 Entry:	R0=Redraw block as returned by Wimp for Wimp_Poll 1 (data%)
	R1=Zap redraw block with r_data containing the text to redraw. All
	   of the block should be setup apart from rectangle to draw
	   and the scroll offsets which are filled in for you.
	   
 Exit:	R0 and flags corrupted.

ZapRedraw_Divide (+&14)
-----------------------

This SWI performs fast division and modulo functions.  As the SWI overhead
may be significant for this routine you may wish to find its address and
call it directly.

 Entry:	R0=numerator
	R1=denominator

 Exit:	R0=R0 DIV R1 
 	R1 corrupted.
 	R2=R0 MOD R1
 	R3 corrupted if the denominator is greater than 32.

ZapRedraw_PlotRectangle (+&15)
------------------------------

This SWI performs fast plotting of rectangles.  It is used internally as a
drop in replacement for the operating system's routines.

The routine doesn't clip to the graphics window.  It would be inefficient
for it to do so - typically the graphics window co-ordinates normally only
need to be read once for a number of rectangles.

 Entry:	R0 = left   X (inclusive)
        R1 = top    Y (inclusive)
        R2 = right  X (exclusive)
        R3 = bottom Y (exclusive)
        R4 = colour (filled word - see ColourTrans_ReturnColourNumber)

Coordinates are in pixels, (0,0) at top left

It is required that R2>R0, and R3>R1.

All co-ordinates must be positive and within display bounds.

 Exit:	R0-R12 corrupted.

ZapRedraw_AddCursorSmart (+&16)
-------------------------------

This SWI takes a line of the same format used in 'r_data', eg the output from
the above SWI, and adds in the codes to place 'cursors' over some of the text
by using the code 0,4 (merge characters) or the code 0,8 (merge cursors).
Here, a cursor means a string of characters to be overlayed.

This is an improvement over the old ZapRedraw_AddCursor command, which
wasn't able to cope with characters within a selection that didn't have the
selection foreground colour, resulting in very strange behaviour in some
cases. ZapRedraw_AddCursor is now implemented in terms of the new routine.

 Entry:	R0=destination string
	R1=redraw block giving initial r_for and r_bac.
	R2=offset in source string of first character to be in the cursor
	R3=cursor length (length in characters of string pointed to by R4)
	R4=pointer to string of cursor characters (usually &7Fs)
	R5=source string (0,2 terminated)
	R6=b0-b7   fg colour to match (=> uses cur fg/bg inverted)
	   b8-b15  bg colour to match (=> used cur fg col as final bg col)
	   b16-b29 reserved
	   b30     do fg matching
	   b31     do bg matching
	R7=b0-b7   high byte to use for cursor characters in R4 string
	   b8-b15  control code to use when merging ie 4 or 8.
	   b16-b23 foreground colour of the cursor
	   b24-b31 background colour of the cursor
	Room should be reserved for the string to grow by 8*R3
	characters. (eg 0,4,f,b,old,0,3,l,h) If the indicated offset (R2)
	is off the end of the string then it will be lengthened with spaces
	(&20) so you should ensure R2+9*R3 characters extra are reserved.
	
 Exit:	R0=end of new destination string (after 0,2 terminator)
 