; Contains mode entry points for BASIC mode.
; $Id: BASIC,fff,v 1.12 2000/11/03 23:28:02 ds Exp $
; -*- armasm -*-

 GET h.ZapBasHdr
 GET h.ZapBASIC
 GET h.BAStxt
 GET h.SWIs
 GET h.Buttons
 GET h.Brackets

 IMPORT charfromoffset
 IMPORT charchar
 IMPORT bas_execute

 EXPORT basic_table_start
 EXPORT basic_author
 EXPORT basic_saveandrun
 EXPORT basic_compile
 EXPORT basic_run
 EXPORT basic_runandquit
 EXPORT basic_basic
 EXPORT basic_postload
 EXPORT basic_clnoff
 EXPORT detokenise_byte
 EXPORT detokenise_len
 EXPORT tokenise_line
 EXPORT direct_tokenise_line
 EXPORT start_code
 EXPORT TestProgram
 EXPORT CmdBASICflagstoggle
 EXPORT BASIC_checkbuffer
 EXPORT BASIC_REMARK
 EXPORT BASIC_UNREMARK
 EXPORT BASIC_REMARKSEL
 EXPORT BASIC_UNREMARKSEL
 EXPORT wimp_nextslot
 EXPORT BASIC_TWRun
 EXPORT local_wkspace_ptr
 EXPORT loadmenuifrequired

fake_tab_character * 13

; 136 release notes:
; replace_area ; this routine needs changing before 136 release so
; DELETENEXT gets undone properly... :)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BASIC mode table					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

basic_table_start
 DCD basic_table_start
 DCD basic_title
 DCD basic_author
 DCD 0
  [ INTL=""
 DCD 5+(1<<11)+(1<<12)
  |
 DCD 5+(1<<11)
  ]
 DCD basic_init
 DCD 0
 DCD basic_table_end-basic_table_start

 DCD basic_postload
 DCD basic_presave
 DCD basic_loading
 DCD basic_start
 DCD basic_end
 DCD basic_width
 DCD basic_linecol
 DCD basic_lineoff
 DCD basic_clnlog
 DCD basic_clnphy
 DCD basic_clnoff
 DCD basic_nextline
 DCD basic_minus
 DCD basic_plus
 DCD basic_sminus
 DCD basic_splus
 DCD basic_cminus
 DCD basic_cplus
 DCD basic_redrawline
 DCD basic_redrawlnum
 DCD basic_char
 DCD basic_delete
 DCD basic_tab
 DCD basic_return
 DCD basic_renumber
 DCD basic_saveandrun
 DCD basic_linestart
 DCD basic_lineend
 DCD basic_linenext
 DCD basic_lineprev
 DCD basic_copy
 DCD basic_joinline
 DCD basic_splitline
 DCD basic_aligncaret
 DCD basic_command
 DCD basic_compile
 DCD Null			; format text
 DCD basic_run
 DCD basic_runandquit
 DCD basic_basic
 DCD basic_search
 DCD basic_replace
 DCD basic_selection
 DCD basic_click ;0		; mouse click (do text action)
 DCD 0
 DCD basic_setwidth
 DCD basic_listfns
 DCD basic_prevline
 DCD gotoopenwindow
 DCD basic_interrogate
basic_table_end

basic_title  FNS ("BASIC")
basic_author FNS ("Dominic Symes")

 LOCAL

basic_init
 TEQ R1,#9
 BEQ spell$l ; OK
 TEQ R1,#12
 BEQ basic_findfunction
 TEQ R1,#1
 BEQ start$l ; OK
 TEQ R1,#2
 BEQ basic_claim ; OK
 TEQ R1,#6
 BEQ basic_cols ; OK
 TEQ R1,#7
 BEQ basic_menu ; OK
 TEQ R1,#11
 BEQ basic_zapversion ; OK
 TEQ R1,#0			; dying?
 MOVEQ R0,#-1			; don't kill module
 MOV PC,R14
start$l
 FNSTR R0,mode_basic
 STR R0,localcopyof_mode_basic
 MOV PC,R14
spell$l
 FNJSR "R7"
 MOVS R7,R0
 BLPL charfromoffset
preloop$l
 CMP R0,#'"'
 EOREQ R1,R1,#&40
 CMP R0,#&F4
 ORREQ R1,R1,#&80
 CMP R0,#13
 BEQ foundsolhre$l
 SUBS R7,R7,#1
 BMI foundsolhre$l
 MOV R0,R7
 BL charfromoffset
 B preloop$l
foundsolhre$l
 CMP R1,#9
 MOVNE R1,#9
 MVNEQ R1,#0
 FNRTS

localcopyof_mode_basic
 & 0

basic_claim
 STMFD R13!,{R1-R11,R14}
 MOV R0,#&100
 FNcall Zap_Claim		; claim buffer (min &100)
 LDMVSFD R13!,{R1-R11,PC}
 FNSTR R0,buf_detoken		; detokenise buffer
 MOV R0,#&120
 FNcall Zap_Claim		; claim buffer
 LDMVSFD R13!,{R1-R11,PC}
 FNSTR R0,buf_retoken		; retokenise buffer
 MOV R0,#4
 FNcall Zap_Claim		; claim buffer
 LDMVSFD R13!,{R1-R11,PC}
 FNSTR R0,buf_insert		; insert buffer
 MOV R0,#&80
 FNcall Zap_Claim
 FNSTR R0,buf_error,VC		; error buffer
 BLVC init_mode_word		; set up mode words if needed
 LDMFD R13!,{R1-R11,PC}

 LOCAL

basic_cols
 ADR R1,d$l
 MOV PC,R14
 [ INTL=""
d$l = "basic_colours",0
 |
d$l	= "Comments",0
	= "Strings",0
	= "Tokenised",0
	= "x in PROCx",0
	= "PROC/FN",0
	= "DEF/END",0
	= "FOR/NEXT",0
	= "IF/THEN",0
	= "CASE",0
	= "DATA",0
	= "Hex numbers",0
	= "Numbers",0
	= "( and )",0
	= "{ and }",0
	= "[ and ]",0
	= ":;,",0
	= "+-*/=<>",0
	= "!?#^",0
	= "* commands",0
	= "Labels",0
	= "Assembler",0
	= "Directives",0
	= "Registers",0
	= "Shifts",0
	= "Branches",0
	= "LDM/STM",0
	= "LDR/STR",0
	= 0
 ]
 ALIGN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create the mode menu						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;X R1=pointer to the menu

basic_menu
 FNJSR
 BL loadmenuifrequired
 FNcall Zap_ReadMenu
 LDRVC R1,[R0,#4]
 FNRTS

;basic_menu
; FNJSR
; ADR R0,d$l
; FNcall Zap_ReadMenu
; LDRVC R1,[R0,#4]
; FNRTS
;d$l
; = "1",10,10
; = "00 ""Basic"" 20",10
; = "   ""Renumber           "" Renumber",10
; = "   ""Drop into BASIC    "" Basic",10
; = "   ""Run                "" Run",10
; = "   ""Run then quit      "" Runandquit",10
; = "   ""Save and run       "" Compile",10
; = "   ""Save, run, quit    "" Saveandrun",10
; = "   ""List of DEF's      "" Listfns",10
; = 0
; ALIGN


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Test detoken/retokenisation					   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TestProgram
 STMFD R13!,{R1-R12,R14}
 MOV R1,R0			; save command tail
 MOV R0,#5
 SWI XOS_File
 LDMVSFD R13!,{R1-R12,PC}
 TST R0,#1
 BLEQ err35
 LDMVSFD R13!,{R1-R12,PC}	; not a file
 AND R2,R2,#&FF00
 TEQ R2,#&FB00
 BLNE err35
 LDMVSFD R13!,{R1-R12,PC}	; not a BASIC file
 MOV R10,R4			; save file length
 MOV R0,#6			; claim
 ADD R3,R4,#&4000		; size to claim (add 4* &1000 buffers)
 SWI XOS_Module
 LDMVSFD R13!,{R1-R12,PC}
 MOV R11,R2			; save block address
 MOV R0,#&FF
 ADD R2,R2,#&4000
 MOV R3,#0
 SWI XOS_File			; load file
 BLVC test_program
 MOVVC R0,#7
 MOVVC R2,R11
 SWIVC XOS_Module			; free claimed block
 LDMFD R13!,{R1-R12,PC}

;E R10=file length R11=&4000 workspace + file
;X file tested #

test_program
 STMFD R13!,{R1-R11,R14}
 ADD R9,R11,#&4000		; start of file
 ADD R9,R9,#1			; skip the 0D
te1
 LDRB R0,[R9]			; first byte
 TEQ R0,#&FF
 LDMEQFD R13!,{R1-R11,PC}	; finished?
 LDRB R6,[R9,#1]
 ADD R6,R6,R0,LSL#8		; line number
 ADD R7,R9,#3			; line start
 BL test_line
 LDRVCB R0,[R9,#2]
 ADDVC R9,R9,R0			; next line
 BVC te1
 LDMVSFD R13!,{R1-R11,PC}

;E R6=line number R7=start of line pointer R11=buffer &4000 long
;X line tested #

test_line
 STMFD R13!,{R1-R11,R14}
 BL test_detoken		; detokenise to +&1000
 LDMVSFD R13!,{R1-R11,PC}
 ADD R0,R11,#&2000		; second buffer
 FNSTR R0,buf_retoken		; save in R11 block
 ADD R0,R11,#&1000		; source line
 MOV R2,#0			; flags
 MOV R8,#0			; default options
 BL tokenise_line		; tokenise
 LDMVSFD R13!,{R1-R11,PC}
 MOV R1,R7			; original
 ADD R2,R11,#&2000		; tokenised line
te13
 LDRB R0,[R1],#1
 LDRB R14,[R2],#1
 TEQ R0,R14
 BNE te14			; mismatch
 TEQ R0,#&0D
 BNE te13			; finished line?
 LDMFD R13!,{R1-R11,PC}
te14
 SWI XOS_WriteS
 FNS ("Suspicious tokenisation at line ")
 MOV R0,R6
 BL test_num
 LDMVSFD R13!,{R1-R11,PC}
 SWI XOS_WriteS
 FNS (" byte offset ")
 SUB R0,R1,R7
 SUB R0,R0,#1
 BL test_num
 SWIVC XOS_NewLine
 LDMFD R13!,{R1-R11,PC}

;E R0=value R11=buffer
;X value printed (in decimal) #

test_num
 STMFD R13!,{R1-R2,R14}
 MOV R1,R11
 MOV R2,#&100
 SWI XOS_ConvertCardinal4
 SWIVC XOS_Write0
 LDMFD R13!,{R1-R2,PC}

;E R7=start of line R11=buffer
;X line detokenised to +&1000 #

test_detoken
 STMFD R13!,{R1-R7,R14}
 ADD R5,R11,#&1000
 MOV R2,#0			; flags
 MOV R3,#0			; data
te10
 LDRB R0,[R7],#1
 TEQ R0,#&0D
 BEQ te11
 ORR R0,R0,R3
 BL fully_detokenise_byte
 MOVCS R3,R0
 BCS te10			; need more
 MOV R3,#0
te12
 LDRB R0,[R1],#1
 TEQ R0,#0
 STRNEB R0,[R5],#1
 BNE te12			; copy string
 B te10
te11
 STRB R0,[R5],#1		; two &0Ds
 STRB R0,[R5]			; two &0Ds
 LDMFD R13!,{R1-R7,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Run the module - run a BASIC program			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

; Run a new task - eg a basic program or assembler task
; Task to run is governed by run_flag
;  0=no task (abort)
;  b0-b7  => 1=run 2=run and quit 3=drop in to basic
;  b8-b15 => Mode number of mode that called (on 1-3)
;	     4 => Code mode (download program from module)
;	     5 => BASIC mode (Program is tokenised)
;	     6 => BASTXT mode (Program is in text form)

start_code
 LDR R11,[R12]			; workspace pointer
 MOV R13,#&A000			; set up a full descending stack
 SUB R13,R13,#4			; first stack entry
 FNLDR R10,run_flag		; save run flags before we init!
 CMP R10,#0
 BLE quit$l			; quit (no run action)
 MOV R0,R10,LSR#8
 AND R0,R0,#&FF
 TEQ R0,#4			; is it code mode?
 BEQ assemble$l			; start up assemble prog if so
 MOV R0,#200
 LDR R1,task$l
 ADR R2,name$l
 SWI XWimp_Initialise
 BVS error$l
 MOV R9,R1			; save task handle
 MVN R0,#0
 MVN R1,#0
 SWI XWimp_SlotSize		; read next slot size in R1
 BVS error$l
 MOV R2,R1			; save next slot size
 FNLDR R0,run_start		; start of data
 FNLDR R1,run_end		; end of data to fetch
 SUB R8,R1,R0			; length of data
 ADD R0,R8,R8,LSR#1		; length of data *1.5
 FNLDR R14,run_expand
 ADD R0,R0,R14			; plus possible expansion space
 ADD R0,R0,#&4000		; +&4000 workspace
 CMP R0,R2
 MOVCC R0,R2			; select largest
 MOV R7,R0			; save size asked for
 MVN R1,#0
 SWI XWimp_SlotSize		; set new size of slot
 BVS error$l
 CMP R0,R7
 BLLT err39
 BVS error$l			; haven't claimed enough memory
 FNLDR R0,run_task		; zaps task handle
 FNLDR R1,run_start		; source buffer
 MOV R2,R9			; destination task
 MOV R3,#&A000			; destination buffer
 FNLDR R14,run_expand
 ADD R3,R3,R14			; plus expansion space
 MOV R4,R8			; length
 SWI XWimp_TransferBlock	; copy the program to Basic Workspace
 BVS error$l
 MOV R0,R9			; task handle
 LDR R1,task$l
 SWI XWimp_CloseDown		; shut down the task (copied the data)
 BVS error$l
 MOV R7,#&A000			; start of data
 FNLDR R0,run_expand
 ADD R7,R7,R0
 BL convert_program		; convert to tokenised basic
 BVS error$l
run$l
 AND R10,R10,#&FF		; get type
 BL create_run_command		; get oscli in R0
 BVS error$l
 SWI XOS_CLI			; enter BASIC
quit$l
 MOV R0,#0
 MOV R1,#0
 MOV R2,#0
 SWI OS_Exit
 MOV PC,#0
task$l = "TASK"
name$l FNS (|zap$|:CC:"_RunProgram")
assemble$l
 MOV R0,#&4000
 MVN R1,#0
 SWI XWimp_SlotSize		; set a 16k slot size
 BVS error$l
 ADRL R1,mem_basass		; address of the program
 MOV R2,#&A000			; dest
 LDR R3,asslen$l		; length of assembler
a$l
 LDR R0,[R1],#4
 STR R0,[R2],#4
 SUBS R3,R3,#4
 BGT a$l			; copy the program
 MOV R7,#&A000			; prog start
 LDR R0,asslen$l
 ADD R6,R7,R0			; prog end
 B run$l
asslen$l DCD mem_basass_end-mem_basass
error$l				; R0=error pointer - report then quit
 MOV R1,#1			; ok box
 ADR R2,name$l			; task name
 SWI XWimp_ReportError
 B quit$l			; exit

;E R7=&A000+expand R8=file length R10=mode.type
;X R7=file start R6=file end R0-R5 corrupt

convert_program
 FNJSR
 MOV R0,R10,LSR#8
 FNLDR R14, mode_bastxt
 TEQ R0, R14
 BEQ co12			; text
 ADD R6,R7,R8			; end of data
 BL replace_line_numbers	; replace the line numbers
 MOVVC R0,#&0D
 STRVCB R0,[R7,#-1]!		; add 0D at start of file
 MOVVC R0,#&FF
 STRVCB R0,[R6],#1		; add FF at end of file
 FNRTS
co12
 MOV R4,R7			; source
 MOV R2,R8			; len
 MOV R5,#&A000			; dest
 MOV R7,R5			; new start
 MOV R0,#&0A
 STRB R0,[R4,R2]
 ADD R2,R2,#1			; ensure stop on end
 BL tokenise_program
 MOVVC R6,R5			; new end
 FNRTS

;E R6=file end R7=file start R10 has 1=chain 2=quit 3=drop
;X R0=oscli command of the from BASIC -.. @ at &9000

create_run_command
 FNJSR
 MOV R1,#&9000
 TEQ R10,#1
 ADREQ R2,st_s2
 ADRNE R2,st_s3
 TEQ R10,#3
 ADREQ R2,st_s4
 BL strcpy
 MOV R0,R7
 BL create_bufferhex
 FNRTS VS
 MOV R0,#','
 STRB R0,[R1],#1
 MOV R0,R6
 BL create_bufferhex
 MOVVC R0,#0
 STRVCB R0,[R1]
 MOVVC R0,#&9000
 FNRTS
st_s2 FNS ("BASIC -chain @")
st_s3 FNS ("BASIC -quit @")
st_s4 FNS ("BASIC @")

;E R0=value R1=buffer for hex version
;X R1=new buffer pointer R2 corrupted #

create_bufferhex
 FNJSR
 MOV R2,#16
 SWI XOS_ConvertHex8
 FNRTS

; R5=app buf st R6=cache R7=addr of data R10=end of buf sect
; Internal R2=line detoken flags R3=line length/num chars left
; R11=w_txtw as no linenos used!
; R2 as follows: bit 00 (&01)	    : in a REM
;		 bit 01 (&02)	    : in a "..."
;		 bit 02 (&04)	    : fn mode
;		 bit 03 (&08)	    : goto has been used...
;		 bit 05 (&20)	    : in a line (not at line start mode)
;		 bit 09 (&200)	    : In a LOOP (FOR/NEXT)
;		 bit 10 (&400)	    : a PRINT since the last :
;		 bit 11 (&800)	    : in a ; or \ BASIC assembler comment...
;		 bit 12 (&1000)	    : In IF...
;		 bit 13 (&2000)	    : in PROC string...
;		 bit 14 (&4000)	    : a recent DEF...
;		 bit 15 (&8000)	    : not after a : THEN ELSE or SOL...
;		 bit 16 (&10000)    : in a hex number...
;		 bit 17 (&20000)    : in a normal number...
;		 bit 18 (&40000)    : last char precludes possibility of num
;		 bit 29 (&80000)    : In CASE...
;		 bit 20 (&100000)   : an asm label...?
;		 bit 21 (&200000)   : actually in ASM instr...
;		 bit 22 (&400000)   : In asm directive...
;		 bit 23 (&800000)   : In Asm regs / in DATA quotes
;		 bit 24 (&1000000)  : Near ASM directives...
;		 bit 25 (&2000000)  : In ASM shifts...
;		 bit 26 (&4000000)  : In B/BL...
;		 bit 27 (&8000000)  : In LDM...
;		 bit 28 (&10000000) : In LDR...
;		 bit 29 (&20000000) : an E in num already?
;
;		 bit 30 (&40000000) : DATA...
;		 bit 31 (&80000000) : *Command (OSCLI) ...

constantbicmask
 DCD &3FFFFFFC

basic_redrawline
 FNJSR

 STMFD R13 !,{R1-R11}
 ADRL R1,localcopyof_mode_basic
 LDR R1,[R1]
 FNcall Zap_GetModeWord
 LDMFD R13 !,{R1-R11}
 STR R0,localmodeword
 LDR R11,[R8,#w_txtw]		; offset to foreground colour mask
 LDR R3,[R8,#w_bpl]		; cache width
 MOV R2,#0			; tokenise flags
 SUBS R0,R7,R5			; file offset
 ADDLE R7,R7,#3			; the source of mystery width limit?/LNUMs
 BLE red0			; at a line start
 SUBS R0,R0,#1
 BLPL cln_readc
 TEQ R0,#&0D
 ADDEQ R7,R7,#3			; line start
 BLNE redraw_back		; fill in leftovers from previous line
 FNRTS VS
red0
red1
 CMP R7,R10
 BLCS red_overflow
 BVS red2
 LDRB R0,[R7],#1		; get first byte
 TST R2,#3			;
 BNE red11			; in a rem/quote expression
 ; TST R2,#&80000000		; doesn't work due to altering tokenised LLs
 ; BNE red11			; in a rem/quote expression
 ; TST R2,#&800			; asm comment...
 ; BNE bas_inasmcomentposs
 CMP R0,#&7E			; is it tokenised
 BGT red3			; yes
bas_inasmcomentposs
 ;TST R2,#8			;
 ;BNE bas_red_inagoto		; in a rem/quote expression
red6
 TEQ R0,#&0D
 BEQ red2			; finish at a return

 TEQ R0,#'"'			; quote
 TSTEQ R2,#&800			; and not in asm comment
 TSTEQ R2,#&80000000		; and not in * command
 BLEQ red16			; entering/leaving a quote
 TST R2,#&800			; see if we are in an asm comment -
 BNE nfanumbtt
 ;BNE checkforendofasmcmnt	; if so, skip irrelevant stuff...
 ;bas_red_irrelevantstuff
 TST R2,#&8000
 BLEQ red_bas_testforoscli
 TST R2,#&100000		; inasm label...
 BLNE atendofasmlabel		; -ve means ends in %
 BNE tonfanumbtt
 TST R2,#&8000
 BLEQ possiblyassemblerins
 TST R2,#&1E00000
 BLNE possiblyassemblerreg
 TST R2,#&200000		; inasm label...
 BLNE atendofasminstr
 BNE nfanumbtt
 ANDS R1,R2,#&02		; make sure we're outside quotes
 TEQEQ R0,#':'			; and there's a : of course
 LDREQ R1,constantbicmask
 BICEQ R2,R2,R1
 TEQNE R0,#' '			; if not ':'/' ' then
 ; ORRNE R2,R2,#&8000		; could not be a * CLI next...
 BICEQ R2,R2,#&700000		; clear in asm label/asm instr...?
 TST R2,#&2000			; in proc/fn
 BNE possiblyendprocfn
backpossiblyendprocfn
 CMP R0,#';'			; semicolon ;(TT)
 CMPNE R0,#'\'			; \-style-semicolon :-\ (TT)
 BLEQ red_bas_semi		; entering/leaving a quote
 TEQ R0,#'&'			; a hex number?
 ORREQ R2,R2,#&10000		; entering a hex number
 CMP R0,#'.'
 BLEQ bas_red_adot
 CMP R0,#'0'
 BCC notprenumberproblems
 CMP R0,#':'
 BCC postprenumberproblems
 CMP R0,#'@'
 BCC notprenumberproblems
 CMP R0,#'Z'
 BLE prenumberproblems
 CMP R0,#'_'
 BEQ underscorespecialcase
 CMP R0,#'`'
 BCC notprenumberproblems
 CMP R0,#'{'
 BCC prenumberproblems
notprenumberproblems
 BIC R2,R2,#&40000
postprenumberproblems
 CMP R0,#'E'
 BEQ oneofthemEees
bas_butwerenotinno
 TST R2,#&40000
 BICNE R2,R2,#&A0000
 BNE nfanumbtt
 CMP R0,#'0'
 BICCC R2,R2,#&A0000
 BCC nfanumbtt
 CMP R0,#':'
 BICCS R2,R2,#&A0000
 BCS nfanumbtt
 ORR R2,R2,#&20000
nfanumbtt
 TST R2,#&20000000
 BLNE maybecanceleflag
 TST R2,#3 << 30		; test recent * / in DATA flag...
 BNE red_bas_foundinoscli	; show * command
 TST R2,#&800
 BNE ba_incomment
 TST R2,#&2000			; set recent flag...
 BLNE bas_foundfpname		; proc/fn / defproc/deffn
 TST R2,#&20000			; set recent flag...
 BLNE bas_red_inanonow		; in a number...
 TST R2,#&10000			; set recent flag...
 BLNE inahexnotillfurthernotice	; in a hex number...
 TST R2,#&100000		; set recent flag...
 BLNE inanasmlabel		; in a label
 TST R2,#&2E00000
 BLNE inanasminstr
 CMP R0,#'('
 CMPNE R0,#')'
 BEQ bas_red_brack1
 CMP R0,#'{'
 CMPNE R0,#'}'
 BEQ bas_red_brack2
 CMP R0,#'['
 CMPNE R0,#']'
 BEQ bas_red_brack3
 CMP R0,#':'
 CMPNE R0,#';'
 CMPNE R0,#','
 BEQ bas_red_punct
 CMP R0,#'+'
 CMPNE R0,#'-'
 CMPNE R0,#'*'
 CMPNE R0,#'/'
 CMPNE R0,#'='
 CMPNE R0,#'<'
 CMPNE R0,#'>'
 BEQ bas_red_symbol
 CMP R0,#'!'
 CMPNE R0,#'?'
 CMPNE R0,#'#'
 CMPNE R0,#'^'
 BEQ bas_red_spanish		;-)
 ;BEQ bas_red_asmsymbols		;-)
red_bas_postcolour
 STRB R0,[R6],#1
 SUBS R3,R3,#1			; save char
 BGT red1			; room for more ?
red10
 CMP R7,R10
 BLCS red_overflow
 BVS red2
 LDRB R0,[R7]			; get first byte of next line
 TEQ R0,#&0D
 ADDEQ R7,R7,#1			; skip if it equals return
 MVNNE R3,#0			; -1 flag if more to go
red2
 ADD R6,R6,R11,LSL#1		; move to background
 LDR R1,[R8,#w_bpl]		; start number of chars
 CMP R3,#0
 SUBPL R3,R1,R3			; number of chars drawn
 MOVMI R3,R1			; whole line (continues)
 MOV R0,#1			; background colour
red15
 SUBS R3,R3,#1
 STRGEB R0,[R6,#-1]!
 BGT red15
 MOV R11,#0			; no valid line number
 CMP R14,#&A5
 STRNE R7,local_cacheddataofs
 STRNE R2,local_cacheddataval2
 STRNE R3,local_cacheddataval3
 STREQ R14,local_cacheddataofs
 FNRTSS				; ret without error

local_cacheddataofs
 DCD &0

local_cacheddataval2
 DCD &0

local_cacheddataval3
 DCD &0

possiblyendprocfn
 CMP R0,#'{'			; and there's a : of course
 BCS nobakpssndprcfn		; backpossiblyendprocfn
 CMP R0,#'_'
 BCS backpossiblyendprocfn
 CMP R0,#'['			; and there's a : of course
 BCS nobakpssndprcfn		; backpossiblyendprocfn
 CMP R0,#'@'			; and there's a : of course
 BCS backpossiblyendprocfn
 CMP R0,#':'			; and there's a : of course
 BCS nobakpssndprcfn		; backpossiblyendprocfn
 CMP R0,#'0'			; and there's a : of course
 BCS backpossiblyendprocfn
 CMP R0,#'('			; and there's a : of course
 BICNE R2,R2,#&8000		; clear recent sol flag..
 ORREQ R2,R2,#&20		; not in hex no, number after is ok
nobakpssndprcfn
; ORREQ R2,R2,#&8000		; clear recent sol flag..
; BICEQ R2,R2,#&200000		; asm instruction...
; SWIEQ &107
 TST R2,#&4000
 BIC R2,R2,#&6000		; clear recent DEF flags...
 BEQ backpossiblyendprocfn

 ;BIC R2,R2,#&20		; at start of line...
 CMP R0,#'*'
 BNE backpossiblyendprocfn
 B red6

; keep in step with above routine...?
possiblyendprocfn2
 CMP R0,#'.'			; hmm...!?!?
 MOVCS PC,R14
 CMP R0,#'('			; and there's a : of course
 BICNE R2,R2,#&8000		; clear recent sol flag..
 ORREQ R2,R2,#&20		; not in hex no, number after is ok
; ORREQ R2,R2,#&8000		; clear recent sol flag..
; BICEQ R2,R2,#&200000		; asm instruction...
; TST R2,#&4000
 BIC R2,R2,#&6000		; clear recent DEF flags...
; MOVEQ PC,R14
; CMP R0,#'*'
; BICEQ R2,R2,#&8000		; clear recent sol flag...
 MOV PC,R14

red3
 BL colour_detokenise_byte	; detokenise...
 MOV R4,R0			; save data
 BCC red4			; detokenise complete
 CMP R7,R10
 BLCS red_overflow
 LDRVCB R0,[R7],#1		; get next byte
 ORRVC R0,R0,R4			; complete data
 BVC red3			; call again
 B red2
red4
 MOV R1,#&0B			; colour for tokenised statements
 ;TST R2,#&20000000
 ;BLNE exponentialproblem	; Hmm...
 TST R2,#&1000			; IF
 MOVNE R1,#&10
 TST R2,#&2000			; PROC/FN
 MOVNE R1,#&0D
 TST R2,#&4000			; DEF?
 MOVNE R1,#&0E
 TST R2,#&80000			; CASE
 MOVNE R1,#&11
 TST R2,#&200			; LOOP
 MOVNE R1,#&0F
 TST R2,#&200000		; In an asm instruction...
 MOVNE R1,#&1D			; e.g. ANDEQ...
 TST R2,#&400000
 MOVNE R1,#&1E
 TST R2,#&4000000
 MOVNE R1,#&21
 TST R2,#&8000000
 MOVNE R1,#&22
 TST R2,#&10000000
 MOVNE R1,#&23
 TST R2,#&800			; overrides all others thus last...
 MOVNE R1,#&09			; In comment?  Never...!?!? (sometimes...)
red14
 LDRB R0,[R4],#1
 TEQ R0,#0
 BEQ red1			; finished so do next byte
 ;MOV R1,R14
 TST R2,#&800			; in assembler comment?
 BNE skipduetoasmcomm$l
 CMP R0,#':'			; colour GOTO's arguments...
 MOVLE R1,#&07
 CMP R0,#'('			; for INSTR(, etc
 MOVEQ R1,#&15
; BICEQ R2,R2,#&200000		; asm instruction...
 CMP R0,#'$'			; for RIGHT$(, etc
 MOVEQ R1,#&0B
 ;TST R2,#&800			; Assembler comment...
 ;MOVNE R1,#9			; rem
skipduetoasmcomm$l
 STRB R1,[R6,R11]		; set colour
 STRB R0,[R6],#1
 SUBS R3,R3,#1
 BGT red14			; still room left
 LDRB R0,[R4]
 TEQ R0,#0
 BEQ red10			; finished bang on line end
 ; otherwise half-way through token...
 MOV R14,#&A5			; set flag!
 B red2				; reached start of next line

red11
 TEQ R0,#&0D
 BEQ tored6			; not a proper character
 TST R2,#3 << 30		; test recent * / in DATA flag...
 BNE red_bas_foundinoscli
 EOR R1,R2,#&800
 TST R1,#&800			; in asm comment?
 CMPEQ R0,#':'
 BEQ ba_thecolonincomment	; clear recent print flag...
 ;CMP R1,#&800
 ;CMPEQ R0,#'&'
 ;BEQ ba_theampersandincomment	; clear recent print flag...
 TST R2,#&1			; in a comment
 MOVNE R14,#9			; rem
 STRNEB R14,[R6,R11]		; set colour for rem
 BNE tored6			; print the character
 TST R2,#&80000002		; in a quote or * command
 BLNE insidequotemarks		; in a quote...
tored6
 TEQ R0,#&0D
 BEQ red2			; finish at a return
 TEQ R0,#&22			; quote
 BLEQ red16			; entering/leaving a quote
 B red_bas_postcolour

possiblyassemblerreg
 TST R2,#&50000			; in hex or nor norm num next
 MOVNE PC,R14
 BIC R1,R0,#&20
 CMP R1,#'A'
 MOVCC PC,R14
 CMP R1,#'Z'
 MOVGT PC,R14
; SWI &107
 B testforasmreg

ba_thecolonincomment
 LDREQ R1,constantbicmask
 BICEQ R2,R2,R1
 MOV R1,#2			; no longer a comment :-|.
 STRB R1,[R6,R11]		; colour it
 B tored6 ; red_bas_postcolour

;ba_theampersandincomment
; LDREQ R1,constantbicmask
; BICEQ R2,R2,R1
; MOV R1,#&09			; no longer a comment :-|.
; STRB R1,[R6,R11]		; colour it
; B tored6 ; red_bas_postcolour

red16
 EOR R1,R2,#&800		; in asm comment?
 TST R1,#&800
 CMPEQ R0,#':'
 BEQ ba_theendofthatthen	; clear recent print flag...
 EOR R2,R2,#2			; toggle flag
 MOV R1,#&800
 ORR R1,R1,#1
 TST R2,R1			; in an assembler comment
 MOVNE R1,#9			; yes
 MOVEQ R1,#10
 STRB R1,[R6,R11]		; colour it
 MOV PC,R14

;bas_red_inagoto
; TEQ R0,#&0D
; BEQ red6			; not a proper character
; ;TST R2,#&1			; in a comment
; MOV R14,#&0C			; gotonum
; STRB R14,[R6,R11]		; set colour for rem
; B red6			; print the character
; ;TST R2,#2			; in a quote
; ;BEQ red6			; not in a quote

ba_theendofthatthen
 TST R2,#&02			; not in a "..."; (TT)
 ;BIC R2,R2,#&710000		; clear in asm label... / hex no...?
 ;BIC R2,R2,#&FC00		; clear other stuff...
 ;BICEQ R2,R2,#&2B
 LDREQ R1,constantbicmask
 BICEQ R2,R2,R1
 MOV R1,#2			; no longer a comment :-|.
 STRB R1,[R6,R11]		; colour it
 B red_bas_postcolour

; checkforendofasmcmnt
;  CMP R0,#'&'
;  CMPNE R0,#'='
;  BNE nfanumbtt
;  BIC R2,R2,#&710000		; clear in asm label...?
;  BIC R2,R2,#&FC00		; clear recent flags...
;  BIC R2,R2,#&28			; SOL & 'GOTO' flag
;  SWI &107
;  B bas_red_irrelevantstuff

bas_red_inanonow
 MOV R1,#&14			; no longer a comment :-|.
 STRB R1,[R6,R11]		; colour it
 MOV PC,R14

red_bas_testforoscli
 CMP R0,#'*'			; * oscli
 ORREQ R2,R2,#&80000002		; set * in it flag
 CMP R0,#'.'			; . asembler label
 ORREQ R2,R2,#&100000
 ORREQ R2,R2,#&20		; Not at SOL anymore...
 MOV PC,R14

possiblyassemblerins		; > A
 CMP R0,#'['
 MOVEQ PC,R14
 CMP R0,#' '
 ORRNE R2,R2,#&8000
 ORRNE R2,R2,#&20
 CMP R0,#'`'
 MOVEQ PC,R14
 CMP R0,#'A'
 BCC possiblyampersandstill
 BIC R1,R0,#&20
 CMP R0,#'|'
 CMPNE R1,#'Z'
 MOVGT PC,R14
 B testforasminst

possiblyampersandstill
 CMP R0,#'&'
 CMPNE R0,#'='
 MOVNE PC,R14
 MOV R1,#&1E			; Directive colour...
 STRB R1,[R6,R11]		; colour it
 ;CMP R0,#'&'
 ;ORREQ R2,R2,#&10000		; entering a hex number
 ;BICEQ R2,R2,#&10000
 ;ORRNE R2,R2,#&20000		; entering a number?
 B red_bas_postcolour

inahexnotillfurthernotice
 CMP R0,#'&'			; * oscli
 CMPNE R0,#'0'			; * oscli
 BCC nolongerisithex		; not in hex no...
 MOVCC PC,R14
 BIC R1,R0,#&20
 CMP R1,#'G'			; * oscli
 BCS nolongerisithex
 CMP R1,#'A'			; * oscli
 BCS tizokstillhex
 CMP R0,#':'
 BICCS R2,R2,#&10000		; not in hex no...
 MOVCS PC,R14
tizokstillhex
 MOV R1,#&13			; no longer a comment :-|.
 STRB R1,[R6,R11]		; colour it
 MOV PC,R14

nolongerisithex
 BIC R2,R2,#&10000		; not in hex no...
 MOV PC,R14

bas_foundfpname
 MOV R1,#&0C			; no - now a comment, then.
 ;;TST R2,#&2000			; set recent flag...
 ;;MOVNE R1,#&0E			; no - now a comment, then.
 ;TST R2,#&4000			; set recent flag...
 ;ADDNE R1,R1,#1			; for DEFPROCs...
 STRB R1,[R6,R11]		; colour it
 MOV PC,R14

red_bas_foundinoscli
 CMP R0,#'"'
 TSTEQ R2,#&80000000
 EOREQ R2,R2,#&2		;
 MOV R1,#&1B			; colour OSCLI...
 TST R2,#&40000000		; test relevant flag...
 STREQB R1,[R6,R11]		; colour it
 BEQ red_bas_postcolour
 CMP R0,#'"'
 BEQ exclusivequoting		; the crafty quote in data statements
 CMP R0,#','			; the crafty comma in data statements
 MOVNE R1,#&12			; colour DATA...
 MOVEQ R1,#&18			; comma colour...
 TST R2,#&800000		; in a DATA...?
 MOVNE R1,#&0A			; "..."
 STRB R1,[R6,R11]		; colour it
 B red_bas_postcolour

exclusivequoting
 EOR R2,R2,#&800000		;
 MOV R1,#&0A			; "..."
 STRB R1,[R6,R11]		; colour it
 B red_bas_postcolour

ba_testcolon_general
 EOR R1,R2,#&800		; in asm comment?
 TST R1,#&800
 CMPEQ R0,#':'
 LDREQ R1,constantbicmask
 BICEQ R2,R2,R1
 MOV PC,R14

bas_red_adot
 TST R2,#&20000
 MOVNE R1,#&14
 STRNEB R1,[R6,R11]		; colour it
 ; BNE red_bas_postcolour
 ;TST R2,#&8000
 ;ORREQ R2,R2,#&100000
 MOV PC,R14

inanasmlabel
 MOV R1,#&1C
 STRB R1,[R6,R11]		; colour it
 MOV PC,R14

inanasminstr
 TST R2,#&800000		; E in num / data...
 BNE inaregisterbasm
 MOV R1,#&1D
 TST R2,#&400000
 MOVNE R1,#&1E
 TST R2,#&4000000
 MOVNE R1,#&21
 TST R2,#&8000000
 MOVNE R1,#&22
 TST R2,#&10000000
 MOVNE R1,#&23
 STRB R1,[R6,R11]		; colour it
 MOV PC,R14

inaregisterbasm
 CMP R0,#'0'
 BICCC R2,R2,#&2E00000		; this manipulation of R2 should *not*
 MOVCC PC,R14			; be here...
 BIC R1,R0,#&20
 CMP R1,#'Z'
 BICGT R2,R2,#&2E00000
 MOVGT PC,R14
 TST R2,#&2000000
 MOVEQ R1,#&1F
 STREQB R1,[R6,R11]		; colour it
 MOVEQ PC,R14
 MOV R1,#&20
 CMP R0,#':'
 BICCC R2,R2,#&2E00000
 MOVCC R1,#&14			; LSLx WHERE x=[0-9]
 STRB R1,[R6,R11]		; colour it
 MOV PC,R14

bas_red_brack1
 BIC R2,R2,#&200000		; asm instruction...
 BIC R2,R2,#&6000		; no more DEF / PROC / FN! :< -> DEFFNx*FX0
 MOV R1,#&15
 STRB R1,[R6,R11]		; colour it
 B red_bas_postcolour

bas_red_brack2
 MOV R1,#&16
 STRB R1,[R6,R11]		; colour it
 B red_bas_postcolour

bas_red_brack3
 MOV R1,#&17
 STRB R1,[R6,R11]		; colour it
 B red_bas_postcolour

bas_red_punct
 MOV R1,#&18
 STRB R1,[R6,R11]		; colour it
 B red_bas_postcolour

bas_red_symbol
 MOV R1,#&19
 STRB R1,[R6,R11]		; colour it
 B red_bas_postcolour

bas_red_spanish		;-)
 MOV R1,#&1A
 STRB R1,[R6,R11]		; colour it
 B red_bas_postcolour

; bas_red_asmsymbols		;-)
;  MOV R1,#&1B
;  STRB R1,[R6,R11]		; colour it
;  B red_bas_postcolour

localmodeword
 DCD 0

;;;E R3=num chars left to write (w_bpl) R2=token flags R5=aparent
;;;  buffer start R6=output pointer R7=address
;;;X R1,R4=corrupted R2,R3,R6 updated width bit of token
;;;  rest preserved #
;;
;;redraw_back
;; STMFD R13!,{R5,R7,R10,R11,R14}
;; SUB R7,R7,R5			; get file offset of line start
;; MOV R0,R7
;; BL basic_linestart		; find first char offset
;; FNRTS VS
;; MOV R11,R0			; save current offset
;; MOV R4,#0			; current data
;; MOV R5,#0			; current column
;;red7
;; MOVS R0,R11
;; MOVMI R0,#&0D
;; BLPL cln_readc
;; ORR R0,R0,R4			; new data
;; BL bas_red_fully_det_byte	; R0=strlen R1=string
;; ADD R11,R11,#1
;; MOV R4,R0			; output
;; BCS red7			; haven't finished
;; ADD R5,R5,R0			; increment column
;; CMP R11,R7
;; MOVCC R4,#0			; new token
;; BCC red7			; next
;;red8
;; SUBS R5,R5,R3
;; BCS red8			; get current column < 0
;; ADDS R5,R5,R3			; number of chars overflow
;; FNRTS EQ			; none
;; SUBS R4,R4,R5			; offset in the string
;; FNRTS MI			; -ve (shouldn't happen)
;; ADD R1,R1,R4
;; SUB R3,R3,R5			; new line len
;; LDR R11,[R8,#w_txtw]
;; MOV R14,#11			; tokenised statement
;;red9
;; LDRB R0,[R1],#1
;; STRB R14,[R6,R11]
;; STRB R0,[R6],#1
;; SUBS R5,R5,#1
;; BHI red9
;; FNRTS

;E R3=num chars left to write (w_bpl) R2=token flags R5=aparent
;  buffer start R6=output pointer R7=address
;X R1,R4=corrupted R2,R3,R6 updated width bit of token
;  rest preserved #

redraw_back
 STMFD R13!,{R5,R7,R11,R14}
 LDR R14,local_cacheddataofs
 CMP R14,R7
 BEQ back_cachevalid

 SUB R7,R7,R5			; get file offset of line start
 MOV R0,R7
 BL basic_linestart		; find first char offset
 LDMVSFD R13!,{R5,R7,R11,PC}
 MOV R11,R0			; save current offset
 MOV R4,#0			; current data
 MOV R5,#0			; current column
red7
 MOVS R0,R11
 MOVMI R0,#&0D
 BLPL cln_readc
 ORR R0,R0,R4			; new data
 BL bas_red_fully_det_byte	; R0=strlen R1=string carry:?
 ADD R11,R11,#1
 MOV R4,R0			; output
 BCS red7			; haven't finished
 ADD R5,R5,R0			; increment column
 CMP R11,R7
 MOVCC R4,#0			; new token
 BCC red7			; next
red8
 SUBS R5,R5,R3
 BCS red8			; get current column < 0
 ADDS R5,R5,R3			; number of chars overflow
 LDMEQFD R13!,{R5,R7,R11,PC}	; none
 SUBS R4,R4,R5			; offset in the string
 LDMMIFD R13!,{R5,R7,R11,PC}	; -ve (shouldn't happen)
 ADD R1,R1,R4			; R1=string addr...
intothe_backredraw
 SUB R3,R3,R5			; new line len
 LDR R11,[R8,#w_txtw]
 MOV R14,#&0B			; tokenised statement
 TST R2,#&1000			; IF
 MOVNE R14,#&10
 TST R2,#&2000			; PROC/FN
 MOVNE R14,#&0D
 TST R2,#&4000			; DEF?
 MOVNE R14,#&0E
 TST R2,#&80000			; CASE
 MOVNE R14,#&11
 TST R2,#&200			; loop
 MOVNE R14,#&0F
 TST R2,#&200000		; In an asm instruction...
 MOVNE R14,#&1D			; e.g. ANDEQ...
 TST R2,#&400000
 MOVNE R14,#&1E
 TST R2,#&4000000
 MOVNE R14,#&21
 TST R2,#&8000000
 MOVNE R14,#&22
 TST R2,#&10000000
 MOVNE R14,#&23
 TST R2,#&20000000
 MOVNE R14,#&0F
 TST R2,#&800			; overrides all others thus last...
 MOVNE R14,#&09			; In comment?  Never...!?!? (sometimes...)
red9
 LDRB R0,[R1],#1
 STRB R14,[R6,R11]
 STRB R0,[R6],#1
 SUBS R5,R5,#1
 BHI red9
 LDMFD R13!,{R5,R7,R11,PC}

back_cachevalid
 LDR R2,local_cacheddataval2
 ;LDR R3,local_cacheddataval3 ; ?
 LDMFD R13!,{R5,R7,R11,PC}

; R7=file offset of line start R11=log lnum CS if not at line start

basic_redrawlnum
 FNJSR
 TEQ R7,#0
 BEQ red5
 SUBS R0,R7,#1
 BLPL cln_readc
 TEQ R0,#&0D
 BNE re2x
red5
 LDR R0,[R9,#f_len]
 SUB R0,R0,R7			; bytes left in file
 CMP R0,#3
 BLT re2x			; don't draw lnum
 MOVS R0,R7
 BLPL cln_readc
 MOV R2,R0
 ADDS R0,R7,#1
 BLPL cln_readc
 ADD R2,R2,R0,LSL#8
 ADDS R0,R7,#2
 BLPL cln_readc
 ADD R0,R2,R0,LSL#16		; 3 byte line number form
 BL conv_3byte_ln		; get line number in R0
 LDR R1,[R8,#w_stline]
 SUB R11,R0,R1			; remove user's fiddle factor ...
 ADDS R0,R0,#0			; clc
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Detokense a byte						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E On first call put R0=byte to detokenise (0-&FF)
;  On subsequent calls R0=returned word with b0-b7 filled with next byte
;  R2=tokenise flags (b0=in a rem b1=in a "..")
;X If CC then R0=string length R1=string R2 updated
;  If CS then I need another byte so fill b0-b7 of R0 with next byte
;  and call this code again (preserving the rest of R0). |
;  This differs from detokenise_byte in that it handles normal
;  characters as well and quote expressions

fully_detokenise_byte
 FNJSR
 BICS R14,R0,#&FF
 BNE cont$l
 ;MOV R1,#&800
 ;ORR R1,R1,#3			; in the middle of something
 TST R2,#&80000003
 BNE inrem$l			; don't expand as in a quote/rem/*
 CMP R0,#&7F
 BCS cont$l			; expand token
inrem$l
 ANDS R1,R2,#3			; make sure we're outside quotes
 BLEQ ba_incomment_general

 TST R2,#&8000
 BLEQ red_bas_testforoscli

 ;TST R2,#&800			; see if we are in an asm comment -
 ;BNE back_nfanumbtt		; if so, skip irrelevant stuff...
 TST R2,#&02			; make sure we're outside quotes
 TEQEQ R0,#':'			; and there's a : of course
 LDREQ R1,constantbicmask
 BICEQ R2,R2,R1
 ; MOVEQ R2,#0
 ;BICEQ R2,R2,#&FF00		; clear recent flags...
 ;BICEQ R2,R2,#&FF00		; clear recent flags...
 ;BICEQ R2,R2,#&FC		; clear 'GOTO' flags ... ???
 ;TEQNE R0,#' '			; if not ':'/' ' then ; fuzzy???
 ORRNE R2,R2,#&8000		; could not be a * CLI next...
 ;;CMP R0,#'0'			; and there's a : of course
 ;;BICCC R2,R2,#&3000		; clear recent proc/fn flags...

 CMP R0,#';'			; semicolon ;(TT)
 CMPNE R0,#'\'			; \-style-semicolon :-\ (TT)
 BLEQ red_bas_semi2		; entering/leaving a quote

 TEQ R0,#'"'
 TSTEQ R2,#&800			; quote and not in asm comment
 TSTEQ R2,#&80000000		; and not in * command
 EOREQ R2,R2,#2
back_bas_butwerenotinno
back_nfanumbtt
 ADR R1,de_buf1
 STR R0,[R1]			; set up the string
 MOV R0,#1			; string length
 ADDS R0,R0,#0			; clc
 FNRTS
cont$l
; BL colour_detokenise_byte	; colour - should not be for speed...
 BL detokenise_byte	; colour - should not be for speed...
 FNRTS CS
 MOV R1,R0			; string address
 BL str_len			; string length
 ADDS R0,R0,#0			; clc
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Detokense a byte						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E On first call put R0=byte to detokenise (0-&FF)
;  On subsequent calls R0=returned word with b0-b7 filled with next byte
;  R2=tokenise flags (b0=in a rem b1=in a "..")
;X If CC then R0=string length R1=string R2 updated
;  If CS then I need another byte so fill b0-b7 of R0 with next byte
;  and call this code again (preserving the rest of R0). |
;  This differs from detokenise_byte in that it handles normal
;  characters as well, quoted expressions and, um, a dozen other things :|

bas_red_fully_det_byte
 FNJSR
 BICS R14,R0,#&FF
 BNE bas_red_contnotsolocal
 TST R2,#&80000003
 BNE bas_red_inrem$l		; don't expand as in a quote/rem/*
 CMP R0,#&7F
 BCS bas_red_contnotsolocal	; expand token
bas_red_inrem$l
 TST R2,#3 << 30		; test recent * / in DATA flag...
 BLNE back_red_bas_foundinoscli	; data statements and stuff
 ANDS R1,R2,#3			; make sure we're outside quotes
 BLEQ ba_incomment_general
 TEQ R0,#'"'
 TSTEQ R2,#&800			; quote and not in asm comment
 TSTEQ R2,#&80000000		; and not in * command
 EOREQ R2,R2,#2
 TST R2,#&800			; see if we are in an asm comment -
 BNE bas_red_back_nfanumbtt	; if so, skip irrelevant stuff...
 TST R2,#&2000			; in proc/fn
 BLNE possiblyendprocfn2
 TST R2,#&8000
 BLEQ red_bas_testforoscli
 TST R2,#&8000
 BLEQ ba_possiblyassemblerins	; > A ba_
 TST R2,#&1E00000
 BLNE ba_possiblyassemblerreg
 TST R2,#&100000		; inasm label...
 BLNE atendofasmlabel		; -ve means ends in %
 BNE to_bas_red_back_nfanumbtt
 TST R2,#&200000		; inasm label...
 BLNE atendofasminstr
 BNE bas_red_back_nfanumbtt

 TST R2,#&C0000003		; test recent */DATA/"/REM
 TEQEQ R0,#':'			; and there's a : of course
 LDREQ R1,constantbicmask
 BICEQ R2,R2,R1
 ; MOVEQ R2,#0			; clear recent flags...
 ;BICEQ R2,R2,#&28		; clear 'GOTO' flag
 ;TEQNE R0,#' '			; if not ':'/' ' then
 ;ORRNE R2,R2,#&8000		; could not be a * CLI next...
 CMP R0,#'.'			; and there's a : of course
 BICCC R2,R2,#&710000		; clear recent asm-comment/hex flags...

 CMP R0,#';'			; semicolon ;(TT)
 CMPNE R0,#'\'			; \-style-semicolon :-\ (TT)
 BLEQ red_bas_semi2		; entering/leaving a quote

 TEQ R0,#'&'			; quote
 ORREQ R2,R2,#&10000		; entering/leaving a quote
 CMP R0,#'0'
 BCC bas_red_back_notprenumberproblems
 CMP R0,#':'
 BCC bas_red_back_postprenumberproblems
 CMP R0,#'@'
 BCC bas_red_back_notprenumberproblems
 CMP R0,#'['
 BCC bas_red_back_prenumberproblems
 CMP R0,#'`'
 BCC bas_red_back_notprenumberproblems
 CMP R0,#'{'
 BCC bas_red_back_prenumberproblems
bas_red_back_notprenumberproblems
 BIC R2,R2,#&40000
bas_red_back_postprenumberproblems
 CMP R0,#'E'
 BEQ bas_red_back_oneofthemEees
bas_red_back_bas_butwerenotinno
 TST R2,#&40000
 BICNE R2,R2,#&A0000
 BNE bas_red_back_nfanumbtt
 CMP R0,#'0'
 BICCC R2,R2,#&A0000
 BCC bas_red_back_nfanumbtt
 CMP R0,#':'
 BICCS R2,R2,#&A0000
 BCS bas_red_back_nfanumbtt
 ORR R2,R2,#&20000
bas_red_back_nfanumbtt
 TST R2,#&20000000
 BLNE maybecanceleflag
 ADR R1,de_buf1
 STR R0,[R1]			; set up the string
 MOV R0,#1			; string length
 ADDS R0,R0,#0			; clc
 FNRTS

ba_possiblyassemblerins
 CMP R0,#'['
 MOVEQ PC,R14
 CMP R0,#' '
 ORRNE R2,R2,#&8000
 ORRNE R2,R2,#&20
 CMP R0,#'`'
 CMPNE R0,#'@'
 MOVLE PC,R14
 BIC R1,R0,#&20
 CMP R0,#'|'
 CMPNE R0,#'`'
 CMPNE R1,#'Z'
 MOVGT PC,R14

 FNJSR "R0,R5,R7,R10"
 BL setupr5r7r10
 BL testforasminst

 FNRTS

ba_possiblyassemblerreg
 TST R2,#&50000			; in hex or nor norm num next
 MOVNE PC,R14
 BIC R1,R0,#&20
 CMP R1,#'A'
 MOVCC PC,R14
 CMP R1,#'Z'
 MOVGT PC,R14

 FNJSR "R0,R5,R7,R10"
 BL setupr5r7r10
 BL testforasmreg

 FNRTS

 LOCAL

;E On first call put R0=byte to detokenise (>=&7F)
;  On subsequent calls R0=returned word with b0-b7 filled with next byte
;  R2=tokenise flags (b0=in a rem b1=in a "..")
;X If CC then R0 points to 0 terminated string R2 updated
;  If CS then I need another byte so fill b0-b7 of R0 with next byte
;  and call this code again (preserving the rest of R0). |

colour_detokenise_byte
 FNJSR "R1"
 BICS R14,R0,#&FF
 BNE cont$l			; this is not a first call

 TST R2,#&20
 BEQ asmspecials		; for AND OR EOR AND MOVE...
notanasmspecial
 BIC R2,R2,#&001F0000		; not in hex no, number after is ok & !E
 BIC R2,R2,#&00001200		; not in a ...?
 ADRL R14,tokentabllkupasm - &80; table...
 LDRB R14,[R14,R0]
 TST R14,#8			; (PROC HAS THIS SET?)
 BICNE R2,R2,#&8400		; set recent begin of line flag...
 ORREQ R2,R2,#&8000		; could not be a * CLI next...
 TST R14,#16
 ORRNE R2,R2,#&1000		; IF - like.
 TST R14,#32
 ORRNE R2,R2,#&80000		; CASE - like.
 TST R14,#64
 ORRNE R2,R2,#&200		; LOOP - like.
 CMP R0,#&F2			; tokenised PROC command ;(TT)
 CMPNE R0,#&A4			; tokenised FN command ;(TT) + others...
 BEQ exceptingprocproc
 CMP R0,#&DC			; tokenised DATA command ;(TT) + others...
 ORREQ R2,R2,#&40000000		; set in DATA flag...
 ;CMP R0,#&F5			; tokenised REPEAT...
 ;BICEQ R2,R2,#&40000000	; set in DATA flag...
 ORR R2,R2,#&20			; not in hex no, number after is ok & !E
 TST R2,#&4000
 BNE inadefcoldetbyt
 BIC R2,R2,#&6000		; end of any DEFxxxs
 TST R14,#128			; def/endproc
 ORRNE R2,R2,#&44000		; set recent def flag + numbers...
 ;BIC R2,R2,#&4000		; end of any DEFxxxs
 ;BIC R2,R2,#&20			; end of any DEFxxxs
 B orthodox_detokenise_byte

detokenise_byte
 FNJSR "R1"
 BICS R14,R0,#&FF
 BNE cont$l			; this is not a first call

orthodox_detokenise_byte
 ADRL R14,tokentabllkupasm - &80	; table...
 LDRB R14,[R14,R0]
 TST R14,#2
 ORRNE R2,R2,#&400		; set recent print flag...
 TST R14,#4
 ORRNE R2,R2,#&1		; set recent print flag...
 ADRL R1,mem_basdata		; token table
 SUB R14,R0,#&7F
 LDR R14,[R1,R14,LSL #2]	; offset in table of this entry
 TEQ R14,#0
 BEQ notatoken$l
 ADD R1,R1,R14			; entry
 LDRB R14,[R1]
 CMP R14,#&80
 MOVCC R0,R1			; finished as it points to a word
 MOVCS R0,R0,ROR #8		; wait for next byte in pair
 FNRTS
cont$l
 MOV R14,R0,LSR #24		; top byte of entry
 TEQ R14,#&8D
 BEQ wait$l			; line number so wait again
 CMP R14,#&80
 BCS doubletoken$l		; double byte token
 TST R0,#&FF00			; have we filled up the word
 BEQ wait$l			; if not then wait for next byte
 MOV R0,R0,ROR#16		; get R0=8Dxxyyzz
 BIC R0,R0,#&FF000000		; remove 8D
 BL conv_3byte_ln		; find the line number
 STMFD R13!,{R1-R2}
 ADR R1,de_buf1
 MOV R2,#&10			; what about the flags...?
 SWI XOS_ConvertCardinal2	;
 LDMFD R13!,{R1-R2}		; there they are...
 B string$l			; return string
notatoken$l
 TEQ R0,#&8D			; is it a tokenised line number
 BNE skip$l			; if not return null
 ORR R2,R2,#1<<3		; register that gotos used
wait$l
 MOV R0,R0,ROR #8		; if so wait for next byte
 SUBS R0,R0,#0			; sec
 FNRTS
skip$l
 STR R0,de_buf1			; return code as the string
string$l
 ADR R0,de_buf1
 ADDS R0,R0,#0			; clc
 FNRTS
doubletoken$l			; R14 = top of character...
 ADRL R1,mem_basdata
 SUB R14,R14,#&7F
 LDR R14,[R1,R14,LSL #2]
 ADD R1,R1,R14			; start of list to match
a$l
 LDR R14,[R1]
 TEQ R14,#0
 BEQ fail$l			; not found
 EOR R14,R14,R0,ROR #24
 EOR R14,R14,R0,ROR #8
 TST R14,#&FF000000
 TSTNE R14,#&00FF00
 ADDNE R1,R1,#16
 BNE a$l			; no match
 AND R14,R0,#&FF
 CMP R14,#&8E			; CASE statement
 ORREQ R2,R2,#&80000
 CMP R14,#&95			; WHILE statement
 ORREQ R2,R2,#&200		; ?CASE? statement
 ADDS R0,R1,#4			; clc and return pointer
 FNRTS
fail$l
 MOV R0,R0,ROR #24
 B skip$l			; token not found
de_buf1 % &10			; detokenise string buffer

 LOCAL

;E R5=buffer skip
;  R6=output buffers (+R5=foreground +2*R5=background)
;  R7=input tokenised line
;  R8=buffer width (w_bpl) [Buffers wrapped around]
;  R9=offset in tokenised line of line to finish with
;X R0=width of output line b31 set if reached line end
;  Characters and foreground colour done. Rest of line not cleared &
;  background cols not done.
;  Internally R2=flags  b0=in a REM/DATA statement
;			b1=in a "" expression
;			b5=in a line (not at line start command mode)
;			b30=in a DATA statement
;			b31=in an OSCLI statement

colour_detokenise_line
 FNJSR "R1-R7"
 MOV R2,#0			; clear flags
 ADD R5,R6,R5			; foreground colour buffer
 ADD R9,R7,R9			; address of start of line to finish with
 MOV R10,#0			; next char offset to output (length)
loop$l				; main loop
 LDRB R0,[R7],#1		; get next input byte
 TEQ R0,#&0D
 BEQ lineend$l
 MOV R3,#2			; default colour (foregound)
 ;MOV R1,#&800
 ;ORR R1,R1,#(3<<30)+1		; REMs *commands and...
 TST R2,#(3<<30)+3		; for assembler comments &800!
 BNE rem$l
 ANDS R1,R2,#3			; make sure we're outside quotes
 BLEQ ba_incomment_general
 TST R2,#&800			; see if we are in an asm comment -
 BNE back_nfanumbtt3		; if so, skip irrelevant stuff...
 TST R2,#&2000			; in proc/fn
 BLNE possiblyendprocfn2
 TST R2,#&8000
 BLEQ red_bas_testforoscli
 TST R2,#&8000
 BLEQ possiblyassemblerins	; > A
 TST R2,#&1E00000
 BLNE possiblyassemblerreg
 TST R2,#&100000		; inasm label...
 BLNE atendofasmlabel		; -ve means ends in %
 BNE to_back_nfanumbtt3
 TST R2,#&200000		; inasm label...
 BLNE atendofasminstr
 BNE back_nfanumbtt3

 ANDS R1,R2,#&02		; make sure we're outside quotes
 TEQEQ R0,#':'			; and there's a : of course
 LDREQ R1,constantbicmask
 BICEQ R2,R2,R1
 ;BICEQ R2,R2,#&FC00		; clear recent flags...
 ;BICEQ R2,R2,#&28		; clear 'GOTO' flag

 ;TEQNE R0,#' '			; if not ':'/' ' then
 ;ORRNE R2,R2,#&8000		; could not be a * CLI next...
 CMP R0,#';'			; semicolon ;(TT)
 CMPNE R0,#'\'			; \-style-semicolon :-\ (TT)
 BLEQ red_bas_semi2		; entering/leaving a quote

 ;TEQ R0,#'"'
 ;EOREQ R2,R2,#2

 TEQ R0,#'"'
 TSTEQ R2,#&800			; quote and not in asm comment
 TSTEQ R2,#&80000000		; and not in * command
 BEQ quote$l
back_nfanumbtt3
 TST R2,#1<<5
 BEQ linestart$l
 TST R2,#&80000002
 MOVNE R3,#10
 BNE char$l			; in a string or * command
 CMP R0,#&7F
 BCC char$l			; ordinary character
 MOV R3,#18			; function
token$l				; R0=token 7F-FF & R3=colour
 ADRL R1,mem_basdata		; token table
 SUB R14,R0,#&7F
 ; THE FOLLOWING LINE WAS BRANCHED TO IN ERROR IN TW CODE.
 LDR R14,[R1,R14,LSL #2]	; offset in table of this entry
 TEQ R14,#0
 BEQ notatoken$l
 ADD R1,R1,R14			; entry
 LDRB R14,[R1]
 CMP R14,#&80
 MOVCC R0,R1			; finished as it points to a word
 MOVCS R0,R0,ROR #8		; wait for next byte in pair
 ;SWI &107	; is this a problem
 FNRTS

notatoken$l

linestart$l			; start of line (after a colon)
 MOV R3,#11			; default command colour
 TEQ R0,#&20
 BEQ space$l
 TEQ R0,#'*'
 MOVEQ R3,#20
 ORREQ R2,R2,#&80000002
 BEQ char$l			; in an oscli statement
 CMP R0,#&7F
 BCS token$l
 B char$l

skip$l
 BL out$l			; output
 B loop$l			; still at line start

quote$l
 MOV R3,#10			; string colour...
 EOR R2,R2,#2			; quote bit...
 B char$l

rem$l				; untokenised REM or DATA or OSCLI section
 MOV R3,#9
 TST R2,#1<<30
 MOVNE R3,#19			; DATA
 TST R2,#1<<31
 MOVNE R3,#20			; colour for ...REM?
char$l				; do one char - no longer at line start
 ORR R2,R2,#1<<5
space$l
 BL out$l
 B loop$l

lineend$l
 ORR R0,R10,#1<<31		; reached end of line
 FNRTS				; break out

; output one character and exit whole thing via FNRTS if need to
out$l				; output the character R0 R3=colour
 CMP R10,R8
 BCS linewrap$l
out2$l
 STRB R0,[R6,R10]
 STRB R3,[R5,R10]
 ADD R10,R10,#1
 MOV PC,R14
linewrap$l
 CMP R7,R9
 MOVGT R0,R8			; output line width
 FNRTS GT			; return from main sub
 MOV R10,#0			; on to next line
 B out2$l
;space$l

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Fast calculate of detokenise length			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E On first call put R5=byte to detokenise (0-&FF) R11<>workspace
;  On subsequent calls R5=returned word with b0-b7 filled with next byte
;  R4=tokenise flags (b0=in a rem b1=in a "..")
;X If CC then R0=string length R4 updated R5=0
;  If CS then I need another byte so fill b0-b7 of R5 with next byte
;  and call this code again (preserving the rest of R5). |
;  This is used to skip various tokens in cln_forward. The regs are set
;  up for this.

detokenise_len
 FNJSR
 BICS R14,R5,#&FF
 BNE cont$l			; in the middle of something
 TST R4,#&80000003
 BNE rem$l			; in a quote/rem/*
 CMP R5,#&7F
 BCS token$l			; detokenise
rem$l
 TEQ R5,#&22
 EOREQ R4,R4,#2
 MOV R5,#0
 ADDS R0,R5,#1			; length 1 and clc
 FNRTS
token$l
 TEQ R5,#&F4
 TEQNE R5,#&DC
 ORREQ R4,R4,#1			; in a Rem/Data
 ADRL R0,mem_basdata
 SUB R14,R5,#&7F
 LDR R14,[R0,R14,LSL#2]
 TEQ R14,#0
 BEQ notatoken$l		; no string found
 ADD R0,R0,R14
 LDRB R14,[R0]			; get first byte
 CMP R14,#&80
 LDRCCB R0,[R0,#11]		; get length byte
 MOVCC R5,#0
 MOVCS R5,R5,ROR#8		; wait for next byte
 FNRTS
cont$l
 MOV R14,R5,LSR#24
 TEQ R14,#&8D
 BEQ wait$l			; line number so wait
 CMP R14,#&80
 BCS doubletoken$l		; double byte token
 TST R5,#&FF00
 BEQ wait$l			; line number & word not full
 MOV R0,R5,ROR#16		; get R0=8Dxxyyzz
 BIC R0,R0,#&FF000000		; remove 8D
 BL conv_3byte_ln		; find the line number
 PUSH "R1,R2"
 ADR R1,de_buf1
 MOV R2,#&10
 SWI XOS_ConvertCardinal2	; find the number
 PULL "R1,R2"
 BL str_len			; get length
 B string$l			; return string
notatoken$l
 TEQ R5,#&8D			; is it a tokenised line number
 BNE skip$l			; if not return null
 ORR R4,R4,#1<<3		; set line numbers flag
wait$l
 MOV R5,R5,ROR#8		; if so wait for next byte
 SUBS R0,R0,#0			; sec
 FNRTS
skip$l
 MOV R0,#1			; just return as ordinay byte
string$l
 MOV R5,#0
 ADDS R0,R0,#0			; clc
 FNRTS
doubletoken$l
 ADRL R0,mem_basdata
 SUB R14,R14,#&7F
 LDR R14,[R0,R14,LSL#2]
 ADD R0,R0,R14			; start of list to match
match$l
 LDR R14,[R0]
 TEQ R14,#0
 BEQ notfound$l			; not found
 EOR R14,R14,R5,ROR#24
 EOR R14,R14,R5,ROR#8
 TST R14,#&FF000000
 TSTNE R14,#&00FF00
 ADDNE R0,R0,#16
 BNE match$l			; no match
 LDRB R0,[R0,#15]		; length byte
 B string$l
notfound$l
 MOV R0,#2
 B string$l			; token not found

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copy with selecting regions				     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

basic_selection
 TEQ R0,#0
 BEQ se0			; selection start
 TEQ R0,#1
 BEQ se2			; selection move
 TEQ R0,#2
 BEQ save_selection		; saving selection
 MOV PC,R14
se0
 FNJSR
 FNcall Zap_UpdateCaret		; make sure at start of a token
 FNRTS VS
 LDR R0,[R10,#c_off]
 FNSTR R0,sel_start		; save actual selected region start
 FNRTS
se2
 STMFD R13!,{R1-R7,R14}
 MOV R7,R3
 MOV R0,#&81			; ctrl key (hardwired in :<)
 MOV R1,#&FE
 MOV R2,#&FF
 SWI XOS_Byte
 BL resetatselstart		; adjust drag checking...
 LDR R6,[R10,#c_off]		; R6=selection start (unless ctrl)
 MOV R0,R6
 BL basic_lineprev
 ;ADD R14,R0,#4
 ;CMP R6,R14
 ;FNSTR R6,sel_start,GT		; save actual selected region start
 MOV R5,R0			; R5=start of line with sel start
 LDR R4,[R10,#c_owidth]		; R4=selection end
 MOV R0,R4
 BL basic_lineprev
 MOV R3,R0			; R3=start of line with sel end
 TEQ R3,R5
 BEQ se5			; selection confined to 1 line
 TEQ R6,R5
 BEQ se4			; already at logical line start
 ;TEQ R6,R3
 ;BEQ se4a			; other end of selection at log, line start
 ;MOV R2,R5			; new selection start (R3=end)
 FNLDR R1,buf_detoken		; scrap... :/
 SWI XWimp_GetPointerInfo
 LDR R1,[R1,#8]
 TST R1,#1
 LDMNEFD R13!,{R1-R7,PC}
 ;BNE adjustdragging
 MOVEQ R2,R5			; new selection start (R3=end)
 FNcall Zap_AlterSel		; alter selected region
 LDMVSFD R13!,{R1-R7,PC}
se4
 STR R3,[R10,#c_owidth]
 B se3
;se4a
; SWI &107
; STR R5,[R10,#c_owidth]
; B se3
se5
 TEQ R6,R5
 BNE se1			; already confined
 ;LDR R2,[R10,#c_owidth]	; R4=selection end
 ;LDR R1,[R9,#f_splito]		; this code is all junk...
 ;CMP R2,R1
 ;LDR R1,[R9,#f_splits]
 ;ADDCS R2,R2,R1
 ;LDR R1,[R9,#f_ptr]
 ;ADD R1,R1,R2
 ;LDRB R1,[R1]
 ;CMP R1,#&0D
 ;SUBEQ R4,R4,#1

 ;LDR R2,[R10,#c_off]		; *good* code !tt!
 FNLDR R2,sel_start		; regain start position...? *bad code*
 CMP R2,#0
 ADDMI R2,R5,#3 ; ?
 MOV R0,R2
 BL basic_lineprev
 SUB R14,R2,R0
 CMP R14,#3
 ADDLO R2,R0,#3
 MOV R3,R4			; selection end
 FNcall Zap_AlterSel		; alter selected region
 LDMVSFD R13!,{R1-R7,PC}
se1
 STR R4,[R10,#c_owidth]
se3
 LDR R0,[R10,#c_owidth]		; old offset
 FNcall Zap_OffLineCol
 STRVC R2,[R10,#c_ocol]
 STRVC R3,[R10,#c_oline]
 LDMFD R13!,{R1-R7,PC}
;se3a
; LDR R0,[R10,#c_owidth]		; old offset - hmm.
; FNcall Zap_OffLineCol
; LDMVSFD R13!,{R1-R7,PC}
; STR R2,[R10,#c_ocol]
; STR R3,[R10,#c_oline]
; LDMFD R13!,{R1-R7,PC}

resetatselstart
 FNLDR R1,buf_detoken		; scrap... :/
 SWI XWimp_GetPointerInfo
 LDR R1,[R1,#8]
 TST R1,#1
 MVNNE R6,#0			; not a ctrl-adjust drag.
 FNSTR R6,sel_start,NE		; save actual selected region start
 MOV PC,R14

;adjustdragging
; LDMFD R13!,{R1-R7,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Replace area primative by direct DoCommand calls	      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=file offset R2=number of bytes R3=new data R4=data len R8/R9
;X file contents R1.R2 replaced by R3.R4 by minimum number of commands #
;  data is concatonated if replace/insert/delete length is 1
;  Uses DoCommand directly and multiops

replace_area			; this routine needs changing before 136 rel
 STMFD R13!,{R1-R5,R14}
 ;SWI &107
 MOV R5,R1			; save file offset
re24
 CMP   R2,#0
 CMPGT R4,#0
 BLE re25
 MOV R0,R5
 BL cln_readc
 LDRB R1,[R3]
 TEQ R0,R1
 ADDEQ R5,R5,#1
 ADDEQ R3,R3,#1
 SUBEQ R2,R2,#1
 SUBEQ R4,R4,#1
 BEQ re24
re26
 CMP   R2,#0
 CMPGT R4,#0
 BLE re25
 ADD R0,R5,R2
 SUB R0,R0,#1
 BL cln_readc
 ADD R1,R3,R4
 LDRB R1,[R1,#-1]
 TEQ R0,R1
 SUBEQ R2,R2,#1
 SUBEQ R4,R4,#1
 BEQ re26
 TEQ R2,R4			; neither string is null
 BEQ re27			; strings are of same length
 FNcall Zap_StartOp
 MOV R1,R5
 MOV R0,#2
 CMP R2,#1
 ORRGT R0,R0,#&10		; don't concat if large block
 FNcall Zap_DoCommand		; delete the old data
 BVS re20
 MOV R2,R4
 MOV R0,#1
 CMP R2,#1
 ORRGT R0,R0,#&10
 FNcall Zap_DoCommand		; insert the new data
re20
 FNcall Zap_StopOp
 LDMFD R13!,{R1-R5,PC}
re27
 MOV R0,#3			; replace
 MOV R1,R5
 CMP R2,#1
 ORRGT R0,R0,#&10
 FNcall Zap_DoCommand		; replace the data
 LDMFD R13!,{R1-R5,PC}
re25
 TEQ R2,R4			; are both null?
 LDMEQFD R13!,{R1-R5,PC}
 CMP R2,#0
 BLE re28
 MOV R0,#2
 MOV R1,R5
 CMP R2,#1
 ORRGT R0,R0,#&10
 FNcall Zap_DoCommand		; delete old and none to replace
 LDMFD R13!,{R1-R5,PC}
re28
 MOV R0,#1
 MOV R1,R5
 MOV R2,R4
 CMP R2,#1
 ORRGT R0,R0,#&10
 FNcall Zap_DoCommand		; insert new as none to delete
 LDMFD R13!,{R1-R5,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Prepare line for search				      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R1=2 => R3=search file offset R4=direction R8/R9
;  R1=3 => R1=detokenised str R2=offset/-ve R3=file off of line
;	   R4=search dir R10=len of the string in R1 R8/R9
;  R1=4 => As for 3 but R2 if the end of match offset
;X If R1=2 return vals as passed with R1=3
;  If R1=3 return R1=0 R2=file off of match R3=next offset

basic_search
 FNJSR
 TEQ R1,#3
 BEQ end$l
 TEQ R1,#4
 BEQ delimit$l
 TEQ R1,#2
 FNRTS NE
start$l
 CMP R4,#0
 BMI bac$l			; don't need to adjust as going backwards
 SUBS R0,R3,#1			; character before (start of token)
 BMI bac$l
 BL cln_readc			; R0=the byte
 TEQ R0,#&8D
 ADDEQ R3,R3,#3			; skip a line number
 TEQ R0,#&C7
 TEQNE R0,#&C8
 ADDEQ R3,R3,#1			; double byte token
bac$l				; R3 now adjusted
 MOV R0,R3
 BL basic_lineprev		; start of the line
 FNRTS VS
 MOV R10,R0			; save start of the line number
 ADD R0,R0,#3			; start of the line
 CMP R4,#0
 BPL for$l			; don't need to check in line number
 CMP R3,R0
 BGE for$l			; it's ok
 SUBS R3,R10,#1			; end of the line before
 BPL bac$l			; not off file start
 FNLDR R1,buf_detoken
 MOV R2,#0
 MOV R3,#0
 MOV R10,#0			; ignore this line
 FNRTS
for$l				; R0=start of line
 MOV R1,R3			; file off in the line
 BL detokenise_line		; R0=file end R1=start R2=det len R3=col
 FNRTS VS
 SUB R0,R0,R10
 ADD R0,R0,#1			; length (inc terminator)
 STR R0,data$l
 MOV R0,R10			; save start offset
 ADD R10,R2,#1			; detokenised length (inc &0D)
 MOV R2,R3			; column offset in line to start at
 MOV R3,R0			; file offset of line start
 FNRTS
end$l
 CMP R2,#0
 BPL match$l
 CMP R4,#0
 SUBMI R3,R3,#1
 LDRPL R0,data$l
 ADDPL R3,R3,R0			; move to next line
 B ret$l
match$l				; convert match to file offset
 MOV R0,R3			; file offset of line start
 MOV R1,R2			; column offset in line
 BL basic_linecol		; convert to an offset
 FNRTS VS
 MOV R2,R0			; match offset
 ADD R3,R2,R4			; next location
 CMP R4,#0
 BMI ret$l			; done - going backwards
 BL cln_readc			; read the character at this offset
 TEQ R0,#&8D
 ADDEQ R3,R3,#3			; skip a line number
 TEQ R0,#&C7
 TEQNE R0,#&C8
 ADDEQ R3,R3,#1			; double byte token
ret$l
 MOV R1,#0
 FNRTS
delimit$l
 MOV R0,R3			; file offset of line start
 SUBS R1,R2,#1			; column offset in line of char before end
 ADDMI R2,R3,#3
 BMI ret$l			; was at start of line
 BL basic_linecol		; convert to an offset
 FNRTS VS
 MOV R2,R0			; offset just before end of match
 ADD R2,R2,#1			; offset of match end
 BL cln_readc			; read the character
 TEQ R0,#&8D
 ADDEQ R2,R2,#3			; skip a line number
 TEQ R0,#&C7
 TEQNE R0,#&C8
 ADDEQ R2,R2,#1			; double byte token
 B ret$l			; R2=end of match offset
data$l DCD 0			; save total length of line for follow on

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; List functions					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

basic_listfns
 CMP R8,#0			; from IB?
 MOVEQ PC,R14			; yes.
 ADR R0,def$l			; "DEF" string
 MOV R1,#1			; to buffer
 MOV R3,#0			; at start
 MOV R4,#1			; +ve direction
 MOV R5,#&F<<28			; string, raw search, no macros etc
 FNjump Zap_Search
def$l = &DD,0			; tokenised DEF
 ALIGN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tokenise Subs							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=pointer to source line (ending in 0D) R7=cursor column R8/0
;  R2=flags
;X R0=len (exc &0D) string tokenised to buf_retoken #
;  R1=source detokenised line length (exc &0D)
;  Cursor column R7 updated for every '.' expanded.
;  Error given if tokenised line is longer than &FB chars.

tokenise_line_speshally
tokenise_line
 STMFD R13!,{R2-R6,R8-R10,R14}
 STR R8,r8windowifneeded
 MOV R4,R0			; source line
 FNLDR R5,buf_retoken		; current pointer
 ADRL R6,mem_basdata		; basic data table
 ADD R8,R4,#1			; source start +1
 ADD R9,R5,#&FB			; end (BASIC lines can only be &FF long)
to3
 CMP R5,R9
 BHI to8			; line full
dontcareiflineisfull
 LDRB R0,[R4],#1		; get next char
 TEQ R0,#&0D
 BEQ to10			; finished?
notfinishedyet$l
 TEQ R0,#fake_tab_character	; pseudo-tab
 BEQ toatab$l
 BL tokenise_char
 B to3
to8
 BL mb_err37
 BNE dontcareiflineisfull
 BL err37
 LDMFD R13!,{R2-R6,R8-R10,PC}
to10
 LDRB R14,[R4]			; get next char
 CMP R14,#&0D
 BNE notfinishedyet$l
 STRB R0,[R5]			; terminator
 FNLDR R1,buf_retoken
 SUB R0,R5,R1			; string length
 SUB R1,R4,R8			; source length
 LDMFD R13!,{R2-R6,R8-R10,PC}
toatab$l
 MOV R0,#32
 BL tokenise_char ; bad news...?
 SUB R5,R5,#1
 B to3
r8windowifneeded
 DCD 0

mb_err37
 FNJSR "R0-R12"
 ADD R14,R9,#&10	; end &10B approx.
 CMP R5,R14
 MOVGES R0,#0
 FNRTS EQ
 LDR R8,r8windowifneeded ; needed.
 BL basic_get_the_mode_word
 TST R0,#1 << 27
 FNRTS EQ
 ADR R0,err_linetoolong
  [ INTL=""
 MOV R1,#1<<29
  |
 MOV R1,#0
  ]
 FNcall Zap_Warning ; assume we have a window...
 MVNS R0,#0
 FNRTS
err_linetoolong
 StrZA "basic_toolong","BASIC line too long"

;E R0=source line (ending in <&20) R2=tokenise flags
;X R0=len string tokenised to buf_retoken R1=source len #

tokenise_search_string
 STMFD R13!,{R2-R10,R14}
 MOV R4,R0			; source line
 FNLDR R5,buf_retoken		; current pointer
 ADRL R6,mem_basdata		; basic data table
 ADD R8,R4,#1			; source start +1
 ADD R9,R5,#&FB			; end (basic lines can only be &FF long)
to13
 CMP R5,R9
 BHI to18			; line full
 LDRB R0,[R4],#1		; get next char
 CMP R0,#&20
 BCC to11			; finished
 BL tokenise_char
 B to13
to18
 BL err37
 LDMFD R13!,{R2-R10,PC}
to11
 MOV R0,#0
 STRB R0,[R5]			; terminator
 FNLDR R1,buf_retoken
 SUB R0,R5,R1			; string length
 SUB R1,R4,R8			; source length
 LDMFD R13!,{R2-R10,PC}

 LOCAL

local7$l
 DCD 0

;E R0=char R2=flags (b0=REM b1="" b2=fn mode b3=wait for linenum)
;   b0=in REM or DATA (b2 of R5 in BASICs code)
;   b1=inside quotes (b0 of R5 in BASICs code)
;   b2=set when in FN mode (R3=1 in BASICs code)
;   b3=set when waiting for a line number (R4=&8D  in BASICs code)
;   b4=set if you should copy the following alphanumerics then switch
;      to FN mode no wait for line numbers (in a variable)
;   b5=set if not at line start (or after : - can give a different ELSE)
;   b6=set if copy across the following hex digits (in a hex expression)
;   b7=set if copy across following digits and '.'s (in a number)
;   b8=set to expand "." when tokenising.
;   b9=set if not at line start
;   b10=recent PRINT, VDU etc.
;   b11=assembler comment?
;   b14=a DEF since the last start of line / active ':'
;   b15=strip out pseudo-'tabs'...?
;   b28-31='()' bracket depth ?????? no.
;  R4=source (char after R0) R5=dest R6=basdata R7=cursor column
;X next character copied to output R2/R4/R5 updated R0-R3,R10 corrupt
;  R7 updated for each '.' expanded #

tokenise_char
 FNJSR
 TST R2,#1<<6
 BNE inhexnum$l			; in some hex expression
 TST R2,#1<<7
 BNE indecnum$l			; in some decimal expression
 TST R2,#1<<4
 BNE invariable$l		; in some alpha numeric expression
cont$l				; decimal num/variable/hex num finished
 TEQ R0,#&20			; space
 BEQ char$l			; skip
 TEQ R0,#&22			; quote
 TSTEQ R2,#&800			; and not in asm comment
 TSTEQ R2,#&80000000		; and not in * command
 EOREQ R2,R2,#2			; toggle quote state
 TST R2,#3			; should we skip ; TT
 BNE char$l			; skip (as in quote/rem or after a *)
 TEQ R0,#':'
 BEQ newline$l			; start new statement
 TST R2,#&800			; asm comment...
 BNE char$l			; skip (as in quote/rem or after a *)
 TEQ R0,#'&'
 BEQ hex$l			; hex expression follows
 TEQ R0,#';'
 TEQNE R0,#'\'
 BLEQ red_bas_semi2		; asm comment (sets bit 11)
 TEQ R0,#','
 BEQ char$l			; skip (may be a list of line numbers)
 TEQ R0,#'*'
 BEQ star$l			; * command or multiply
 TEQ R0,#'.'			; TT fix...
 BEQ num$l			; after a . label or dec point
 BL test_decdigit
 BCC keyword$l			; not a digit
 TST R2,#8
 BEQ num$l			; if not a line number then copy the expr
 SUB R1,R0,#'0'			; current sum
 MOV R3,R4			; current pointer
a$l
 LDRB R0,[R3],#1
 BL test_decdigit
 BCC linenum$l			; found line number ok
 SUB R0,R0,#'0'			; next digit
 ADD R1,R1,R1,LSL#2		; mult by 5
 ADD R1,R0,R1,LSL#1		; mult by 10 and add last digit
 CMP R1,#&FF00
 BCC a$l			; do next digit
 LDRB R0,[R4,#-1]		; restore R0
 B num$l			; too large so copy as a number
setfn$l
 ORR R2,R2,#4			; fn mode
 BIC R2,R2,#8			; no wait for lns
char$l
 ; BL ba_testcolon_general	; ???
 TEQ R0,#&20
 ORRNE R2,R2,#((1<<5) + (1<<9))	; no longer at line start
inchar$l
 STRB R0,[R5],#1
 FNRTS
hex$l
 ORR R2,R2,#1<<6		; copy hex digits
 B char$l			; continue
inhexnum$l
 BL test_hexdigit
 BCS char$l			; copy the hex digit
 BIC R2,R2,#1<<6		; cancel
 B cont$l			; continue

constantbicmask2
 DCD &3FFFFFFC

newline$l
 BIC R2,R2,#1<<5		; reset modes
 BIC R2,R2,#(1<<14)+(3<<10)	; clear recent DEF flag...
 ORR R2,R2,#(1<<9)		; treat an ELSE normally...
 B inchar$l			; continue
star$l
 TST R2,#1<<5			; are we in command mode
 ORREQ R2,R2,#1			; don't tokenise if so (OSCLI)
 BEQ char$l			; and continue
 TST R2,#1<<14			; are we in a DEF...structure...?
 ;ORRNE R2,R2,#1		; don't tokenise if so (OSCLI)
				; (*cmds broken unless preceded by ':')
 BEQ char$l			; and continue
 B setfn$l			; continue reseting mode to fn
num$l
 ORR R2,R2,#1<<7		; copy dec exprns
 B char$l
indecnum$l
 BL test_decexpr		; dec digit or "."
 BCS char$l			; copy the dec digit
 BIC R2,R2,#1<<7		; cancel mode
 ORR R2,R2,#4			; FN mode
 BIC R2,R2,#8			; no wait for lns
 B cont$l			; continue
linenum$l
 SUB R4,R3,#1			; next char to look at
 MOV R0,R1			; line number
 BL conv_ln_3byte		; 3 byte form
 FNRTS VS
 MOV R14,#&8D
 STRB R14,[R5],#1		; tokenised number follows
 STRB R0,[R5],#1
 MOV R0,R0,LSR#8		; save new line number
 STRB R0,[R5],#1
 MOV R0,R0,LSR#8		; Don't change wait for line num status
 STRB R0,[R5],#1		; for ON GOTO 1,2,3 etc.
 ORR R2,R2,#1<<5		; no longer at line start
 FNRTS
keyword$l
 CMP R0,#'A'
 BCC variable$l			; not keyword
 CMP R0,#'Z'
 BHI variable$l			; not keyword
 SUB R1,R0,#'A'			; offset from A
 ADD R3,R6,#&204		; letter offsets table
 LDR R1,[R3,R1,LSL#2]		; this letter offset
 CMP R1,#0
 BLE variable$l			; no keywords starting with this letter
 ADD R1,R6,R1			; start of list
entry$l
 LDR R0,[R1]
 TEQ R0,#0
 LDREQB R0,[R4,#-1]		; restore R0 &
 BEQ variable$l			; reached end of list
 MOV R3,R4			; next char
 ADD R10,R1,#1			; next to match
b$l
 STR R7,local7$l
 LDRB R14,[R10],#1		; table byte
 TEQ R14,#0
 BEQ match$l			; found match
 LDRB R0,[R3],#1		; source byte
 TEQ R0,R14
 BEQ b$l			; continue match
 TEQ R0,#'.'			; can we expand a dot?
 ADDNE R1,R1,#16
 BNE entry$l			; if not try next table entry
 TST R2,#1<<8
 ADDEQ R1,R1,#16
 BEQ entry$l			; dots not expandable
c$l
 LDRB R0,[R10],#1
 TEQ R0,#0
 ADDNE R7,R7,#1			; expand each extra character
 BNE c$l
match$l
 LDR R1,[R1,#12]		; get token word
 MOV R10,R1,LSR#24		; get BASIC Info Byte
 TST R10,#1
 BEQ d$l			; doesn't matter if alphanumeric follows
 LDRB R0,[R3]			; get next byte
 BL test_alphanum
 LDRCS R7,local7$l		; Don't update column...TT?
 LDRCSB R0,[R4,#-1]		; restore R0 &
 BCS variable$l			; continue as no match
d$l
 MOV R4,R3			; update source pointer
 TST R10,#1<<3			; is it a 2 byte token
 BEQ onebyte$l			; no
 STRB R1,[R5],#1		; pre-main tokenisation storage here...
 MOV R1,R1,LSR#8
 BIC R10,R10,#4			; don't go to command mode
 B endkeyword$l
onebyte$l
 AND R0,R1,#&FF			; default token
 TEQ R0,#&8B			; ELSE is a special case
 BEQ anelse$l			; Not an else
notelse$l
 TST R10,#1<<6			; different token in fn mode?
 BNE differentinfnmode$l
endkeyword$l
 STRB R1,[R5],#1		; Main tokenisation storage here...

 AND R0,R1,#&FF			; default token
 ADRL R14,tokentabllkupasm - &80; table...
 LDRB R14,[R14,R0]
 TST R14,#2			; tokenised print/swi/vdu &c
 ORRNE R2,R2,#&400		; set recent print flag...

 TST R10,#2			; force FN mode?
 ORRNE R2,R2,#4
 ; BICNE R2,R2,#8
 BIC R2,R2,#1<<3
 TST R10,#4			; force command mode?
 BICNE R2,R2,#&C
 TST R10,#1<<4
 ORRNE R2,R2,#1<<3		; line numbers may follow
 TST R10,#1<<5
 ORRNE R2,R2,#1			; don't tokenise following
 ;AND R1,R1,#&FF		; get the actual token
 TEQ   R0,#&A4			; FN...?
 TEQNE R0,#&F2			; PROC...?
 ORREQ R2,R2,#1<<4		; copy alphanumerics after FN/PROC
 ORR R2,R2,#1<<5:OR:1<<9;1<<5	; no longer at line start
 TST R14,#8			; tokenised the/else/else command ;(TT)
 BICNE R2,R2,#&20		; reset modes
 CMP R0,#&DD			; tokenised DEF command ;(TT)
 ORREQ R2,R2,#1<<14		; set recent DEF flag...
 FNRTS
variable$l
 BL test_alphanum
 BCC setfn$l			; default mode a carry on if no
 ORR R2,R2,#1<<4		; copy alpha num
 B char$l
invariable$l
 BL test_alphanum
 BCS char$l			; carry on
 BIC R2,R2,#1<<4		; no longer in alpha num
 ORR R2,R2,#4			; FN mode
 BIC R2,R2,#8			; no wait for lns
 B cont$l			; continue processing this byte
anelse$l
 TST R2,#1<<9			; are we at line start
 MOVEQ R1,#&CC			; other code for ELSE at line start
 B endkeyword$l
differentinfnmode$l
 ;TST R2,#4			; in FN mode?
 TST R2,#1<<5			; at SOL...?
 MOVNE R1,R1,LSR#16		; get function mode token
 B endkeyword$l

; ADRL R14,tokentabllkupasm - &80; table...
; LDRB R14,[R14,R0]
; TST R14,#8

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Tokenise Subs						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;E R0=pointer to source line (ending in 0D) R7=cursor column
;;  R2=flags
;;X R0=len (exc &0D) string tokenised to buf_retoken #
;;  R1=source detokenised line length (exc &0D)
;;  Cursor column R7 updated for every '.' expanded.
;;  Error given if tokenised line is longer than &FB chars.
;
;tokenise_line
; STMFD R13!,{R2-R6,R8-R10,R14}
; MOV R4,R0			; source line
; FNLDR R5,buf_retoken		; current pointer
; ADRL R6,mem_basdata	       ; basic data table
; ADD R8,R4,#1			; source start +1
; ADD R9,R5,#&FB			; end (basic lines can only be &FF long)
;to3
; CMP R5,R9
; BHI to8			; line full
; LDRB R0,[R4],#1		; get next char
; TEQ R0,#&0D
; BEQ to10			; finished
; BL tokenise_char
; B to3
;to8
; BL err37
; LDMFD R13!,{R2-R6,R8-R10,PC}
;to10
; STRB R0,[R5]			; terminator
; FNLDR R1,buf_retoken
; SUB R0,R5,R1			; string length
; SUB R1,R4,R8			; source length
; LDMFD R13!,{R2-R6,R8-R10,PC}
;
;;E R0=source line (ending in <&20) R2=tokenise flags
;;X R0=len string tokenised to buf_retoken R1=source len #
;
;tokenise_search_string
; STMFD R13!,{R2-R10,R14}
; MOV R4,R0			; source line
; FNLDR R5,buf_retoken		; current pointer
; ADRL R6,mem_basdata	       ; basic data table
; ADD R8,R4,#1			; source start +1
; ADD R9,R5,#&FB			; end (basic lines can only be &FF long)
;to13
; CMP R5,R9
; BHI to18			; line full
; LDRB R0,[R4],#1		; get next char
; CMP R0,#&20
; BCC to11			; finished
; BL tokenise_char
; B to13
;to18
; BL err37
; LDMFD R13!,{R2-R10,PC}
;to11
; MOV R0,#0
; STRB R0,[R5]			; terminator
; FNLDR R1,buf_retoken
; SUB R0,R5,R1			; string length
; SUB R1,R4,R8			; source length
; LDMFD R13!,{R2-R10,PC}
;
; LOCAL
;
;;E R0=char R2=flags (b0=REM b1="" b2=fn mode b3=wait for linenum)
;;   b0=in REM or DATA (b2 of R5 in BASICs code)
;;   b1=inside quotes (b0 of R5 in BASICs code)
;;   b2=set when in FN mode (R3=1 in BASICs code)
;;   b3=set when waiting for a line number (R4=&8D  in BASICs code)
;;   b4=set if you should copy the following alphanumerics then switch
;;	to FN mode no wait for line numbers (in a variable)
;;   b5=set if not at line start (or after : - gives different ELSE)
;;   b6=set if copy across the following hex digits (in a hex expression)
;;   b7=set if copy across following digits and '.'s (in a number)
;;   b8=set to expand "." when tokenising.
;;  R4=source (char after R0) R5=dest R6=basdata R7=cursor column
;;X next character copied to output R2/R4/R5 updated R0-R3,R10 corrupt
;;  R7 updated for each '.' expanded #
;
;tokenise_char
; FNJSR
; TST R2,#1<<6
; BNE inhexnum$l			; in some hex expression
; TST R2,#1<<7
; BNE indecnum$l			; in some decimal expression
; TST R2,#1<<4
; BNE invariable$l		; in some alpha numeric expression
;cont$l				; decimal num/variable/hex num finished
; TEQ R0,#&20			; space
; BEQ char$l			; skip
; TEQ R0,#&22			; quote
; EOREQ R2,R2,#2			; toggle quote state
; TST R2,#3			; should we skip
; BNE char$l			; skip (as in quote/rem or after a *)
; TEQ R0,#'&'
; BEQ hex$l			; hex expression follows
; TEQ R0,#':'
; BEQ newline$l			; start new statement
; TEQ R0,#','
; BEQ char$l			; skip (may be a list of line numbers)
; TEQ R0,#'*'
; BEQ star$l			; * command or multiply
; TEQ R0,#'.'
; BEQ num$l			; after a . label or dec point
; BL test_decdigit
; BCC keyword$l			; not a digit
; TST R2,#8
; BEQ num$l			; if not a line number then copy the expr
; SUB R1,R0,#'0'			; current sum
; MOV R3,R4			; current pointer
;a$l
; LDRB R0,[R3],#1
; BL test_decdigit
; BCC linenum$l			; found line number ok
; SUB R0,R0,#'0'			; next digit
; ADD R1,R1,R1,LSL#2		; mult by 5
; ADD R1,R0,R1,LSL#1		; mult by 10 and add last digit
; CMP R1,#&FF00
; BCC a$l			; do next digit
; LDRB R0,[R4,#-1]		; restore R0
; B num$l			; too large so copy as a number
;setfn$l
; ORR R2,R2,#4			; fn mode
; BIC R2,R2,#8			; no wait for lns
;char$l
; TEQ R0,#&20
; ORRNE R2,R2,#1<<5		; no longer at line start
; STRB R0,[R5],#1
; FNRTS
;hex$l
; ORR R2,R2,#1<<6		; copy hex digits
; B char$l			; continue
;inhexnum$l
; BL test_hexdigit
; BCS char$l			; copy the hex digit
; BIC R2,R2,#1<<6		; cancel
; B cont$l			; continue
;newline$l
; BIC R2,R2,#&0F			; reset modes
; B char$l			; continue
;star$l
; TST R2,#4			; are we in command mode
; ORREQ R2,R2,#1			; don't tokenise if so (OSCLI)
; BEQ char$l			; and continue
; B setfn$l			; continue reseting mode to fn
;num$l
; ORR R2,R2,#1<<7		; copy dec exprns
; B char$l
;indecnum$l
; BL test_decexpr		; dec digit or "."
; BCS char$l			; copy the dec digit
; BIC R2,R2,#1<<7		; cancel mode
; ORR R2,R2,#4			; fn mode
; BIC R2,R2,#8			; no wait for lns
; B cont$l			; continue
;linenum$l
; SUB R4,R3,#1			; next char to look at
; MOV R0,R1			; line number
; BL conv_ln_3byte		; 3 byte form
; FNRTS VS
; MOV R14,#&8D
; STRB R14,[R5],#1		; tokenised number follows
; STRB R0,[R5],#1
; MOV R0,R0,LSR#8		; save new line number
; STRB R0,[R5],#1
; MOV R0,R0,LSR#8		; Don't change wait for line num status
; STRB R0,[R5],#1		; for On Goto 1,2,3 etc.
; ORR R2,R2,#1<<5		; no longer at line start
; FNRTS
;keyword$l
; CMP R0,#'A'
; BCC variable$l			; not keyword
; CMP R0,#'Z'
; BHI variable$l			; not keyword
; SUB R1,R0,#'A'			; offset from A
; ADD R3,R6,#&204		; letter offsets table
; LDR R1,[R3,R1,LSL#2]		; this letter offset
; CMP R1,#0
; BLE variable$l			; no keywords starting with this letter
; ADD R1,R6,R1			; start of list
;entry$l
; LDR R0,[R1]
; TEQ R0,#0
; LDREQB R0,[R4,#-1]		; restore R0 &
; BEQ variable$l			; reached end of list
; MOV R3,R4			; next char
; ADD R10,R1,#1			; next to match
;b$l
; LDRB R14,[R10],#1		; table byte
; TEQ R14,#0
; BEQ match$l			; found match
; LDRB R0,[R3],#1		; source byte
; TEQ R0,R14
; BEQ b$l			; continue match
; TEQ R0,#'.'			; can we expand a dot?
; ADDNE R1,R1,#16
; BNE entry$l			; if not try next table entry
; TST R2,#1<<8
; ADDEQ R1,R1,#16
; BEQ entry$l			; dots not expandable
;c$l
; LDRB R0,[R10],#1
; TEQ R0,#0
; ADDNE R7,R7,#1			; expand each extra character
; BNE c$l
;match$l
; LDR R1,[R1,#12]		; get token word
; MOV R10,R1,LSR#24		; get Basic Info Byte
; TST R10,#1
; BEQ d$l			; doesn't matter if alphanumeric follows
; LDRB R0,[R3]			; get next byte
; BL test_alphanum
; LDRCSB R0,[R4,#-1]		; restore R0 &
; BCS variable$l			; continue as no match
;d$l
; MOV R4,R3			; update source pointer
; TST R10,#1<<3		; is it a 2 byte token
; BEQ onebyte$l			; no
; STRB R1,[R5],#1
; MOV R1,R1,LSR#8
; BIC R10,R10,#4			; don't go to command mode
; B endkeyword$l
;onebyte$l
; AND R0,R1,#&FF			; default token
; TEQ R0,#&8B			; Else is a special case
; BNE notelse$l			; Not an else
; TST R2,#1<<5		; are we at line start
; MOVEQ R1,#&CC			; other code for else at line start
; B endkeyword$l
;notelse$l
; TST R10,#1<<6		; different token in fn mode?
; BEQ endkeyword$l		; no
; TST R2,#4
; MOVNE R1,R1,LSR#16		; get function mode token
;endkeyword$l
; STRB R1,[R5],#1
; TST R10,#2			; force fn mode?
; ORRNE R2,R2,#4
; BICNE R2,R2,#8
; TST R10,#4			; force command mode?
; BICNE R2,R2,#&C
; TST R10,#1<<4
; ORRNE R2,R2,#8			; line numbers may follow
; TST R10,#1<<5
; ORRNE R2,R2,#1			; don't tokenise following
; AND R1,R1,#&FF			; get the actual token
; TEQ	R1,#&A4			; Fn
; TEQNE R1,#&F2			; Proc
; ORREQ R2,R2,#1<<4		; copy alphanumerics after Fn/Proc
; ORR R2,R2,#1<<5		; no longer at line start
; FNRTS
;variable$l
; BL test_alphanum
; BCC setfn$l			; default mode a carry on if no
; ORR R2,R2,#1<<4		; copy alpha num
; B char$l
;invariable$l
; BL test_alphanum
; BCS char$l			; carry on
; BIC R2,R2,#1<<4		; no longer in alpha num
; ORR R2,R2,#4			; fn mode
; BIC R2,R2,#8			; no wait for lns
; B cont$l			; continue processing this byte

;E R0=byte
;X R0 saved and CS if one of the following |

test_decexpr
 CMP R0,#'.'
 MOVEQ PC,R14
test_decdigit
 CMP R0,#'9'
 BICHIS PC,R14,#Cbit
 CMP R0,#'0'
 MOV PC,R14

test_hexdigit
 CMP R0,#'f'
 BICHIS PC,R14,#Cbit
 CMP R0,#'a'
 MOVCS PC,R14
 CMP R0,#'F'
 BICHIS PC,R14,#Cbit
 CMP R0,#'A'
 MOVCS PC,R14
 B test_decdigit

;E R0 = char
;X CC = non-alpha - CS = alphanumeric.
test_alphanum
 CMP R0,#'z'
 BICHIS PC,R14,#Cbit
 CMP R0,#'_'			; &5F
 MOVCS PC,R14
 CMP R0,#'Z'
 BICHIS PC,R14,#Cbit
 CMP R0,#'A'
 MOVCS PC,R14
 B test_decdigit

 LOCAL

shorttab$l	DCD az1$l - shorttab$l,0,cz1$l - shorttab$l
		DCD 0,0 ; dz1$l - shorttab$l,ez1$l - shorttab$l
		DCD fz1$l - shorttab$l,0,0,iz1$l - shorttab$l,0,0
		DCD lz1$l - shorttab$l,0,0,0,pz1$l - shorttab$l,0
		DCD rz1$l - shorttab$l,sz1$l - shorttab$l,0,0
		DCD vz1$l - shorttab$l,0,0,0,0 ;zz1$l - shorttab$l

az1$l = "1~2~3~4~SL}SR}",0
;bz1$l = "{",0
cz1$l = "0~10~11~12~13~14~15~1~2~3~4~5~6~7~8~9~P0~P10~P11~P12~P13~P14~P15~P1~P2~P3~P4~P5~P6~P7~P8~P9~",0
;dz1$l = "{",0
;ez1$l = "{",0
fz1$l = "0~1~2~3~4~5~6~7~P{",0
iz1$l = "P~",0
lz1$l = "INK~K~R~SL}SR}",0
;nz1$l = "{",0
pz1$l = "0~10~11~12~13~14~15~1~2~3~4~5~6~7~8~9~C|",0
rz1$l = "0|10|11|12|13|14|15|1|2|3|4|5|6|7|8|9|OL}OR}RX}",0
sz1$l = "L|P|",0
vz1$l = "1~2~3~4~5~6~",0
;zz1$l = "{",0

 ALIGN

testforasmreg
 PUSH "R14"
 ADRL R14,localmodeword
 LDR R14,[R14]
 TST R14,#1 << 29
 LDMNEFD R13 !,{PC}
 STR R1,bas_localstored1	; B for later
 SUB R14,R1,#'A'
 MOV R14,R14,LSL #2
 ADR R1,shorttab$l
 LDR R1,[R1,R14]
 PULL "R14"
 CMP R1,#0			; R1 corrupted in this instance...
 MOVEQ PC,R14

 FNJSR "R0,R5,R6,R7,R10"
 ;SWI &107
 ADR R6,shorttab$l
 ADD R6,R6,R1
 STR R7,bas_localstored0
 STR R10,bas_localstored4
 STR R5,bas_localstored5
loop1$l
 MOV R1,#0
 LDR R7,bas_localstored0
 LDR R10,bas_localstored4
loop2$l
 BL getnextasmletter
 LDRB R14,[R6,R1]
 CMP R14,#'Z'
 BGT bai_foundaregstage1
 TEQ R14,#0
 BEQ bai_notfoundareg
 CMP R0,R14
 ADDEQ R1,R1,#1
 BEQ loop2$l
 CMPLT R1,#0
 BEQ bai_notfoundareg
ba_reg_nextoneplease
 LDRB R14,[R6],#1
 CMP R14,#'Z'
 BLE ba_reg_nextoneplease
 B loop1$l

bai_foundaregstage1
 LDR R7,bas_localstored0
 LDR R10,bas_localstored4
 LDR R5,bas_localstored5
 STR R14,bas_localstored1
 STR R0,bas_localstored4 ; ?
 ;SUB R7,R7,#2			; hmm.
 BL getprevasmletter
 CMP R0,#&A4			; FNtoken
 BEQ bai_notfoundareg		; no preceding...
 CMP R0,#&80
 BCS carronasfound
 BL getprevasmletter
 CMP R0,#&A4			; FNtoken
 BEQ bai_notfoundareg		; no preceding...
 CMP R0,#&80
 BCS carronasfound
 BL getprevasmletter
 CMP R0,#&A4			; FNtoken
 BEQ bai_notfoundareg		; no preceding...
 CMP R0,#&80
 BCS carronasfound
 CMP R0,#'['
 CMPNE R0,#'{'
 ;CMPNE R0,#':'	; for moveqR0 case...?
 CMPNE R0,#'@'
 BLE carronasfound
 CMP R0,#&A4			; FNtoken
 BEQ bai_notfoundareg		; no preceding...
 CMP R0,#&80
 BGE carronasfound
 BL getprevasmletter
 CMP R0,#':'
 CMPNE R0,#&A4			; FNtoken
 BEQ bai_notfoundareg		; no preceding...
 CMP R0,#'@'
 BLE carronasfound		; no preceding...
 CMP R0,#&80
 BGE carronasfound
 BL getprevasmletter
 CMP R0,#':'
 CMPNE R0,#&A4			; FNtoken
 BEQ bai_notfoundareg		; no preceding...
carronasfound
 LDR R0,bas_localstored4
 LDR R14,bas_localstored1
 CMP R0,#'0'
 BCC foundthattherereg
 CMP R0,#';'			; comments...
 CMPNE R0,#'\'			; comments...
 CMPNE R0,#':'
 BEQ foundthattherereg
 CMP R0,#'R'
 CMPNE R0,#':'
 CMPLE R14,#'}'
 BEQ foundthattherereg
 ;BIC R1,R0,#&20
 CMP R0,#'Z'
 BLE bai_notfoundareg ; hmm.
foundthattherereg
 LDR R14,bas_localstored1
 CMP R14,#'{'
 ANDEQ R1,R2,#&200000		; still in instr...?
 CMP R1,#&200000		; yes...?
 BEQ bai_notfoundareg
 BIC R2,R2,#&1E000000		; clear in asm label...?
 BIC R2,R2,#&00710000		; clear in asm label...?
 BIC R2,R2,#&00007400		; clear recent flags...
 ;BIC R2,R2,#&00000008		; SOL & 'GOTO' flag
 CMP R14,#'{'
 CMPNE R14,#'~'
 BEQ disableapcs
notdisableapcs
 ORR R2,R2,#&800000		; found reg...
 CMP R14,#'}'
 ORREQ R2,R2,#&2000000		; found shift...
bai_notfoundareg
 FNRTS

 LOCAL

disableapcs
 ADRL R1,localmodeword
 LDR R1,[R1]
 TST R1,#1 << 28
 BNE bai_notfoundareg
 B notdisableapcs

bai_checkforlong
 BL getnextasmletter
 STR R0,bas_localstored2
 STR R7,bas_localstored0
 STR R10,bas_localstored4
 CMP R0,#' '
 BLE bai_foundasmstage4
 B bai_notfoundatall

table$l DCD aa$l - table$l,bb$l - table$l,cc$l - table$l
	DCD dd$l - table$l,ee$l - table$l
	DCD ff$l - table$l,0,0,0,0
	DCD 0,ll$l - table$l,mm$l - table$l,nn$l - table$l,oo$l - table$l
	DCD pp$l - table$l,0,rr$l - table$l,ss$l - table$l,tt$l - table$l
	DCD uu$l - table$l,vv$l - table$l,ww$l - table$l,0,0,zz$l - table$l
	DCD 0,_I$l - table$l

;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
aa$l = 0,1,4,7,0,0,0,0,0,0,0,16,0,21,0,0,0,0,24,32,0,0,0,0,0,0
aX$l = "S",0,"S",0,"C|D|FR|",0,"IGN",0,"D|",0,"NSERT{",0,"N"
;	B  C  D	       L    N  S       T
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
bb$l = 1,0,4,0,9,0,12,17,22,0,0,25,83,86,0,91,0,94,0,0,0,97,0,0,0,0 ; ???
bX$l = "L",0,"CS",0,"Q",0,"ET",0,"IS",0,"C|",0,"ALCCCSEQEGEGTHIHSLELSLOLTMINENVOPLST",0,"I",0,"EV",0,"L",0,"K",0,"CS",0
;	A  C	E  G	H    I  L							  M  N	  P  R  V
;	0000000001111111111222222222233333333334444444444555555555566666666667777777777888888888899999999990000000000
;	1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
;bX$l = "L",0,"CS",0,"Q",0,"ET",0,"IS",0,"C|",0,"%ALCCCSEQEGEGTHIHSLELSLOLTMINENVOPLST",0,"I",0,"EV",0,"L",0,"K|",0,"CS",0

;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
cc$l = 0,0,0,1,0,0,0,0,1,0,0,0,6,16,22,0,0,0,0,0,0,0,0,0,0,0
cX$l = "OP",0,"FE|FNP",0,"FE|F",0,"ND{S",0
;	D    M	       N     O
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
dd$l = 0,0,1,0,0,0,0,0,30,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,0,0
dX$l = "B{D{FS{FD{FE{FP{F{PW{P{ZA{Z{",0,"V|",0,"F",0
;	C			     I  V
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
ee$l = 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,4,0,0,0,0,0,0,50,0,0
eX$l = "R|",0,"UB{UD{UFS{UFD{UFE{UFP{UF{UPW{UP{US{UW{UZA{UZ{",0,"P",0
;	O  Q						 X
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
ff$l = 0,0,0,1,0,0,4,0,7,0,0,28,33,0,36,0,0,39,0,0,0,0,0,0,0,0
fX$l = "V",0,"N",0,"LE{LLB{LLW{LLD{LL{X",0,"TT",0,"L",0,"G",0,"D",0
;	D  G  I			   L	M  O  R
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
ll$l = 0,0,0,1,0,10,15,0,0,0,0,0,0,0,18,0,0,0,0,21,0,0,0,0,0,0
lX$l = "CFMR",0,"MS",0,"N",0,"G",0,"C",0
;	D	 F ?  G  O  T
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
mm$l = 0,0,1,0,0,0,0,0,0,0,0,4,0,7,12,0,0,15,20,0,23,28,0,0,0,0
mX$l = "R|",0,"A|",0,"FF",0,"V|",0,"C|S|",0,"R|",0,"FL|",0,"FN|",0
;	C  L  N	   O  R	   S  U	   V
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
nn$l = 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,4,0,0,0,0,0,0,0,0
nX$l = "P",0,"M",0
;	O  R
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
oo$l = 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,4,0,0,0,0,0,0,0,0
oX$l = "T{",0,"R|",0,0
;	P  R
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
pp$l = 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,5,0,0,0
pX$l = "LW{",0
;	O   W
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
rr$l = 0,0,0,1,0,4,0,0,0,0,0,0,9,12,0,15,0,0,18,0,0,0,0,0,0,0
rX$l = "F",0,"C|S|",0,"F",0,"D",0,"W",0,"B|C|F",0
;	D  F	M  N  P  S
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
ss$l = 0,1,0,4,0,7,0,0,12,0,0,0,15,0,0,0,26,0,0,29,38,0,43,0,0,0
sX$l = "C|",0,"C",0,"MS",0,"N",0,"LA|ULL|UL|",0,"T",0,"CFMR",0,"B|F",0,"AP|I|PB|P|",0 ; note pb.
;	B  D  F	   I  M		 Q  T	     U	  W
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
tt$l = 1,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0
tX$l = "N",0,"QPLQ",0,"T",0
;	A  E	  S
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
uu$l = 0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,16,0,0,0,0,0,0,0,0
uX$l = "LAL|LA|ULL|UL|",0,"D",0
;	M	       R
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
vv$l = 0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,16,0,0,0,0,0,0,0,0
vX$l = "UX{U{",0
;	D
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
ww$l = 0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wX$l = "C|SA{S|",0
;	F
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
zz$l = 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
zX$l = "{",0
;      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
_I$l = 0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0
_X$l = "{",0
;	!
;	00000000011111111112222222222333333333344444444445555555555666666666
;	12345678901234567890123456789012345678901234567890123456789012345678
 ALIGN

testforasminst
 TST R2,#&1000000
 MOVNE PC,R14
 PUSH "R14"
 ADRL R14,localmodeword
 LDR R14,[R14]
 TST R14,#1 << 29
 LDMNEFD R13 !,{PC}
 STR R1,bas_localstored1	; B for later
 SUB R14,R1,#'A'
 MOV R14,R14,LSL #2
 ADRL R1,table$l
 LDR R1,[R1,R14]
 PULL "R14"
 CMP R1,#0
 MOVEQ PC,R14			; R1 corrupted in this instance...

 FNJSR "R0,R5,R6,R7,R10"
 ADRL R6,table$l
 ADD R6,R6,R1
 BL getnextasmletter ; Hmm...
 STR R7,bas_localstored0
 STR R10,bas_localstored4	; something that got changed a while back?
 CMP R0,#'"' ;;;;;\/\/
 CMPNE R0,#'&' ;;;;;\/\/
 CMPNE R0,#' '
 BLE ba_alternativepossibilities
 CMP R0,#'A'
 BCC bai_notfoundatall
 CMP R0,#'Z'
 BGT bai_notfoundatall
 SUB R14,R0,#'A'
 LDRB R14,[R6,R14]
 CMP R14,#0
 BEQ bai_notfoundatall
 ADD R6,R6,#25
 ADD R6,R6,R14
loop1$l
 MOV R1,#0
 ;LDR R5,bas_localstored3
 LDR R7,bas_localstored0
 LDR R10,bas_localstored4
loop2$l
 BL getnextasmletter ; Hmm...
 LDRB R14,[R6,R1]
 CMP R14,#'Z'
 BGT bai_foundasmstage1
 TEQ R14,#0
 BEQ bai_notfoundatall
 CMP R0,#' '
 MOVEQ R0,#255
 CMP R0,R14
 ADDEQ R1,R1,#1
 BEQ loop2$l
 CMPLT R1,#0
 BEQ bai_notfoundatall		; in testing...
bai_nextoneplease
 LDRB R14,[R6],#1
 CMP R14,#'Z'
 BLE bai_nextoneplease
 B loop1$l

cond$l = "ALCCCSEQGEGTHIHSLELSLOLTMINENVPLVCVS",0
 ALIGN

bai_foundasmstage1
 STR R14,bas_localstored1
 CMP R14,#'{'			; DCD
 BEQ bai_indirectivecheck
 CMP R14,#''			; BLS...
 BEQ fromabl_simply		; bai_foundasmstage4???
 CMP R0,#'P'			; simple but works...?
 BLEQ posspc1
 CMP R0,#'='			; DS assembler stuff...
 BLEQ checkfwdsforcomma
 CMP R0,#'R'			; simple but works...?
 CMPNE R0,#'~'			; DS new assembler stuff...
 BLEQ getnextasmletter		; simple but works...?
 ;BEQ bai_notfoundatall
 ;BLNE checkfwdsforcomma
 ;BLNE getnextasmletter		; simple but works...?
bfposspc1
 STR R0,bas_localstored2
 STR R7,bas_localstored0
 STR R10,bas_localstored4
 CMP R0,#'@'
 BLE tobai_foundasmstage3
ba_theremustbesomemore
 ADRL R6,cond$l
 MOV R1,R0
 BL getnextasmletter
loop3$l
 LDRB R14,[R6],#2
 CMP R14,#0
 BEQ bai_foundasmstage2		; bai_notfoundatall
 CMP R1,R14
 BGT loop3$l
 BLT bai_foundasmstage2
 LDRB R14,[R6,#-1]
 CMP R0,R14
 BNE loop3$l
 BL getnextasmletter ; Hmm...
 STR R7,bas_localstored0
 STR R10,bas_localstored4
 STR R0,bas_localstored2
 ; eq (or whatever) matches
bai_foundasmstage2
 LDR R14,bas_localstored1
 CMP R14,#''			; LDM / STM (FD)
 CMPNE R14,#''			; LDR / STR (FD)
 BEQ ba_checkforastack
 CMP R14,#''			; LDR / STR (FD)
 BEQ ba_checkforanumthangy
 CMP R14,#''			; LDR / STR (FD)
 BEQ ba_checkforacoproTorL
bai_foundasmstage3
 LDR R0,bas_localstored2
 LDR R7,bas_localstored0
 LDR R10,bas_localstored4
 LDR R14,bas_localstored1
 CMP R14,#''			; BL - danger - possible BLE...?
 BEQ fromabl_simply2
 CMP R14,#250			; BL - danger - possible BLE...?
 BCS floatingptsub
; TEQ R14,#''
 TEQ R14,#157
 BEQ checkingfornopandbrk
; TEQ R14,#''
 TEQ R14,#188
 BEQ checkingforalign
 CMP R0,#'R'			; not PC yet...
 CMPNE R0,#'@'
 MOVLT R1,#0			; set up a flag...
 BLT verypostbai_foundasmstage4
; TEQ R14,#''
 TEQ R14,#132
 BEQ fromabl_simply3
; CMP R14,#''			; LDR / STR (FD)
 CMP R14,#156			; LDR / STR (FD)
 CMPNE R14,#''			; LDR / STR (FD)
 CMPEQ R0,#'B'
 BLEQ getnextasmletter		; works...?
 CMP R0,#'S'
 BLEQ getnextasmletter		; simple but works...?
 CMP R0,#'X'
 CMPNE R0,#'W'
 BLEQ getnextasmletter		; simple but works...?
 CMP R0,#'L'
 BEQ bai_checkforlong
 CMP R0,#'P'			; simple but works...?
 BLEQ posspc1
 CMP R0,#'R'			; not PC yet...
 BLEQ getnextasmletter		; simple but works...?
fromabl_simply
 CMP R0,#'_'
 CMPNE R0,#63			; ?
 BGT bai_notfoundatall		; catches all 'too long' instructions...
bai_foundasmstage4
 MOV R1,#0			; set up a flag...
postbai_foundasmstage4
 BL getnextasmletter		; simple but works...?
verypostbai_foundasmstage4
 CMP R0,#','
 CMPNE R0,#'"'
 CMPNE R0,#'\'
 CMPNE R0,#'&'
 CMPNE R0,#';'
 CMPNE R0,#':'
 CMPNE R0,#&F4			; tokenised REM
 BEQ bai_foundasmstage5
 CMP R0,#32
 BLT bai_foundasmstage5
 ;ORREQ R1,R1,#1			; set up a flag...
 BEQ postbai_foundasmstage4

 CMP R0,#'+'
 CMPNE R0,#'-'
 BEQ bai_prelpchking$l ; bai_lpchking$l

 ;CMP R0,#'('
 ;CMPNE R0,#'%'
 ;CMPNE R0,#'$'
 ;CMPNE R0,#'!'
 ;CMPEQ R1,#1
 ;BEQ bai_foundasmstage5

 ;CMP R0,#'0'			; CATCHES '=' FOR INSTANCE...
 ;BCC bai_notfoundatall
 CMP R0,#'='
 CMPNE R0,#'?'
 BEQ bai_notfoundatall
 ;CMP R0,#'_'
 ;CMPNE R0,#'`'
 ;CMPNE R0,#'Z'
 ;BGT bai_notfoundatall
 ;CMP R0,#'9'
 ;BLE bai_foundasmstage5
 ;CMP R0,#'@'
 ;BLT bai_notfoundatall
bai_prelpchking$l
 LDR R14,bas_localstored1
 CMP R14,#''			; BLS/BEQ/B...
 CMPNE R14,#''			; BL - Danger in basic...
 BEQ ckhpossiblybranching
 ;MOV R1,#1
bai_lpchking$l
 BL getnextasmletter		; simple but works...?
 CMP R0,#','
 CMPNE R0,#'"'
 CMPNE R0,#'\'
 CMPNE R0,#'&'
 CMPNE R0,#';'
 CMPNE R0,#':'
 CMPNE R0,#&F4			; tokenised REM
 BEQ bai_foundasmstage5
 CMP R0,#32
 BLT bai_foundasmstage5
 ;ORREQ R1,R1,#1
 BEQ bai_lpchking$l
 ;BCC bai_notfoundatall

 CMP R0,#'+'
 CMPNE R0,#'-'
 BEQ bai_lpchking$l
 ;CMP R0,#'('
 ;CMPNE R0,#'%'
 ;CMPNE R0,#'$'
 ;CMPNE R0,#'!'
 ;CMPEQ R1,#1
 ;BEQ bai_foundasmstage5

 ;CMP R0,#'0'
 ;BCC bai_notfoundatall
 CMP R0,#'='
 CMPNE R0,#'?'
 BEQ bai_notfoundatall
 ;CMP R0,#'_'
 ;CMPNE R0,#'`'
 B bai_lpchking$l
 ;CMP R0,#'Z'
 ;BGT bai_notfoundatall
 ;CMP R0,#'9'
 ;BLE bai_foundasmstage5
 ;CMP R0,#'@'
 ;BLT bai_notfoundatall

 B bai_lpchking$l

bai_lpchking2$l
 BL getnextasmletter		; simple but works...?
checkingfornopandbrk
 CMP R0,#':'
 BEQ bai_foundasmstage5
 CMP R0,#32
 BLT bai_foundasmstage5
 BEQ bai_lpchking2$l
 B bai_notfoundatall

bai_lpchking6$l
 BL getnextasmletter		; simple but works...?
checkingforalign
 CMP R0,#':'
 CMPNE R0,#';'
 CMPNE R0,#&F4 ; REM
 BEQ direvtive_foundasmstage5
 CMP R0,#32
 BLT direvtive_foundasmstage5
 BEQ bai_lpchking6$l
 CMP R0,#'9'
 BLE direvtive_foundasmstage5
 B bai_notfoundatall

direvtive_foundasmstage5
 ORR R2,R2,#&1600000
 FNRTS

bai_foundasmstage5
 ORR R2,R2,#&1200000
 LDR R14,bas_localstored1
 CMP R14,#'{'			; DIRECTIVE...
 ORREQ R2,R2,#&400000
 CMP R14,#''			; LDM / STM (FD)
 ORREQ R2,R2,#&8000000
 CMP R14,#''			; BLS/BEQ/B...
 CMPNE R14,#''			; BL - Danger in basic...
 ORREQ R2,R2,#&4000000		; directive???????????
 CMP R14,#''			; LDR / STR (FD)
 ORREQ R2,R2,#&10000000
bai_notfoundatall
 FNRTS

tobai_foundasmstage3
 LDR R14,bas_localstored1
 CMP R14,#''			; LDM / STM (FD)
 BEQ ba_theremustbesomemore
 B bai_foundasmstage3		; as ordinary...

fromabl_simply2
 CMP R0,#'_'
 CMPNE R0,#63			; ?
 BGT bai_notfoundatall		; catches all 'too long' instructions...
 B verypostbai_foundasmstage4

fromabl_simply3
 CMP R0,#'S'
 CMPNE R0,#'P'
 BLEQ getnextasmletter		; works...? um PC...?!?!?
 CMP R0,#'_'
 CMPNE R0,#63			; ?
 BGT bai_notfoundatall		; catches all 'too long' instructions...
 B bai_foundasmstage4

ba_checkforastack
 LDR R0,bas_localstored2
 LDR R7,bas_localstored0
 LDR R10,bas_localstored4
 MOV R1,R0
 BL getnextasmletter
 ADR R6,stackdir$l
loop4$l
 LDRB R14,[R6],#2
 CMP R14,#0
 BEQ bai_notfoundatall
 CMP R1,R14
 BGT loop4$l
 BLT bai_notfoundatall
 LDRB R14,[R6,#-1]
 CMP R0,R14
 BNE loop4$l
 BL getnextasmletter		; simple...
goback_norm_ba
 STR R0,bas_localstored2
 STR R7,bas_localstored0
 STR R10,bas_localstored4
 B bai_foundasmstage3 ; leap back...

ba_checkforanumthangy
 LDR R0,bas_localstored2
 LDR R7,bas_localstored0
 LDR R10,bas_localstored4
 CMP R0,#'S'
 BEQ SHorWSB_bachk
 CMP R0,#'H'
 BEQ SHorSB_bachk
 B goback_norm_ba

SHorWSB_bachk
 BL getnextasmletter
 CMP R0,#'H'
SHorSB_bachk
 BLEQ getnextasmletter
 CMP R0,#'B'
 BLEQ getnextasmletter
 CMP R0,#'W'
 BLEQ getnextasmletter
 B goback_norm_ba

ba_checkforacoproTorL
 LDR R0,bas_localstored2
 LDR R7,bas_localstored0
 LDR R10,bas_localstored4
 CMP R0,#'T'
 BLEQ getnextasmletter
 CMP R0,#'L'
 BLEQ getnextasmletter
 B goback_norm_ba

; MOV R1,R0
; BL getnextasmletter
; ADRL R6,thangydir$l
;loop4a$l
; LDRB R14,[R6],#2
; CMP R14,#0
; BEQ bai_notfoundatall
; CMP R1,R14
; BGT loop4a$l
; BLT bai_notfoundatall
; LDRB R14,[R6,#-1]
; CMP R0,R14
; BNE loop4a$l
; BL getnextasmletter		; simple...
; STR R7,bas_localstored0
; STR R10,bas_localstored4
; STR R0,bas_localstored2
; B bai_foundasmstage3 ; leap back...

stackdir$l = "DADBEAEDFAFDIAIB",0
 ALIGN

bas_localstored0
 DCD 0
bas_localstored1
 DCD 0
bas_localstored2
 DCD 0
bas_localstored3
 DCD 0
bas_localstored4
 DCD 0
bas_localstored5
 DCD 0

floatingptsub
 CMP R0,#'F'
 CMPNE R0,#'@'
 BLE bai_foundasmstage4
 CMP R0,#'S'			; fp precisions...
 CMPNE R0,#'D'			; fp precisions...
 CMPNE R0,#'E'			; fp precisions...
 CMPNE R0,#'P'			; fp precisions...
 BLEQ getnextasmletter		; simple but works...?
 LDR R14,bas_localstored1
 CMP R14,#''
 BEQ fromabl_simply
 CMP R0,#'Z'			; fp precisions...
 CMPNE R0,#'M'			; fp precisions...
 CMPNE R0,#'P'			; fp precisions...
 BLEQ getnextasmletter		; simple but works...?
 B fromabl_simply

ba_alternativepossibilities
 LDR R0,bas_localstored1	; B for later
 CMP R0,#'B'
 BEQ to_bai_foundasmstage4beta
 CMP R0,#'Z'
 CMPNE R0,#'P'
 CMPNE R0,#'\'
 MOVEQ R14,#'{'
 STREQ R14,bas_localstored1
 BEQ bai_foundasmstage4
 B bai_notfoundatall

to_bai_foundasmstage4beta
 MOV R14,#''
 STR R14,bas_localstored1
 ;MOV R1,#'&'
 ;B stage4betaloop

bai_foundasmstage4beta
 BIC R1,R1,#&FF000000		; flags...
stage4betaloop
 BL getnextasmletter		; simple but works...?
 AND R14,R1,#&FF
 CMP R0,#&F4			; tokenised REM
 BEQ bai_foundasmstage5
 CMP R0,#','
 CMPNE R0,#'"'
 CMPNE R0,#'\'
 CMPNE R0,#'&'
 CMPNE R0,#';'
 CMPNE R0,#':'
 CMPNE R0,#&F4			; tokenised REM
 BEQ bai_foundasmstage5
 CMP R0,#32
 BLT bai_foundasmstage5
 ORREQ R1,R1,#&80000000
 BEQ stage4betaloop

 CMP R0,#'+'
 CMPNE R0,#'-'
 BEQ stage4betaloop
 ;AND R14,R1,#&80000000
 ;CMP R0,#'('
 ;CMPNE R0,#'%'
 ;CMPNE R0,#'$'
 ;CMPNE R0,#'!'
 ;CMPEQ R14,#&80000000	; has there been a space...?
 ;BEQ bai_foundasmstage5
 ;CMP R0,#'0'
 ;BCC bai_notfoundatall
 CMP R0,#'='
 CMPNE R0,#'?'
 BEQ bai_notfoundatall
 B stage4betaloop
 ;SWI &107
 ;CMP R0,#'_'
 ;CMPNE R0,#'`'
 ;CMPNE R0,#'Z'
 ;BGT bai_notfoundatall
 ;CMP R0,#'9'
 ;BLE bai_foundasmstage5
 ;CMP R0,#'@'
 ;BLT bai_notfoundatall

 ;B bai_foundasmstage5

bai_directivecheck		; for EQUD etcetera...
 BL getnextasmletter		; Hmm...
bai_indirectivecheck		; for EQUD etcetera...
 CMP R0,#','
 CMPNE R0,#'"'
 CMPNE R0,#'\'
 CMPNE R0,#'&'
 CMPNE R0,#';'
 CMPNE R0,#':'
 CMPNE R0,#&F4			; tokenised REM
 BEQ bai_foundasmstage5
 CMP R0,#32
 BLT bai_foundasmstage5
 BEQ bai_directivecheck
 CMP R0,#'='
 CMPNE R0,#'?'
 BEQ bai_notfoundatall
 B bai_directivecheck

posspc1
 FNJSR
 BL getnextasmletter		; simple but works...?
 CMP R0,#'C'			; simple but works...?
 BL getnextasmletter		; simple but works...?
 FNRTS

getnextasmletter
	FNJSR
	LDR R14,[R9,#f_ptr]
;	CMP R7,R14
;	BCC eolorwrong
;	SWICS &107		; ?????????????????????
	LDR R0,[R9,#f_bufl]
	ADD R14,R14,R0
	CMP R7,R14
	BCS eolorwrong
;	SWICS &107		; ?????????????????????
	CMP R7,R10
	BLCS red_overflow
	BVS eolorwrong
	LDRB R0,[R7],#1		; get first byte
	CMP R0,#'a'
	FNRTS CC
	CMP R0,#'{'
	BICCC R0,R0,#&20
	FNRTS

getprevasmletter			; no adjust R5,R10...???
	FNJSR
	LDR	R14,[R9,#f_ptr]
	CMP	R7,R14
	BLE	eolorwrong
	LDR	R0,[R9,#f_splite]
	ADD	R0,R14,R0
	CMP	R7,R0
;	BCS	solrighthere
	LDREQ	R14,[R9,#f_splits]	; only subtract split size if
	SUBEQ	R7,R7,R14		;   at split end
;	LDR	R14,[R9,#f_splite]
;	TEQ	R0,R14
;;	LDRB	R0,[R7]			; don't subtract 1 just yet
;	LDREQ	R14,[R9,#f_splits]	; only subtract split size if
;	SUBEQ	R7,R7,R14		;   at split end
;;	LDR	R14,[R9,#f_ptr]
;	SUB	R7,R7,#1		; *now* subtract 1
	LDR	R14,[R9,#f_ptr]
	CMP	R7,R14
	BLE	eolorwrong
	LDRB	R0,[R7],#-1			; ,#-1]!
	CMP	R0,#'a'
;	FNRTS CC			; faster...
	BICCS	R0,R0,#&20
	FNRTS
;readprev_assumeCR
;;	ADD	R7,R7,R14
;	MOV	R0,#13			; hardwired CR :(
;	FNRTS

;  LDR R14,[R9,#f_ptr]
;  CMP R7,R14
;  BLE eolorwrong
;  LDR R0,[R9,#f_splite]
;  ADD R0,R14,R0
;  CMP R7,R0
;  BCS solrighthere
;  LDR R0,[R9,#f_splito]
;  ADD R0,R14,R0
;  CMP R7,R0
;  LDRCS R0,[R9,#f_splits]
;  SUBCS R7,R7,R0
; solrighthere
;  LDRB R0,[R7],#-1		; get a byte
;  CMP R0,#'a'
;  BICCS R0,R0,#&20
;  FNRTS

eolorwrong
 MOV R0,#13			; hardwired CR :(
 FNRTS

ckhpossiblybranching
 CMP R0,#'='
 CMPNE R0,#':'
 BNE bai_foundasmstage5
 B bai_notfoundatall

checkfwdsforcomma
 FNJSR "R0,R1,R5,R7,R10"
loopa$l
 LDR R14,[R9,#f_ptr]
 LDR R0,[R9,#f_bufl]
 ADD R14,R0,R14
 CMP R7,R14
 FNRTS CS			; EOF!
 BL getnextasmletter		; simple but works...?
 CMP R0,#":"
 CMPNE R0,#';'			; hardwired CR :(
 CMPNE R0,#13			; hardwired CR :(
 FNRTS EQ
 CMP R0,#&7F			; token?
 FNRTS CS			; token? hmm.
 CMP R0,#","
 BNE loopa$l
 LDMFD R13!,{R0,R1,R5,R7,R10,R14}
 B getnextasmletter		; simple but works...?

 LOCAL

basic_prevline
 ;FNJSR
 ;BL basic_linestart
 SUBS R0,R0,#12
 MOVMI R0,#0
 MOV PC,R14
 ;FNcall Zap_ClipCache
 ;FNRTS

  LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Perform line alteration					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=buf_detoken start R2=string len (exc 0D) R3=line col R4=w_flags
;  R5=num bytes R6 = Flags R7=address data
;X line in buf_detoken altered R0=new length (exc 0D) #

change_line_insert
 STMFD R13!,{R1-R11,R14}
 MOV R10,R1			; buffer start
 MOV R1,R2			; current line length
 CMP R1,R3
 MOVLT R1,R3			; insert later
 ADD R1,R1,R5			; after bytes inserted
 ADD R1,R1,#128			; bit for luck (and terminator/(SPACES!))
 MOV R0,R10
 FNcall Zap_Ensure		; make sure buffer big enough
 LDMVSFD R13!,{R1-R11,PC}
 MOV R10,R0
 FNSTR R0,buf_detoken		; new buffer pointer
 CMP R2,R3
 BGT ch1			; no need to insert spaces (was CS)???
 ;SWI &107
 CMP R6,#0
 MOVNE R3,R2			; = no spaces...?
 ADD R1,R10,R2			; offset to insert
 BNE ch1
 ;ADD R3,R3,#1
 ;ADD R1,R1,#1 ; ?
 MOV R0,#&20			; space
 SUB R2,R3,R2			; number of spaces
 ADD R2,R2,#1			; INSERT_SPACES
 BL strstr			; insert the extra spaces
 MOV R2,R3			; new end offset
 ADD R10,R10,#1
ch1
 TST R4,#2			; overwrite?
 BNE ch2			; overwrite
 ADD R1,R10,R3			; place to start shifting
 SUB R3,R2,R3			; amount to shift up
 ADD R2,R1,R5			; dest to place string
 MOV R4,R1			; save address to insert data
 ADD R6,R2,R3			; end afterwards
 FNcall Zap_MoveBytes
 MOV R1,R7			; data
 MOV R2,R4			; dest
 MOV R3,R5			; num bytes
 FNcall Zap_MoveBytes		; copy in data
ch3
 MOV R0,#&0D
 STRB R0,[R6],#1		; add terminator
 STRB R0,[R6]			; add terminator
 SUB R0,R6,R10			; new length
 ;SUB R0,R0,#1
 LDMFD R13!,{R1-R11,PC}
ch2
 ADD R6,R10,R2			; actual end of text
 MOV R1,R7			; data
 ADD R2,R10,R3			; dest
 MOV R3,R5			; num of bytes
 ADD R4,R2,R5			; save end of overwrite
 FNcall Zap_MoveBytes		; copy in data
 CMP R6,R4
 MOVCC R6,R4			; new end due to overwrite
 B ch3

;E R1=buf_detoken start R2=string len (exc 0D) R3=line col R5=num bytes
;  R7=0 delete/1 shift delete
;X line in buf_detoken altered R0=new length (exc 0D) R7=new car col #

change_line_delete
 STMFD R13!,{R1-R6,R14}
 TEQ R7,#0			; normal delete
 MOV R7,R3
 SUBEQ R7,R7,R5			; new cursor col after delete
 CMP R7,#0
 MOVMI R7,#0
 MOVMI R5,R3			; clip number of chars to delete
 SUB R6,R2,R5			; string length after delete
 SUB R0,R2,R7			; num chars left in line
 SUBS R3,R0,R5			; number left in line after the delete
 MOVLT R5,R0			; clip number to delete
 MOVLT R3,#0
 SUB R4,R2,R5			; string len after delete
 ADD R2,R1,R7			; dest
 ADD R1,R2,R5			; source
 ADD R3,R3,#1			; copy the return as well
 FNcall Zap_MoveBytes
 MOV R0,R6
 LDMFD R13!,{R1-R6,PC}

;E R1=buf_detoken start R2=string len (exc 0D) R3=line col
;  R4=num bytes to replace R5=replacement len R7=replacement data
;X Line in buf_detoken altered R0=new length #

change_line_replace
 STMFD R13!,{R1-R10,R14}
 MOV R0,R1			; buffer start
 ADD R1,R2,R5
 ADD R1,R1,#&10			; new size required
 FNcall Zap_Ensure
 LDMVSFD R13!,{R1-R10,PC}
 FNSTR R0,buf_detoken
 MOV R10,R0			; new buffer pointer
 ADD R4,R3,R4			; col after the replace block
 CMP R4,R2
 MOVCS R4,R2			; clip to end of string
 ADD R5,R3,R5			; col after the replacement
 SUB R8,R2,R4			; number of bytes to shift up
 MOV R9,R3			; save column
 ADD R1,R10,R4			; source
 ADD R2,R10,R5			; dest
 ADD R3,R8,#1			; num to shift (add the return)
 FNcall Zap_MoveBytes		; shift up/down
 MOV R1,R7
 ADD R2,R10,R9			; dest
 SUB R3,R5,R9			; num bytes
 FNcall Zap_MoveBytes		; copy in replacement
 ADD R0,R5,R8			; new line length
 LDMFD R13!,{R1-R10,PC}

;E R0=tokenise len (at buf_retoken) R1=detokenised len R8
;X R0=new tokenised line length with spaces removed. NB spaces
;  will not be removed if they cause phy line offset to change.

remove_spaces
 STMFD R13!,{R1-R5,R14}
 MOV R5,R1			; save detokenised length
 LDR R1,[R8,#w_format]
 TST R1,#1<<15		; check non standard edit
 LDMEQFD R13!,{R1-R5,PC}
 FNLDR R1,buf_retoken
 MOV R2,R0			; save old tok length
to12
 CMP R0,#0
 BLE to14			; reached start of string
 SUB R0,R0,#1
 LDRB R14,[R1,R0]
 TEQ R14,#&20
 BEQ to12			; carry on
 ADD R0,R0,#1			; new len
to14
 SUB R14,R2,R0			; change in tok length
 SUB R14,R5,R14			; new detokenised length
 LDR R3,[R8,#w_bpl]		; line width
 MOV R4,R3			; current col
to15
 CMP R14,R4
 ADDHI R4,R4,R3
 BHI to15			; find end of line with new length
 CMP R5,R4
 MOVHI R0,R2			; restore old length
 LDMHIFD R13!,{R1-R5,PC}	; will not split over line end
 MOV R14,#&0D
 STRB R14,[R1,R0]		; removes spaces
 LDMFD R13!,{R1-R5,PC}

;E R5=num bytes R7=data
;X R2=0 if no dots R2=&100 o/w |

count_dots
 STMFD R13!,{R5,R7,R14}
 MOV R2,#0
co11
 SUBS R5,R5,#1
 LDMMIFD R13!,{R5,R7,PC}
 LDRB R0,[R7],#1
 TEQ R0,#'.'
 BNE co11
 MOV R2,#&100
 LDMFD R13!,{R5,R7,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; cln subs							 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

basic_clnphy
 STMFD R13!,{R2-R11,R14}
 MOV R2,R9			; file block
 LDR R3,[R8,#w_bpl]		; line length
 LDR R7,[R8,#w_cline]
 LDR R9,[R8,#w_coff]
 MOV R10,R0			; search phy line
 CMP R10,R7,LSR#1
 MOVLS R7,#0
 MOVLS R9,#0			; base offsets
 BL cln_LOGLINE
 LDMVSFD R13!,{R2-R11,PC}
cln_phy_2
 CMP R10,R7
 BCC cln_phy_backward
 BEQ cln_phy_end
cln_phy_1
 MOV R4,#0
 MOV R5,#0			; start of line vals
 MOV R6,#0
 MOV R8,#0
cln_phy_3
 BL cln_FORWARD			; move to start of next phy line
 BVS cln_phy_end
 CMP R10,R7
 BCC cln_phy_vs			; shot past it
 BEQ cln_phy_end		; hit that line
 TEQ R6,#0
 BEQ cln_phy_3			; still on this log line
 B cln_phy_1			; moved to next logical line
cln_phy_end
 LDR R8,[R13,#6*4]		; get window pointer off stack
 BL read_ln2			; get logical line num
 MOV R1,R0			; log
 MOV R0,R9			; file off
 LDMFD R13!,{R2-R11,PC}
cln_phy_backward
 BL cln_BACKWARD
 BVC cln_phy_2
cln_phy_vs
 BLVC err6
 LDMFD R13!,{R2-R11,PC}		; return with error

basic_clnlog
 STMFD R13!,{R2-R11,R14}
 MOV R2,R9			; file block
 LDR R3,[R8,#w_bpl]		; line length
 MOV R10,R0			; search log line
 MOV R7,#0			; phy line
 MOV R9,#0			; off
cln_log_1
 LDR R8,[R13,#6*4]		; get window pointer off stack
 BL read_ln2			; get the logical line number
 BVS cln_log_vs			; not found
 CMP R10,R0
 BEQ cln_log_end		; match
 BLT cln_log_vs			; passed it so not found
 MOV R4,#0
 MOV R5,#0
 MOV R6,#0
 MOV R8,#0			; start of line vals
cln_log_2
 BL cln_FORWARD			; move to next physical line
 BVS cln_log_vs
 TEQ R6,#0
 BEQ cln_log_2			; still on same phy line
 B cln_log_1			; onto a new logical line
cln_log_end
 MOV R0,R9			; offset
 MOV R1,R7			; phy line num
 LDMFD R13!,{R2-R11,PC}
cln_log_vs
 ADDS R0,R0,#0			; clv
 B cln_log_end			; return nearest posn

;E R0=search logical line (not corrected) R9
;X R0=logical line number counting 0,1,2,3 etc #
;  This differs from basic_clnlog
;  in that it does not assume line numbers are in correct order
;  and returns R0=-1 if the line is not found.

find_log
 STMFD R13!,{R1-R11,R14}
 MOV R10,R0			; search log line
 MOV R5,#&0D
 ORR R5,R5,R5,LSL#8
 ORR R5,R5,R5,LSL#16		; set up return mask
 MOV R2,#0			; start file offset
 MOV R3,#0			; current logical line start
fl1
 MOV R0,R2
 BL read_uln			; get the logical line number
 BVS fl4			; not found
 TEQ R10,R0
 BEQ fl3			; match
 BL log_FORWARD			; move to next logical line
 BCS fl4			; gone off file end
 ADD R3,R3,#1			; inc logical line number
 B fl1				; onto a new logical line
fl3
 MOV R0,R3			; log line num
 LDMFD R13!,{R1-R11,PC}
fl4
 ADDS R0,R0,#0			; clv
 MVN R0,#0			; R0=-1 for not found
 LDMFD R13!,{R1-R11,PC}

basic_clnoff
 STMFD R13!,{R3-R11,R14}
 LDR R1,[R9,#f_len]
 TEQ R1,#0			; null length file special case
 BEQ cln_off_0
 CMP R0,R1
 MOVCC R10,R0
 MOVCS R10,R1			; search offset in file or on end
 MOV R2,R9			; file block
 LDR R3,[R8,#w_bpl]
 LDR R7,[R8,#w_cline]
 LDR R9,[R8,#w_coff]
 CMP R10,R9,LSR#1		; if offset nearer start of file
 MOVLS R7,#0
 MOVLS R9,#0			; base offsets
 BL cln_LOGLINE
 LDMVSFD R13!,{R3-R11,PC}
cln_off_2
 CMP R10,R9
 BCC cln_off_backward
 BEQ cln_off_end
 ADR R11,cln_off_blk		; temp data store
cln_off_1
 MOV R4,#0
 MOV R5,#0
 MOV R6,#0
 MOV R8,#0			; start of log line vals
cln_off_4
 STMIA R11,{R7,R9}		; save start of line
 BL cln_FORWARD
 BVS cln_off_3			; off end of file
 CMP R10,R9
 BEQ cln_off_end		; exact match
 LDMLEIA R11,{R7,R9}
 BLE cln_off_end		; was on the previous line
 TEQ R6,#0
 BEQ cln_off_4			; still on this physical line
 B cln_off_1			; on next log line
cln_off_end
 LDR R8,[R13,#5*4]		; get window pointer off stack
 BL read_ln2			; get logical ln
 MOV R2,R0
 MOV R0,R7			; phy line
 MOV R1,R9			; start offset of line
 LDMFD R13!,{R3-R11,PC}
cln_off_backward
 BL cln_BACKWARD
 BVC cln_off_2
 LDMFD R13!,{R3-R11,PC}		; return with error
cln_off_blk
 DCD 0
 DCD 0
 DCD 0				; small data block
cln_off_3
 LDMIA R11,{R7,R9}		; get previous line vals
 B cln_off_end

cln_off_0
 MOV R0,#0
 MOV R1,#0
 MOV R2,#0
 LDMFD R13!,{R3-R11,PC}		; null file

;;;; middle level forward/backward subs & split buffer handling ;;;;

;E R2=fileblk R3=line len R4=line flags R5=data R6=log ln R7=phy ln
;  R8=0 for first call/previous line len R9=file off of start of phy line
;X Vals updated to the start of the next physical line. R8=len of this
;  phy line (exc 0A) which may be greater than R3 if a token causes some
;  overflow. It returns VS if the end of the buffer lies on this line.
;  Saves R2,R10-R11.

cln_FORWARD
 STMFD R13!,{R10-R11,R14}
 TEQ R8,#0			; are we at log line start
 ADDEQ R9,R9,#3			; first interesting character
 SUBNE R8,R8,R3			; overflow onto this line from previous
 LDR R10,[R2,#f_ptr]
 LDR R11,[R2,#f_splito]
 CMP R9,R11
 ADD R9,R10,R9
 BCS cln_FO_1
 ADD R11,R10,R11
 BL cln_forward			; first half of buffer
 SUBVC R9,R9,R10
 LDMVCFD R13!,{R10-R11,PC}
cln_FO_1
 LDR R0,[R2,#f_bufl]
 ADD R11,R10,R0
 LDR R0,[R2,#f_splits]
 ADD R10,R10,R0			; aparant start of second half
 ADD R9,R9,R0
 BL cln_forward			; second half of buffer
 SUB R9,R9,R10			; file offset
 LDMVCFD R13!,{R10-R11,PC}
 CMP R8,R3			; is the last line full
 ADDCS R7,R7,#1			; if so inc phy line (but not log line)
 LDMFD R13!,{R10-R11,R14}	; and return
 MOVCS PC,R14			; return VC if could do this line
 ORRS PC,R14,#Vbit

;E R2=fileblk R3=line len R7=phy ln R9=file off of start of phy line
;X vals updated to _A_ previous log line, VS if error R2-R3,R10-R11 saved

cln_BACKWARD
 STMFD R13!,{R10-R11,R14}
 MOV R5,#&0D
 ORR R5,R5,R5,LSL#8
 ORR R5,R5,R5,LSL#16		; set up return mask
 MOV R11,R9			; save current start of phy line
 STMFD R13!,{R7}		; save phy line
 LDR R8,[R2,#f_ptr]		; start of first half
 LDR R7,[R2,#f_splito]		; len of first half
 CMP R9,R7
 ADD R9,R8,R9			; address in first half
 BLS cln_BA_1			; in first half
 LDR R6,[R2,#f_splits]		; split gap size
 ADD R10,R8,R7			; end of first half
 ADD R10,R10,R6			; start of second half
 ADD R9,R9,R6			; address in second half
 BL cln_backward		; second half of buffer
 SUB R9,R9,R6			; address in first half
 BVC cln_BA_2			; at start of a log line
cln_BA_1
 MOV R10,R8			; start of first half
 BL cln_backward		; first half of buffer
cln_BA_2
 SUBS R9,R9,R8			; file offset of log line (&clv)
 MOV R10,R9			; save new offset
 MOV R4,#0			; flags
 MOV R5,#0			; byte
 MOV R6,#0			; zero line counts
 MOV R7,#0			; start of logical line
 MOV R8,#0			; offset
cln_BA_3
 BL cln_FORWARD			; move forward one phy line
 BVS cln_BA_vs2
 TEQ R6,#0
 MOVNE R4,#0
 MOVNE R5,#0
 MOVNE R6,#0
 MOVNE R8,#0			; zero counts if moved to next log line
 CMP R9,R11
 BLT cln_BA_3			; not reached start pos yet
 BHI cln_BA_vs			; no match = error
 MOV R9,R10			; new offset
 LDMFD R13!,{R0}		; original phy line
 SUB R7,R0,R7			; new phy line
 LDMFD R13!,{R10-R11,PC}
cln_BA_vs
 LDMFD R13!,{R0}		; original phy line
 ; MOV R9,R10			; new offset
 ; SUB R7,R0,R7			; new phy line
 ; SWI &107
 BL err5			; internal error (cln_backward)
 LDMFD R13!,{R10-R11,PC}	; ret with error
cln_BA_vs2
 LDMFD R13!,{R0}		; restore stack
 BL err5a			; internal error (cln_backward II)
 LDMFD R13!,{R10-R11,PC}	; ret with error

;E E2=fileblk R3=line len R7=phy line R9=file offset of phy line
;X If not at log line start then vals moved to _A_ logical line start #

cln_LOGLINE
 FNJSR
 CMP R9,#0
 FNRTS LE
 SUB R0,R9,#1
 LDR R1,[R2,#f_splito]
 CMP R0,R1
 LDRCS R1,[R2,#f_splits]
 ADDCS R0,R0,R1
 LDR R1,[R2,#f_ptr]
 LDRB R0,[R1,R0]
 TEQ R0,#&0D
 BLNE cln_BACKWARD		; move to start of this logical line
 FNRTS

;;;;;;;;;;;;;;;; low level forward/backward subs ;;;;;;;;;;;;;;;;;;;

;E R3=line len R4=flags R5=data R6=log count R7=phy ln R8=cur offset
;  in phy line R9=curr address in buffer R11=end of section
;X All values moved to start of the next physical line in the section.
;  R2 & R10-R11 saved. Note that if it reaches the end of the section
;  before it is certain that it has reached the next phy line the returns
;  VS. Otherwise returns VC.

cln_forward
 FNJSR
 BICS R14,R5,#&FF
 BNE cln_fo_token
cln_fo_l
 CMP R9,R11
 BCS cln_fo_vs			; end of section reached
 AND R14,R9,#3
 BIC R9,R9,#3
 LDR R1,[R9],#4
 SUB R8,R8,R14			; compensate for branching into code
 ADD R14,R14,R14,LSL#1		; times 3
 ADD PC,PC,R14,LSL#3		; times 8 & branch into code
 DCD 0
cln_fo_a
 AND R0,R1,#&000000FF		; 6 instructions for each byte
 CMP R0,   #&0000007F		; so each bit is 24 bytes long =3*8
 BCS cln_fo_0
 TEQ	R0,#&0000000D
 TEQNE  R0,#&00000022
 BEQ cln_fo_0
 AND R0,R1,#&0000FF00
 CMP R0,   #&00007F00
 BCS cln_fo_1
 TEQ	R0,#&00000D00
 TEQNE  R0,#&00002200
 BEQ cln_fo_1
 AND R0,R1,#&00FF0000
 CMP R0,   #&007F0000
 BCS cln_fo_2
 TEQ	R0,#&000D0000
 TEQNE  R0,#&00220000
 BEQ cln_fo_2
 AND R0,R1,#&FF000000
 CMP R0,   #&7F000000
 BCS cln_fo_3
 TEQ	R0,#&0D000000
 TEQNE  R0,#&22000000
 BEQ cln_fo_3
 ADD R8,R8,#4			; new offset
 CMP R9,R11
 BCS cln_fo_v			; overflow and compensate
 CMP R8,R3			; off end of line?
 LDRLS R1,[R9],#4
 BLS cln_fo_a			; loop if not off end of line
cln_fo_nl
 SUB R0,R8,R3			; find overflow
 SUB R9,R9,R0			; start of phy line
 ADD R7,R7,#1			; inc phy line
 MOV R8,R3			; line offset
 FNRTS
cln_fo_v
 SUB R0,R9,R11			; size of overflow
 SUB R8,R8,R0			; subtract the chars
 MOV R9,R11			; new nextchar
 CMP R8,R3
 BHI cln_fo_nl			; we've gone onto a newline
cln_fo_vs
 FNRTV				; overflown buffer before next phy line
cln_fo_0
 SUB R9,R9,#4
 B cln_fo_m
cln_fo_1
 ADD R8,R8,#1
 MOV R0,R0,LSR#8
 SUB R9,R9,#3
 B cln_fo_m
cln_fo_2
 ADD R8,R8,#2
 MOV R0,R0,LSR#16
 SUB R9,R9,#2
 B cln_fo_m
cln_fo_3
 ADD R8,R8,#3
 MOV R0,R0,LSR#24
 SUB R9,R9,#1
cln_fo_m
 CMP R9,R11
 BCS cln_fo_v			; overflowed buffer (so char not valid)
 TEQ R0,#&0D
 BEQ cln_fo_ret
 CMP R8,R3
 BCS cln_fo_nl			; gone to next phy line if R8>=R3
 TEQ R0,#&22
 BEQ cln_fo_quote
 ADD R9,R9,#1
 MOV R5,R0			; data byte
 BL detokenise_len
 BCC cln_fo_donetok
cln_fo_token
 CMP R9,R11
 BCS cln_fo_vs			; interrupted
 LDRB R0,[R9],#1		; get next byte
 ORR R5,R5,R0
 BL detokenise_len
 BCS cln_fo_token		; needs another byte
cln_fo_donetok
 ADD R8,R8,R0			; increment column
 MOV R5,#0			; not waiting any more
 CMP R8,R3
 BLE cln_fo_l			; not reached end of line for certain
 ADD R7,R7,#1			; next physical line
 FNRTS
cln_fo_ret
 CMP R8,R3
 BHI cln_fo_nl			; already on next line
 ADD R9,R9,#1			; include this char
 ADD R7,R7,#1
 ADD R6,R6,#1			; next phy & log line
 FNRTS
cln_fo_quote
 ADD R9,R9,#1			; include this quote
 ADD R8,R8,#1
 EOR R4,R4,#2			; toggle quote state
 B cln_fo_l			; do next character

;E R5=return mask R9=addr in buffer R10=start of section
;X VS if overflowed section before prev log line }
;  VC if reached _A_ prev logical line (in R9)	 } R1-R4,R6-R8,R11 saved

cln_backward
 CMP R9,R10			; start of buf
 BLS cln_ba_vs
 SUB R9,R9,#1			; skip 0A/a char (if already at start)
cln_ba_2
 CMP R9,R10
 BLS cln_ba_vs			; start of buf
 TST R9,#3
 BEQ cln_ba_a			; word aligned
 LDRB R0,[R9,#-1]!
 TEQ R0,R5,LSR#24
 BNE cln_ba_2
 ADD R9,R9,#1			; start of log line
 MOV PC,R14			; ret
cln_ba_a
 LDR R0,[R9,#-4]!		; word aligned R9
 EOR R0,R0,R5			; ret mask
 TST   R0,#&FF000000
 TSTNE R0,#&00FF0000
 TSTNE R0,#&0000FF00
 TSTNE R0,#&000000FF
 BEQ cln_ba_m			; match found
 CMP R9,R10
 BHI cln_ba_a			; still some chars left
cln_ba_vs
 MOV R9,R10
 ORRS PC,R14,#Vbit	      ; return start of buffer error
cln_ba_m
 TST   R0,#&FF000000
 ADDEQ R9,R9,#1
 TSTNE R0,#&00FF0000
 ADDEQ R9,R9,#1
 TSTNE R0,#&0000FF00
 ADDEQ R9,R9,#1			; R9 points to the 0A
 CMP R9,R10
 BCC cln_ba_vs			; off start of buffer
 ADD R9,R9,#1			; start of next line
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Quick line moving subs					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R5=mask R2=file offset R9=file
;X CS if hit buffer end
;  CC If R7<>0 then points to next 3 bytes R2 updated
;     If R7=0 then next 3 bytes straddle boundry
; R0-R2,R6-R7 corrupt |

log_FORWARD
 FNJSR
 LDR R1,[R9,#f_ptr]		; file start
 LDR R6,[R9,#f_splito]
 CMP R2,R6
 ADD R7,R1,R2
 BCS log_FO_1
 ADD R6,R1,R6
 BL log_forward			; first half of buffer
 SUB R2,R7,R1
 BCC log_FO_2			; match ok
log_FO_1
 LDR R0,[R9,#f_bufl]
 ADD R6,R1,R0			; new top
 LDR R0,[R9,#f_splits]
 ADD R1,R1,R0			; aparant start of second half
 ADD R7,R7,R0			; new address
 BL log_forward			; second half of buffer
 SUB R2,R7,R1			; file offset
 FNRTS CS			; reached end of file
log_FO_2
 SUB R0,R6,R7			; number of bytes left
 CMP R0,#3
 MOVLT R7,#0			; this pointer's no good!
 ADDS R0,R0,#0			; clc
 FNRTS

;E R5=mask R6=end of buffer R7=current pointer in buffer
;X CC moved to next byte after mask match in R7
;  CS hit buffer end before next match and R6=R7
;  R0 corrupted R7 updated |

log_forward
clfo_1
 CMP R7,R6
 BCS clfo_vs			; end of section reached
 TST R7,#3			; can we start word search ?
 BEQ clfo_2			; yes
 LDRB R0,[R7],#1		; next byte
 TEQ R0,R5,LSR#24
 BNE clfo_1			; no match
 BICS PC,R14,#Cbit	      ; return match found
clfo_2
 LDR R0,[R7],#4
 EOR R0,R0,R5
 TST   R0,#&000000FF
 TSTNE R0,#&0000FF00
 TSTNE R0,#&00FF0000
 TSTNE R0,#&FF000000
 BEQ clfo_m			; match found
 CMP R7,R6
 BCC clfo_2			; loop for next word
clfo_vs
 MOV R7,R6			; new nextchar
 ORRS PC,R14,#Cbit	      ; overflown buffer before next match
clfo_m
 TST   R0,#&000000FF
 SUBEQ R7,R7,#1
 TSTNE R0,#&0000FF00
 SUBEQ R7,R7,#1
 TSTNE R0,#&00FF0000
 SUBEQ R7,R7,#1			; R9 now points to the byte after the match
 CMP R7,R6
 BHI clfo_vs			; was off the end of the buffer
 BICS PC,R14,#Cbit	      ; return match found

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Moving to start/end of line					   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

basic_aligncaret
 ;CMP R10,#&8000		; eeek error
 ;SWICC &107
 CMP R10,#&8000			; eeek error
 MOVCC PC,R14

 STMFD R13!,{R1,R14}
 ;MOV R1,#5 ; car_cursor
 ;FNcall Zap_ReadVar
 ;MOV R10,R0
 LDR R0,[R10,#c_loff]		; start of physical line
 CMP R0,#0
 BLE al1			; at logical line start
 SUB R0,R0,#1
 LDR R1,[R9,#f_len]		; bug1
 CMP R0,R1			; bug1
 BLCC cln_readc
 TEQ R0,#&0D
 LDMNEFD R13!,{R1,PC}		; not at a logical line start
al1
 LDR R14,[R10,#c_loff]
 ADD R14,R14,#3			; first valid character
 LDR R0,[R10,#c_off]
 CMP R0,R14			; are we in a valid line
 LDMCSFD R13!,{R1,PC}		; yes
 MOV R0,R14			; new posn
 LDR R14,[R9,#f_len]
 CMP R0,R14
 MOVCS R0,R14			; clip to file end
 STR R0,[R10,#c_off]		; correct first valid character
				; this code can cause crashes on RPCs.
				; it *was* been disabled to stop scF6 and
				; changing mode from the BASIC mode from
				; crashing the machine.  Hopefully this does
				; not have *too* many side effects :( :((
 LDMFD R13!,{R1,PC}

;E R0=file offset R9
;X file offset brought into range #

clip_offset
 FNJSR
 CMP R0,#0
 MOVMI R0,#0
 LDR R14,[R9,#f_len]
 CMP R0,R14
 MOVCS R0,R14
 FNRTS

basic_linestart
 FNJSR
 BL basic_lineprev
 ADDVC R0,R0,#3
 BLVC clip_offset
 FNRTS

basic_lineend
 FNJSR
 BL basic_linenext
 SUBVC R0,R0,#1
 BLVC clip_offset
 FNRTS

basic_linenext
 STMFD R13!,{R1-R3,R14}
 MOV R2,R0
 LDR R3,[R9,#f_len]
li2
 CMP R2,R3
 MOVCS R0,R3
 LDMCSFD R13!,{R1-R3,PC}
 MOV R0,R2
 BL cln_readc
 ADD R2,R2,#1
 TEQ R0,#&0D
 BNE li2
 MOV R0,R2
 LDMFD R13!,{R1-R3,PC}

basic_lineprev
 STMFD R13!,{R1-R2,R14}
 SUB R2,R0,#1			; first char to look at
li1
 CMP R2,#0
 MOVMI R0,#0
 LDMMIFD R13!,{R1-R2,PC}
 MOV R0,R2
 BL cln_readc
 TEQ R0,#&0D
 SUBNE R2,R2,#1
 BNE li1
 ADD R0,R2,#1
 LDMFD R13!,{R1-R2,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Cursor positioning						   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=file offset of line start R1=file offset to convert to column
;X R0=column R1=cursor width

 LOCAL

basic_lineoff
 FNJSR "R2-R10"
 BL basic_linestart		; move to start of line
 FNRTS VS
 MOV R2,#0			; detokenise flags
 MOV R3,#0			; data store
 LDR R4,[R9,#f_len]		; file end
 MOV R5,#0			; column of last token
 MOV R6,#0			; current column
 MOV R7,R0			; file offset of first char
 LDR R8,[R8,#w_bpl]		; width of screen
 MOV R10,R1			; match offset
 CMP R10,R7
 BLS end$l
loop$l
 CMP R7,R4
 MOVCS R7,R4
 BCS end$l			; end of file
 MOV R0,R7
 BL cln_readc
 TEQ R0,#&0D
 BEQ end$l			; end of line
 ADD R7,R7,#1			; move to next byte
 ORR R0,R0,R3
 BL fully_detokenise_byte
 MOVCS R3,R0
 BCS loop$l			; next byte
 MOV R3,#0
 ADD R6,R6,R0			; new column
 CMP R6,R8
 SUBHI R6,R6,R8			; definately gone onto next line
 CMP R10,R7
 MOVCS R5,R6
 BCS loop$l			; not passed match yet
 MOV R6,R5			; this was the column of the match
 CMP R6,R8
 SUBCS R6,R6,R8			; column offset
end$l
 MOV R0,R6			; column
 MOV R1,#1			; caret width
 FNRTS

 LOCAL

;E R0=file offset of log line start(+3) R1=file offset
;X R0=Total column of this offset on line

conv_lineoff
 FNJSR "R1-R10"
 MOV R2,#0			; detokenise flags
 MOV R3,#0			; data store
 LDR R4,[R9,#f_len]		; file end
 MOV R5,#0			; column of last token
 MOV R6,#0			; current column
 MOV R7,R0			; file offset of first char
 MOV R10,R1			; match offset
 CMP R10,R7
 BLS end$l			  ; already passed it
loop$l
 CMP R7,R4
 MOVCS R7,R4
 BCS end$l			  ; end of file
 MOV R0,R7
 BL cln_readc
 TEQ R0,#&0D
 BEQ end$l			  ; end of line
 ADD R7,R7,#1			; move to next byte
 ORR R0,R0,R3
 BL fully_detokenise_byte
 MOVCS R3,R0
 BCS loop$l			   ; next byte
 MOV R3,#0
 ADD R6,R6,R0			; new column
 CMP R10,R7
 MOVCS R5,R6			; haven't passed match yet
 BCS loop$l			   ; not passed match yet
 MOV R6,R5			; this was the column of the match
end$l
 MOV R0,R6			; column
 FNRTS

 LOCAL

;E R0=file offset of (phy) line start R1=column in line
;X R0=file offset of nearest char on left #

basic_linecol
 FNJSR "R1-R10"
 FNSTR R0,tmp_linecol		; save start of physical line
 BL basic_linestart		; move to start of the logical line
 FNRTS VS
 MOV R2,#0			; current flags
 MOV R3,#0			; current data
 LDR R4,[R9,#f_len]
 MOV R5,R0			; last valid offset
 MOV R6,#0			; current column
 MOV R7,R0			; file offset of first char
 LDR R8,[R8,#w_bpl]		; window width
 ADDS R10,R1,#0			; search column
 MOVLE R10,#0			; find column to match in R10
 FNLDR R0,tmp_linecol
 CMP R7,R0
 BCS online$l			; already on the physical line
skip$l				; skip until reached the physical line
 CMP R7,R4
 MOVCS R7,R4
 BCS end$l
 MOV R0,R7
 BL cln_readc			; get byte
 TEQ R0,#&0D
 BEQ end$l			; reached line end
 ORR R0,R0,R3
 ADD R7,R7,#1			; move to next byte
 BL fully_detokenise_byte
 MOVCS R3,R0
 BCS skip$l			; next byte
 MOV R3,#0
 ADD R6,R6,R0			; new column
 FNLDR R1,tmp_linecol
 CMP R7,R1			; have we reached phy line start yet
 MOVCC R5,R7			; if not
 BCC skip$l			; then do next character
a$l
 SUBS R6,R6,R8
 BPL a$l
 ADD R6,R6,R8			; get column to range 0..R8-1
 B check$l
online$l			; on the physical line
 CMP R7,R4
 MOVCS R7,R4
 BCS end$l
 MOV R0,R7
 BL cln_readc			; get byte
 TEQ R0,#&0D
 BEQ end$l			; reached line end
 ORR R0,R0,R3
 ADD R7,R7,#1			; move to next byte
 BL fully_detokenise_byte
 MOVCS R3,R0
 BCS online$l			; next byte
 MOV R3,#0
 ADD R6,R6,R0			; new column
check$l
 CMP R10,R6			; has the column R6 passed R10 yet
 MOVHI R5,R7
 BHI online$l			; not reached match
 MOVCC R7,R5			; was in previous expression
end$l
 CMP R7,R4
 MOVCC R0,R7			; file offset
 MOVCS R0,R4
 FNRTS

;E R0=line off R1=caret off R2=caret col R8/R9
;X R1/R2 new posn after / R2=-1 and R1=new file offset #

basic_plus
 STMFD R13!,{R3-R4,R14}
 ADD R2,R2,#1			; new column
 LDR R3,[R8,#w_bpl]
 CMP R2,R3
 BCS pl1			; gone off line end
 MOV R1,R2			; new column
 BL basic_linecol
 LDMVSFD R13!,{R3-R4,PC}
 MOV R1,R0			; new offset
 LDMFD R13!,{R3-R4,PC}
pl1
 CMP R2,R3
 BHI pl2
 ADD R4,R1,#1			; position of next token
 MOV R1,R4
 BL basic_lineoff		; find actual column offset in R0 (uses R0)
 LDMVSFD R13!,{R3-R4,PC}
 TEQ R0,R3
 BNE pl2			; not positioned at line end
 MOV R0,R4
 BL cln_readc
 TEQ R0,#&0D
 BNE pl2			; not a return char
 MOV R1,R4			; new file offset
 LDMFD R13!,{R3-R4,PC}
pl2
 MVN R2,#2			; (-3)
 MOV R0,#0			; new x
 LDR R1,[R10,#c_line]
 ADD R1,R1,#1			; new y
 LDMFD R13!,{R3-R4,PC}

basic_minus
 FNJSR
 SUBS R2,R2,#1
 BMI mi1			; gone off line start
 MOV R1,R2			; new column
 BL basic_linecol
 FNRTS VS
 MOV R1,R0			; new offset
 FNRTS
mi1
 CMP R0,#0
 FNRTS LE			; at file start
 SUB R2,R0,#1			; end of last line
 MOV R0,R2
 BL cln_readc
 TEQ R0,#&0D
 BEQ mi2			; at start of logical line
 LDR R1,[R10,#c_line]
 SUBS R1,R1,#1
 MOVMI R1,#0
 LDR R0,[R8,#w_bpl]
 SUB R0,R0,#1			; specify x,y
 MVN R2,#2			; (-3)
 FNRTS
mi2
 MOV R1,R2			; new file offset
 MVN R2,#0			; giving file offset (-1)
 FNRTS

basic_splus
 STMFD R13!,{R3-R7,R14}
 MOV R7,R1			; save offset
 LDR R6,[R9,#f_len]		; length of file
 MVN R3,#0			; have met a white space flag
 MVN R2,#0			; returns offset
cln_sp1
 CMP R7,R6
 MOVCS R1,R6			; end of file
 LDMCSFD R13!,{R3-R7,PC}
 MOV R0,R7
 BL cln_readc
 TEQ   R0,#' '
 TEQNE R0,#')'
 TEQNE R0,#'('
 TEQNE R0,#':'
 TEQNE R0,#&0D
 MOVEQ R3,#1			; reached a white space
 ADD R7,R7,#1			; next char
 BEQ cln_sp1			; a white space character
 MOVS R3,R3
 BMI cln_sp1			; no white spaces yet!
 SUB R1,R7,#1
 LDMFD R13!,{R3-R7,PC}

basic_sminus
 STMFD R13!,{R3-R7,R14}
 MOV R7,R1			; save offset
 MVN R3,#0			; have met a white space flag
 MVN R2,#0			; returning an offset
cln_sm1
 CMP R7,#0
 MOVLE R1,#0			; start of file
 LDMLEFD R13!,{R3-R7,PC}
 SUB R0,R7,#1
 BL cln_readc
 TEQ   R0,#' '
 TEQNE R0,#')'
 TEQNE R0,#'('
 TEQNE R0,#':'
 TEQNE R0,#&0D
 MOVEQ R3,#1			; reached a white space
 SUB R7,R7,#1			; this char
 BEQ cln_sm1			; a white space character
 MOVS R3,R3
 BMI cln_sm1			; no white spaces yet!
 ADD R1,R7,#1
 LDMFD R13!,{R3-R7,PC}

;E R1=file offset
;X R1=last char of line R2=-1

basic_cplus
 STMFD R13!,{R6-R7,R14}
 LDR R6,[R9,#f_len]
 MOV R7,R1			; save offset
 MVN R2,#0			; returning offset
cln_l1
 CMP R7,R6
 MOVCS R1,R6			; end of file
 LDMCSFD R13!,{R6-R7,PC}
 MOV R0,R7
 BL cln_readc
 TEQ R0,#&0D
 ADD R7,R7,#1
 BNE cln_l1
 SUB R1,R7,#1			; end of line
 LDMFD R13!,{R6-R7,PC}

;E R1=file offset
;X R1=start of line R2=-1

basic_cminus
 STMFD R13!,{R7,R14}
 MOV R7,R1			; save offset
 MVN R2,#0			; returning offset
cln_l2
 CMP R7,#0
 MOVLE R1,#0			; start of file
 LDMLEFD R13!,{R7,PC}
 SUB R0,R7,#1
 BL cln_readc
 TEQ R0,#&0D
 SUB R7,R7,#1
 BNE cln_l2
 ADD R1,R7,#1
 LDMFD R13!,{R7,PC}

basic_nextline
 STMFD R13!,{R2-R11,R14}
 MOV R10,R0
 MOV R2,R9			; file block
 LDR R3,[R8,#w_bpl]
 LDR R7,[R8,#w_cline]
 LDR R9,[R8,#w_coff]
 CMP R10,R9,LSR#1		; if offset nearer start of file
 MOVLS R7,#0
 MOVLS R9,#0			; base offsets
 BL cln_LOGLINE
 LDMVSFD R13!,{R2-R11,PC}
cln_nex_2
 CMP R9,R10
 BHI cln_nex_backward		; move back if R9>R10
cln_nex_1
 MOV R4,#0
 MOV R5,#0
 MOV R6,#0
 MOV R8,#0
cln_nex_4
 BL cln_FORWARD
 BVS cln_nex_3			; off end of file
 TEQ R6,#0
 BEQ cln_nex_4			; move to start of next logical line
 CMP R10,R9
 BCS cln_nex_1			; if not past R10 yet then loop
 LDR R0,[R2,#f_len]
 CMP R9,R0
 BCS cln_nex_3			; off end of file (may not have had a VS)
 ADDS R0,R9,#0			; offset of line & clv
 MOV R1,R7			; phy line
 LDMFD R13!,{R2-R11,PC}		; returns with no error
cln_nex_backward
 BL cln_BACKWARD
 BVC cln_nex_2
 LDMFD R13!,{R2-R11,PC}		; return with error
cln_nex_3
 ADDS R1,R7,#0			; phy line and clv
 LDR R0,[R2,#f_len]
 LDMFD R13!,{R2-R11,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BASIC loading saveing file entry points		    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

basic_postload
 FNJSR
 MOV R14,#0
 STR R14,loadingerror
 STR R8,r8cbzwtmp
 STR R9,r9cbzwtmp
 BL check_format
 FNRTS CS			; not encrypted basic
 BLVC remove_ends		; remove ends and move down file
 BLVC remove_lns		; replace line numbers
 LDR R14,loadingerror
 CMP R14,#0
 FNRTS EQ
 MVN R1,#100 ; 1second
 ADR R2,callbackwarn
 FNcall Zap_CallBack
 FNRTS

callbackwarn
 FNJSR "R0-R9"
 LDR R14,loadingerror
 TST R14,#4			; low priority
 ADRNE R0,warnaboutterminator
 TST R14,#2
 ADRNE R0,warnaboutdataloss
 TST R14,#1			; high priority
 ADRNE R0,warnaboutcorruptfile
 MOV R1,#512
  [ INTL=""
 ORR R1,R1,#1<<29
  ]
 LDR R8,r8cbzwtmp ; should use offsets...
 LDR R9,r9cbzwtmp ; should use offsets...
 FNcall Zap_Warning
 FNRTS

r8cbzwtmp
 DCD 0

r9cbzwtmp
 DCD 0

warnaboutterminator
 StrZ "basic_noterm","This BASIC file has a missing terminator"

warnaboutdataloss
 StrZ "basic_appendeddata","Appended data truncated - beware of data loss"

warnaboutcorruptfile
 StrZ "basic_corrupted","BASIC file seriously corrupted - truncated on loading"
 ALIGN

basic_presave
 FNJSR
 BL replace_lns
 BLVC replace_ends
 FNRTS

;E R9=file
;X CC if &0D at start, CS otherwise |

check_format
 LDR R0,[R9,#f_len]
 CMP R0,#0
 ORRLES PC,R14,#Cbit
 STMFD R13!,{R1,R14}
 MOV R0,#0
 BL cln_readc			; get first char of file
 TEQ R0,#&0D
 LDMFD R13!,{R1,R14}
 BICEQS PC,R14,#Cbit
 ORRS PC,R14,#Cbit

;E R2=len R3=address of data block

basic_loading
 FNJSR
 CMP R2,#2
 FNRTS LT			; cannot be a basic file
 LDRB R14,[R3]
 TEQ R14,#&0D
 FNRTS NE			; no return at start
 ADD R14,R3,R2
 LDRB R14,[R14,#-1]
 TEQ R14,#&FF
 FNRTS NE			; no FF at end
 STMFD R13!,{R1-R3}
 ADD R1,R3,#1
 SUB R3,R2,#2
 SUB R2,R1,#1
 FNcall Zap_MoveBytes		; shift down 1 byte
 LDMFD R13!,{R1-R3}
 SUB R2,R2,#2			; new length
 BL remove_line_numbers
 FNRTS

basic_start
 FNJSR
 MOV R0,#0
 FNSTR R0,sel_start
 FNLDR R0,mode_basic		; mode number
 STR R11,local_wkspace_ptr
 BL restore_mode_word

; MOV R8,#0
; FNLDR R1,mode_basic		; mode number
; FNcall Zap_GetModeWord
; CMP R0,#0
; BLEQ forfirsttime$l

 CMP R8,#0			; TT Don't do anything if in IB menu
 BLNE but_destroyanypanes	; destroy any made so far...
 CMP R8,#0			; TT Don't do anything if in IB menu
 BLNE gomakepanehappen
 FNRTSS

;forfirsttime$l
; FNJSR
; FNLDR R1,mode_basic		; mode number
; MOV R0,#&1E000
; ORR R0,R0,#&42
; FNcall Zap_PutModeWord
; FNRTS

local_wkspace_ptr
 DCD 0

basic_setwidth
 FNJSR "R10"
 FNLDR R10,mode_basic
 BL set_width
 FNRTS

basic_end
 FNJSR
 FNLDR R0,mode_basic
 BL save_mode_word
 CMP R8,#0			; TT Don't do anything if in IB menu
 BLNE but_destroyanypanes	; TT ... ? problem?
 FNRTS

basic_width
 FNJSR "R1"
 FNLDR R0,mode_basic
 MOV R1,#&0D
 BL calc_mode_width
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Load/save subs					      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R9
;X &0D at start removed and &FF at end removed / VS if no match

remove_ends
 STMFD R13!,{R1-R3,R14}
 LDR R3,[R9,#f_len]
 CMP R3,#2			; was it a null file
 LDMCCFD R13!,{R1-R3,PC}	; if so then return (TEMPORARY?)
 MOV R0,#0
 MOV R1,#0
 FNcall Zap_SplitBuffer		; split buffer at start
 LDMVSFD R13!,{R1-R3,PC}
 LDR R1,[R9,#f_ptr]
 LDR R2,[R9,#f_splite]
 LDRB R0,[R1,R2]		; first char of file
 TEQ R0,#&0D
 BLNE err31			; bad prog
 LDMVSFD R13!,{R1-R3,PC}
 ADD R2,R2,#1
 SUB R3,R3,#1
 STR R2,[R9,#f_splite]
 STR R2,[R9,#f_splits]
 STR R3,[R9,#f_len]		; 'delete char'
 MOV R0,R3
 MOV R1,#0
 FNcall Zap_SplitBuffer		; shift down to buffer start
 LDMVSFD R13!,{R1-R3,PC}
 LDR R1,[R9,#f_ptr]
 LDR R2,[R9,#f_splits]
 SUB R3,R3,#1			; 'delete char off file end'
 ADD R2,R2,#1			; increase split size
 LDRB R0,[R1,R3]
 TEQ R0,#&FF			; still check for last character = &FF
 BNE notrailingFF
 ;BLNE err31			; bad prog
 ;LDMVSFD R13!,{R1-R3,PC}
 STR R2,[R9,#f_splits]
 STR R3,[R9,#f_len]
 STR R3,[R9,#f_splito]		; new file state
 LDMFD R13!,{R1-R3,PC}

notrailingFF
 LDR R0,loadingerror
 ORR R0,R0,#4			; badly terminated
 STR R0,loadingerror
 LDMFD R13!,{R1-R3,PC}

;E R9=file at buffer start
;X first 3 bytes of each line replace by 3byte line number format #

remove_lns
 STMFD R13!,{R1-R3,R14}
 LDR R3,[R9,#f_ptr]		; start of file
 LDR R2,[R9,#f_len]		; file len
 BL remove_line_numbers
 LDR R14,[R9,#f_len]		; file len
 SUB R0,R14,R2
 STR R2,[R9,#f_len]
 STR R2,[R9,#f_splito]		; file split offset
 LDR R14,[R9,#f_splits]		; file split size
 ADD R14,R14,R0
 STR R14,[R9,#f_splits]		; file split size
 LDMFD R13!,{R1-R3,PC}

;E R2=length R3=file start with ends removed
;X Line numbers replaced by 3 byte format #

remove_line_numbers
 STMFD R13!,{R1-R3,R14}
 ADD R2,R3,R2			; end of file
 MOV R1,R3
re1
 SUB R0,R2,R3			; amount of file left
 CMP R0,#4			; finished?
 LDMLTFD R13!,{R1-R3,PC}
 CMP R3,R1
 BEQ skipchkmoisone
 LDRB R14,[R3,#-1]		; line number high
 CMP R14,#13			; CR chk
 BNE badlycorrupted
skipchkmoisone
 LDRB R0,[R3]			; line number high
 CMP R0,#&FF			; eof marker
 BEQ endoflnconversion
 LDRB R14,[R3,#1]		; line number low
 ADD R0,R14,R0,LSL#8		; line number
 BL conv_ln_3byte
 LDMVSFD R13!,{R1-R3,PC}
 LDRB R14,[R3,#2]		; total line length
 STRB R0,[R3]
 MOV R0,R0,LSR#8
 STRB R0,[R3,#1]
 MOV R0,R0,LSR#8
 STRB R0,[R3,#2]		; save line number in 3 byte form
 ADD R3,R3,R14			; start of next line
 B re1

badlycorrupted
 LDR R0,loadingerror
 ORR R0,R0,#1
 STR R0,loadingerror
endoflnconversion
 LDR R0,loadingerror
 ORR R0,R0,#2
 STR R0,loadingerror
 SUB R0,R2,R3			; size of change
 LDMFD R13!,{R1-R3,R14}
 SUB R2,R2,R0
 MOV PC,R14

loadingerror
 DCD 0

;E R9=file
;X &0D at start and &FF at end added #

replace_ends
 FNJSR "R1-R3"
 LDR R3,[R9,#f_len]
 MOV R0,#0
 MOV R1,#1
 FNcall Zap_SplitBuffer		; split buffer at start
 FNRTS VS
 LDR R1,[R9,#f_ptr]
 LDR R2,[R9,#f_splite]
 SUB R2,R2,#1
 ADD R3,R3,#1
 STR R2,[R9,#f_splite]
 STR R2,[R9,#f_splits]
 STR R3,[R9,#f_len]		; 'insert char'
 MOV R0,#&0D
 STRB R0,[R1,R2]		; insert an 0D
 MOV R0,R3
 MOV R1,#1
 FNcall Zap_SplitBuffer		; shift down to buffer start
 FNRTS VS
 LDR R1,[R9,#f_ptr]
 LDR R2,[R9,#f_splits]
 MOV R0,#&FF
 STRB R0,[R1,R3]		; add FF onto the end
 ADD R3,R3,#1			; 'insert char off file end'
 SUB R2,R2,#1			; decrease split size
 STR R2,[R9,#f_splits]
 STR R3,[R9,#f_len]
 STR R3,[R9,#f_splito]		; new file state
 FNRTS

;E R9=file
;X file split at end with 4 bytes free and line numbers replaced / VS

replace_lns
 STMFD R13!,{R1-R7,R14}
 LDR R0,[R9,#f_len]
 MOV R1,#4
 FNcall Zap_SplitBuffer		; coagulate text 4 bytes free
 LDRVC R6,[R9,#f_len]
 LDRVC R7,[R9,#f_ptr]		; file start
 ADDVC R6,R7,R6			; file end
 BLVC replace_line_numbers
 LDMFD R13!,{R1-R7,PC}

;E R6=end of prog R7=start of prog
;X start of line numbers replaced by 2 byte form and length byte
;  and undone on error #

replace_line_numbers
 STMFD R13!,{R1-R7,R14}
 MOV R5,#&0D
 ORR R5,R5,R5,LSL#8
 ORR R5,R5,R5,LSL#16		; return mask
 MOV R3,R7			; save data start
re10
 CMP R7,R6			; finished ?
 LDMCSFD R13!,{R1-R7,PC}
 MOV R4,R7			; save start of line
 BL log_forward			; find end of line
 BCS re40			; corrupt file
 SUB R1,R7,R4			; find length of line
 CMP R1,#4
 BLT re41			; line too small
 CMP R1,#&100			; line too big
 BCS re37
 LDRB R0,[R4]
 LDRB R14,[R4,#1]
 ORR R0,R0,R14,LSL#8
 LDRB R14,[R4,#2]
 ORR R0,R0,R14,LSL#16		; read 3 byte line number
 BL conv_3byte_ln
 MOV R14,R0,LSR#8
 STRB R14,[R4]			; line number high
 STRB R0,[R4,#1]		; line number low
 STRB R1,[R4,#2]		; line length
 B re10				; next line
re35
 SUB R2,R4,R3			; R3=file start R2=length
 BL remove_line_numbers		; put them back again
 BL err35			; get error string
 MOV R1,R2			; error offset
 BL error_offset
 LDMFD R13!,{R1-R7,PC}
re37
 SUB R2,R4,R3			; R3=file start R2=length
 BL remove_line_numbers		; put them back again
 BL err37			; get error string
 MOV R1,R2			; error offset
 BL error_offset
 LDMFD R13!,{R1-R7,PC}
re41
 SUB R2,R4,R3			; R3=file start R2=length
 BL remove_line_numbers		; put them back again
 BL err41			; get error string
 MOV R1,R2			; error offset
 BL error_offset
 LDMFD R13!,{R1-R7,PC}
re40
 SUB R2,R4,R3			; R3=file start R2=length
 BL remove_line_numbers		; put them back again
 BL err40			; get error string
 ; MOV R1,R2			; error offset
 ; BL error_offset
 LDMFD R13!,{R1-R7,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Renumbering						   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

renumbertemp$l
 DCD 0

;X saves regs as called by the e_command sub.

basic_renumber
 CMP R8,#0			; from IB?
 MOVEQ PC,R14			; yes.
 STMFD R13!,{R1-R11,R14}
 SWI XHourglass_On
 FNcall Zap_CalculateChecksum
 STR R0,renumbertemp$l
 BL renumber_rate		; find line number spacing
 BVS bas_exit_renumber
 MOV R1,#0			; no goto's changed yet
 BL renumber_file		; renumber file
 BVS bas_exit_renumber
 TEQ R1,#0
 BEQ re14			; can do a quick update
 LDR R7,[R9,#f_flags]
 ORR R0,R7,#1<<14		; unlink input
 STR R0,[R9,#f_flags]
 MOV R0,#0
 MOV R1,#0
 MOV R2,#0
 FNcall Zap_NewTxtStatus	; redraw file
 STR R7,[R9,#f_flags]
 B bas_exit_renumber
re14
 ADR R10,update_linenos		; sub to call
 FNcall Zap_EachWindow		; call for each window
bas_exit_renumber
 FNcall Zap_CalculateChecksum
 MOV R2,R0
 SWI XHourglass_Off
 LDR R1,renumbertemp$l
 CMP R1,R2
 LDMEQFD R13!,{R1-R11,PC}	; unchanged...
 MVN R0,#0			; changed...
 FNcall Zap_MarkChanged		; file modified...
 FNcall Zap_NewFileTitle
; SWI &107			; beep!
 LDMFD R13!,{R1-R11,PC}

;E R8/R9=file
;X line numbers updated after a renumber

update_linenos
 FNJSR
 FNcall Zap_GetWindState	; update the coords
 MOV R0,#0
 STR R0,[R8,#w_txtn]		; buffer not now valid
 FNcall Zap_UpdateLns
 FNRTS

;E R1=display flags R3=start line R4=increment R9=file
;X If R1=0 on entry then save_txt_status called when first goto
;  found and set to 1 on exit. Data renumbered.

renumber_file
 FNJSR
 BL update_line_numbers		; replace old Goto with new value
; FNRTS VS
 BLVC reset_line_numbers	; alter 'start of line' numbers
 FNRTS

;E R1=display flags R3=first number R4=gap R8/R9=file
;X R1<>0 if some goto updated. GOTO's updated #

update_line_numbers
 STMFD R13!,{R2-R10,R14}
 MOV R10,R1			; save disp flag
 MOV R5,#&8D
 ORR R5,R5,R5,LSL#8
 ORR R5,R5,R5,LSL#16		; get encrypted number mask
 MOV R2,#0			; current offset
re12
 BL log_FORWARD			; move to next offset
 MOVCS R1,R10
 LDMCSFD R13!,{R2-R10,PC}	; reached end of file no linenos
 TEQ R10,#0
 BNE re31			; already set up
 MOV R0,#0			; first changed char
 MOV R1,#0			; signed change
 STMFD R13!,{R2}		; save off
 STR R0,[R9,#f_docom]		; no command being executed
 LDR R2,[R9,#f_len]		; first shiftable character
 FNcall Zap_SaveTxtStatus	; before changing text
 LDMFD R13!,{R2}
 LDMVSFD R13!,{R2-R10,PC}
 MOV R10,#1			; file changed
re31
 SUB R0,R2,#1			; offset of the &8D
 BL check_file_off		; in a rem?
 LDMVSFD R13!,{R2-R10,PC}
 TST R0,#3
 BNE re12			; wasn't valid
 MOV R0,R2			; offset of line number
 BL read_uln			; find unadjusted line number
 BLVC find_log			; find log line from 0 in R0
 LDMVSFD R13!,{R2-R10,PC}
 CMP R0,#0
 MVNMI R0,#0			; number not found
 MLAPL R0,R4,R0,R3		; new line number
 BL write_lnum
 B re12

;E R0=file offset R9=file
;X R0=detokenise flags at this offset #

check_file_off
 STMFD R13!,{R1-R5,R14}
 MOV R3,R0			; save file offset
 BL basic_linestart		; move to the start of the line
 LDMVSFD R13!,{R1-R5,PC}
 MOV R4,R0			; current file offset
 MOV R2,#0			; detokenise flags
 MOV R5,#0			; empty buffer
cl10
 CMP R4,R3
 BGE cl11			; reached the point
 MOV R0,R4
 BL cln_readc
 ORR R0,R0,R5
 BL fully_detokenise_byte
 LDMVSFD R13!,{R1-R5,PC}
 MOVCS R5,R0
 MOVCC R5,#0			; starting again
 ADD R4,R4,#1			; next offset
 B cl10
cl11
 MOV R0,R2			; the flags
 LDMFD R13!,{R1-R5,PC}

;E R0=line number/-1 R2=offset R7=address/0 to use offset R9
;X Line num saved R2 updated R1,R7 corrupt |

write_lnum
 FNJSR
 CMP R0,#0
 BMI wr1			; write @'s instead
 TEQ R7,#0
 BEQ wr1			; use cln_writec
 BL conv_ln_3byte_noerr
 STRB R0,[R7],#1
 MOV R0,R0,LSR#8
 STRB R0,[R7],#1
 MOV R0,R0,LSR#8
 STRB R0,[R7],#1
 FNRTS
wr1
 LDR R1,[R9,#f_len]
 SUB R14,R1,R2			; amount left in file
 CMP R14,#3
 FNRTS LT			; out of room
 CMP R0,#0
 BMI wr2
 BL conv_ln_3byte_noerr
 MOV R1,R0
 BL cln_writec
 ADD R2,R2,#1
 MOV R0,R1,LSR#8
 BL cln_writec
 ADD R2,R2,#1
 MOV R0,R1,LSR#16
 BL cln_writec
 ADD R2,R2,#1
 FNRTS
wr2
 SUB R2,R2,#1
 MOV R1,#4
wr3
 MOV R0,#'@'
 BL cln_writec
 ADD R2,R2,#1
 SUBS R1,R1,#1
 BHI wr3
 FNRTS

;E R3=first number R4=gap R9=file
;X file line numbers replaced from first line onwards #

reset_line_numbers
 STMFD R13!,{R1-R10,R14}
 MOV R5,#&0D
 ORR R5,R5,R5,LSL#8
 ORR R5,R5,R5,LSL#16		; get return mask
 MOV R2,#0			; current offset
 MOV R7,#0			; current address
 LDR R0,[R9,#f_len]
 CMP R0,#4
 LDMLTFD R13!,{R1-R10,PC}	; file too small
re13
 MOV R0,R3
 BL write_lnum
 ADD R3,R3,R4
 BL log_FORWARD
 BCC re13			; found another match so loop
 LDMFD R13!,{R1-R10,PC}

;E R8/R9
;X R3=first line number R4=line gap to renumber at #

renumber_rate
 STMFD R13!,{R1-R2,R14}
 ADRL R1,localmodeword
 LDR R1,[R1]
 TST R1,#1 << 16
 BNE forcingturnedon
 LDR R1,[R8,#w_height]		; number of lines in the file
 MOV R0,#&FF00			; number of valid line numbers
 SUB R0,R0,#10			; don't use 0-9 first line is 10
 BL div_mod			; gap between line numbers in R0
 CMP R0,#10
 MOVCS R0,#10			; maximum spacing 10
 MOV R3,#10			; first line number
 MOVS R4,R0			; gap
 BLEQ err36			; number of lines>number line nos
 LDMFD R13!,{R1-R2,PC}

forcingturnedon
 MOV R3,#0
 MOV R4,#1
 LDMFD R13!,{R1-R2,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Save And Run						       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mo_s0	= "BASIC -quit ",0
mo_s1	= "BASIC -chain ",0
	ALIGN

basic_saveandrun
 ADR R7,mo_s0
 B save_and_run

basic_compile
 ADR R7,mo_s1
; B save_and_run

;E R7=command to use to run file R8-R10=file
;X file saved and then run using this command #

save_and_run
 CMP R8,#0			; from IB?
 MOVEQ PC,R14			; yes.
 STMFD R13!,{R1-R2,R14}
 FNcall Zap_SaveFile
 LDRVC R0,[R9,#f_len]		; length of file
 ADDVC R0,R0,R0,LSR#1		; *1.5
 BLVC wimp_nextslot		; reserve space to run the program
 LDMVSFD R13!,{R1-R2,PC}
 FNLDR R1,buf_retoken		; buffer &110 bytes
 MOV R2,R7			; command
 BL strcpy
 LDR R2,[R9,#f_name]
 BL strcopy			; complete command
 FNLDR R0,buf_retoken
 SWI XWimp_StartTask		; run the program
 LDMFD R13!,{R1-R2,PC}

;E R0=size wanted for next wimpslot
;X size of next slot set to at least R0 if possible #

wimp_nextslot
 STMFD R13!,{R1-R10,R14}	; recall wimp_slotsize corrupts lots
 MOV R10,R0			; save required size
 MVN R0,#0
 MVN R1,#0
 SWI XWimp_SlotSize		; read next size
 LDMVSFD R13!,{R1-R10,PC}
 CMP R1,R10			; next slot already big enough?
 MVNLT R0,#0
 MOVLT R1,R10			; set new size
 SWILT XWimp_SlotSize
 LDMFD R13!,{R1-R10,PC}

basic_run
 MOV R7,#1
 B run_program

basic_runandquit
 MOV R7,#2
 B run_program

basic_basic
 MOV R7,#3
; B run_program

;E R7=what to do (1=run 2=runandquit 3=dropintobasic)
;  R8=window (giving source mode number 5=tokenised/6=text) R9
;X Tries to run the program #

run_program
 CMP R8,#0			; from IB?
 MOVEQ PC,R14			; yes.
 STMFD R13!,{R1-R7,R14}
 MOV R1,#4
 FNcall Zap_ReadVar
 LDMVSFD R13!,{R1-R7,PC}
 FNSTR R0,run_task		; zaps task handle
 LDR R0,[R9,#f_len]
 MOV R1,#0
 FNcall Zap_SplitBuffer		; coagulate text
 LDMVSFD R13!,{R1-R7,PC}
 LDR R0,[R9,#f_ptr]
 LDR R1,[R9,#f_len]
 FNSTR R0,run_start		; start of the program
 ADD R0,R0,R1
 FNSTR R0,run_end		; end of the program
 LDRB R0,[R8,#w_format]		; data type
 ORR R7,R7,R0,LSL#8
 FNSTR R7,run_flag		; save flags
 MOV R14,#0
 FNSTR R14,run_expand
 FNLDR R14, mode_bastxt
 TEQ R0, R14			; text program?
 LDREQ R0,[R8,#w_height]
 ADDEQ R0,R0,R0,LSL#1
 ADDEQ R0,R0,#4096
 BICEQ R0,R0,#3			; word align
 FNSTR R0,run_expand,EQ
 ADR R0,ru_s0			; command name
 SWI XWimp_StartTask		; enter my module (as a new task)
 MOV R14,#0
 FNSTR R14,run_flag		; reset the flag again
 LDMFD R13!,{R1-R7,PC}
ru_s0 FNS (|zap$|:CC:"Basic_RunProgram")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Insert lines						       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

basic_return
 LDR R0,[R8,#w_format]
 TST R0,#1<<14
 BEQ basic_splitline		; stream paradigm
; B insert_returns

;E R1=number of returns R8-R10=input caret
;X returns added onto line end corrupts R0-R10 #

insert_returns
 FNJSR
 MOV R7,R1			; save num lines
 BL count_autoindent
 FNRTS VS
 MOV R3,R0			; save number of spaces
 ADD R6,R0,#4			; total line length
 MUL R1,R7,R6			; num bytes needed
 FNLDR R0,buf_retoken
 FNcall Zap_Ensure
 FNRTS VS
 FNSTR R0,buf_retoken		; new buffer pointer
 MOV R5,R0			; buffer
 LDR R0,re_d0
 STR R0,[R5],#3			; new line
 CMP R3,#0
 BLE re17
re15
 MOV R0,#&20
 STRB R0,[R5],#1
 SUBS R3,R3,#1
 BGT re15
re17
 MOV R0,#&0D
 STRB R0,[R5],#1		; add line end
re3
 SUBS R7,R7,#1
 BLE re16			; created buffer
 FNLDR R1,buf_retoken
 MOV R2,R5
 MOV R3,R6
 FNcall Zap_MoveBytes
 ADD R5,R5,R6
 B re3
re16
 LDR R0,[R10,#c_off]
 BL basic_linenext		; find offset to insert the new line
 FNRTS VS
 MOV R1,R0			; offset
 FNLDR R3,buf_retoken		; data
 SUB R2,R5,R3			; num bytes
 MOV R0,#&11			; block insert
 ADR R7,returns_sub
 BL do_nocur			; ???????????????????????????????????
 FNRTS VS			; error
 ADD R0,R1,R2
 SUB R0,R0,#1			; new caret offset
 STR R0,[R10,#c_off]
 FNcall Zap_ReflectCaret
 FNcallc Zap_ShowCursor,VC
 FNRTS
re_d0		    DCD &0D404054 ; null line

returns_sub
 FNjump Zap_Command

;E R8-R10=input caret in line to split/add return on to
;X R0=number of spaces to auto indent following lines by
;  R1=R0 or 0 if current cursor offset was smaller.

count_autoindent
 LDR R0,[R8,#w_format]
 TST R0,#1<<16
 MOVEQ R0,#0
 MOVEQ R1,#0
 MOVEQ PC,R14			; no auto indent
 STMFD R13!,{R2-R4,R14}
 LDR R0,[R10,#c_off]
 BL basic_linestart
 LDMVSFD R13!,{R2-R4,PC}
 MOV R2,R0			; save line start
 MOV R3,R0
 LDR R4,[R9,#f_len]
co15
 CMP R3,R4
 BCS co16
 MOV R0,R3
 BL cln_readc
 TEQ R0,#&20
 ADDEQ R3,R3,#1
 BEQ co15			; count spaces
co16
 SUB R0,R3,R2			; number of spaces
 LDR R1,[R10,#c_off]
 SUB R1,R1,R2			; current indent into line
 CMP R1,R0
 MOVLT R1,#0
 MOVGT R1,R0			; do indent
 LDMFD R13!,{R2-R4,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Split and join					   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

basic_splitline
 FNJSR
 LDR R0,[R10,#c_off]		; offset to split at
 LDR R14,[R9,#f_len]
 CMP R0,R14
 LDMCSFD R13!,{R14}
 BCS insert_returns		; insert line(s) if at file end
 BL cln_readc
 CMP R0,#13			; hardwired EOL
 BNE asnormal$l
 FNcall Zap_ReflectCaret
asnormal$l
 LDR R0,[R10,#c_off]		; offset to split at
 BL count_autoindent		; R0=number of spaces to add
 FNSTR R1,tmp_split3,VC		; save number of spaces
 BLVC prepare_line_speshally	; prepare_line ; detokenise line R1=data R2=dlen
 FNRTS VS			; R3=col R4=olen R6=oloff
 CMP R3,R2
 MOVCS R3,R2			; clip column to line end
 MOV R7,R3			; R7=column to split at
 ADD R0,R1,R7			; start of second line
 STMFD R13!,{R2,R7}
 MOV R2,#0
 BL tokenise_line_speshally	; retokenise the second line R8 ok.
 LDMFD R13!,{R2,R7}
 BLVC remove_spaces		; remove spaces from the end
 FNRTS VS
 MOV R5,R0			; save tokenised line length
 FNLDR R0,tmp_split3		; auto indent amount
 ADD R5,R5,R0			; total length
 FNSTR R1,tmp_split2		; save detokenised length
 FNLDR R0,buf_insert
 ADD R1,R5,#&40	; was &10
 FNcall Zap_Ensure		; reserve space for it
 FNRTS VS
 FNSTR R0,buf_insert
 LDR R1,re_d1
 STR R1,[R0],#3			; write new line header
 MOV R1,R0			; buffer pointer
 MOV R0,#&20
 FNLDR R2,tmp_split3
 BL strstr			; insert auto indent spaces
 MOV R2,R1
 FNLDR R1,buf_retoken
 FNLDR R0,tmp_split3
 SUB R3,R5,R0			; length of tokenised line
 ADD R3,R3,#1			; copy return as well
 FNcall Zap_MoveBytes		; create tokenised 2nd line
 ADD R5,R5,#4			; include header & terminator
 FNLDR R0,buf_detoken
 MOV R14,#&0D
 STRB R14,[R0,R7]		; first line detokenised
 ADD R7,R7,#1
 STRB R14,[R0,R7]		; extra work...
 SUB R7,R7,#1
 FNcall Zap_StartOp		; do in one go
 BL update_line_off_speshally	; shrink down the first line
 BVS sp1			; R0=new tokenised length
 ADD R6,R6,R0
 ADD R6,R6,#1			; start of the next line
 MOV R0,#&11			; insert line
 MOV R1,R6
 MOV R2,R5
 FNLDR R3,buf_insert		; line to insert
 FNcall Zap_Command		; insert the new line
 FNcall Zap_StopOp
 FNRTS VS
 FNLDR R5,tmp_split2		; detokenised len of second line
 FNLDR R7,tmp_split3		; new cursor line offset
 BL move_cursor_speshally	; move_cursor	; put in new posn
 FNcallc Zap_ShowCursor,VC
 FNRTS
sp1
 FNcall Zap_StopOp
 FNRTS
re_d1
 DCD &00404054 ; 0 line number at line start

basic_joinline
; B join_line

;E R8-R10=input caret
;X Line joined at caret (and colon added if in non standard) #

join_line
 FNJSR "R1-R10"
 LDR R0,[R10,#c_off]
 BL basic_linenext		; find the start of the next line
 FNRTS VS
 ADD R0,R0,#3			; line start
 LDR R14,[R9,#f_len]
 CMP R0,R14
 FNRTS CS			; no line to join
 MOV R1,R0			; file off in line
 BL detokenise_line_speshally	; detokenise to buf_detoken
 FNRTS VS			; R0=end off R1=buf R2=det len R3
 MOV R7,R0			; save end of source line
 MOV R5,R2			; save len of detokenised source
 ;SUB R5,R2,#1			; save len of detokenised source
 FNLDR R0,buf_insert
 ADD R1,R5,#&10
 FNcall Zap_Ensure		; reserve memory for it
 FNRTS VS
 FNSTR R0,buf_insert
 FNLDR R1,buf_detoken		; source
 MOV R2,R0			; dest
 LDR R0,[R8,#w_format]
 TST R0,#1<<15
 BEQ jo10			; not in non standard mode
jo11
 LDRB R0,[R1]
 TEQ R0,#&20
 ADDEQ R1,R1,#1
 SUBEQ R5,R5,#1
 BEQ jo11			; strip leading spaces
jo10
 ADD R3,R5,#1
 FNcall Zap_MoveBytes		; copy the string
 BL prepare_line_speshally	; detokenise line to join to
 FNRTS VS			; R6=original line off
 SUB R2,R2,#1
 SUB R4,R7,R6			; R4=original data length
 MOV R7,R3			; save column offset
 FNLDR R0,buf_detoken
 ADD R1,R2,R5			; total length
 ADD R1,R1,#&10			; plus bits
 FNcall Zap_Ensure		; reserve memory for second half of string
 FNRTS VS
 FNSTR R0,buf_detoken		; buffer with first line
 FNLDR R1,buf_insert		; buffer with second line
 LDR R14,[R8,#w_format]
 TST R14,#1<<15
 BEQ jo1			; don't add colon
 TEQ   R5,#0			; nothing to add?
 TEQNE R2,#0			; nothing to add to?
 BEQ jo1			; one of strings is empty
 ADD R14,R0,R2
 LDRB R14,[R14,#-1]		; last byte of first line
 TEQ R14,#':'
 BEQ jo1			; already a colon on first
 LDRB R14,[R1]
 TEQ R14,#':'
 BEQ jo1			; already a colon on second
 MOV R14,#':'
 STRB R14,[R0,R2]
 ADD R2,R2,#1			; add colon onto first line
jo1
 ADD R2,R0,R2
 ADD R3,R5,#1			; copy the return as well
 FNcall Zap_MoveBytes
 MOV R2,#0			; tokenise flags
 BL update_line_speshally
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Cursor Copy							   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

basic_copy
 TEQ R0,#2
 MOVEQS PC,R14			; please insert via my e_char
 FNJSR "R4"
 MOV R5,R1			; save number of bytes
 FNLDR R0,buf_insert
 FNcall Zap_Ensure
 FNRTS VS
 FNSTR R0,buf_insert		; make sure buffer big enough
 STMFD R13!,{R1}
 LDR R0,[R10,#c_loff]
 LDR R1,[R10,#c_off]
 TEQ R0,R1
 MVNNE R0,#0
 BLEQ basic_lineoff
 ADDVS R13,R13,#8
 FNRTS VS
 LDR R1,[R10,#c_col]
 LDR R14,[R9,#w_margin]
 SUB R1,R1,R14
 CMP R0,R1			; detect and correct for lies :-)
 LDR R0,[R10,#c_off]
 LDMFD R13!,{R1}
 STMFD R13!,{R0}
 SUBLO R0,R0,#1
 STRLO R0,[R10,#c_off]
 FNLDR R1,buf_insert		; buffer
 MOV R2,R5			; number
 MOV R0,#&0D			; byte
 BL strstr			; fill buffer with spaces
 BL prepare_line		; detokenise line R1=detokenised data
 LDMFD R13!,{R14}
 STR R14,[R10,#c_off]		; restore lies
 FNRTS VS
 FNSTR R2,tmp_copy		; save detokenised length
 ADD R1,R1,R3			; source	; ???
 ADD R7,R3,R5			; new column
 SUBS R0,R2,R3			; number of chars left in line
 MOVMI R0,#0			; number of chars left
 MOV R3,R5			; number to copy
 CMP R3,R0
 MOVGT R3,R0			; clip number to copy
 MOV R4,R3
; SUBGT R4,R3,#1			; for EOLs?
 FNLDR R2,buf_insert		; dest
 CMP R0,#1
 BLE alternative_exit$l
 FNcall Zap_MoveBytes		; copy the data

 CMP R4,R5
 MOVLT R2,R4			; num of chars
 MOVGE R2,R5			; num of chars

 FNLDR R3,buf_insert		; buffer
 FNLDR R5,tmp_copy		; detokenised length
 BL move_cursor_lie		; R6=line start offset R7=col in line
 FNRTS

; there's still a bug somewhere :-/
; copy at the end of lines which stop near the end of lines to observe it...
alternative_exit$l
 FNcall Zap_MoveBytes		; copy the data

; SWI &107

 CMP R4,R5
 MOVLT R2,R4			; num of chars
 MOVGE R2,R5			; num of chars

 FNLDR R3,buf_insert		; buffer

; SUB R0,R3,R2
; LDRB R14,[R0,#-1]
; CMP R14,#13
; SUBEQ R2,R2,#1

; FNLDR R5,tmp_copy		; detokenised length

 MOV R0,R6
 BL basic_linenext
 MOV R6,R0

 LDR R4,[R10,#c_off]

 MOV R1,#6 ; car_input
 FNcall Zap_ReadVar

 LDR R0,[R0,#c_off]
 CMP R0,R4
 MOV R0,R6
 BLCC basic_linenext ; another?!

 ; why does this leave a trace :-/
 FNcall Zap_JumptoOffset
 FNRTS

basic_tab
 LDR R0,[R8,#w_flags]
 MOV R0,R0,LSR#9
 ANDS R2,R0,#3			; tab mode
 MOV R0,R1			; number of times
 BEQ advance_tab		; unix=default tab
 TEQ R2,#2
 BEQ insert_tab			; column insert tab
 B edit_tab			; edit/auto tab

;E R0=number of tab stops to advance R8-R10=input caret
;X cursor advanced #

advance_tab
 STMFD R13!,{R1-R7,R14}
 MOV R7,R0			; save number of times
 BL prepare_line		; R1=det R2=detlen R3=col R4=len
 LDMVSFD R13!,{R1-R7,PC}	; R6=off
 MOV R5,R2			; detokenised length
 MOV R0,R3			; current column
 LDR R1,[R8,#w_tab]
 BL div_mod			; find current tab stop
 ADD R0,R0,R7			; new tab stop
 LDR R1,[R8,#w_tab]
 MUL R7,R1,R0			; new column
 BL move_cursor
 FNcallc Zap_ShowCursor,VC
 LDMFD R13!,{R1-R7,PC}

;E R0=number of tab stops to insert R8-R10=input caret
;X tab stops inserted as spaces #

insert_tab
 FNJSR "R1-R11"
 ;STMFD R13!,{R1-R11,R14}
 MOV R7,R0			; save number of times
 BL prepare_line		; R1=det R2=detlen R3=col R4=len
 FNRTS VS ; LDMVSFD R13!,{R1-R11,PC}	; R6=off
 MOV R5,R3			; save current column
 MOV R0,R3
 LDR R1,[R8,#w_tab]
 BL div_mod			; find current tab stop
 ADD R0,R0,R7			; new tab stop
 LDR R1,[R8,#w_tab]
 MUL R0,R1,R0			; new column
 SUBS R5,R0,R5			; number of spaces to insert
 FNRTS LE ; LDMLEFD R13!,{R1-R11,PC}
insert_the_tab
 FNLDR R0,buf_insert
 MOV R1,R5
 FNcall Zap_Ensure
 FNRTS VS ; LDMVSFD R13!,{R1-R11,PC}
 FNSTR R0,buf_insert		; buffer for data
 MOV R7,R0
 MOV R0,#&20
 MOV R1,R7
 MOV R2,R5
 BL strstr			; fill buffer with spaces
 LDR R4,[R8,#w_flags]
 BL basic_char			; insert
 FNRTS ; LDMFD R13!,{R1-R11,PC}

local_startofthisline
 DCD 0

;E R8-R10=input caret
;X spaces inserted to advance caret to next edit/auto stop #

edit_tab
 FNJSR "R1-R11"
 BL prepare_line		; R1=det R2=detlen R3=col R4=len
 FNRTS VS			; R6=off
 MOV R7,R3			; save current column
 LDR R0,[R10,#c_off]
tabbackloop
 BL basic_lineprev
 FNRTS VS
 SUBS R0,R0,#1			; previous line
 BMI middleofnextlineupplease ; nextlineupplease
 ; FNRTS MI			; at start...?
 BL basic_linestart
 FNRTS VS
 STR R0,local_startofthisline
 MOV R1,R0
 BL detokenise_line		; R1=start R2=len R3=col
 FNRTS VS
 MOV R5,R7			; start col
 LDR R0,[R8,#w_flags]
 TST R0,#1<<10
 BNE ed3			; auto indent tab
ed1
 CMP R7,R2
 BGE ed2			; finished
 LDRB R0,[R1,R7]
 TEQ R0,#&20
 ADD R7,R7,#1
 BNE ed1
ed3
 CMP R7,R2
 BGE ed2			; finished
 LDRB R0,[R1,R7]
 TEQ R0,#&20
 ADDEQ R7,R7,#1
 BEQ ed3
ed2
 SUBS R5,R7,R5			; number of spaces
 BGT insert_the_tab

nextlineupplease
 LDR R0,local_startofthisline
 SUBS R0,R0,#1
 BPL tabbackloop
middleofnextlineupplease
 LDR R0,[R10,#c_col]
 AND R5,R0,#7
 RSB R5,R5,#7
 CMP R5,#0
 MOVEQ R5,#8
 B insert_the_tab ; insertsomeanyway

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Insert chars/delete chars					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R5=num bytes R7=data R8-R10=input R11=my work R12=zap work

basic_char
 FNJSR "R3,R4"
; BL err37
; FNRTS
 BL clearanyserosizesels
 ADRL R1,localcopyof_mode_basic
 LDR R1,[R1]
 BL charchar

preloop$l
 MOV R3,#0
loop$l
 CMP R3,R5
 FNRTS GE
; this code /may/ cause too much trouble...
 LDRB R14,[R7,R3]
 CMP R14,#13			; HARDWIRED
 BEQ douptohere$l
 ADD R3,R3,#1
 CMP R3,R5
 BLT loop$l
 BL do_up_to_here
 FNRTS

douptohere$l
 LDRB R14,[R7]
 CMP R14,#13			; HARDWIRED
 BEQ justareturn$l

 MOV R6,R5			; push
 CMP R3,R5
 MOVCC R5,R3
 BL do_up_to_here
 MOV R5,R6			; pull

 ADD R7,R7,R3
 SUB R5,R5,R3
 B preloop$l

justareturn$l
 PUSH "R2-R10"
 LDR R0,[R8,#w_format]
 BIC R2,R0,#1<<16
 STR R2,[R8,#w_format]
 PUSH "R0"
 MOV R1,#1
 BL insert_returns
 PULL "R0"
 PULL "R2-R10"
 STR R0,[R8,#w_format]
 ADD R7,R7,#1
 SUB R5,R5,#1
 B preloop$l

do_up_to_here
 FNJSR "R3,R4,R5,R6,R7"
 BL prepare_line_speshally	; set up R1-R4,R6
 FNRTS VS

 PUSH "R4,R6"
 LDR R4,[R13,#12]		; stacked w_flags
 MOV R6,#0
 BL change_line_insert		; insert R7,R5 data
 PULL "R4,R6"

 BLVC count_dots			; get tokenise flag in R2
 ADDVC R7,R3,R5			; new cursor column offset
 BLVC update_line_speshally
 FNRTS

; This is needed so zero size selections don't spring into
; life on (de)tokenisation... (TT)

clearanyserosizesels
 FNJSR "R1,R2,R4,R8,R9"
 MOV R4,R8
 FNcall Zap_GetSel
 FNRTS CC
 CMP R4,R8		; zero size selection - in this window...?
 FNRTS NE
 FNcallc Zap_ClearSel
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Insert chars/delete chars					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R4=w_flags R5=num bytes R7=data R8-R10=input R11=my work R12=zap work

basic_char_no_spaces
 FNJSR "R4"
 ADRL R1,localcopyof_mode_basic
 LDR R1,[R1]
 BL charchar
 BL prepare_line_speshally	; set up R1-R4,R6
 FNRTS VS
 CMP R3,R2			; if off end of line
 MOVCS R3,R2			; bind to line...
 PUSH "R4,R6"
 LDR R4,[R13,#8]		; get stacked w_flags
 MOV R6,#1
 BL change_line_insert		; insert R7,R5 data
 PULL "R4,R6"
 BLVC count_dots		; get tokenise flag in R2
 ADDVC R7,R3,R5			; new cursor column offset
 BLVC update_line_speshally
 FNRTS

;E R5=num bytes R7=1 for s-del R8-R10=input R11=my work R12=zap work

basic_delete
 FNJSR
 BL prepare_line_speshally	; set up R1-R4,R6
 FNRTS VS
 LDR R0,[R8,#w_format]		; format word
 TEQ R7,#0
 BNE de17			; shift delete
 CMP R3,#0
 BGT de16			; not at line start
 TST R0,#1<<14
 FNRTS NE
 LDR R0,[R10,#c_loff]
 CMP R0,#0
 FNRTS LE			; at start of file
 SUB R0,R0,#1
 STR R0,[R10,#c_off]
 FNcall Zap_UpdateCaret		; move to end of last line
 BL join_line
 FNRTS
de17
 SUB R14,R2,#1
 CMP R3,R14
 BCC de16			; not at line end
 TST R0,#1<<14
 BLEQ join_line
 FNRTS
de16
 BL change_line_delete
 MOVVC R2,#0			; tok flags
 BLVC update_line_speshally
 FNRTS

 LOCAL

;E R8-R10=input caret (detokenises line at input prior to del/insert)
;X R1=detokenised data R2=detokenised line len R3=column offset in line
;  R4=original line len R6=original line off #

prepare_line
 FNJSR
 LDR R1,[R10,#c_loff]
 LDR R0,[R9,#f_len]
 CMP R1,R0
 BCC ok$l
 PUSH "R1-R11"			; off end of file so insert returns
 MOV R1,#1
 BL insert_returns
 PULL "R1-R11"
ok$l				; we are in a line
 LDR R1,[R10,#c_loff]		; start of line offset
 MOV R0,R1
 BL basic_linestart
 FNRTS VS
 MOVVC R6,R0			; save start of line file offset
 BLVC detokenise_line		; detokenise the line to R1->R2 R3=col
 SUB R4,R0,R6			; save original line length
 LDR R0,[R10,#c_col]		; col of caret on the phy line (inc margin)
 LDR R14,[R8,#w_margin]
 SUBS R0,R0,R14
 MOVMI R0,#0			; col of caret on the phy line (exc margin)
 ;PUSH "R1"
 ;ADRL R14,addontor3cnt		; adjust for inserted tabs :-/
 ;LDRB R14,[R14]
 ;SUB R3,R3,R14
 LDR R14,[R8,#w_bpl]		; width
a$l
 SUBS R3,R3,R14			; can we move down another line (dodgy code?)
 ADDGE R0,R0,R14		; yes, so move the cursor
 BGE a$l			; repeat until boosted to correct line
 MOV R3,R0			; column offset (refined to caret posn)
 ;ADD R3,R3,R14
 ;PULL "R1"
 FNRTS

 LOCAL

;E R8-R10=input caret (detokenises line at input prior to del/insert)
;X R1=detokenised data R2=detokenised line len R3=column offset in line
;  R4=original line len R6=original line off #

prepare_line_speshally
 FNJSR
 LDR R1,[R10,#c_loff]
 LDR R0,[R9,#f_len]
 CMP R1,R0
 BCC ok$l
 PUSH "R1-R11"			; off end of file so insert returns
 MOV R1,#1
 BL insert_returns
 PULL "R1-R11"
ok$l				; we are in a line
 LDR R1,[R10,#c_loff]		; start of line offset
 MOV R0,R1
 BL basic_linestart
 FNRTS VS
 MOV R6,R0			; save start of line file offset
 LDR R1,[R10,#c_off]		; offset of cursor position...? NEW TT!
 ;BL getcurcurofsinr1
 ; ADD R1,R1,#1
 BL detokenise_line_speshally	; detokenise the line to R1->R2 R3=col
 ;ADD R3,R3,#1
 FNRTS VS
 SUB R4,R0,R6			; save original line length
 ;BL getcolumnofcursorinR0
 LDR R0,[R10,#c_col]		; col of caret on the phy line (inc margin)
 LDR R14,[R8,#w_margin]
 SUBS R0,R0,R14
 MOVMI R0,#0			; col of caret on the phy line (exc margin)
 PUSH "R1"
 ADRL R14,addontor3cnt		; adjust for inserted tabs :-/
 LDRB R14,[R14]
 SUB R3,R3,R14
 SUB R3,R3,#1			; was 2
 LDR R1,[R8,#w_bpl]		; width
 BL adjustR0ifcuronprevline
a$l
 SUBS R3,R3,R1			; can we move down another line (dodgy code?)
 ;ADDGT R0,R0,R1			; yes, so move the cursor
 ;BGT a$l			; repeat until boosted to correct line
 ADDGE R0,R0,R1			; yes, so move the cursor
 BGE a$l			; repeat until boosted to correct line
 ADRL R14,addontor3cnt		; adjust for inserted tabs :-/
 LDRB R14,[R14]
 ADD R3,R0,R14
 PULL "R1"
; LDR R14,[R8,#w_bpl]		; width
;a$l
; SUBS R3,R3,R14		; can we move down another line (dodgy code?)
; ADDGE R0,R0,R14		; yes, so move the cursor
; BGE a$l			; repeat until boosted to correct line
; ADRL R14,addontor3cnt		; adjust for inserted tabs :-/
; LDRB R14,[R14]
; ADD R3,R0,R14			; column offset (refined to caret posn)
 FNRTS

;getcolumnofcursorinR0 ; local_cur_offspl1 set up...
; FNJSR "R1,R2,R3"
; LDR R2,[R10,#c_col]		; offset of cursor position...? NEW TT!
; LDR R3,[R10,#c_line]
; FNcall Zap_FindOffset
; LDR R0,local_cur_offspl1
; FNcall Zap_OffLineCol
; MOV R0,R2			; column.
; FNRTS

;getcurcurofsinr1
; FNJSR "R0,R2,R3"
; LDR R2,[R10,#c_col]		; offset of cursor position...? NEW TT!
; LDR R3,[R10,#c_line]
; FNcall Zap_FindOffset
; MOV R1,R0
; ;SUB R1,R0,#1 ; ????????????
; STR R1,local_cur_offspl1
; FNRTS

;local_cur_offspl1
; DCD 0

adjustR0ifcuronprevline ; local_cur_offspl1 set up...
 FNJSR "R1-R5"
 CMP R3,#0
 FNRTS LE
 MOV R5,R1
 MOV R4,R0
 LDR R0,[R10,#c_off]		; offset of cursor position...? NEW TT!
 ;LDR R0,local_cur_offspl1	; offset of cursor position...? NEW TT!
 FNcall Zap_OffLineCol
 LDR R1,[R10,#c_line]
 CMP R3,R1
 ADDLT R0,R4,R5
 FNRTS LT
 LDR R1,[R8,#w_bpl]		; width
 CMP R4,R1
 MOVCS R0,R4
 FNRTS CS
 ;BCS specialcaseforveol
 CMP R4,#0			; at start of a physical line...?
 MOVNE R0,R4
 FNRTS NE
 LDR R0,[R10,#c_off]		; offset of cursor position...? NEW TT!
 ;LDR R0,local_cur_offspl1
 ;LDR R0,[R10,#c_off]		; offset of cursor position...? NEW TT!
 BL basic_clnoff
 FNRTS VS
 MOV R3,R1			; R3=physical line start offset
 MOV R0,R2
 BL basic_clnlog
 FNRTS VS
 CMP R0,R3
 MOVEQ R0,R4
 ADDNE R0,R4,R5
 FNRTS

;specialcaseforveol
; ;MOV R0,R4
; ;FNRTS
;
; ;LDR R0,[R10,#c_off]		; offset of cursor position...? NEW TT!
; ;LDR R1,[R9,#f_len]		; len
; ;CMP R0,R1
; ;MOVCS R0,R4
; ;FNRTS CS
; ;BL cln_readc
; ;CMP R0,#13
; ;MOVEQ R0,R4
; ;FNRTS EQ
; ;SWI &107
;
; ;LDR R14,[R10,#c_line]
; ;ADD R14,R14,#1
; ;STR R14,[R10,#c_line]
; ;MOV R14,#0
; ;STR R14,[R10,#c_col]
; MOV R0,R4
; ;SUB R0,R4,R5
; FNRTS

; BL basic_clnoff
; FNRTS VS
; MOV R3,R2			; R3=physical line start offset
; LDR R0,[R10,#c_off]		; offset of cursor position...? NEW TT!
; ADD R0,R0,#1
; BL basic_clnoff
; FNRTS VS
; CMP R3,R2			; if on a different logical line...
; MOVNE R0,R4
; ADDEQ R0,R4,R5
; SWIEQ &107
; FNRTS

 ;LDR R1,[R10,#c_col]
 ;LDR R14,[R8,#w_margin]
 ;SUBS R0,R0,R14
 ;MOVMI R0,#0			; col of caret on the phy line (exc margin)

 LOCAL

;E R1=file offset R6=line start(+3) R8/R9
;X R1=detokenised data R2=detokenised len R3=col offset
;  R4=original line len #

prepare_line_off_speshally
 FNJSR
 MOV R0,R6
 BL detokenise_line_speshally		; R0=end R1=data R2=len R3=col
 SUBVC R4,R0,R6			; source line length
 FNRTS

;E R1=file offset R6=line start(+3) R8/R9
;X R1=detokenised data R2=detokenised len R3=col offset
;  R4=original line len #

prepare_line_off
 FNJSR
 MOV R0,R6
 BL detokenise_line		; R0=end R1=data R2=len R3=col
 SUBVC R4,R0,R6			; source line length
 FNRTS

; ;E R2=tokenise flags R4=original line len R6=original off
; ;  R7=new cur col R8-R10=input caret
; ;X Line tokenised, screen updated, cursor updated #
;
; update_line
;  STMFD R13!,{R1-R7,R14}
;  FNLDR R0,buf_detoken
;  MOV R3,R7			; save cursor col
;  BL tokenise_line		; tokenise line to buf_retoken & update R7
;  LDMVSFD R13!,{R1-R7,PC}
;  BL remove_spaces
;  LDMVSFD R13!,{R1-R7,PC}
;  SUB R14,R7,R3			; find increment
;  ADD R5,R1,R14			; actual detokenised length
;  MOV R1,R6			; file offset
;  MOV R2,R4			; file line len
;  FNLDR R3,buf_retoken		; data
;  MOV R4,R0			; data len
;  STMFD R13!,{R7}		; save R7
;  LDR R7,[R9,#f_flags]
;  ORR R7,R7,#1<<24
;  STR R7,[R9,#f_flags]		; make input invisible
;  BL replace_area		; may change altered state
;  LDR R7,[R9,#f_flags]
;  BIC R7,R7,#1<<24
;  STR R7,[R9,#f_flags]		; make input invisible
;  LDMFD R13!,{R7}
;  LDMVSFD R13!,{R1-R7,PC}
;  BL move_cursor			; put in new posn
;  LDMVSFD R13!,{R1-R7,PC}
;  FNcall Zap_ShowCursor
;  LDMFD R13!,{R1-R7,PC}

 LOCAL

;E R2=tokenise flags R4=original line len R6=original off
;  R7=new cur col R8-R10=input caret
;X Line tokenised, screen updated, cursor updated #

update_line_speshally
 STMFD R13!,{R1-R7,R14}
 ADRL R14,addontor3cnt		; adjust for inserted tabs :-/
 LDRB R14,[R14]			; note the B.
 SUB R7,R7,R14
 FNLDR R0,buf_detoken
 MOV R3,R7			; save cursor col
 BL tokenise_line_speshally	; tokenise line to buf_retoken & update R7
;dead
; BVS dead
; LDMVSFD R13!,{R1-R7,PC}
 BLVC remove_spaces
 LDMVSFD R13!,{R1-R7,PC}
 SUB R14,R7,R3			; find increment
 ADD R5,R1,R14			; actual detokenised length
 MOV R1,R6			; file offset
 MOV R2,R4			; file line len
 FNLDR R3,buf_retoken		; data
 MOV R4,R0			; data len
 STMFD R13!,{R7}		; save R7 (and R5?)
 LDR R7,[R9,#f_flags]
 ORR R7,R7,#1<<24
 STR R7,[R9,#f_flags]		; make input invisible
 BL replace_area		; may change altered state
 LDR R7,[R9,#f_flags]
 BIC R7,R7,#1<<24
 STR R7,[R9,#f_flags]		; make input invisible
 LDMFD R13!,{R7} ; R5 too?
; LDMVSFD R13!,{R1-R7,PC}
 BLVC move_cursor_speshally ; move_cursor			; put in new posn
 FNcallc Zap_ShowCursor,VC

 ;LDR R14,[R10,#c_wind]
 ;STR R14,[R10,#c_owind]
 ;LDR R14,[R10,#c_line]
 ;STR R14,[R10,#c_oline]
 ;LDR R14,[R10,#c_col]
 ;STR R14,[R10,#c_ocol]

 ;FNcall Zap_ClearCaret ; ?
 ;FNcall Zap_PlotCaret ; ?
 ;SWI &107
 ;SWI &107
 LDMFD R13!,{R1-R7,PC}

 LOCAL

;E R4=original line len R6=original off R8/R9
;X R0=tok len, Line tokenised, screen updated (no cursor moves) #

update_line_off
 STMFD R13!,{R1-R7,R14}
 FNLDR R0,buf_detoken
 MOV R2,#0
 BL tokenise_line		; tokenise line to buf_retoken & update R7
; LDMVSFD R13!,{R1-R7,PC}
 BLVC remove_spaces
; LDMVSFD R13!,{R1-R7,PC}
 MOVVC R1,R6			; file offset
 MOVVC R2,R4			; file line len
 FNLDR R3,buf_retoken,VC	; data
 MOVVC R4,R0			; data len
 BLVC replace_area		; direct area replace
; LDMVSFD R13!,{R1-R7,PC}
 MOVVC R0,R4			; new line length
 LDMFD R13!,{R1-R7,PC}

;E R4=original line len R6=original off R8/R9
;X R0=tok len, Line tokenised, screen updated (no cursor moves) #

update_line_off_speshally
 STMFD R13!,{R1-R7,R14}
 FNLDR R0,buf_detoken
 MOV R2,#0
 BL tokenise_line_speshally	; tokenise line to buf_retoken & update R7
; LDMVSFD R13!,{R1-R7,PC}
 BLVC remove_spaces
; LDMVSFD R13!,{R1-R7,PC}
 MOVVC R1,R6			; file offset
 MOVVC R2,R4			; file line len
 FNLDR R3,buf_retoken,VC	; data
 MOVVC R4,R0			; data len
 BLVC replace_area		; direct area replace
; LDMVSFD R13!,{R1-R7,PC}
 MOVVC R0,R4			; new line length
 ;FNcall Zap_ShowCursor
 ;LDR R14,[R10,#c_wind]
 ;STR R14,[R10,#c_owind]
 ;LDR R14,[R10,#c_line]
 ;STR R14,[R10,#c_oline]
 ;LDR R14,[R10,#c_col]
 ;STR R14,[R10,#c_ocol]
 ; FNcall Zap_ClearCaret ; ? - no no no
 LDMFD R13!,{R1-R7,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

re2x
 SUBS R0,R0,#0			; sec
 FNRTS

;E R5=detokenised len R6=line start offset R7=col in line R8-R10=caret
;X cursor moved to this posn and plotted (not shown) #

move_cursor_lie
 STMFD R13!,{R1-R7,R14}
 MOV R14,#1
 B mo_lie$l

move_cursor
 STMFD R13!,{R1-R7,R14}
mo_nolie$l
 MOV R14,#0
mo_lie$l
 STR R14,lie$l
 MOV R0,R6
 MOV R4,R6			; log loff
 BL basic_clnoff		; R0=phy line R1=loff
 LDMVSFD R13!,{R1-R7,PC}
 MOV R3,R0			; phy line
 MOV R6,R1			; phy loff
 LDR R2,[R8,#w_bpl]
 CMP R7,R2
 BCC mo2$l
mo1$l
 SUBS R7,R7,R2
 SUBHS R5,R5,R2			; reduce line len
 ADDHS R3,R3,#1			; update phy line
 BHS mo1$l
 ADDS R7,R7,R2
 TEQNE R5,#0			; are we exactly at line end & is column=0
 LDREQ R14,lie$l
 TEQEQ R14,#0
 BEQ moveback$l
 TEQ R5,#0
 TEQEQ R7,#0
moveback$l
 SUBEQ R3,R3,#1
 MOVEQ R7,R2			; move to end of last line
 MOV R0,R3
 BL basic_clnphy
 LDMVSFD R13!,{R1-R7,PC}
 MOV R6,R0
mo2$l
 MOV R0,R4
 LDR R1,[R13,#24]		; new column (stacked R7)
 BL basic_linecol		; find off
 LDMVSFD R13!,{R1-R7,PC}
 STR R0,[R10,#c_off]
  LDR R14,lie$l
  TEQ R14,#0
  BEQ mo3$l
  BL basic_clnoff
  LDMVSFD R13!,{R1-R7,PC}
  TEQ R1,R6			; these will differ when tokens wrapped
  BEQ mo3$l
  MOV R1,#5 ; car_cursor
  FNcall Zap_ReadVar
  TEQ R0,R10
  LDREQ R0,[R10,#c_off]		; lie about caret offset :-)
  ADDEQ R0,R0,#1
  STREQ R0,[R10,#c_off]		; (currently causes a COPY problem...)
mo3$l
 LDR R0,[R8,#w_margin]
 ADD R0,R0,R7
 STR R0,[R10,#c_col]		; new col
 STR R3,[R10,#c_line]
 STR R6,[R10,#c_loff]
 FNcall Zap_PlotCaret
 LDMFD R13!,{R1-R7,PC}
lie$l & 0

; LOCAL

;E R5=detokenised len R6=line start offset R7=col in line R8-R10=caret
;X cursor moved to this posn and plotted (not shown) #

move_cursor_speshally
 STMFD R13!,{R1-R7,R14}
 ADRL R14,addontor3cnt		; adjust for inserted tabs :-/
 LDR R14,[R14]
 BIC R14,R14,#&80000000
 MOV R14,R14,LSR #16
 SUB R5,R5,R14
 ; SUB R5,R5,#1			; extra CR at end...
 B mo_nolie$l

 LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Do operation with caret invisible			    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0-R6,R8-R12=parameters R7=address of # sub
;X R0-R6,R8-R10=returned vals - sub called in cursor mode -2 #

do_nocur
 STMFD R13!,{R7,R14}		; outer save
 STMFD R13!,{R0-R1,R14}		; pre call
 STR R7,[R13,#8]		; save address to call
 MOV R1,#10
 FNcall Zap_ReadVar		; R0=current cursor mode
 MOV R7,R0			; save current cursor mode
 MVN R0,#1			; -2
 FNcall Zap_WriteVar		; write the new cursor mode
 MOV R14,PC			; return address
 LDMFD R13!,{R0-R1,PC}		; call the sub
 BVS dn1			; error
 STMFD R13!,{R0-R1}		; save returned vals
 MOV R0,R7
 MOV R1,#10
 FNcall Zap_WriteVar		; write old cursor value
 LDMFD R13!,{R0-R1}
 LDMFD R13!,{R7,PC}		; go home
dn1
 STMFD R13!,{R1-R2}
 ADDS R2,R0,#0			; save error & clv
 MOV R0,R7
 MOV R1,#10
 FNcall Zap_WriteVar		; write old cursor value
 MOV R0,R2			; restore error
 LDMFD R13!,{R1-R2}
 LDMFD R13!,{R7,R14}
 ORRS PC,R14,#Vbit

 LOCAL

basic_interrogate
; CMP R0,#9
; BEQ arecentpasehappened
 CMP R0,#11
 MOVEQ PC,R14
 CMP R0,#10
 BEQ wheresitgoingtogo
 CMP R0,#2   ; no softwrap, please...
 CMPNE R0,#5 ; ConfineH - not currently :(
 CMPNE R0,#8 ; Smart cursors - not currently :(
 CMPNE R0,#12 ; Linesel - not currently :(
 CMPNE R0,#13 ; Smart cursors - not currently :(
 CMPNE R0,#23
 MVNEQ R0,#0
 CMP R0,#14		; what mode type?
 MOVEQ R0,#2		; fall through be careful.
 CMP R0,#0
 MOVNE PC,R14
 CMP R1,#4
 MOVCS R0,R1
 MOVCC R0,#4
 MOV PC,R14

basic_findfunction
 FNJSR "R2-R7,R11"
 ADRL R11,local_wkspace_ptr
 LDR R11,[R11]
 LDR R14,[R9,#f_len]		; at last char...?
 CMP R14,#0
 BEQ notfound$l
 CMP R0,R14
 BGT notfound$l
 MOV R7,R0
 MOV R5,R7
 MOV R6,#0
; MOV R0,R7
 BL cln_readc
 CMP R0,#13		; hardwired eol
 SUBEQ R7,R7,#1
loop$l
 MOVS R0,R7
 BLPL cln_readc
 CMP R0,#&A4
 CMPNE R0,#&F2
 BEQ foundaproc
 CMP R0,#'%'		;
 CMPNE R0,#'0'
 BLT notfoundFNorPROC$l
 CMP R0,#'='		;
 CMPNE R0,#':'
 BEQ notfoundFNorPROC$l
 SUBS R7,R7,#1
 BPL loop$l
notfoundFNorPROC$l
 FNLDR R1,buf_detoken	; ADR R6,local_fubuf
 MOV R14,#'.'		; .
 STRB R14,[R1],#1
loop2a$l
 ADD R7,R7,#1
 MOV R0,R7
 PUSH "R1"
 BL cln_readc
 PULL "R1"
 BIC R14,R0,#&20
 CMP R0,#'%'
 CMPNE R0,#'0'
 BLT togoandfindit
 CMP R0,#'_'
 CMPNE R0,#'9'
 BLE carryon$l
 CMP R14,#'['
 BCS togoandfindit
 CMP R0,#'@'
 BLT togoandfindit
carryon$l
 STRB R0,[R1],#1
 B loop2a$l

togoandfindit
 FNLDR R14,buf_detoken	; ADR R6,local_fubuf
 SUB R14,R1,R14
 CMP R14,#1
 BLE notfound$l

 MOV R7,R5

 ADR R2,notalphanum$l
 BL strcopy
 FNLDR R0,buf_detoken
 MOV R1,#0		; stored cursor loc.
 MOV R3,R7
 MOV R4,#-1
 MOV R5,#((7<<29) + (1<<25))
 FNcall Zap_Search
 MOVS R1,R0
 MOVPL R0,R1		; done
 MOVPL R1,#0		; found
 FNRTS PL

secondtry$l
 FNLDR R0,buf_detoken
 MOV R1,#0		; stored cursor loc.
 MOV R3,R7
 MOV R4,#1
 MOV R5,#((7<<29) + (1<<25))
 FNcall Zap_Search
 MOVS R1,R0
 MOVPL R0,R1		; done
 MOVPL R1,#0		; found
 FNRTS PL

notfound$l
 MOV R1,#1		; found
 FNRTS

foundaproc
 FNLDR R1,buf_detoken	; ADR R6,local_fubuf
 MOV R14,#&DD		; def
 STRB R14,[R1],#1
 MOV R3,R0		; save for a bit...
 ADR R2,maybesomesp$l
 BL strcpy
 STRB R3,[R1],#1
loop2$l
 ADD R7,R7,#1
 MOV R0,R7
 PUSH "R1"
 BL cln_readc
 PULL "R1"
 BIC R14,R0,#&20
 CMP R14,#'@'
 BCC goandfindit
 CMP R0,#'_'
 CMPNE R14,#'Z'
 BGT goandfindit
 STRB R0,[R1],#1
 B loop2$l
goandfindit
 ADR R2,notalphanum$l
 BL strcopy
 FNLDR R0,buf_detoken
 MOV R1,#0
 MOV R3,#-1
 MOV R4,#1
 MOV R5,#((7<<29) + (1<<25))
 FNcall Zap_Search
 MOVS R1,R0
 BMI notfound$l
 MOV R0,R1		; done
 MOV R1,#0		; found
; MOV R0,#0		; found
 FNRTS

notalphanum$l
 FNS ("\\[^0-9A-Za-z_]")
maybesomesp$l
 FNS ("\\[ ]\\*")

;local_fubuf
; DCD 0
; DCD 0
; DCD 0
; DCD 0
; DCD 0
; DCD 0

 ;LDR R0,arecentpaste
 ;CMN R0,#1
 ;MOVEQ R0,#9
 ;MOVEQ PC,R14
 ;MOV R1,R0
 ;MOV R0,#0
 ;LDR R8,arecentpaste + 4
 ;LDR R9,arecentpaste + 8
 ;MOV PC,R14

;arecentpaste
; DCD 0
; DCD 0
; DCD 0

wheresitgoingtogo
 CMP R2,#4
 MOVLT PC,R14
 FNJSR "R2"
loop1$l
 SUB R2,R2,#1
 LDRB R14,[R3,R2]		; last character
 TEQ R14,#&0D			; is a return so enter line
 MOVEQ R0,#0
 FNRTS EQ
 CMP R2,#0
 BGT loop1$l
 FNRTS

 LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Trap line renumbers when stuff inserted		    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

local_linelengthoone
 DCD 0
local_bas_command_num
 DCD 0
local_bas_command_line
 DCD 0
local_bas_command_col
 DCD 0

; execute_command entry point

basic_command
 FNJSR "R1,R3-R12"			; should preserve R10 at least...
; SWI &107
; MVN R14,#0
; STR R14,arecentpaste
 AND R14,R0,#7			; get basic command number
 TEQ R14,#1			; insert
 TEQNE R14,#6			; insert
 BNE postco1			; if not then pass on
 PUSH "R2"
 LDR R14,[R9,#f_len]		; at last char...?
 CMP R1,R14
 BGE co2			; if so then insert a line
 CMP R2,#4
 BLT co1			; not a full line
loop1$l
 SUB R2,R2,#1
 LDRB R14,[R3,R2]		; last character
 TEQ R14,#&0D			; harddwired CR
 BEQ co2			; is a return so enter line
 CMP R2,#0
 BGT loop1$l
co1
 PULL "R2"
postco1
 BL chk_for_single_spaces
 BEQ do_command_method
 STR R0,local_bas_command_num
 BL special_135_case_chk
 BNE do_command_method
 AND R14,R0,#7
 CMP R14,#1
 CMPNE R14,#6
 BNE eeeknotatallorthodox
 ; B eeeknotatallorthodox2
 BL getcursorpointer		; mash R10... :(
 BL store_colandline
 LDR R0,[R10,#c_off]
 CMP R0,R1
 BNE eeeknotatallorthodox ; ???
 PUSH "R10"
 BL getlinelength ; new tok line l.
 STR R0,local_linelengthoone
 ; BL prepare_line ; R4 = orig tokenised line length
 MOV R5,R2
 MOV R7,R3
 ADD R0,R2,#1024 ; lots, at least...
 FNcall Zap_Claim ; stick data into a heap block...
 MOV R1,R7
 MOV R7,R0			; r7 now has has data in hp blk
 MOV R2,R0
 MOV R3,R5
 BL copy_and_detokenise ;FNcall Zap_MoveBytes
 MOV R5,R0 ; new length...
 LDR R4,[R8,#w_flags]
 PUSH "R7"
 BIC R4,R4,#2
 BL basic_char_no_spaces ; like basic_char...
 PULL "R7"
 BVS veesetreturn
 MOV R0,R7
 FNcall Zap_Free ; done...! leak...?
 LDR R14,local_bas_command_num
 TST R14,#&40
 BLNE select_resulting_region
 PULL "R10"
 BL aligncaretifneeded
 ;LDR R0,[R10,#c_off]
 BL getlinelength ; new tok line l.
 LDR R2,local_linelengthoone
 SUB R2,R0,R2
 ;BL getcursorpointer
 ;FNcall Zap_ClearCaret ; ???
 ;SWI &107
 FNRTS

veesetreturn
 MOV R3,R0
 MOV R0,R7
 FNcall Zap_Free ; done...! leak...?
 MOV R0,R3
 PULL "R10"
 FNRTV

eeeknotatallorthodox
 FNcall Zap_StartOp
 FNcall Zap_DoCommand
 PUSH "R0-R10"
 BL getcursorpointer
 ;MOV R1,#5 ; car_cursor
 ;FNcall Zap_ReadVar
 ;MOV R10,R0
 BL prepare_line_speshally	; R1=det R2=detlen R3=col R4=len
 BVS error_ccomexit2$l
 MOV R7,R3			; save current column
 MOV R2,#0			; tokenise flags ; 4 ll 6 offs 7 ; col;
 BL update_line_speshally	; with input conditions...
 ;SWI &20107 ; gets called
 ; R2 may need adjusting as a result of this...
ccomexit$l
 PULL "R0-R10"
 FNcall Zap_StopOp
 ;BL getcursorpointer
 ;FNcall Zap_ClearCaret ; ???
 ;SWI &107
 FNRTS
error_ccomexit2$l
 ADD R13,R13,#4
 PULL "R1-R10"
 FNRTS

do_command_method
 ;PUSH "R0"
 ;BL getcursorpointer
 ;BL getlinelength
 ;STR R0,local_linelengthoone
 ;PULL "R0"
 ;FNcall Zap_StartOp
 FNcall Zap_DoCommand
 ;PUSH "R0-R1,R3-R10"
 ;MOV R1,#5 ; car_cursor
 ;FNcall Zap_ReadVar
 ;MOV R10,R0
 ;BL prepare_line		; R1=det R2=detlen R3=col R4=len
 ;BVS ccomexit2$l
 ;MOV R7,R3			; save current column
 ;MOV R2,#0			; tokenise flags ; 4 ll 6 offs 7 ; col;
 ;BL update_line			; with input conditions...
 ;LDR R0,[R10,#c_off]
 ;BL getlinelength ; new tok line l.
 ;LDR R2,local_linelengthoone
 ;SUB R2,R0,R2 ; R2 may need adjusting as a result of this...
;ccomexit2$l
; PULL "R0-R1,R3-R10"
; FNcall Zap_StopOp
 ;SWI &107
 ;BL getcursorpointer
 ;FNcall Zap_ClearCaret ; ???
 ;SWI &107
 FNRTS

co2
 PULL "R2"
 ADD R14,R3,R2
 LDRB R14,[R14,#-1]		; last character
 TEQ R14,#&0D
 BNE co3			; is a return so enter line
 BL co4
 FNRTS

;E R2=len R3= data...
co4
 STMFD R13!,{R1-R3,R6-R7,R10,R14}
 MOV R10,R0			; save command number
 MOV R0,R1
 BL basic_lineprev
 MOV R1,R0			; start of logical line
; STR R1,arecentpaste
; STR R8,arecentpaste + 4
; STR R9,arecentpaste + 8
 CMP R2,#&F0
 BCS co10			; too large

 BL count_lines
 MOV R7,R0			; number of lines user wants to insert
 BL count_back
 MOV R6,R0			; previous line
 BL count_forward
 SUB R0,R0,R6			; number of free lines (+1)
 CMP R7,R0
 BGE co10			; not enough room so insert and renumber
 ADD R6,R6,#1			; first line to use
 BL alter_text			; replace the line numbers
 LDMVSFD R13!,{R1-R3,R6-R7,R10,PC}
 MOV R3,R0			; new data address
 MOV R0,R10			; get command number
 FNcall Zap_DoCommand		; insert it
 LDMFD R13!,{R1-R3,R6-R7,R10,PC}
co10
 MOV R6,#1<<16			; an unused sequence of numbers
 BL alter_text			; replace the line numbers
 LDMVSFD R13!,{R1-R3,R6-R7,R10,PC}
 MOV R3,R0			; new data with numbers replaced
 MOV R0,R10			; command number
 FNcall Zap_DoCommand		; insert as normal
 BLVC basic_renumber		; make sure renumber save regs
 LDMFD R13!,{R1-R3,R6-R7,R10,PC}

copytmp$l
 DCD &0

co3
 STMFD R13!,{R1-R3,R6-R7,R10}
; FNcall Zap_StartOp
 PUSH "R0-R3"
 ADD R0,R2,#5
 FNcall Zap_Claim
 STR R0,copytmp$l
 MOV R1,R3
 MOV R3,R2
 ADD R2,R0,#3
 FNcall Zap_MoveBytes
 PULL "R0-R3"
 ADD R2,R2,#4
 LDR R3,copytmp$l
 ; new code...
 LDRB R14,bins_singlereturn
 ADD R10,R2,R3
 STRB R14,[R10,#-1]
 ; back to old stuff...
 BL co4				; dodgy original insertion
 ;FNcall Zap_FindInput
 ;MOV R1,R0
 ;ADR R3,bins_singlereturn
 ;MOV R2,#1
 ;MOV R0,#1
 ;FNcall Zap_DoCommand		; insert it
; FNcall Zap_StopOp
 LDR R0,copytmp$l
 FNcall Zap_Free

 LDMFD R13!,{R1-R3,R6-R7,R10}
 ADD R2,R2,#4			; !!!! zap expects
 FNRTS				; R2 = size of inserted region...

;insertstars
; FNJSR "R0,R2,R3"
; PUSH "R1"
; ADR R3,bins_fourstars
; MOV R2,#3
; MOV R0,#1
; FNcall Zap_DoCommand		; insert them...
; MOV R10,#1
; PULL "R1"
; ADD R1,R1,#3
; FNRTS

;X R10
getcursorpointer
 FNJSR "R0,R1"
 MOV R1,#5 ; car_cursor
 FNcall Zap_ReadVar
 MOV R10,R0
 FNRTS

aligncaretifneeded
 FNJSR
 LDR R0,[R10,#c_off]
 BL cln_readc
 CMP R0,#32
 FNRTS CS
 FNcall Zap_ReflectCaret ; Zap_PlotCaret ; ???
 FNRTS

getlinelength
 FNJSR "R1-R7"
 BL prepare_line_speshally ; prepare_line_ ; R4 = orig tokenised line length
 MOV R0,R4
 FNRTS

store_colandline
 FNJSR
 LDR R14,[R10,#c_col]
 STR R14,local_bas_command_col
 LDR R14,[R10,#c_line]
 STR R14,local_bas_command_line
 FNRTS

 ; kludge which doesn't get undone properly...
 ; ...or even redrawn properly...
select_resulting_region
 FNJSR "R0-R7"
 FNcall Zap_ClearSel
 LDR R2,local_bas_command_col
 LDR R3,local_bas_command_line
 FNcall Zap_FindOffset
 MOV R7,R0
 LDR R2,[R10,#c_col]
 LDR R3,[R10,#c_line]
 FNcall Zap_FindOffset
 MOV R3,R0
 MOV R2,R7
 ;MOV R0,#7
 ;FNcall Zap_ReadVar
 ;MOV R10,R0
 ;FNcall Zap_GetWindOff
 ;STR R0,[R10,#c_wind]
 ;STR R0,[R10,#c_owind]
 ;BL offset_line_column
 ;LDMVSFD R13!,{R1-R7,R10,PC}
 ;STR R3,[R10,#c_line]
 ;STR R2,[R10,#c_col]
 ;STR R4,[R10,#c_off]
 ;STR R0,[R10,#c_loff]
 ;STR R1,[R10,#c_width]
 ;MOV R0,R5
 ;BL offset_line_column
 ;LDMVSFD R13!,{R1-R7,R10,PC}
 ;STR R3,[R10,#c_oline]
 ;STR R2,[R10,#c_ocol]
 ;STR R5,[R10,#c_owidth]		; enter new selection vals
 ;STR R2,
 FNcall Zap_AlterSel
 FNRTS

special_135_case_chk
 FNJSR "R0"
 ;AND R0,R0,#7
 ;CMP R0,#2
 ;BNE not_special_135_case
 BL basic_getzapversion
 CMP R0,#136
 BCS not_special_135_case
 MVNS R0,#0
 FNRTS
not_special_135_case
 MOVS R0,#0
 FNRTS

bins_singlereturn
 & &0D0D0D0D
bins_fourstars
 & &2A2A2A2A

startofbuf_candd
 DCD 0

;E R1 = src R2 = dest R3 = length of original
;X Copy R1 to R2, detokenising as we go... Return length in R0.

copy_and_detokenise
 FNJSR "R1-R7,R10"
 BL getinitialflags
 MOV R10,R2
 MOV R2,R0 ; flags...? bit 1 in a ".."
 STR R10,startofbuf_candd
 MOV R6,R1
 MOV R5,R3
preloopone$l
 MOV R3,#0
loopone$l
 SUBS R5,R5,#1
 BMI theexuifound
 LDRB R0,[R6],#1
 ORR R0,R0,R3
 ;PUSH "R5,R10" ; probably not needed...
 BL fully_detokenise_byte
 ;PULL "R5,R10" ; probably not needed...
 MOVCS R3,R0
 BCS loopone$l			; need more
looptwo$l
 LDRB R14,[R1],#1
 STRB R14,[R10],#1
 SUBS R0,R0,#1
 BNE looptwo$l
 ;CMP R5,#0
 ;BPL preloopone$l
 B preloopone$l
theexuifound
 LDR R0,startofbuf_candd
 SUB R0,R10,R0
 ;SUB R0,R0,#1			; rtn len -1
 FNRTS

; LDRB R0,[R6],#1
;anotherbitofthebytetodet
; BL fully_detokenise_byte
; BLCS copy_and_dgetnextbyte
; BCS anotherbitofthebytetodet
;looptwo$l
; LDRB R14,[R1],#1
; STRB R14,[R10],#1
; SUBS R0,R0,#1
; BNE looptwo$l
; SUBS R5,R5,#1
; BPL loopone$l
; LDR R0,startofbuf_candd
; SUB R0,R10,R0
; SUB R0,R0,#1
; FNRTS

;copy_and_dgetnextbyte
; LDRB R3,[R6],#1
; BIC R3,R3,#&80
; BIC R0,R0,#&7F
; ORR R0,R0,R3
; CMP R0,R0
; MOV PC,R14

getinitialflags ; tokenises depending on where they're going to...hmm.
 FNJSR "R1-R7"
 LDR R7,[R10,#c_off]
 MOV R0,R7
 BL basic_linestart
 MOV R2,#0 ; flags...? bit 1 in a ".."
 MOV R6,R0
preloopfour$l
 MOV R3,#0
loopfour$l
 MOV R0,R6
 ADD R6,R6,#1
 BL cln_readc
 ORR R0,R0,R3
 BL fully_detokenise_byte
 MOVCS R3,R0
 BCS loopfour$l
 CMP R6,R7
 BLT preloopfour$l
 MOV R0,R2 ; return flags...
 FNRTS

; CMP R5,#0
; BPL preloopone$l
;loopfour$l
; MOV R0,R6
; BL cln_readc
;anotherbitofthebytetodetX2
; BL fully_detokenise_byte
; BLCS copy_and_dgetnextbyte
; BCS anotherbitofthebytetodetX2
; ADD R6,R6,#1
; CMP R6,R7
; BLE loopfour$l
; MOV R0,R2 ; return flags...
; FNRTS

;E R3=data (a block of lines) R2=len>=4
;X R0=num of new lines in this data (ie num of returns) |

count_lines
 STMFD R13!,{R2-R3,R14}
 MOV R0,#0
co20
 LDRB R14,[R3],#1
 TEQ R14,#&0D
 ADDEQ R0,R0,#1
 SUBS R2,R2,#1
 BGT co20
 LDMFD R13!,{R2-R3,PC}

;E R1=file offset of current log line start R9=file
;X R0=highest line number of line before R1 offset |

count_back
 STMFD R13!,{R1-R2,R14}
 LDR R0,[R9,#f_len]
 CMP R0,#4
 MOVLT R0,#9
 LDMLTFD R13!,{R1-R2,PC}	; special case of file empty
 SUBS R2,R1,#1			; first offset a previous line cound start
 MOVLE R0,#0			; line before
 LDMLEFD R13!,{R1-R2,PC}
co21
 SUBS R2,R2,#1
 BLE co22
 MOV R0,R2
 BL cln_readc
 TEQ R0,#&0D
 BNE co21
 ADD R2,R2,#1
co22
 MOV R0,R2
 BL read_uln
 MOVVS R0,#9			; default for null file want to start at 10
 ADDS R0,R0,#0			; clv
 LDMFD R13!,{R1-R2,PC}

;E R1=file offset of line start R9=file
;X R0=lowest line number of line following R1 offset |

count_forward
 FNJSR
 MOV R0,R1
 BL read_uln			; read line number
 MOVVS R0,#&FF00		; top line number if at end
 ADDS R0,R0,#0			; clv
 FNRTS

;E R2=num bytes R3=block of lines R6=first num to use
;X R0=Data copied to buf_detoken+file_blk and then renumbered
;  starting at R6 and in steps of 1. #

alter_text
 STMFD R13!,{R1-R4,R9,R14}
 FNLDR R0,buf_detoken		; dest
 ADD R1,R2,#f_end_mark		; total length required
 FNcall Zap_Ensure
 LDMVSFD R13!,{R1-R4,R9,PC}
 FNSTR R0,buf_detoken
 MOV R9,R0
 STR R2,[R9,#f_len]
 STR R2,[R9,#f_bufl]
 STR R2,[R9,#f_splito]
 STR R2,[R9,#f_splite]
 MOV R14,#0
 STR R14,[R9,#f_splits]		; simulate a file block
 MOV R1,R3			; source
 MOV R3,R2			; length
 ADD R2,R9,#f_end_mark		; destination
 STR R2,[R9,#f_ptr]		; complete file block
 FNcall Zap_MoveBytes		; copy the data
 MOV R3,R6			; first line number
 MOV R4,#1			; renumber increment
 MOV R1,#1			; don't update display
 BL renumber_file		; do a proper renumber on this
 LDRVC R0,[R9,#f_ptr]		; address of data
 LDMFD R13!,{R1-R4,R9,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BASIC conversion subs					       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=line number
;X R0=line number in 3 byte form b0-b23 /VS if out of range #
;  or _noerr form does line numbers out of range as well

conv_ln_3byte
 CMP R0,#&FF00			; check in range
 BCS err30
conv_ln_3byte_noerr
 STMFD R13!,{R1,R14}
 AND R14,R0,#&3F00
 ORR R1,R14,#&4000		; do b8-b13
 AND R14,R0,#&003F
 ORR R14,R14,#&040		; do b0-b5
 ORR R1,R1,R14
 MOV R14,R0,LSR#12
 AND R14,R14,#&0C		; get b14-b15
 ORR R14,R14,R0,LSR#16		; add b16-b17
 AND R0,R0,#&C0
 ORR R14,R14,R0,LSR#2		; add b6-b7
 EOR R14,R14,#&54		; toggle the bits
 ORR R0,R14,R1,LSL#8		; answer
 LDMFD R13!,{R1,PC}

;E R0=line number in 3 byte form (in bottom 3 bytes)
;X R0=line number |

conv_3byte_ln
 STMFD R13!,{R1,R14}
 BIC R0,R0,#&FF000000		; clear top byte
 MOV R1,R0,LSR#8
 BIC R1,R1,#&C000
 BIC R1,R1,#&00C0		; get b0-b5,b8-b13 in correct place
 EOR R0,R0,#&54
 AND R14,R0,#&30
 ORR R1,R1,R14,LSL#2		; add in b6-b7
 AND R14,R0,#&0C
 ORR R1,R1,R14,LSL#12		; add in b14-b15
 AND R14,R0,#&03
 ORR R0,R1,R14,LSL#16		; add in b16-b17
 LDMFD R13!,{R1,PC}

;E R0=file line offset R9
;X R0=(unadjusted) line number of this line / VS if off end #

read_uln
 STMFD R13!,{R1-R3,R14}
 MOV R2,R0			; save offset
 LDR R1,[R9,#f_len]
 SUB R1,R1,R2			; number of bytes left
 CMP R1,#3
 BLLT err33
 LDMVSFD R13!,{R1-R3,PC}
 MOV R0,R2
 BL cln_readc
 MOV R3,R0
 ADD R0,R2,#1
 BL cln_readc
 ORR R3,R3,R0,LSL#8
 ADD R0,R2,#2
 BL cln_readc
 ORR R0,R3,R0,LSL#16
 BL conv_3byte_ln
 LDMFD R13!,{R1-R3,PC}

;E R0=file line offset R8/R9
;X R0=(adjusted) line number of this line / VS if off end #

read_ln
 STMFD R13!,{R1-R3,R14}
 MOV R2,R0			; save offset
 LDR R1,[R9,#f_len]
 SUB R1,R1,R2			; number of bytes left
 CMP R1,#3
 BLLT err33
 LDMVSFD R13!,{R1-R3,PC}
 MOV R0,R2
 BL cln_readc
 MOV R3,R0
 ADD R0,R2,#1
 BL cln_readc
 ORR R3,R3,R0,LSL#8
 ADD R0,R2,#2
 BL cln_readc
 ORR R0,R3,R0,LSL#16
 BL conv_3byte_ln
 LDR R1,[R8,#w_stline]
 SUB R0,R0,R1			; adjust for stline
 LDMFD R13!,{R1-R3,PC}

;E R9=file phy line offset R2=file (V is cleared on entry) R8=window
;X R0=(adjusted) logical line number of the line / 0 if off end |

read_ln2
 STMFD R13!,{R9,R14}
 ADDS R0,R9,#0			; copy offset and clv
 MOV R9,R2			; file block
 BL basic_lineprev		; R0=offset of logical line start
 BLVC read_ln
 SUBVSS R0,R0,R0		; R0=0 and clv
 LDMFD R13!,{R9,PC}

;E R1=line num R4=source R5=dest and 0A stuck on end as a stop.
;X line tokenised, R4 & R5 updated #
;  R0=-1/source line address if line too long.

direct_tokenise_line
 STMFD R13!,{R1-R3,R6-R10,R14}
 MOV R2,#&100			; flags + expand .'s
 ADRL R6,mem_basdata
 MOV R7,#0			; column offset
 MOV R8,R5			; save line start
 MOV R9,R4			; save source start
 STRB R1,[R5,#1]		; line num low
 MOV R1,R1,LSR#8
 STRB R1,[R5],#3		; line num high
to16
 LDRB R0,[R4],#1
 TEQ R0,#&0A
 BEQ to17
 ;TST R2,#3			; hopefully not needed...
 ;TEQEQ R0,#&09			; pseudo-tab
 BL tokenise_char		; corrupts R0-R3,R10
 BVC to16
 LDMFD R13!,{R1-R3,R6-R10,PC}
to17
 MOV R0,#&0D
 STRB R0,[R5],#1		; finish line
 SUB R0,R5,R8			; line length
 STRB R0,[R8,#2]		; save at line off #2
 CMP R0,#&100			; length in range? long line/256 chr limit
 MVNCC R0,#0
 MOVCS R0,R9			; start of bad line
 LDMFD R13!,{R1-R3,R6-R10,PC}

bas_asm_det_mov_prob
 PUSH "R0,R5,R7,R10"
 BL getnextasmletter
 BIC R0,R0,#&20
 CMP R0,#'Q'
 BNE forgetasm_notthere
 BL getnextasmletter
 BIC R0,R0,#&20
 CMP R0,#'S'
 BLEQ getnextasmletter
 BIC R0,R0,#&20
 CMP R0,#'R'
; CMPNE R0,#'r'
 BLEQ getnextasmletter
 CMP R0,#' '
 BLE foundthatuglyasmmov
 CMP R0,#'0'
 BLT forgetasm_notthere
 CMP R0,#':'
 BCS forgetasm_notthere
foundthatuglyasmmov
 ORR R2,R2,#&1200000		; asm instr...!
 BIC R2,R2,#&D0000		; not in hex no, number after is ok & !E
; BIC R2,R2,#&50000		; in hex or nor norm num next
 ORR R2,R2,#&20			; not at SOL
 PULL "R0,R5,R7,R10"
 B orthodox_detokenise_byte
forgetasm_notthere
 PULL "R0,R5,R7,R10"
 B notanasmspecial

bas_asm_det_orr_prob
 PUSH "R0,R5,R7,R10"
 BL getnextasmletter
 BIC R0,R0,#&20
 CMP R0,#'R'
 BNE forgetasm_notthere
 B foundthatuglyasmmov

to_back_nfanumbtt3
 CMP R1,#-1
 BNE back_nfanumbtt3
 BIC R2,R2,#&710000		; clear in asm label...?
 BIC R2,R2,#&F400		; clear recent flags...
 BIC R2,R2,#&28			; SOL & 'GOTO' flag
 B back_nfanumbtt3

bas_red_contnotsolocal		; eek should set up r5,r7,r10
 BL to_colour_detokenise_byte	; colour - should not be for speed...
 FNRTS CS
 MOV R1,R0			; string address
 BL str_len			; string length
 ADDS R0,R0,#0			; clc
 FNRTS

to_colour_detokenise_byte	; sets up r5,r7,r10  - hopefully OK.
 FNJSR "R5,R7,R10"		; not R0...!
 BL setupr5r7r10
 BL colour_detokenise_byte
 FNRTS

setupr5r7r10
 FNJSR "R0"
 ADD R7,R11,#1			; R11 = offset...!?!?!
 LDR R14,[R9,#f_ptr]		; file start pointer
 LDR R0,[R9,#f_splito]		; split start
 CMP R7,R0
 ADD R7,R7,R14
 ADDCC R10,R14,R0		; apparent buffer end.
 LDRCS R0,[R9,#f_bufl]		; buffer end
 SUBCS R0,R0,#1
 ADDCS R10,R14,R0		; apparent buffer end.
 LDRCS R14,[R9,#f_splits]	; split size
 ADDCS R7,R7,R14
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		Save the selection			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R2=data len R3=data address R4=filetype
;X data converted to a BASIC Prog for saving R2,R3,R4 updated #

save_selection
 STMFD R13!,{R1,R5-R7,R14}
 CMP R2,#4			; valid line?
 BCC sa10
 ADD R0,R3,R2
 LDRB R0,[R0,#-1]
 TEQ R0,#&0D			; block of lines ?
 BNE sa10
 MOV R0,R3
 ADD R1,R2,#2
 FNcall Zap_Ensure
 LDMVSFD R13!,{R1,R5-R7,PC}
 MOV R7,R0			; ensure enough space for 0D &FF
 ADD R6,R7,R2			; end
 BL replace_line_numbers
 LDMVSFD R13!,{R1,R5-R7,PC}
 MOV R1,R7
 ADD R2,R1,#1
 SUB R3,R6,R7
 FNcall Zap_MoveBytes		; shift up 1
 MOV R3,R7			; start
 SUB R2,R6,R7			; old len
 MOV R0,#&0D
 STRB R0,[R7],#1		; 0D at start
 MOV R0,#&FF
 STRB R0,[R7,R2]		; FF at end
 ADD R2,R2,#2			; new len
 LDMFD R13!,{R1,R5-R7,PC}
sa10
 MOV R4,#&FF0
 ADD R4,R4,#&F			; set filetype to data...?
 LDMFD R13!,{R1,R5-R7,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Replace (as in search and replace)			     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ;E R1=file offset R2=number of bytes R3=new data R4=data len R8/R9
;
; basic_replace
;  FNJSR "R1-R10"
;  MOV R0,R1
;  BL basic_linestart
;  FNRTS VS
;  MOV R6,R0			; R6=actual line start
;  LDR R0,[R9,#f_len]
;  CMP R6,R0
;  FNRTS CS			; gone off file end
;  MOV R5,R4			; R5=new data len
;  MOV R7,R3			; R7=new data
;  PUSH "R0-R7"
;  ADD R1,R1,R2			; end of data to replace
;  BL prepare_line_off_speshally
;  MOV R10,R3
;  PULL "R0-R7"
;  ;ADD R10,R1,R3			; end of data to replace
;  ;MOV R10,R3
;  FNRTS VS			; R2=delen R3=col R4=ilen
;  BL prepare_line_off_speshally
;  FNRTS VS			; R2=delen R3=col R4=ilen
;  MOV R0,R6
;  MOV R1,R10
;  ;BL conv_lineoff		; R0=end col
;  ;FNRTS VS
;  MOV R14,R10
;  MOV R10,R4			; save initial length
;  SUBS R4,R14,R3
;  ;SUBS R4,R0,R3
;  MOVMI R4,#0			; actual col amount to replace
;  FNLDR R1,buf_detoken
;  BL change_line_replace
;  MOV R4,R10			; restore initial length
;  MVN R7,#0			; no cursor
;  BL update_line_off_speshally
;  FNRTS

;E R1=file offset R2=number of bytes R3=new data R4=data len R8/R9

basic_replace
 FNJSR "R1-R10"
 MOV R0,R1
 BL basic_linestart
 FNRTS VS
 MOV R6,R0			; R6=actual line start
 LDR R0,[R9,#f_len]
 CMP R6,R0
 FNRTS CS			; gone off file end
 MOV R5,R4			; R5=new data len
 MOV R7,R3			; R7=new data
 ADD R10,R1,R2			; end of data to replace
 BL prepare_line_off
 FNRTS VS			; R2=delen R3=col R4=ilen
 MOV R0,R6
 MOV R1,R10
 BL conv_lineoff		; R0=end col
 FNRTS VS
 MOV R10,R4			; save initial length
 SUBS R4,R0,R3
 MOVMI R4,#0			; actual col amount to replace
 FNLDR R1,buf_detoken
 BL change_line_replace
 MOV R4,R10			; restore initial length
 MVN R7,#0			; no cursor
 BL update_line_off
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Detokenise a line					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

constantbicmask3
 DCD &3FFFFFFC

 LOCAL

;E R0=file offset of logical line start+3
;  R1=a file offset in the line R8/R9
;X R0=file offset of 0D terminator
;  R1=buffer start (buf_detoken)
;  R2=length of detokenised line (exc 0D)
;  R3=column offset in the line of position given by R1 #
; internal
;  R2=detok flags	R3=column offset of file offset
;  R4=end of file	R5=output buffer pointer
;  R6=buffer start	R7=buffer end
;  R8=file off to trap	R9=file
;  R10=current file offset (R11=basic's workspace)

detokenise_line
 FNJSR "R4-R10"
 MOV R2,#0
 STR R2,addontor3cnt
into_detokenise_line
 MOV R10,R0			; save file offset
 MOV R8,R1			; offset to trap
 FNLDR R6,buf_detoken		; current buffer start
 MOV R5,R6			; current pointer
 ADD R7,R6,#&100		; current buffer end (claimed &100)
 LDR R4,[R9,#f_len]		; end of file
 MOV R3,#0			; trapped column
loop$l
 SUB R0,R7,R5			; amount free in buffer
 CMP R0,#&18			; 24 bytes free?
 BLT enlarge$l			; no
gettoken$l
 CMP R10,R4
 BCS fileend$l			; off end of file
 MOV R0,R10
 ;LDR R1,[R9,#f_len]		; bug1
 ;CMP R0,R1			; bug1
 BL cln_readc			; get next byte
 TEQ R0,#&0D
 BEQ end$l			; end of line
 ADD R10,R10,#1
 ;MOV R1,#&800
 ;ORR R1,R1,#3			; in the middle of something
 TST R2,#&80000003
 BNE inrem$l			; don't expand as in a quote/rem/*
 CMP R0,#&7F
 BCS expand$l			; expand token
inrem$l
 MOV R14,#0
 STR R14,lastthingthatwasdone
 ANDS R1,R2,#3			; make sure we're outside quotes
 BLEQ ba_incomment_general

 TEQ R0,#'*'			; '*'?
 TSTEQ R2,#&8000		; and at statement start?
 ORREQ R2,R2,#&80000002		; we're in a *command

 TST R2,#&02			; make sure we're outside quotes
 TEQEQ R0,#':'			; and there's a : of course
 LDREQ R1,constantbicmask3
 BICEQ R2,R2,R1
 ;BICEQ R2,R2,#&FC00		; clear recent flags...
 ;BICEQ R2,R2,#&28		; clear 'GOTO' flag
 ;TEQNE R0,#' '			; if not ':'/' ' then
 ORRNE R2,R2,#&8000		; could not be a * CLI next...
 TST R2,#&2000			; in proc/fn
 BLNE possiblyendprocfn2
 CMP R0,#';'			; semicolon ;(TT)
 CMPNE R0,#'\'			; \-style-semicolon :-\ (TT)
 BLEQ red_bas_semi2		; entering/leaving a quote

 TEQ R0,#'"'
 TSTEQ R2,#&800			; quote and not in asm comment
 TSTEQ R2,#&80000000		; and not in * command
 EOREQ R2,R2,#2

back_nfanumbtt2
 STRB R0,[R5],#1
done$l				; token has been expanded
 CMP R10,R8			; passed trap offset?
 SUBLE R3,R5,R6			; next offset matches or is before trap one
 B loop$l

;done2$l				; token has been expanded
 ;CMP R10,R8			; passed trap offset?
 ;SUBLE R3,R5,R6			; next offset matches or is before trap one
 ;LDRLE R14,addontor3cnt
 ;ADDLE R14,R14,#1
 ;STRLE R14,addontor3cnt
 ;SWILE &107
 ;B loop$l

end$l
 STRB R0,[R5],#1 ; PROBLEM LINE ??????????????
 STRB R0,[R5]
 MOV R0,R10			; end of line (->&0D)
 FNLDR R1,buf_detoken		; buf start (returned)
 SUB R2,R5,R1			; string length

 FNRTS

fileend$l
 MOV R0,#&0D
 STRB R0,[R5],#1		; PROBLEM LINE ??????????????
 STRB R0,[R5]
 MOV R0,R4			; exit nicely
 FNLDR R1,buf_detoken		; (returned)
 SUB R2,R5,R1

 FNRTS

enlarge$l
 MOV R0,R6			; buffer address (to ensure)
 SUB R1,R7,R6			; old length
 SUB R5,R5,R6			; current offset
 ADD R1,R1,#&80			; new length
 FNcall Zap_Ensure		; enlarge buffer
 FNRTS VS
 FNSTR R0,buf_detoken		; new pointer
 MOV R6,R0
 ADD R7,R1,R6
 ADD R5,R5,R6			; new pointers
 B loop$l

expand$l
 STR R0,local_token_tmp_storage
 LDR R14,addontor3cnt
 CMP R14,#0
 BMI tabspecialcases$l
expandloop$l
 BL detokenise_byte
 BCC token$l			; detokenise complete
 CMP R10,R4
 BCS fileend$l
 PUSH "R0"
 MOV R0,R10
 ;LDR R1,[R9,#f_len]		; bug1
 ;CMP R0,R1			; bug1
 ;BLCC cln_readc		; bug1
 BL cln_readc
 ADD R10,R10,#1
 PULL "R1"
 ORR R0,R0,R1
 B expandloop$l

token$l				; R0=tokenised string
 LDRB R14,[R0],#1
 TEQ R14,#0
 STRNEB R14,[R5],#1		; output
 BNE token$l
 LDR R14,addontor3cnt
 CMP R14,#0
 BMI tabmorespecialcases$l
 B done$l			; finished so do next byte

addontor3cnt ; number inserted before mark reached
 DCD 0

lastthingthatwasdone
 DCD 0

tabspecialcases$l
 ;CMP R10,R8			; at the trap offset?
 ;SUBNE R14,R8,#1
 ;CMPNE R10,R14			; at the trap offset?
 ADD R14,R8,#1
 CMP R10,R14			; at the trap offset?

 ;SUBNE R14,R8,#2		; sub is backwards...
 ;CMPNE R10,R14			; at the trap offset?
 ADDNE R14,R8,#2		; needed :(
 CMPNE R10,R14			; at the trap offset?

 BEQ expandloop$l
 LDR R14,lastthingthatwasdone	; why...?
 CMP R14,#0
 MOV R14,#0
 STR R14,lastthingthatwasdone	; clear this flag at this point...
 BNE expandloop$l
 MOV R14,#fake_tab_character
 STRB R14,[R5],#1		; output a pseudo-'tab' character...
 ADD R14,R8,#1
 CMP R10,R14			; passed trap offset?
 LDR R14,addontor3cnt
 ADD R14,R14,#&10000
 ;BGT expandloop$l
 ;LDR R14,addontor3cnt
 ADDLE R14,R14,#1
 STR R14,addontor3cnt
 B expandloop$l

tabmorespecialcases$l
 CMP R10,R8			; at the trap offset?
 SUBNE R14,R8,#1
 CMPNE R10,R14		; at the trap offset?

 ADDNE R14,R8,#1
 CMPNE R10,R14			; at the trap offset?

 ;SUBNE R14,R8,#2
 ;CMPNE R10,R14			; at the trap offset?
 ;ADDNE R14,R8,#2
 ;CMPNE R10,R14			; at the trap offset?

 BEQ done$l
 LDR R14,local_token_tmp_storage
 CMP R14,#&F2 ; PROC
 CMPNE R14,#&A4 ; FN
 CMPNE R14,#&84 ; OR for the ORIGIN case...
 ;CMPNE R14,#&E4 ; GOSUB
 ;CMPNE R14,#&E5 ; GOTO
 ;CMPNE R14,#&8C ; THEN
 ;CMPNE R14,#&8B ; ELSE
 ;CMPNE R14,#&CC ; ELSE (SOL)
 BEQ done$l
 MOV R14,#fake_tab_character
 STRB R14,[R5],#1		; output a pseudo-'tab' character...
 LDR R14,addontor3cnt
 ADD R14,R14,#&10000
 STR R10,lastthingthatwasdone
 CMP R10,R8			; passed trap offset?
 ;BGT done$l
 ;LDR R14,addontor3cnt
 ADDLE R14,R14,#1
 STR R14,addontor3cnt
 B done$l

local_token_tmp_storage
 DCD 0

detokenise_line_speshally
 FNJSR "R4-R10"
 MOV R2,#&80000000
 STR R2,addontor3cnt
 MOV R2,#0
 B into_detokenise_line

 LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; REM *****************************************************
; REM *							  *
; REM *	     Tim Tyler's main additions begin here        *
; REM *							  *
; REM *****************************************************

; REM code to call the e_openwindow entry point.
; REM This routine should be pointed directly to from e_openwindow

gotoopenwindow
 STMFD	 R13 !,{R14}

 BL	 openwindowroutine

 CMP	 R0,#0			; REM If there was a pane then no problem
 LDMNEFD R13 !,{PC}		; REM just return...
 BL	 gomakepanehappen	; REM ...otherwise try to make one...
 BL	 openwindowroutine	; REM ...and redraw it...

 LDMFD	 R13 !,{PC}

openwindowroutine
 STMFD	 R13 !,{R0-R12,R14}
 STMFD	 R13 !,{R1-R11}
 ADRL	 R1,localcopyof_mode_basic
 LDR	 R1,[R1]
 FNcall  Zap_GetModeWord
 LDMFD	 R13 !,{R1-R11}

 TST	 R0,#1 << 17
;ww TSTEQ	 R0,#1 << 30
 BEQ	 bas_justcallthebasemode

 STR	 R0,bas_ModeWordFlags

 BL	 but_trytoloadmode	    ; REM load buttons if it is not there.

 ADR	 R0,buttonsamed2
 FNcall  Zap_TestModeName
 CMP	 R0,#1
 BMI	 bas_justcallthebasemode

 MOV	 R0,#18
 ADR	 R1,buttonsamed
 SWI	 XOS_Module
 BVS	 bas_justcallthebasemode

 ADD	 R3,R3,#&28
 STR	 R3,bas_LocalJump
 LDMFD	 R13 !,{R0-R12,R14}

 MOV	 R2,#0
 MOV	 R3,#0
 MOV	 R4,#0
;ww ADRL	 R3,basic_clnoff  ; REM pointer to custom
;ww ADRL	 R4,basic_clnphy
;ww LDR	 R2,bas_ModeWordFlags
;ww ANDS	 R2,R2,#1 << 30
;ww MOVNE	 R2,#&FF		; REM use window wrap flag...
;ww ORRNE	 R2,R2,#&FF00		; REM use custom e_clnoff
;ww ORRNE	 R2,R2,#&FF000000	; REM use custom e_clnphy
;ww ORRNE	 R2,R2,#&40000
 ; LDMFD R13,{R0-R12,R14}
 ;MOV	 R14,PC
 LDR	 PC,bas_LocalJump
 ;STR	 R0,bas_LocalJump
 ;LDMFD	 R13 !,{R0-R12,R14}
 ;LDR	 R0,bas_LocalJump
 ;MOV	 PC,R14

bas_justcallthebasemode
 LDMFD	  R13 !,{R0-R12,R14}
 MOV	  R0,#1
 MOV	  PC,R14

HaveAnotherTry
 BL	 but_trytoloadmode
 CMP	 R0,#0
 BPL	 backinthethickofit
 LDMFD	 R13 !,{R0-R12,PC}

buttonsamed
 =    "Zap"

buttonsamed2
 =    "Buttons",0,0

bas_LocalJump
 DCD	0

bas_ModeWordFlags
 DCD	0

 LOCAL

; REM Main routine; calls Buttons_Open.
; REM This routine is what is commonly used to open a button bar.
; REM it loads the relevent templates files if they are not
; REM already loaded, sets up a sprite area, and loads any
; REM scripts and menu files required.

gomakepanehappen
 STMFD	 R13 !,{R0-R12,R14}

 LDR	 R11,[R12]		; workspace pointer
 ;FNLDR R1,mode_basic
 ADRL	 R14,localcopyof_mode_basic
 LDR	 R14,[R14]
 LDRB	 R0,[R8,#w_format]
 CMP	 R0,R14
 LDMNEFD R13 !,{R0-R12,PC}

 STMFD	 R13 !,{R1-R11}
 MOV	 R1,R14
 FNcall  Zap_GetModeWord
 LDMFD	 R13 !,{R1-R11}

 STR	 R0,bas_LocalJump	     ; REM temporarily...

 ANDS	 R0,R0,#1 << 17 ; TT?
 LDMEQFD R13 !,{R0-R12,PC}

 ADR	 R0,buttonsamed2
 FNcall  Zap_TestModeName
 CMP	 R0,#0
 BMI	 HaveAnotherTry
backinthethickofit
 MOV	 R0,#18
 ADR	 R1,buttonsamed
 SWI	 XOS_Module
 LDMVSFD R13 !,{R0-R12,PC}
 ADD	 R10,R3,#&24

 LDR	 R0,bas_LocalJump
 MOV	 R4,#0
 ANDS	 R1,R0,#1 << 20		 ; REM flags for left
 ORRNE	 R4,R4,#2
 ANDS	 R1,R0,#1 << 19		 ; REM flags for top
 ORRNE	 R4,R4,#4
 ANDS	 R1,R0,#1 << 18		 ; REM flags for fleeting...
 ORRNE	 R4,R4,#8

 ; ORR	   R4,R4,#14

 LDR	 R0,AddressOfScriptFile
 CMP	 R0,#0
 BLEQ	 getthethreeelements

 MOV	 R7,#0			 ; REM for handler...
 MOV	 R6,#0			 ; REM for dX and dY...
 LDR	 R5,AddressOfMenu
 LDR	 R3,AddressOfScriptFile
 LDR	 R2,AddressOfTemplateFile
 LDR	 R1,AddressOfSpriteArea

 MOV	 R0,#0

 MOV	 R14,PC
 MOV	 PC,R10
 MOV	 R0,R0			  ; REM NOP

 LDMFD	 R13 !,{R0-R12,PC}

; REM load the stuff the button bar needs...

getthethreeelements
 STMFD	 R13 !,{R0-R4,R14}
 ADR	 R1,markcmdpath
 BL	 LoadANDReturnMiscAddress
 STR	 R0,AddressOfScriptFile

 BL	 but_changeLFto00

 ADR	 R1,marksprpath
 BL	 LoadANDReturnSpriteAddress

 ADR	 R1,marktempath
 BL	 LoadANDReturnMiscAddress
 STR	 R0,AddressOfTemplateFile

 BL	 loadmenuifrequired

 LDMFD	 R13 !,{R0-R4,PC}

; REM used to load the menu file...

loadmenuifrequired
 FNJSR
 LDR	 R0,AddressOfMenu
 CMP	 R0,#0
 FNRTS   NE

 ADR	 R1,markmenpath
 BL	 LoadANDReturnMiscAddress
 STR	 R0,AddressOfMenu

 FNRTS

LoadANDReturnMiscAddress
 FNJSR "R1-R5"

 MOV	 R0,#5
 SWI	 XOS_File
 FNRTS	 VS

 STR	 R4,tempS2
 BIC	 R0,R4,#3
 ADD	 R0,R0,#&10
 FNcall  Zap_Claim
 STRVC	 R0,tempS1

 MOVVC	 R3,#0
 MOVVC	 R2,R0
 MOVVC	 R0,#255
 SWIVC	 XOS_File
 FNRTS VS

 LDR	 R0,tempS1
 LDR	 R1,tempS2
 ADD	 R14,R0,R1
 MOV	 R2,#0
 STRB	 R2,[R14]
 BIC	 R14,R14,#3
 STR	 R2,[R14,#8]
 FNRTS

LoadANDReturnSpriteAddress
 STMFD	 R13 !,{R1-R5,R14}

 MOV	 R0,#5
 SWI	 OS_File

 BIC	 R0,R4,#3
 ADD	 R0,R0,#&10
 FNcall  Zap_Claim

 STRVC	 R0,AddressOfSpriteArea
 ADDVC	 R4,R4,#5
 STRVC	 R4,[R0]

 MOVVC	 R3,#0
 ADDVC	 R2,R0,#4
 MOVVC	 R0,#255
 SWIVC	 OS_File

 LDMFD	 R13 !,{R1-R5,PC}

tempS1
 DCD	0

tempS2
 DCD	0

AddressOfTemplateFile
 DCD	0

AddressOfSpriteArea
 DCD	0

AddressOfScriptFile
 DCD	0

AddressOfMenu
 DCD	0

; REM Make sure the zeros pad to word alignment...

markcmdpath
 =    "<ZapBASIC$Scripts>",0,0

marksprpath
 =    "<ZapBASIC$Sprites>",0,0

marktempath
 =    "<ZapBASIC$Templates>",0,0,0,0

markmenpath
 =    "<ZapBASIC$Menus>",0,0,0,0

 DCD	&8017
CmdBASICflagstoggle
 STMFD	 R13 !,{R14}
 LDR	 R10,[R0]		; REM gets word argument...

 ADRL	 R1,localcopyof_mode_basic
 LDR	 R1,[R1]

 STMFD	 R13 !,{R1-R11}
 ADRL	 R1,localcopyof_mode_basic
 LDR	 R1,[R1]
 FNcall  Zap_GetModeWord
 LDMFD	 R13 !,{R1-R11}
 MOV	 R7,R0

 CMP	 R2,#15
 BEQ	 but_tickquery		; REM bit 15 of R2 indicates a 'tickquery'

 MOV	 R5,#0

 AND	 R1,R10,#&FF
 BL	 bas_execute
 MOV	 R1,R10,LSR #8
 AND	 R1,R1,#&FF
 TST	 R1,#&80
 BLNE	 bas_execute
 MOV	 R1,R10,LSR #16
 AND	 R1,R1,#&FF
 TST	 R1,#&80
 BLNE	 bas_execute
 MOV	 R1,R10,LSR #24
 AND	 R1,R1,#&FF
 TST	 R1,#&80
 BLNE	 bas_execute

 MOV	 R0,R7
 ADRL	 R1,localcopyof_mode_basic
 LDR	 R1,[R1]
 FNcall  Zap_PutModeWord

 CMP	 R8,#0
 LDMEQFD R13 !,{PC}

 ANDS	 R0,R5,#2
 BLNE	 sortbbout		; REM if the button bar has changed

 ANDS	 R0,R5,#&10
 BLNE	 but_sortwwout3		; REM window redraw if needed...

 ANDS	 R0,R5,#8
 BLNE	 but_sortwwout2		; REM window redraw if needed...

 ANDS	 R0,R5,#4
 BLNE	 but_sortwwout		; REM window redraw if needed...

 ANDS	 R0,R5,#1
 BLNE	 sortbuttonsout		; REM the BB needs deleting/creating

 LDMFD	 R13 !,{PC}

sortbbout
 STMFD	 R13 !,{R5,R7,R14}
 MOV	 R0,#3

 MOV	 R7,R7,LSR #18
 MOV	 R7,R7,LSL #29
 MOV	 R7,R7,LSR #1

 BL	 but_callmiscentrypt	    ; REM sets/clears any bits (from R7)

 CMP	 R0,#0

 BLNE	 callopenthewindow

 LDMFD	 R13 !,{R5,R7,PC}

callopenthewindow
 STMFD	 R13 !,{R14}

 MOV	 R1,R8
 SWI	 Wimp_GetWindowState

 MOV	 R0,#1

 BL	 gotoopenwindow

 LDMFD	 R13 !,{PC}

sortbuttonsout
 STMFD	 R13 !,{R5,R14}

 ANDS	 R0,R7,#1 << 17 ; TT?
 BLEQ	 but_closeanypanes	    ; REM buttons have been toggled off

 ANDS	 R0,R7,#1 << 17 ; TT?
 LDMEQFD R13 !,{R5,PC}

 BL	 gomakepanehappen	; REM buttons have been toggled on

 BL	 gotoopenwindow		; REM Redraws the BBs - has to be done
 BL	 gotoopenwindow		; REM twice - due to the first such

 LDMFD	 R13 !,{R5,PC}

seltmp_bas1$l
 DCD 0
 DCD 0

basic_click
 FNJSR
 PUSH "R0-R11"
 FNcall Zap_GetSel
 STR R1,seltmp_bas1$l
 STR R2,seltmp_bas1$l + 4
 PULLS "R0-R11"
 FNLDR R9,mode_basic
 MOV R11,#e_click
 FNcall Zap_BaseMode
 PULLS "R0-R11"
 MOV R7,R8
 FNcall Zap_GetSel
 BCS endofclicprocessing
 CMP R7,R8
 BNE endofclicprocessing
 ADD R0,R1,R2
 SUBS R0,R0,#1
 BMI endofselareturn
 BL charfromoffset
 CMP R0,#13
 BEQ endofselareturn
 SUBS R0,R1,#1
 BMI nottheendofclicprocessing
 BL charfromoffset
 CMP R0,#13
 BNE endofclicprocessing
nottheendofclicprocessing
 ADD R3,R1,R2
 ADD R2,R1,#3
 FNSTR R2,sel_start		; save actual selected region start
 FNcall Zap_AlterSel
 B endofclicprocessing

endofselareturn
 MOV R4,R1
 SUBS R0,R4,#1
 BMI endofclicprocessing
 BL charfromoffset
 CMP R0,#13
 BEQ endofclicprocessing
 LDR R3,seltmp_bas1$l
 CMP R1,R3
 BNE endofselareturn2
loop$l
 SUBS R4,R4,#1
 BMI selsub_atstartoffile
 MOV R0,R4
 BL charfromoffset
 CMP R0,#13
 BNE loop$l
selsub_atstartoffile
 ADD R3,R1,R2
 ADD R2,R4,#1
 FNSTR R2,sel_start		; save actual selected region start
 FNcall Zap_AlterSel
 B endofclicprocessing
endofselareturn2
 ADD R3,R1,R2
 SUB R3,R3,#1
 MOV R2,R1
 FNSTR R2,sel_start		; save actual selected region start
 FNcall Zap_AlterSel
endofclicprocessing
 PULL "R0-R11"
 BL make_sure_no_line_numbers_selected
 BL bc_reposition_the_caret
 FNRTS

make_sure_no_line_numbers_selected
 FNJSR "R0-R4,R8,R9"
 MOV R3,R8
 FNcall Zap_GetSel		; R1 = start R2= len
 FNRTS CS
 CMP R3,R8
 FNRTS NE
 CMP R2,#12			; fudge...
 FNRTS CS
 ADD R3,R1,R2			; end...
 MOV R0,R1
 BL basic_linestart
 CMP R1,R0
 FNRTS GT
 MOV R2,R0
 FNSTR R2,sel_start		; save actual selected region start
 FNcall Zap_AlterSel
 FNRTS

bc_reposition_the_caret
 FNJSR "R0-R4,R10"
 ADRL R1,localmodeword
 LDR R1,[R1]
 TST R1,#1 << 26
 FNRTS EQ

 MOV R4,R2
 MOV R0,#&81 ; ctrl key (hardwired in :<)
 MOV R1,#&FE
 MOV R2,#&FF
 SWI XOS_Byte
 FNRTS CS
 MOV R1,#10
 FNcall Zap_ReadVar
 FNRTS VS
 CMP R0,#2
 FNRTS GT
 MOVEQ R1,#6
 MOVNE R1,#5
 FNcall Zap_ReadVar
 FNRTS VS
 MOV R10,R0
 LDR R0,[R10,#c_off]
 BL cln_readc
 CMP R0,#127
 FNRTS CC		; not in a token...
 LDR R14,[R8,#w_margin]
 CMP R4,R14
 MOVCC R4,R14
 STR R4,[R10,#c_col]
 STR R3,[R10,#c_line]	; what about cloff?
 FNcall Zap_PlotCaret
 FNRTS

; basic_sel_adjusting
;  CMP R1,#1
;  BNE basic_sel_normal
;  PUSH "R0-R10"
;  ;FNLDR R0,car_mode
;  CMP R0,#0
;  BLE tobasic_sel_normal
;  ;FNLDR R10,car_selection
;  BL test_cblk$l
;  BNE tobasic_sel_normal
;  BL order_selection$l
;  ;FNcall Zap_FindOffset
;  ; BVS tobasic_sel_normal
;
;  MOV R4,R0			; save offset of click
;  LDR R2,[R10,#c_off]		; selection start
;  LDR R3,[R10,#c_owidth]		; selection end
;  ADD R1,R2,R3
;  CMP R0,R1,ASR#1		; compare with the average
;  MOVLT R2,R3			; make old end the start
;  MOV R3,R0			; new end
;  ;BL select_region		; alter selected region
;
;  SWI &107
; tobasic_sel_normal
;  PULL "R0-R10"
;  B basic_sel_normal
;  FNRTS
;
; ;E R10=caret blk R8
; ;X EQ if this caret in this window |
;
; test_cblk$l
;  FNJSR
;  ;LDR R0,[R10,#c_wind]
;  ;FNLDR R14,wind_list
;  ;ADD R14,R14,R0,LSL #w_shift
;  ;TEQ R8,R14
;  FNRTS
;
; ;X car_selection ordered so start off<=end off |
;
; order_selection$l
;  STMFD R13!,{R0,R10,R14}
;  ;FNLDR R10,car_selection
;  ;LDR R0,[R10,#c_wind]
;  ;CMP R0,#0			; any selection?
;  ;LDMMIFD R13!,{R0,R10,PC}
;  ;LDR R0,[R10,#c_off]
;  ;LDR R14,[R10,#c_owidth]
;  ;CMP R0,R14			; correct way around?
;  ;LDMLEFD R13!,{R0,R10,PC}
;  ;STR R0,[R10,#c_owidth]
;  ;STR R14,[R10,#c_off]
;  ;LDR R0,[R10,#c_line]
;  ;LDR R14,[R10,#c_oline]
;  ;STR R0,[R10,#c_oline]
;  ;STR R14,[R10,#c_line]
;  ;LDR R0,[R10,#c_col]
;  ;LDR R14,[R10,#c_ocol]
;  ;STR R0,[R10,#c_ocol]
;  ;STR R14,[R10,#c_col]
;  LDMFD R13!,{R0,R10,PC}

;amenucreation
; STMFD	  R13 !,{R0,R14}
; BL	  loadmenuifrequired
;
; FNcall  Zap_ReadMenu
;
; LDR	  R1,[R0,#4]
;
; LDMFD	  R13 !,{R0,PC}^

insidequotemarks
 MOV R1,#10
 TST R2,#&800			; Assembler comment...
 MOVNE R1,#9			; rem
 STRB R1,[R6,R11]		; colour for quote
 MOV PC,R14

 LOCAL

 DCD 0
BASIC_REMARKSEL
 FNJSR
 MOV R6,R8
 FNcall Zap_GetSel
 FNRTS CS
 CMP R6,R8
 FNRTS NE
 MOV R6,R1
 SWI XHourglass_On
 FNcall Zap_StartOp
remselloop$l
 BL checkforescapekey
 BCS endREMARKSEL
 MOV R0,R6
 FNcall Zap_JumptoOffset
 BL BASIC_REMARK
 MOV R0,R6
 BL basic_linenext
 ADD R0,R0,#1
 BL basic_linestart
 MOV R6,R0
 FNcall Zap_GetSel
 ADD R0,R1,R2
 CMP R6,R0
 BCC remselloop$l
endREMARKSEL
 FNcall Zap_StopOp
 SWI XHourglass_Off
 FNRTS

 LOCAL

 DCD 0
BASIC_UNREMARKSEL
 FNJSR
 MOV R6,R8
 FNcall Zap_GetSel
 FNRTS CS
 CMP R6,R8
 FNRTS NE
 MOV R6,R1
 SWI XHourglass_On
 FNcall Zap_StartOp
unremselloop$l
 BL checkforescapekey
 BCS endUNREMARKSEL
 MOV R0,R6
 FNcall Zap_JumptoOffset
 BL BASIC_UNREMARK
 MOV R0,R6
 BL basic_linenext
 ADD R0,R0,#1
 BL basic_linestart
 MOV R6,R0
 FNcall Zap_GetSel
 ADD R0,R1,R2
 CMP R6,R0
 BCC unremselloop$l
endUNREMARKSEL
 FNcall Zap_StopOp
 SWI XHourglass_Off
 FNRTS

 LOCAL

 DCD 0
BASIC_UNREMARK
 FNJSR "R0-R12"
 LDR R0,[R10,#c_off]
 BL basic_lineend ; returns R0
 MOVVC R7,R0
 LDRVC R0,[R10,#c_off]
 BLVC basic_linestart ; returns R0
 BVS quitelyexit$l

 MOV R6,R0
loop2$l
 MOVS R0,R6
 BLPL cln_readc
 CMP R0,#&F4
 BEQ foundaremtoubnrem
 CMP R0,#33
 FNRTS CS
 ADD R6,R6,#1
 CMP R6,R7
 BLE loop2$l
 FNRTS
foundaremtoubnrem
 MOV R0,R6
 FNcall Zap_JumptoOffset
 MOV R5,#3
 MOV R7,#1
 ADRL R11,local_wkspace_ptr
 LDR R11,[R11]
 BL basic_delete ; eek R11 not set up...!
 FNRTS
quitelyexit$l
 SUBS R14,R14,R14
 FNRTS

 LOCAL

 DCD 0
BASIC_REMARK
 FNJSR "R0-R12"
 LDR R0,[R10,#c_off]
 BL basic_lineend		; returns R0
 MOVVC R7,R0
 LDRVC R0,[R10,#c_off]
 BLVC basic_linestart		; returns R0
 BVS quitelyexit$l
 MOV R6,R0
loop2$l
 MOVS R0,R6
 BLPL cln_readc
 CMP R0,#32
 BNE insert_it_comment
 ADD R6,R6,#1
 CMP R6,R7
 BLE loop2$l
 FNRTS
quitelyexit$l
 SUBS R14,R14,R14
 FNRTS

insert_it_comment
 MOV R0,R6
 FNcall Zap_JumptoOffset
 LDR R4,[R8,#w_flags]
 MOV R5,#3			; 3
 ADR R7,namedremark
 ADRL R11,local_wkspace_ptr
 LDR R11,[R11]
 BIC R4,R4,#2
 BL basic_char			; eek R11 not set up...!
 FNRTS

namedremark
 = "REM",0

 LOCAL

atickquerychk
 CMP R9,#0
 MOVEQ R0,#2
 MOV PC,R14

 DCD 7+(1<<15)
BASIC_checkbuffer
 CMP R2,#15
 BEQ atickquerychk
 CMP R9,#0
 MOVEQ PC,R14
 FNJSR
 SWI XHourglass_On
 MOV R14,#0
 STR R14,anysofar
 FNcall Zap_GetFileOff
 MOV R10,R0			; R10 is the file offset
 MOV R7,#0
loop$l
loop2$l
 BL checkforescapekey
 BCS basicchk_rapidex
 LDR R1,[R9,#f_ptr]
 MOV R0,R7
 BL long_op_display		; log the offset on the hourglass
 MOV R6,#0
 ADD R7,R7,#2			; skip linenumber
 B incandret2$l
loop3$l
 MOV R0,R7
 BL charfromoffset
 CMP R0,#13			; return character
 BEQ check_carriagereturnfound
 TST R6,#1
 BNE incandret2$l
 CMP R0,#'"'			; quote bit.
 TSTEQ R6,#&800			; and not in asm comment
 TSTEQ R6,#&80000000		; and not in * command
 EOREQ R6,R6,#2
 TST R6,#&2
 BNE incandret2$l
 TEQ R0,#':'
 BICEQ R6,R6,#&180		; no asm cmt / no recent print
 TST R6,#&100			; set recent print flag...
 BNE incandret2$l
 TEQ R0,#&F4			; REM
 TEQNE R0,#&DC			; DATA
 ORREQ R6,R6,#1
 ADRL R1,tokentabllkupasm - &80	; table...
 LDRB R14,[R1,R0]
 TST R14,#2
 ORRNE R6,R6,#&80		; set recent print flag...
 TEQ R0,#';'
 TEQNE R0,#'\'
 BLEQ poss_chk_asm_cmnt
 TEQ R0,#'('
 TEQNE R0,#&8A ; tab
 TEQNE R0,#&A7 ; instr
 TEQNE R0,#&B0 ; point
 TEQNE R0,#&C0 ; left$
 TEQNE R0,#&C1 ; mid$
 TEQNE R0,#&C2 ; right$
 TEQNE R0,#&C4 ; string$
 BEQ openbracket1
 CMP R0,#')'
 BEQ closebracket1
 CMP R0,#'{'
 BEQ openbracket2
 CMP R0,#'}'
 BEQ closebracket2
 CMP R0,#&E7			; if
 ORREQ R6,R6,#4
 TST R6,#&10
 BLNE possiblyatrailingthen
 CMP R0,#&8C			; then
 ORREQ R6,R6,#&10		; then with no if
 BICEQ R6,R6,#&60		; spaces?
 AND R14,R6,#4
 CMPEQ R14,#4
 ORREQ R6,R6,#8			; then with an if
incandret2$l
 ADD R7,R7,#1
 LDR R14,[R9,#f_len]
 CMP R7,R14
 BCC loop3$l
basicchk_rapidex
 BL unsetflagsofanythown
 SWI XHourglass_Off
 FNRTS

poss_chk_asm_cmnt
 TST R6,#&80
 MOVEQ PC,R14
 ORR R6,R6,#&100		; in asm comment.
 MOV PC,R14

possiblyatrailingthen
 TST R6,#&40
 MOVNE PC,R14
 CMP R0,#' '
 ORREQ R6,R6,#&20
 ORRNE R6,R6,#&40
 MOV PC,R14

openbracket1
 MOV R0,R6,LSR #24
 ADD R0,R0,#1
 BIC R6,R6,#&FF000000
 ORR R6,R6,R0,LSL #24
 B incandret2$l

closebracket1
 MOV R0,R6,LSR #24
 SUB R0,R0,#1
 BIC R6,R6,#&FF000000
 ORR R6,R6,R0,LSL #24
 B incandret2$l

openbracket2
 MOV R0,R6,LSR #16
 ADD R0,R0,#1
 AND R0,R0,#&FF
 BIC R6,R6,#&FF0000
 ORR R6,R6,R0,LSL #16
 B incandret2$l

closebracket2
 MOV R0,R6,LSR #16
 SUB R0,R0,#1
 AND R0,R0,#&FF
 BIC R6,R6,#&FF0000
 ORR R6,R6,R0,LSL #16
 B incandret2$l

check_carriagereturnfound
incandret1$l
 BIC R6,R6,#1
 ADR R2,errmsg_mismatchedq
 TST R6,#2
 BLNE report_to_user
 ADR R2,errmsg_mismatchedb1
 TST R6,#&FF000000
 BLNE report_to_user
 ADR R2,errmsg_mismatchedb2
 TST R6,#&FF0000
 BLNE report_to_user
 TST R6,#&4		; an if
 BNE toendofifthenchks
notevenanif
 TST R6,#&18
 ADR R2,errmsg_thennoif
 BLNE report_to_user
 B endofifthenchks
toendofifthenchks
 ;TST R6,#&10
 ;ADREQ R2,errmsg_ifnothen
 ;BLEQ report_to_user
endofifthenchks
 AND R14,R6,#&70
 CMP R14,#&30
 ADR R2,errmsg_trailingthen
 BLEQ report_to_user
 ADD R7,R7,#1
 LDR R14,[R9,#f_len]
 CMP R4,R14
 BCC loop2$l
 FNRTS

report_to_user
 FNJSR "R1-R3"
  [ INTL=""
 MOV R1,R2
 ADR R2,spacetempstore
 MOV R3,#32
 FNcall Zap_LookupToken
  |
 ADR R1,spacetempstore
 BL strcopy
  ]
 BL reporttouser
 MOV R0,R10			; recover r9 if this has been lost...!
 FNcall Zap_ConvFileOff
 FNRTS

errmsg_mismatchedq
 StrZ "basic_misquote","Mismatched quotes"
errmsg_mismatchedb1
 StrZ "basic_misbracket","Mismatched brackets"
errmsg_mismatchedb2
 StrZ "basic_misbrace","Mismatched braces"
errmsg_thennoif
 StrZ "basic_misTHEN","THEN with no IF"
;errmsg_ifnothen
; = "IF with no THEN",0
errmsg_trailingthen
 StrZA "basic_THENspace","Trailing spaces after THEN"

;E R7 = offset R9 file
reporttouser
 STMFD R13 !,{R1-R11,R14}
 LDR R11,[R9,#f_name]
 ;FNcall Zap_GetFileOff
 ;MOV R10,R0
 LDR R14,anysofar
 CMP R14,#0
 BLEQ tostartupthrowback
 MOV R0,R7
 BL copyinlinenumber
 MOV R1,R11 ; stored f_name !
 ADR R2,spacetempstore - 10
 ADR R3,filenamename ; problemreporttoolong
 MOV R4,R10 ; the relevant file...
 MOV R5,#&100 ; flags - 1 extra line...
 ORR R0,R7,#1<<31
 ADR R6,querynamename2 ;
 ADR R7,querynamename ;
  [ INTL=""
 ORR R3,R3,#1<<31
 ORR R6,R6,#1<<31
 ORR R7,R7,#1<<31
  ]
 LDR R8,throwbackr8
 LDR R9,throwbackr9
 FNcall Zap_Throwback
 LDMFD R13 !,{R1-R11,PC}

;E R0 = offset, R8/R9
copyinlinenumber
 STMFD R13 !,{R1-R11,R14}
 ;MOV R0,R1
 BL basic_clnoff
 ;ADD R10,R2,#1
 ADD R10,R2,#1
 MOV R0,R10
 ADR R1,spacetempstore - 10
 MOV R2,#10
 SWI XOS_ConvertInteger4 ; decimal
 ADR R3,spacetempstore - 10
 SUB R1,R1,R3
 ADD R3,R3,#8
 SUB R1,R3,R1
 LDR R0,fourspaces
 STR R0,spacetempstore - 12
 STR R0,spacetempstore - 8
 STR R0,spacetempstore - 4
 MOV R0,R10
 MOV R2,#10
 SWI XOS_ConvertInteger4 ; decimal
 MOV R0,#32
 STRB R0,[R1]
 LDMFD R13 !,{R1-R11,PC}

fourspaces
 = "    "
 = "ab"
tenleftlineni
 = "cdefghij  "
spacetempstore
 % 32

filenamename
 StrZ "basic_tb_file","File : "

querynamename
 StrZ "basic_tb_header","Syntactical queries..."

querynamename2
 StrZA "zap_tb_infl","   Line  Message"

anysofar
 DCD &0

throwbackr8
 DCD &0

throwbackr9
 DCD &0

tostartupthrowback
 FNJSR
 BL startupthrowback
 MOV R0,R10			; recover r9 if this has been lost...!
 FNcall Zap_ConvFileOff
 FNRTS

unsetflagsofanythown
 STMFD R13 !,{R14}
 LDR R14,anysofar
 CMP R14,#0
 BEQ bas_tb_justend		; beep too.
 LDR R8,throwbackr8
 LDR R9,throwbackr9
 ADR R0,tbunsetflagstogg
 FNcall Zap_CommandString
 LDMFD R13 !,{PC}

bas_tb_justend
 ADR R0,warnallisok
  [ INTL=""
 MOV R1,#5<<29
  |
 MOV R1,#1<<31
  ]
 FNcall Zap_Warning
 LDMFD R13 !,{PC}

warnallisok
 StrZ "basic_progOK","No problems found"

tbunsetflagstogg
 = "FFLAGS_TOGGLE 3",0
 ALIGN

startupthrowback
 STMFD R13 !,{R1-R12,R14}
 MOV R0,#76
  [ INTL=""
 ORR R0,R0,#1<<29 ; throwback_HasTokenList
  ]
 ADR R2,tokenlist$l
 FNcall Zap_CreateThrowback
 STR R8,throwbackr8
 STR R9,throwbackr9
 STR R14,anysofar
 LDMFD R13 !,{R1-R12,PC}

 [ INTL=""
tokenlist$l
	& 0,9
	= "basic_tb_header_nolf",0
	ALIGN
	& 0,12 :OR: 6<<28
	= "basic_tb_file",0
	ALIGN
	& 0,0
 ]

;E R0=numerator R1=denominator
;X percentage shown on hourglass #

long_op_display
 STMFD R13!,{R1-R3,R14}
 MOV R2,#100
 MUL R0,R2,R0
 BL div_mod
 CMP R0,#99
 MOVCS R0,#99
 SWI XHourglass_Percentage
 LDMFD R13!,{R1-R3,PC}

 LOCAL

checkforescapekey
 STMFD R13 !,{R0,R1,R2,R14}
 MOV R0,#129
 MOV R1,#&8F
 MOV R2,#255
 SWI XOS_Byte
 LDMFD R13 !,{R0,R1,R2,PC}

 LOCAL

chk_for_single_spaces ; so snipping out /single/ spaces before tokens works
 FNJSR "R0-R3"
 AND R0,R0,#7
 CMP R0,#2
 FNRTS NE
 ;B donttrytobeclever
 ;BIC R1,R1,#&F0000000
 ;BIC R2,R2,#&F0000000
 ADD R0,R1,R2
 SUB R2,R1,#1
 LDR R14,[R9,#f_len]
 CMP R0,R14
 FNRTS CS ; note somethime EQ :(
; loop_for_singles$l
; SUBS R2,R2,#1
; BMI trytobeclever
; ADD R0,R4,R2
; BL cln_readc
; CMP R0,#' '
; CMPNE R0,#':'
; BNE donttrytobeclever
; CMP R2,#0
; BGE loop_for_singles$l
; trytobeclever
; MOV R0,R3
 BL cln_readc ; last
 ;CMP R0,#127
 MOV R3,R0 ;
 ;BCS atokensodocommand
 MOV R0,R2
 BL cln_readc	; first
 ;CMP R0,#127
 ;FNRTS CC	; if NOT(start OR end on a token)...
 ;atokensodocommand
 CMP R0,#&E0	; END...
 CMPNE R0,#&9F  ; ERR
 CMPNE R3,#&84  ; OR
 ;CMPNE R0,#'D' ; enD ; sod these for the moment.
 ;CMPNE R0,#'R' ; erR
 ;CMPNE R1,#'C' ; Case
 ;CMPNE R1,#'I' ; If
 ;CMPNE R1,#'P' ; Proc
 ;CMPNE R1,#'S' ; beatS
 ;CMPNE R1,#'W' ; While
 ;CMPNE R1,#'O' ; Or
 BEQ endwithNEflag1
 ;B endwithNEflag1 ; ?????????????? &20107
 CMP R3,#&E7	; IF	CASE ;(
 CMPNE R3,#&F2  ; PROC  WHILE ;(
 CMPEQ R0,#'D'  ; from enD...
 BEQ endwithNEflag1 ; retokenise
 CMP R3,#&E0	; END...
 CMPEQ R0,#'P'  ; from APP... ; doesn't fire...
 BEQ endwithNEflag1 ; retokenise

 CMP R0,#127
 BCS endwithazerohere ; simply snip
 CMP R3,#127
 BCC endwithNEflag1 ; retokenise
endwithazerohere ; don't retokenise...
 ; FNRTS CC ; if NOT(start OR end on a token)...
 MOVS R0,#0
 FNRTS
endwithNEflag1 ; retokenise...
 MOVS R0,#-1
 FNRTS

exceptingprocproc
 TST R2,#&4000			; DEF
; ORREQ R2,R2,#&42000		; set PROC + recent no numbers...
; BEQ orthodox_detokenise_byte
differentprocdetbyt
 TSTNE R2,#&2000
 BICNE R2,R2,#&4000
 ORR R2,R2,#&42000		; set PROC + recent no numbers...
 B orthodox_detokenise_byte

inadefcoldetbyt
 CMP R0,#&F2			; tokenised PROC command ;(TT)
 CMPNE R0,#&A4			; tokenised FN command ;(TT) + others...
 BICNE R2,R2,#&6000		; end of any DEFxxxs
 BICNE R2,R2,#&20		; end of any DEFxxxs
 TST R14,#128			; def/endproc
 ORRNE R2,R2,#&44000		; set recent def flag + numbers...
 B orthodox_detokenise_byte

asmspecials
 ADRL R14,localmodeword
 LDR R14,[R14]
 TST R14,#1 << 29
 BNE notanasmspecial		; don't bother if 'don't colour code is on
 CMP R0,#&EC			; MOVE
 BEQ bas_asm_det_mov_prob
 CMP R0,#&84			; MOVE
 BEQ bas_asm_det_orr_prob
 ;SUB R14,R0,#&80
 ADR R1,tokentabllkupasm - &80	; table...
 LDRB R14,[R1,R0]
 TST R14,#1
 BEQ notanasmspecial
 ORR R2,R2,#&1200000		; asm instr.
 BIC R2,R2,#&D0000		; not in hex no, number after is ok & !E
 ORR R2,R2,#&20			; not in hex no, number after is ok
 B orthodox_detokenise_byte

 LOCAL

 DCD 7+(1<<15)
BASIC_TWRun
 CMP R2,#15
 BEQ tickquery$l
 FNJSR				; allow zap to kill now
 CMP R8,#0			; from IB?
 FNRTS EQ

 FNcall Zap_SaveFile
 FNRTS VS
 CMP R0,#0
 FNRTS NE			; not actually saved...?!
 ADRL R11,local_wkspace_ptr
 LDR R11,[R11]
 LDR R0,[R9,#f_len]		; length of file
 ADD R0,R0,R0,LSR#1		; *1.5
 BL wimp_nextslot		; reserve space to run the program
 FNRTS VS
 FNLDR R1,buf_retoken		; buffer &110 bytes
 ADR R2,twstartstr
 BL strcpy
 LDR R0,[R9,#f_name]
 FNcall Zap_FindLeafName
 MOV R2,R0
 BL strcpy
 ADR R2,twstartstr2
 BL strcpy
 LDR R2,[R9,#f_name]
 BL strcpy			; complete command
 MOV R14,#'"'
 STRB R14,[R1],#1
 MOV R14,#0
 STRB R14,[R1],#1
 FNLDR R0,buf_retoken
 ;BL create_task_window ; SWI XOS_CLI	; run the program
 ;;MOV R0,R10
 SWI XWimp_StartTask
 FNRTS
tickquery$l
 CMP R8,#0
 MOVEQ R0,#2
 MOVNE R0,#0
 MOV PC,R14

 ; -wimpslot...?
twstartstr
 FNS ("TaskWindow -quit -ctrl -name """)
twstartstr2
 FNS (""" ""BASIC -chain ")

; 1 = ASM instr if at sol.
; 2 = PRINT/TO/VDU/BPUT/INPUT...
; 4 = REM/DATA
; 8 = THEN ELSE ELSE
; 16 = IF ENDIF THEN ELSE ELSE
; 32 = CASE etc
; 64 = FOR NEXT REPEAT UNTIL WHILE
; 128 = DEF / ENDPROC

 = 0,0,0,32 ; important - 'OTHERWISE'...
tokentabllkupasm
 = 1,1,1,0,1,0,0,0,0,0,0,24,24,0,0,0 ; 8
 = 0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,0 ; 9
 = 0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0 ; A
 = 0,0,0,0,0,1,0,1,2,0,0,0,0,0,0,0 ; B
 = 0,0,0,0,0,0,0,0,0,32,32,32,24,16,64,0 ; C
 = 0,0,0,0,0,2,0,0,0,0,0,0,4,128,0,0 ; D
 = 128,128,0,64,0,0,0,16,2,0,0,0,0,64,0,2 ; E
 = 0,2,0,0,4,72,0,0,0,0,128,0,0,64,0,0 ; F

enditendofasmlabel1
 MOV R1,#&1C			; label
 STRB R1,[R6,R11]		; colour it
 BIC R2,R2,#&710000		; clear in asm label...?
 BIC R2,R2,#&F400		; clear recent flags...
 BIC R2,R2,#&28			; SOL & 'GOTO' flag
 B red_bas_postcolour

enditendofasmlabel2
 BIC R2,R2,#&710000		; clear in asm label...?
 BIC R2,R2,#&F400		; clear recent flags...
 BIC R2,R2,#&28			; SOL & 'GOTO' flag
 MOV PC,R14

atendofasmlabel
 TEQ R0,#'%'			; lastindeed
 TEQNE R0,#'!'			; lastindeed
 BEQ endingwithapercent
 TEQ R0,#':'			; and there's a : of course
 TEQNE R0,#';'			; and there's a : of course
 TEQNE R0,#'<'			; and there's a : of course
 TEQNE R0,#'='			; and there's a : of course
 TEQNE R0,#'>'			; and there's a : of course
 TEQNE R0,#'?'			; and there's a : of course
 TEQNE R0,#'/'			; if not ':'/' ' then
 CMPNE R0,#'-'			; if not ':'/' ' then
 BGT bas_red_zerores
 BIC R2,R2,#&710000		; clear in asm label...?
 BIC R2,R2,#&F400		; clear recent flags...
 BIC R2,R2,#&28			; SOL & 'GOTO' flag
 MOVS R1,#0
 MOV PC,R14

endingwithapercent
 MVNS R1,#0
 MOV PC,R14

atendofasminstr
 TEQ R0,#'='			; and there's not an = (DarrenS!)
 ;CMPNE R0,#';'			; junk
 CMPNE R0,#'@'			; and there's a < alphabetical...
 ;CMPNE R0,#'&'			; um wow?
 BGE bas_red_zerores		; return if not at end of asm instr.
 BIC R2,R2,#&1E000000		; clear in asm label...?
 BIC R2,R2,#&00710000		; clear in asm label...?
 BIC R2,R2,#&00007400		; clear recent flags...
 ; BIC R2,R2,#&00000008		; 'GOTO' flag
 MOVS R1,#0
 MOV PC,R14

exponentialproblem
 CMP R0,#'E'
 MOVEQ R1,#&0F
 ;CMPNE R0,#32
 ;MOVEQ PC,R14
 BIC R2,R2,#&20000000		; 1E2 BIT.
; SWI &107  left in by accident?
 MOV PC,R14

oneofthemEees
 TST R2,#&20000			; in a decimal number
 BEQ bas_butwerenotinno
 TST R2,#&20000000		; E so far...?
 BICNE R2,R2,#&20000000
 BICNE R2,R2,#&20000
 ORRNE R2,R2,#&40000
 ORREQ R2,R2,#&20000000
 ORREQ R2,R2,#&20000
 BICEQ R2,R2,#&40000
 B nfanumbtt

maybecanceleflag
 CMP R0,#'E'
 BICGT R2,R2,#&20000000		; no more Es
 MOVGE PC,R14
 CMPNE R0,#'9'
 BICGT R2,R2,#&20000000		; no more Es
 MOVGT PC,R14
 CMP R0,#'0'
 BICLT R2,R2,#&20000000		; no more Es
 MOV PC,R14

red_bas_semi
 BIC R2,R2,#&10000		; not in hex no any more...
 MOV R1,#&80000000		; a * ?
 ORR R1,R1,#&400		;
 TST R2,R1			; a recent PRINT?
 MOVNE PC,R14			; no juice...
 TST R2,#2			; in a quote;
 MOVNE R1,#10			; yes
 MOVEQ R1,#9			; no - now a comment, then.
 ORREQ R2,R2,#&800		; must keep bit 1 sane for detokenising...?
 BICEQ R2,R2,#&34000000		; not in LDR/LDM...
 STRB R1,[R6,R11]		; colour it
 MOV PC,R14

bas_red_zerores
 MOVS R1,#1
 MOV PC,R14

underscorespecialcase
 TST R2,#&30000
 BNE nfanumbtt ; postprenumberproblems

prenumberproblems
 ORR R2,R2,#&40000
 B postprenumberproblems

ba_incomment
 TEQ R0,#':'			; the end of that...?
 BEQ ba_theendofthatthen	; clear recent print flag...
 MOV R1,#9			; no - now a comment, then.
 STRB R1,[R6,R11]		; colour it
 B red_bas_postcolour

tonfanumbtt
 CMP R1,#-1
 BNE nfanumbtt
 MOV R1,#&1C			; label
 STRB R1,[R6,R11]		; colour it
 BIC R2,R2,#&710000		; clear in asm label...?
 BIC R2,R2,#&F400		; clear recent flags...
 BIC R2,R2,#&28			; SOL & 'GOTO' flag
 B red_bas_postcolour

to_bas_red_back_nfanumbtt
 CMP R1,#-1
 BNE bas_red_back_nfanumbtt
 BIC R2,R2,#&710000		; clear in asm label...?
 BIC R2,R2,#&F400		; clear recent flags...
 BIC R2,R2,#&28			; SOL & 'GOTO' flag
 B bas_red_back_nfanumbtt

bas_red_back_oneofthemEees
 TST R2,#&20000			; in an assembler comment
 BEQ bas_red_back_bas_butwerenotinno
 TST R2,#&20000000		; E so far...?
 BICNE R2,R2,#&20000
 BICNE R2,R2,#&20000000
 ORRNE R2,R2,#&40000
 ORREQ R2,R2,#&20000
 ORREQ R2,R2,#&20000000
 BICEQ R2,R2,#&40000
 B bas_red_back_nfanumbtt

bas_red_back_prenumberproblems
 ORR R2,R2,#&40000
 B bas_red_back_postprenumberproblems

red_bas_semi2
 TST R2,#&400			; a recent PRINT?
 MOVNE PC,R14			; no juice...
 TST R2,#2			; in a quote;
 ORREQ R2,R2,#&800		; must keep bit 1 sane for detokenising...?
 BICEQ R2,R2,#&34000000		; not in LDR/LDM...
 MOV PC,R14

ba_incomment_general
 TST R2,#&02			; tokenised print command ;(TT)
 TEQEQ R0,#':'			; tokenised print command ;(TT)
 BICEQ R2,R2,#&FC00
 BICEQ R2,R2,#&2B
 MOV PC,R14

back_red_bas_foundinoscli
 TST R2,#&40000000		; test relevant DATA flag...
 MOVEQ PC,R14
 CMP R0,#'"'
 EOREQ R2,R2,#&800000
 MOV PC,R14

; REM *****************************************************
; REM *							  *
; REM *	      Tim Tyler's main additions end here         *
; REM *							  *
; REM *****************************************************



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Load token table					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; token values
; format
; 0		&81 offsets to keywords for tokens &7F-&FF
;		0=no tokens starting with this letter
;		OR -> string of keyword (12) (if first byte<&7F)
;		OR -> list of key byte (4),keyword string (12)
;		key=#0 Token
;		    #1 Second byte of token /0
;		    #2 Function token if different /0
;		    #3 Basic info byte (see below)
;		keyword=#0-#10 zero terminated string
;			#11    length byte
; &204		26 offsets to list pointers for keywords starting A-Z
;		List of keyword (12), key (4)
; BASICs info byte = b0 set if not to tokenise if alphanumeric follows
;		     b1 set to go to FN mode after (it is a function)
;		     b2 set to go to command mode after (eg THEN)
;		     b3 set if the token is 2 bytes
;		     b4 set if line number may follow (eg GOTO)
;		     b5 set to not detokenise following (REM/DATA)
;		     b6 set if different token in command mode
;		     b7 set if token string contains a '('

mem_basdata
 BIN data.ZapBasData
 ALIGN

; assemble instruction program

mem_basass
 BIN data.Assemble
mem_basass_end

 END
