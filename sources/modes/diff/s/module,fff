; Diff colouring mode
; $Id: module,fff,v 1.4 2001/04/24 12:47:56 james Exp $
;
; (c) Zap Developers 2001
;
; This is a reasonably simple colouring mode. It should serve
; as a good tutorial example - reasonably well-commented, and
; generally accurate and safe about how it does things.

	GET	h.Diff
	GET	h.Version

	AREA	|!!!Module_Header_Area|,CODE,READONLY
	ENTRY

	DCD	0x00
	DCD	init_code
	DCD	finalise_code
	DCD	0x00
	DCD	title_string
	DCD	help_string
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0

help_string = "ZapDiff",9
	    = version,"(00 Jan 0000)"
 [ BUILD > ""
		= " ",BUILD
  [ (BUILD:RIGHT:1 < "0" :LOR: BUILD:RIGHT:1 > "9") :LAND: patch_level <> ""
		= "-",patch_level
  ]
 |
  [ test_flag
		= " [TEST"
   [ patch_level <> ""
		= " ",patch_level
   ]
		= "]"
  |
   [ patch_level <> ""
		= " patch-",patch_level
   ]
  ]
 ]
	FNS (" © Zap Developers")

title_string FNS ("ZapDiff")

ws_store	DCD	0
zap_modulename	=	"Zap", 0

get_workspace
	LDR	r11, ws_store
	MOV	pc, lr

init_code
	FNJSR
	LDR	r2, [r12, #0]
	CMP	r2, #0
	BNE	module_init
	MOV	r0, #6
	MOV	r3, #ws_size
	SWI	XOS_Module
	FNRTS	VS
	STR	r2, [r12, #0]
	ADRL	r0, ws_store
	STR	r2, [r0, #0]
	MOV	r0, #-1
	STR	r0, [r2, #ws_modenumber]
	MOV	r0, #0
	STR	r0, [r2, #ws_menudata]
module_init
	MOV	r0, #18
	ADR	r1, zap_modulename
	SWI	XOS_Module
	FNRTS	VS
	MOV	r12, r4		;  Zap workspace
	ADR	r0, mode_table
	FNcall	Zap_AddMode
	FNRTS

finalise_code
	FNJSR
	MOV	r0,#7
	LDR	r2,[r12]
	SWI	XOS_Module
	FNRTS	VS
	MOV	r0,#0
	STR	r0,[r12]
	FNRTS

mode_name
	=	"Diff", 0
mode_author
	=	"James Aylett and Darren Salt", 0
	ALIGN

mode_table
	DCD	mode_table
	DCD	mode_name
	DCD	mode_author
	DCD	0		;  basemode = text
	DCD	emode_UsesMessageTrans :OR: emode_MayBeCloned :OR: emode_ModeWordIsBlock
	DCD	mode_init
	DCD	0
	DCD	mode_table_end - mode_table
	DCD	0
	DCD	0
	DCD	0
	DCD	mode_start
	DCD	mode_end
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode_nextline
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode_redrawline
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode_prevline
mode_table_end

; initialise our mode. Various things happen here, and it's one
; of the more complex entry points as a result. Some reason codes,
; aren't anything to do with initialisation at all.
;
; Important things to note here are how we never rely on a static notion
; of our mode number - it's always figured out dynamically (allowing us to
; be cloned successfully), and that we need to be careful about UPGRADING
; options and colours, not just setting them up in the first place. Of
; course, if a mode never gets extended, we don't win anything by being
; careful (but this mode was extended by two colours within hours of being
; written, so ... :-).
;
; FIXME: we don't currently upgrade clone modes properly. I think we
; know how to do it, but we need to be sure. Until then, your clone modes
; won't upgrade smoothly (best solution is to delete them then recreate).
	
	LOCAL
mode_init
	CMP	r1, #einit_ModeMenu
	BEQ	init_modemenu
	CMP	r1, #einit_ModeStarting
	BEQ	init_modestarting

	CMP	r1, #einit_ColoursSubmenu
	ADREQ	r1, colsmenu$l
	MOVEQ	pc, lr

	CMP	r1, #einit_RedrawStart
	BEQ	init_redrawstart

	TEQ	r1, #einit_ModeStarted
	MOVNE	pc, lr

	FNJSR	"r1-r3, r7, r8"
	MOV	r8, #0
	LDR	r1, [r11, #ws_modenumber]
	BL	init_colours
	FNRTS	VS

	FNcall	Zap_GetModeWord
	TEQ	r0, #0
	BEQ	init_config

	LDR	r7, [r0, #0]
	CMP	r7, #mb_size
	FNRTS	EQ
	; Config block is wrong size! We must resize it ...
	MOV	r1, #mb_size
	FNcall	Zap_Ensure
	FNRTS	VS
	MOV	r7, #mb_size
	STR	r7, [r0, #mb_sizestore]
	; ... and then set useful defaults for any new options.
	; (Not done because we don't yet have any options at all.)

	; Store the mode word back as our default.
	FNcall	Zap_PutModeWord
	FNRTS
colsmenu$l
	=	"diff_colours", 0
	ALIGN

; We don't have an entry in the config file at all.
; Grab a mode word block (first word is the size of the block, so Zap can
; handle things automatically for new windows), and write useful defaults
; into it. Also set up the ModeData variables into useful default states
; (these are the defaults for w_format et al).
init_config
	MOV	r0, #mb_size
	FNcall	Zap_Claim
	FNRTS	VS
	MOV	r7, #mb_size
	STR	r7, [r0, #mb_sizestore]
	MOV	r7, #0
	STR	r7, [r0, #mb_flags]
	FNcall	Zap_PutModeWord

	ADR	r3, vardata$l
	MOV	r2, #0
	LDR	r7, [r3], #4
setupvars$l
	LDR	r0, [r3], #4
	FNcall	Zap_ModeData
	ADD	r2, r2, #1
	CMP	r2, r7
	BLT	setupvars$l
	FNRTS
vardata$l
	DCD	2		; total vars to write
	DCD	0x77 :OR: (tab_DisplayAsSpaces :SHL: tab_DisplayFormat_config_shift)
	DCD	0x7 :OR: modeconfig_LineNumberColon :OR: modeconfig_CursorSmart

	
; Store our real mode number. We want to know the base mode number, so
; we can supply commands and similar that will do meaningful things
; in our base mode and all clones, but exit gracefully in others.
	LOCAL
init_modestarting
	LDR	r1, [r11, #ws_modenumber] ; first init?
	CMP	r1, #-1		; if it isn't, this is a clone init (ignore)
	STREQ	r0, [r11, #ws_modenumber] ; hang onto it so we know our base
	MOV	pc, lr

; Load our mode menu
	LOCAL
init_modemenu
	FNJSR
	BL	load$l
	LDRVC	r1, [r0, #4]
	FNRTS
load$l
	FNJSR
	LDR	r0, [r11, #ws_menudata]
	CMP	r0, #0
	FNRTS	NE

	ADR	r0, menu_path$l
	FNcall	Zap_LoadMenu
	STRVC	r0, [r11, #ws_menudata]
	FNRTS
menu_path$l
	=	"<ZapDiff$Menus>", 0
	ALIGN


; Check to see if we have enough colours allocated to this mode yet.
; If not, change the allocation and write some useful defaults.
	LOCAL
init_colours
	FNJSR	"r1-r5"
	MOV	r0, #-1
	FNcall	Zap_ModeColourNum
	CMP	r0, #colour_max
	FNRTS	GE
	MOV	r2, r0		; current number of colours

	MOV	r0, #colour_max
	FNcall	Zap_ModeColourNum
	CMP	r2, #colour_base
	MOVLT	r2, #colour_base ; don't overwrite system colours
	ADR	r3, cols$l
	ADD	r3, r3, r2, LSL #2
	SUB	r3, r3, #(4*colour_base) ; find data for our first colour
set_col$l
	LDR	r0, [r3], #4
	FNcall	Zap_ModeColour
	ADD	r2, r2, #1
	CMP	r2, #colour_max
	BLT	set_col$l
	FNRTS
cols$l
	DCD	0xbbefef10	; beige
	DCD	0x0000dd10	; red
	DCD	0x00cc0010	; green
	DCD	0x00885510	; olive
	DCD	0xFFBB0010	; cyan


; Called immediately before redraw. We figure out what
; type of diff this file is, and save it in our workspace.
; We know that no other redraw request will happen until
; our e_redrawline has been called following this.
	LOCAL
init_redrawstart
	FNJSR	"r0-r5,r11"
	MOV	r0,#0
	LDR	r1,[r9,#f_ptr]
	LDR	r2,[r9,#f_splito]
	LDR	r3,[r9,#f_splits]
	LDR	r5,[r9,#f_len]
	ADD	r3,r1,r3
scan$l
	; check first char of line
	BL	readchar$l
	TEQ	r4,#'-'		; '-' => unified format
	MOVEQ	r4,#diff_UNIFIED
	BEQ	knowndiff$l
	TEQ	r4,#'*'		; '*' => context format
	MOVEQ	r4,#diff_CONTEXT
	BEQ	knowndiff$l
	TEQ	r4,#'d'		; 'd' => "diff" line? RCS format?
	BEQ	diff_or_rcs$l
	TEQ	r4,#'a'		; 'a' => RCS format, if followed by digit
	BEQ	maybe_rcs$l
	TEQ	r4,#'O'		; 'O' => "Only in" line
	BEQ	nextline$l
	CMP	r4,#'0'		; digit => standard format? ed format?
	RSBHSS	r14,r4,#'9'
	BHS	standard_or_ed$l
	; anything else - not a diff file...?
unknowndiff$l
	MOV	r4,#diff_UNKNOWN
knowndiff$l
	BL	get_workspace
	STR	r4,[r11,#ws_difftype]
	FNRTS

readchar$l
	CMP	r0,r5
	BHS	unknowndiff$l	; OK so long as no extra registers pushed :-)
	CMP	r0,r2
	MOVHS	r1,r3
	LDRB	r4,[r1,r0]
	ADD	r0,r0,#1
	MOV	pc,r14

nextline$l
	MOV	r11,#e_linenext
	FNcall	Zap_CallMode
	B	scan$l

standard_or_ed$l
	; standard is "<number><letter><number>"
	; ed       is "<number><letter>"
	BL	readchar$l
	CMP	r4,#'0'
	RSBHSS	r14,r4,#'9'
	BHS	standard_or_ed$l; skip digits
	CMP	r4,#'a'
	RSBHSS	r14,r4,#'z'
	BLO	unknowndiff$l	; must be lowercase letter
	; if the next chr is a digit, we have standard format
	BL	readchar$l
	CMP	r4,#'0'
	RSBHSS	r14,r4,#'9'
	MOVLO	r4,#diff_ED
	MOVHS	r4,#diff_STANDARD
	B	knowndiff$l

diff_or_rcs$l
	; RCS is "d<number>" or "a<number>"
	BL	readchar$l
	TEQ	r4,#'i'
	BEQ	nextline$l	; 'i' => "diff" line
maybe_rcs$l
	CMP	r4,#'0'
	RSBHSS	r14,r4,#'9'
	MOVHS	r4,#diff_RCS
	BHS	knowndiff$l	; digit => RCS format
	B	unknowndiff$l


; e_start / e_end must get Zap to save & restore all mode options
mode_start
	FNJSR
	LDRB	r0, [r8, #w_format] ; mode number
	FNcall	Zap_RestoreModeWord
	FNRTS

mode_end
	FNJSR
	LDRB	r0, [r8, #w_format] ; mode number
	FNcall	Zap_SaveModeWord
	FNRTS

; First, let text mode draw the line without colouring, and then
; recolour as necessary based on the diff type (detected at
; e_init #13).
	LOCAL
mode_redrawline
	FNJSR	"r11"

	LDRB	r0, [r7, #0]	; first char of line
	PUSH	"r0, r6, r9"
	; Can't use Zap_BaseMode because r11 is a parameter to e_redrawline :-(
	MOV	r0, #0
	FNcall	Zap_ReadMode
	MOV	lr, pc
	LDR	pc, [r1, #(2*e_redrawline)]

	PULL	"r4, r6, r9"	; r4 = first char of line
	BL	get_workspace
	LDR	r11,[r11,#ws_difftype]
	CMP	r11,#diff_NUM_TYPES
	ADDLO	pc,pc,r11,LSL #2
	B	done$l
	B	standard$l
	B	context$l
	B	unified$l
	B	done$l	; ed format
	B	done$l	; rcs format
			; can't colour ed, rcs without multiline parsing

standard$l
	; add start '>', remove start '<'
	; control lines start with digits
	CMP	r4, #'>'
	MOVEQ	r1, #colour_add
	BEQ	drawline$l

	CMP	r4, #'<'
	MOVEQ	r1, #colour_remove
	BEQ	drawline$l

	CMP	r4, #'0'
	RSBHSS	r14, r4, #'9'
	MOVHS	r1, #colour_control
	BHS	drawline$l

informationals$l
	TEQ	r4,#'d'
	TEQNE	r4,#'O'
	MOVEQ	r1,#colour_info
	BEQ	drawline$l
	B	done$l

context$l
	; add start '!', remove start '!' (!)
	; control lines start and end with '*'
	; filename lines start with '*' (old) or '-' (new)
	TEQ	r4, #'!'
	MOVEQ	r1, #colour_change
	BEQ	drawline$l

	TEQ	r4, #'*'
	; TO DO: check last character
	MOVEQ	r1, #colour_control
	BEQ	drawline$l

	B	informationals$l

unified$l
	; add start '+', remove start '-' (also colours old, new filenames)
	; control start '@'
	CMP	r4, #'+'
	MOVEQ	r1, #colour_add
	BEQ	drawline$l

	CMP	r4, #'-'
	MOVEQ	r1, #colour_remove
	BEQ	drawline$l

	CMP	r4, #'@'
	MOVEQ	r1, #colour_control
	BEQ	drawline$l

	B	informationals$l

	; can't colour without multiline parsing

drawline$l
	LDR	r0, [r8, #w_txtw]
	ADD	r6, r6, r0
loop$l	STRB	r1, [r6],#1
	SUBS	r0, r0, #1
	BNE	loop$l

done$l
	FNRTS

; If e_prevline (which is called before here) was told that we're
; redrawing based on an edit action which includes the first character
; of the file (ie it starts at offset 0) then redraw the entire file
; rather than just the line surrounding the change. This is because
; the redraw code always checks the first character of the file to see
; whether this is a 'normal' or unified diff - if that character changes
; we may need to update the entire file. We could be more cautious, and
; check the actual character to see if we need to bother, but our redraw
; isn't too expensive, and the code starts getting very messy at that point
	LOCAL
mode_nextline
	FNJSR	"r2, r9, r11"
	LDR	r2, [ws, #ws_lastprevline]
	CMP	r2, #0
	BNE	just_nextline$l
	LDR	r0, [r9, #f_len]
	FNcall	Zap_OffsetLine	; \E r0/r1 the wrong way round ...
	EOR	r0, r0, r1
	EOR	r1, r0, r1
	EOR	r0, r1, r0
	FNRTS
just_nextline$l
	LDRB	r9, [r8, #w_format] ; ie our mode number
	MOV	r11, #e_nextline
	FNcall	Zap_BaseMode
	FNRTS

; Remember the start of this edit action
; (zealous, since some f_docom's aren't relevant here) - but
; diff redraw is reasonably cheap. 'Proper' modes would want to be
; more cautious
	LOCAL
mode_prevline
	STR	r0, [ws, #ws_lastprevline]
just_prevline$l
	FNJSR	"r9, r11"
	LDRB	r9, [r8, #w_format] ; ie our mode number
	MOV	r11, #e_prevline
	FNcall	Zap_BaseMode
	FNRTS

	END
