; makefile.s
; converted from makefile.bas by bas2asm.pl
; $Id: module,fff,v 1.15 2003/03/05 01:27:53 christian Exp $

	GET	h.Makefile

	ENTRY

	DCD	0x00
	DCD	StartUpHere
	DCD	0x00
	DCD	0x00
	DCD	D1
	DCD	ModHelpString
	DCD	D1
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	module_flags

; -------- module command table -----------

D1	=	"ZapMakeFile",0
	DCD	0
	DCD	0
	DCD	0
	DCD	D2
	=	0

D2	=	27,0," provides support for",27,2,"Zap editor.",13
	=	"It provides a syntax-colouring mode for Acorn Make",27,7,"s.",0
	ALIGN

ModHelpString
	=	"ZapMakeFile",9,"0.11 (00 Jan 0000) © "
lp1	=	"Tim Tyler",0
	ALIGN

module_flags
	DCD	1			; 32 bit compatible

Data3
	=	"Zap",0
	DCD	0

w_formmb
	DCD	-1
	=	0x18, 0x18, 0x0, 0x0
	DCD	0	;  REM mainwkspflags

StartUpHere
	STMFD	sp!, {lr}
	LDR	r2, [r12, #0]
	CMP	r2, #0
	BNE	ModuleInit
	MOV	r0, #6
	MOV	r3, #0x20
	SWI	XOS_Module
	LDMVSFD	sp!, {pc}
	STR	r2, [r12, #0]
	ADRL	r0, Data47
	STR	r2, [r0, #0]
	MOV	r0, #0
	STR	r0, [r2, #20]
ModuleInit
	MOV	r0, #4
	STR	r0, [r2, #12]
	MOV	r0, #0x12
	ADR	r1, Data3
	SWI	XOS_Module
	MOV	r12, r4
RefDataTab
	ADR	r0, mode_table
	FNcall	0
	ADR	r0, CmdTable
	FNcall	Zap_AddCommands
	LDMFD	sp!, {pc}


ObeyLabeled
	=	"MakeFile",0
	ALIGN

mode_table
	DCD	mode_table
	DCD	ObeyLabeled
	DCD	lp1
	DCD	0x00	;  REM = BaseMode = Text
	DCD	13 + 1<<10 + 1<<14			; e_mode
	DCD	Initialisation	;  REM init
	DCD	menu_file				; e_menu
	DCD	mode_table_end - mode_table	;  REM size of table ; len
	DCD	0x00	;  postload
	DCD	0x00	;  REM beforesave ; e_presave	\ called before saved
	DCD	0x00
	DCD	E_Start	;  REM e_start		 \ window entering mode
	DCD	E_End	;  REM e_end		   \ window leaving mode
	DCD	0x00	;  REM e-width		   \ find work area width
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00	;  REM lp7 ; e_clnphy	     \ physical to file offs
	DCD	0x00	;  REM clnlog
	DCD	0x00	;  REM clnphy
	DCD	0x00	;  REM clnoff
	DCD	0x00
	DCD	0x00	;  e_sminus	 \ perform shift-left
	DCD	0x00	;  e_splus	 \ perform shift-right
	DCD	0x00
	DCD	0x00
	DCD	redrawline	;  REM e_redrawline   \ redraw line of display
	DCD	0x00
	DCD	charchar
	DCD	0x00
	DCD	0x00	;  e_tab       \ tab key pressed
	DCD	0x00
	DCD	0x00
	DCD	0x00	;  trytwo    \  REM e_saveandrun
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00	;  e_compile \ compile & run and don't exit
	DCD	0x00
	DCD	0x00	;  e_run \ run the program being edited
	DCD	0x00	;  e_runandquit \ run
	DCD	0x00	;  \ drops into language...?
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00
	DCD	0x00	;  REM e_setwidth - changing window width
	DCD	0x00
	DCD	redrawA	;  REM e_prevline \ find start of update reg'n; Easy!
	DCD	0					; e_openwindow
	DCD	mode_interrogate	;  REM ; e__interrogate
mode_table_end

menu_file	=	"ZapMakeFile:Menus",0
		ALIGN

; --------- e_init -----------

Initialisation
	CMP	r1, #1
	MOVCC	pc, lr
	STREQ	r0, [r11, #4]
	STREQ	r0, modenumberlocal
	TEQ	r1, #6
	ADREQ	r1, MenuExtension
	MOVEQ	pc, lr
	TEQ	r1, #2
	MOVNE	pc, lr

	STMFD	sp!, {r1, r7, r8, lr}
		;  REM here? yes!
	STMFD	sp!, {r0, r1, r7}	; this code overwrites the
	MOV	r8, #'a'		; "greetings..." text with
	ADRL	r1, TableHere		; the offset into TableHere
loop2					; of each alpha char
	LDRB	r0, [r1]		; ...this is why we need "Yum"
	CMP	r0, r8
	BGE	GtIt
loop
	LDRB	r0, [r1], #1
	CMP	r0, #'z'
	BLE	loop
	LDRB	r0, [r1]
	CMP	r0, #'*'
	BNE	loop2
	B	done$l
backinaction
	ADD	r8, r8, #1
	CMP	r8, #'z'
	BLE	loop2

done$l
	LDMFD	sp!, {r0, r1, r7}
	MOV	r8, #0
	BL	ZapModeWord
	TEQ	r7, #0
	BEQ	nocfginit
	LDR	r0, [r7, #0]
	CMP	r0, #zizeofcfgwksp
	LDMEQFD	sp!, {r1, r7, r8, pc}
	;  REM no !Config...
nocfginit
	MOV	r0, #col_last		; was 0x11 - but that's wrong!
	FNcall	Zap_ModeColourNum	;  REM change palette size.
	TEQ	r7, #0
	BEQ	noheapblkatall
	LDR	r1, [r7, #0]
	TEQ	r1, #zizeofcfgwksp
	BEQ	justendtheresnoneed
	MOVVC	r1, #zizeofcfgwksp
	MOVVC	r0, r7
	LDRVC	lr, [r12, #0]
	ADDVC	lr, lr, #8
	STMVCFD	sp!, {lr}
	MOVVC	lr, pc
	LDMVCFD	sp!, {pc}
	MOVVC	r7, r0
	STRVC	r1, [r7, #0]
	BLVC	OnToWrtMdeWrd
noheapblkatall
	MOV	r0, #zizeofcfgwksp
	LDR	lr, [r12, #0]
	ADD	lr, lr, #4	;  REM zap call - start heap block
	STMFD	sp!, {lr}
	MOV	lr, pc
	LDMFD	sp!, {pc}
	MOV	r7, r0
	BLVC	OnToWrtMdeWrd
	MOVVC	r0, #zizeofcfgwksp
	STRVC	r0, [r7, #0]
	MOVVC	r0, #0
	STRVC	r0, [r7, #4]
	MOVVC	r0, #0x0D	; col_commands?
	STRVC	r0, [r7, #8]
	LDRVC	r0, startupformatwd
	STRVC	r0, [r7, #0x0C]
	LDRVC	r0, SDsasa	;  REM Dater 5%/8% !! vc= no !config file ?
	LDRVC	r1, [r11, #4]
	MOVVC	r2, #0
	LDRVC	lr, [r12, #0]
	ADDVC	lr, lr, #Zap_ModeData	;  REM call - RD/WRT Zap Dater mode words.
	STMVCFD	sp!, {lr}
	MOVVC	lr, pc
	LDMVCFD	sp!, {pc}
	BLVC	UnkPreColBit	;  REM to set up colours with zmcs
justendtheresnoneed
	LDMFD	sp!, {r1, r7, r8, pc}



; --------- command table -----------------
CmdTable
	DCD	CmdTable
	DCD	0
	=	"MAKEFILE_FLAGSTOGGLE",0
	ALIGN
	DCD	Cmdhtmlflagstoggle
	DCD	0


basemode
	LDR	r9, modenumberlocal
	FNjump	Zap_BaseMode
modenumberlocal
	DCD	0
startupformatwd
	DCD	0x07800000

GtIt
	ADRL	r0, AlphaIndex
	SUB	r7, r8, #'a'
	ADD	r0, r0, r7, LSL #2
	ADRL	r7, TableHere
	SUB	r7, r1, r7
	STR	r7, [r0]
	B	backinaction

MenuExtension
	=	"Comments", 0		; 9
	=	"Strings", 0		; 10
	=	"< ... >", 0		; 11
	=	"( ... )", 0		; 12
	=	"Commands", 0		; 13
	=	"Punctuation", 0	; 14
	=	"Numbers", 0		; 15
	=	"-switches", 0		; 16
	=	"+Commands", 0		; 17
	=	"c.file",0		; 18
	=	"h.header",0		; 19
	=	"o.object", 0		; 20
	=	"s.assembler",0		; 21
	=	0
	ALIGN

R8tmp	DCD	0
R9tmp	DCD	0
R12tmp	DCD	0


lasttryadr
	DCD	0


; -- initialise default colours

UnkPreColBit
	STMFD	sp!, {r1-r4, lr}
	ADR	r3, DefaultColours
	LDR	r1, [r11, #4]	;  REM normally 0
PreZModColBit
	MOV	r2, #0x09	;  REM start colours
ZModColBit
	LDRB	r0, [r3], #1
	FNcall	Zap_ModeColour	;  REM Read colour definitions
	LDMVSFD	sp!, {r1-r4, pc}
	ADD	r2, r2, #1
	TEQ	r2, #col_last	;  REM max colours
	BNE	ZModColBit
	LDMFD	sp!, {r1-r4, pc}
DefaultColours
		;  REM Colour Numbers :
	=	0x0A	;  REM Comment Colour =&9
	=	0x0F	;  REM String colour  =&A
	=	0x03	;  REM < ... >	      =&B
	=	0x0D	;  REM ( ... )	      =&C
	=	0x09	;  REM Commands	      =&D
	=	0x0C	;  REM Misc Punct.    =&E
	=	0x0E	;  REM Numbers	      =&F
	=	0x02	;  REM -switches      =&10
	=	0x04	;  REM +Commands      =&11
	=	0x01	;  REM c.file	      =&12
	=	0x02	;  REM h.header	      =&13
	=	0x0B	;  REM .o.	      =&15 ; RED!
	=	0x03	;  REM .s.	      =&14
	ALIGN

;Tk1frm12andret
;	LDR	r0, [r11, #12]
;	SUBS	r0, r0, #1
;	STR	r0, [r11, #12]
;	MVNNE	r0, #0
;	MOVS	pc, lr

ZapModeWord
	STMFD	sp!, {r0-r2, lr}
	LDR	r1, [r11, #4]
	LDR	r2, [r12, #0]
	ADD	r2, r2, #0x0164	;  REM Zap_GetModeWord - read the mode word
	MOV	lr, pc
	MOV	pc, r2
	MOV	r7, r0
	LDMFD	sp!, {r0-r2, pc}

OnToWrtMdeWrd
	STMFD	sp!, {r0-r2, lr}
	LDR	r1, [r11, #4]
WrtMdeWrd
	MOV	r0, r7
	LDR	r2, [r12, #0]
	ADD	r2, r2, #0x0168	;  REM zap call...write the mode word
	MOV	lr, pc
	MOV	pc, r2
	LDMFD	sp!, {r0-r2, pc}

localdefltmw
	DCD	0
initialiseheap
	STMFD	sp!, {r1-r6, r8-r12, lr}
	MOV	r0, #zizeofcfgwksp
	LDR	lr, [r12, #0]
	ADD	lr, lr, #4
	STMFD	sp!, {lr}
	MOV	lr, pc
	LDMFD	sp!, {pc}
	MOV	r7, r0
	STR	r1, [r7, #0]
	LDR	r0, localdefltmw
	LDR	r0, [r0, #0xC]
	STR	r0, [r7, #0xC]
	MOV	r0, #0x0D	; col_commands?
	STR	r0, [r7, #8]	;  REM AT THE START MAKE COLOUR OK?
	BL	OnToWrtMdeWrd
	LDMFD	sp!, {r1-r6, r8-r12, pc}


; ---------- e_start -----------

E_Start
	STMFD	sp!, {r1, r6, r7, lr}
	STMFD	sp!, {r1-r12, lr}
	LDRB	r1, [r11, #4]
	ORR	r1, r1, #0x100
	FNcall	Zap_ReadVar
	STR	r0, localdefltmw
	LDMFD	sp!, {r1-r12, lr}
	BL	ZapModeWord
	CMP	r7, #0
	BLEQ	initialiseheap
	TEQ	r8, #0
	BEQ	BeforeAllare8
	LDRVC	r1, [r7, #0]
	TEQVC	r1, #zizeofcfgwksp
	BEQ	BeforeAllare8
	MOVVC	r1, #zizeofcfgwksp
	MOVVC	r0, r7
	LDRVC	lr, [r12, #0]
	ADDVC	lr, lr, #8
	STMVCFD	sp!, {lr}
	MOVVC	lr, pc
	LDMVCFD	sp!, {pc}
	MOVVC	r7, r0
	STRVC	r1, [r7, #0]
	BLVC	OnToWrtMdeWrd
BeforeAll
	LDR	r0, localdefltmw
	LDR	r0, [r0, #0xC]
	STR	r0, [r7, #0xC]
	MOV	r0, #0x0D	; col_commands?
	STR	r0, [r7, #8]	;  REM AT THE START MAKE COLOUR OK?
BeforeAllare8
	LDRVC	r0, [r11, #4]
	LDRVC	lr, [r12, #0]
	ADDVC	lr, lr, #0x015C	;  REM restore mode options on e_start
	STMVCFD	sp!, {lr}
	MOVVC	lr, pc
	LDMVCFD	sp!, {pc}
	LDR	r1, [r7, #0x0C]
	ADRL	r0, w_formmb
	STR	r1, [r0, #0x08]
	LDMFD	sp!, {r1, r6, r7, pc}


; ------------ e_end -------------

E_End	FNJSR	"R7"
	BL	ZapModeWord
	LDRVC	r0, [r11, #4]
	FNcallc	Zap_SaveModeWord,VC
	FNRTS

SDsasa
	DCD	0x1200004D

		; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
adrofrsix
	DCD	0

; general notes here:
;
; this seems to bear an enormous resemblance to MJE's assembler mode. Thus,
; we can guess at the register allocations:
;
; r0		current character
; r1		general purpose
; r2		colour
; r3		w_txtw
; r4		tab mode
; r5		apparent start
; r6		output pointer - if -ve, we're faking the bit of the logical
;				 line before the current physical line
; r7		input pointer
; r8/r9
; r10		split
; r11		line number
; r12		 0-7  cr
;		 8-11 flags
;		12-19 bpl
;		24-31 tab
; r14		current column
;
; thus [r6]		= output char
;      [r6,r3]		= fg colour
;      [r6,r3,lsl #1]	= bg colour

; ----------- e_redrawline ----------

; this start bit is the same as MJE's assembler mode
redrawline
	FNJSR	"R6,R12"
	STMFD	sp!, {r7, r11}
	STR	r6, adrofrsix
	BL	Branch208		; r11 = Data47 = module private workspace
	BL	ZapModeWord
	LDR	r2, [r7, #8]		;  REM Preserved start colour & flags (from previous line)
	LDR	r3, [r7, #0x0C]
	ADRL	r12, w_formmb
	STR	r3, [r12, #8]
	LDMFD	sp!, {r7, r11}		;  REM calls...
	LDR	r3, [r8, #w_txtw]	;  REM char width of cached line (x 8)
	LDRB	r12, [r8, #w_cr]	;  REM code of lf...?
	BIC	r2, r2, #0x700
	BIC	r2, r2, #0xFF
	ORR	r2, r2, #col_commands	; though I don't know why we start off in commands colour
	ORR	r2, r2, #0xF000		;  REM ! ; fe? ; ff000
	BIC	r2, r2, #0x00E00000	;  REM HERE? &0F000000
	LDR	r5, [r9, #f_ptr]	;  REM ?
	LDR	r10, [r9, #f_bufl]	;  REM ?
	ADD	r10, r10, r5		; point to end of file
	TEQ	r7, r10			; have we finished?
	FNRTS	EQ
	LDR	r10, [r9, #f_splite]	;  REM ?
	ADD	r10, r10, r5
	CMP	r7, r10			; are we past the split?
	MOVCC	r10, r5			; nope
	MOV	r6, #0
BitAftStart				; search back to the start of the logical line
	SUB	r6, r6, #1
	LDRB	r0, [r7], #-1
	TEQ	r0, r12			; cr?
	BEQ	UpToStart
	CMP	r7, r10			; at split?
	BCS	BitAftStart
	TEQ	r5, r10			; SOF
	LDRNE	r10, [r9, #f_splits]	; after split?
	SUBNE	r7, r7, r10
	MOVNE	r10, r5			; new end of section
	CMP	r7, r10			; skip it and try again
	BCS	BitAftStart
	SUB	R6,R6,#1		; cl fix
	SUB	R7,R7,#1		;
UpToStart				;
	ADDS	r6, r6, #2		;
	ADD	r7, r7, #2		;
	SUBPL	r7, r7, r6
	LDMPLFD	sp, {r6}
	TEQ	r5, r10
	LDREQ	r10, [r9, #f_splito]	; restore regs used while searching back
	ADDEQ	r10, r10, r5		;
	LDRNE	r10, [r9, #f_splits]	;
	ADDNE	r5, r5, r10		;
	LDRNE	r10, [r9, #f_len]	;
	ADDNE	r10, r10, r5		;
	LDRB	r0, [r8, #w_tabchar]	; tabchar
	ORR	r12, r12, r0, LSL #24
	LDR	r0, [r8, #w_bpl]	;  REM bytes per line / width of text
	ORR	r12, r12, r0, LSL #12
RtAtStrtA
	MOV	lr, #0			; column 0

RtAtStrtB				; main colouring loop
	CMP	r7, r10			;  at split?
	BCC	Branch13		; nope - ok
	LDR	r10, [r9, #f_len]
	ADD	r10, r10, r5
	CMP	r7, r10
	FNRTS	CS
	LDR	r1, [r9, #f_splits]	; load split size
	ADD	r7, r7, r1		; skip over it
	ADD	r5, r5, r1		;
	ADD	r10, r10, r1		;
Branch13
	LDRB	r0, [r7], #1		; REM get char
	AND	r1, r12, #0xFF		; get CR char
	EOR	r2, r2, #0x0400		; toggle newline flag for following tests
	TEQ	r0, r1			;
	TSTEQ	r2, #0x0400		; ...this one
	MOVEQ	R2,#col_commands	; clear flags & set colours for new logical line
	BEQ	RtAtStrtB
	BIC	r2, r2, #0x0400		; clear newline flag
	TEQ	r0, r1			; at CR?
	BEQ	BranchNL		; yes - skip this char

	; syntax colouring proper begins here

	CMP	r6, #0			; are we really doing a line?
	MOVGT	r1, #col_bg2		;
	STRGTB	r1, [r6, r3,LSL #1]	; yes - store bg col

	AND	r1, r2, #0xFF
	CMP	r1, #col_commands	; colouring a command?
	BEQ	BNL2			; store r6 and r7 in Sol6 and Sol7

Backhome				; here we start all the colouring checks
	AND	r1, r2, #0xFF		;
	CMP	r1, #col_comments	;
	BEQ	aftertestA		; no checks at all inside comments

	TEQ	r0, #'>'		; <...> colouring
	BEQ	GSTtestMO		;
GSTstop
	TEQ	r0, #')'		; (...) colouring
	TEQNE	r0, #'}'		;
	BEQ	GSTtestBO		;

GSTstopB
	CMP	r6, #0			;  REM Here begins the |G-type GStrans testing
	BGT	aftertestA	;  mon ok1
aftert7
	LDR	r1, Sol7
	ADD	r1, r1, #2
	CMP	r7, r1
	BLE	aftertestA		;  REM code never fires?
	LDRB	r1, [r7, #-2]		;  REM in hope
	CMP	r1, #'#'		; ...why?
	BEQ	AfterColour

aftertestA
	TEQ	r0, #'"'
	BEQ	QuoteBit
	AND	r1, r2, #0xFF
	CMP	r1, #col_commands
	CMP	r1, #col_comments
	BEQ	ComCodeRestart
	CMP	r1, #col_strings
	BEQ	BeforeColour
	TST	r2, #0x10000000		;  REM START OF LINE FLAG...
	BNE	NotatStart
	BIC	r2, r2, #0x40000000
	TEQ	r0, #'#'
	BEQ	CommentStart
NotatStart
	AND	r1, r2, #0xFF
	TEQ	r1, #col_rounds
	BEQ	BranchYYY
					; this does entirely the wrong thing

afterteststop
	AND	r1, r2, #0xFF
	TEQ	r1, #col_commands	; are we in commands?
	BICEQ	r2, r2, #0xFF
	ORREQ	r2, r2, #col_fg		; yes - revert to fg colour
	ANDEQ	r1, r2, #0xFF
	TEQ	r1, #col_fg		;
	TEQNE	r1, #col_numbers	;
	BNE	BeforeColour
	CMP	r0, #'9'
	RSBLSS	r1, r0, #'0'
	BLS	PreTisNum		; think we have a number
	AND	r1, r2, #0xFF
	TEQ	r1, #col_numbers	;
	BNE	NotANumber
	CMP	r0, #'9'
	RSBLSS	r1, r0, #'0'
	BICHI	r2, r2, #0xFF
	ORRHI	r2, r2, #col_fg		; now in numbers
	CMP	r0, #'%'
	BLE	NotANumber
	TEQ	r0, #'x'		; allow 0x20
	BEQ	TisANumber
	TEQ	r0, #'_'		; allow 2_00100000
	BEQ	TisANumber
	CMP	r1, #'@'
	BHI	NotANumber

TisANumber
	BIC	r2, r2, #0xFF
	ORR	r2, r2, #col_numbers
	TST	r2, #0x80000000
	BICNE	r2, r2, #0x90000000
	B	BeforeColour

NotANumber
	CMP	r0, #'_'
	BEQ	PlainNoOSChk
	CMP	r0, #128
	BCS	PlainNoOSChk
	CMP	r0, #'0'
	BCC	itsoknow	;  AfterCmdCntChk
	CMP	r0, #':'
	BCC	DontBother	;  itsoknow
	AND	r1, r0, #0xDF
	CMP	r1, #'Z'
	RSBLSS	r1, r1, #'A'
	BLS	PlainNoOSChk
itsoknow
	AND	r1, r2, #0xFF
	TEQ	r1, #col_comments
	TEQNE	r1, #col_strings
	BEQ	DontBother		; don't do table lookup if in comment or string
Bother
	STMFD	sp!, {lr}
	BL	TableChk2		;  REM **************************
	LDMFD	sp!, {lr}
	TEQ	r0, #'.'
	TEQEQ	r1, #0xEA00
	BEQ	AfterColour
	;TST	r2, #0x14000000		; SOL check removed 0.11 cl
	TEQ	r0, #'#'
	BEQ	CommentStart		;  REM bugs
DontBother
	TST	r2, #0x00E00000
	BNE	CmdCntChk
AfterCmdCntChk
	AND	r1, r2, #0xFF
	TEQ	r1, #col_comments
	BEQ	BeforeColour
	TEQ	r1, #col_fg
	BNE	SymbolChecking	;  REM  BR if not normal colour...
PlainNoOSChk
	CMP	r0, #'9'
	RSBLSS	r1, r0, #'/'	;  REM = asc "0"
	BICLS	r2, r2, #0xFF
	ORRLS	r2, r2, #col_fg
	BLS	BeforeColour

SymbolChecking				; check for misc punctuation
	CMP	r6, #0
	BLT	BeforeColour		; nothing to do here
	TEQ	r0, #':'
	TEQNE	r0, #'$'
	TEQNE	r0, #';'
	TEQNE	r0, #'^'
	TEQNE	r0, #'*'
	TEQNE	r0, #'.'
	TEQNE	r0, #'='
	TEQNE	r0, #'<'
	TEQNE	r0, #'>'
	TEQNE	r0, #'\'
	TEQNE	R0, #'@'		; new cl
	TEQNE	R0, #'%'		; new 0.07
	TEQNE	R0, #'-'		; new 0.07
	MOVEQ	r1, #col_punct
	STREQB	r1, [r6, r3]
	BEQ	AfterColour

BeforeColour
	TEQ	r0, #' '
	TEQNE	r0, r12, LSR #24	;  REM = tab?
	BEQ	TabbingSub
Branch24
	CMP	r6, #0
	BLE	firstpass		;  REM new addition to test
	ANDGT	r1, r2, #0x0F		;  REM write colours
	STRGTB	r1, [r6, r3]
AfterColour
	CMP	r6, #0
	STRGTB	r0, [r6], #1		; write char if in the line
firstpass
	ADD	lr, lr, #1		; next column
BeginOfEnd
	AND	r1, r12, #0xFF		;
	TEQ	r0, r1			; cr?
	BICEQ	r2, r2, #0x78000000	; start of line flags...
	CMP	r6, #0
	ADDLTS	r6, r6, #1
	BMI	RtAtStrtB
	LDMEQFD	sp, {r6}		; if now inside current physical line start
	BEQ	RtAtStrtA		; round loop using current colours
	AND	r1, r12, #0xFF		;
	TEQ	r0, r1			; cr?
	BEQ	tocheckbackwardsnow	; yes - ceck for commands at EOL

	ORRNE	r2, r2, #0x0400
backcheckbackwardsnow
	BIC	r1, r12, #0xFF000000	;  REM if not width...
	CMP	lr, r1, LSR #12		;  WIDTH
	BICLT	r2, r2, #0x0400
	BLT	RtAtStrtB		;  REM go round loop...
	BEQ	tohaveajollygoodtime
tohaveajollygoodback
	BIC	r0, r12, #0xFF000000
	CMP	lr, r0, LSR #12		;  width...?
	BICGE	r2, r2, #0x0400		;  REM NE
	AND	r0, r12, #0x0200
	ORR	r2, r2, r0
	LDMFD	sp!, {r6, r12}
	STMFD	sp!, {r7, r11}
	BL	Branch208
	BL	ZapModeWord
	STR	r2, [r7, #8]
	LDMFD	sp!, {r7, r11, pc}	;  REM on exit set things up r7...
fromslash
	CMP	r6, #0
	BLT	BeforeColour		;  REM BLT     BeforeColour%
	STRB	r1, [r6, r3]
	B	AfterColour
					;  REMB	      BeforeColour%
ComCodeRestart
	TEQ	r0, #'_'
	BEQ	AfterCmdCntChk
	AND	r1, r0, #0xDF
	CMP	r1, #'Z'
	RSBLSS	r1, r1, #'@'
	BLS	AfterCmdCntChk
	B	itsoknow

CmdCntChk
	CMP	r0, #32
	BNE	AfterCmdCntChk
	CMP	r6, #0
	BGT	r6version
	CMP	r6, #0
	MOVLE	r1, #10
	LDRGTB	r1, [r7, #-2]		;  REM danger
overdangerperhaps
	CMP	r1, #32
	BEQ	AfterCmdCntChk
	MOV	r1, r2, LSR #21
	AND	r1, r1, #7
	SUBS	r1, r1, #1
	BICEQ	r2, r2, #0x10000000
	BIC	r2, r2, #0x00E00000
	ORR	r2, r2, r1, LSL #21
	B	AfterCmdCntChk

r6version
	LDR	r1, Sol6	;  REM 13/10
	SUB	r1, r1, #1
	CMP	r6, r1	;  REM 13/10
	LDRGTB	r1, [r6, #-1]	;  REM 13/10
	BGT	overdangerperhaps	;  REM 13/10
	MOV	r1, #' '
	B	AfterCmdCntChk	;  REM 13/10

BranchNL
	AND	r1, r2, #0xFF
	TEQ	r1, #col_comments
	TEQNE	r1, #col_strings
	BEQ	DontBother2
Bother2
	STMFD	sp!, {lr}
	BL	TableChk2	;  REM swap with sect below?;;;
	LDMFD	sp!, {lr}
DontBother2
	MOV	lr, #0x70000000	;  REM	      ;;Jeez, what a mess!;;
	B	BeginOfEnd

; called when we are in col_commands colour at start of line
BNL2
	BIC	r2, r2, #0x10000000	;  REM START OF LINE FLAGS SET...
	STR	r6, Sol6
	SUB	r1, r7, #1
	STR	r1, Sol7
	B	Backhome

; called when we think we have a number
PreTisNum
	CMP	r6, #0			; can't tell,
	BLT	TisANumber		; so guess we have
	LDRB	r1, [r6, #-1]
	CMP	r1, #' '		; " 0"
	BEQ	TisANumber
	TEQ	r1, #'.'		; ".0"
	TEQNE	r1, #':'
	TEQNE	r1, #'-'
	BNE	BeforeColour
	ADD	r1, r6, r3
	LDRB	r1, [r1, #-1]		; load previous fg colour
	;AND	r1, r1, #0x0F
	CMP	r1, #col_numbers
	BEQ	TisANumber
	BIC	r2, r2, #0xFF
	ORR	r2, r2, #col_fg
	B	BeforeColour

Sol6	DCD	0
Sol7	DCD	0

; called when we are in ( ... ) sequence (?)
BranchYYY
	CMP	r6, #0
	BLT	BeforeColour		; can't tell
	CMP	r0, #'9'
	RSBLSS	r1, r0, #'0'
	MOVLS	r1, #col_numbers
	STRLSB	r1, [r6, r3]
	BLS	AfterColour
	LDR	r1, Sol7
	ADD	r1, r1, #2
	CMP	r7, r1
	MOVLE	r1, #10
	LDRGTB	r1, [r7, #-2]		;  REM danger
	TEQ	r0, #'.'		;  REM if in number
	BNE	TryNextA
	CMP	r1, #'9'
	BGT	TryNextA
	CMP	r1, #'0'
	BLT	TryNextA
	MOV	r1, #col_numbers
	STRB	r1, [r6, r3]
	B	AfterColour

TryNextA
	TEQ	r0, #'_'		;  REM if in number
	BNE	BeforeColour
	CMP	r1, #'9'
	BGT	BeforeColour
	CMP	r1, #'0'
	BLT	BeforeColour
	MOV	r1, #col_numbers
	STRB	r1, [r6, r3]
	B	AfterColour


	; --------------------------


; <...> colouring
localrtadr
	DCD	0

GSTtestMO
	MOV	r1, #0
GSTtest
	STR	r1, localrtadr
	CMP	r6, #0
	BLT	GSTstop
	STMFD	sp!, {r0, r2, r4, r5}
	AND	r1, r2, #0xFF	; extract colour
	TEQ	r1, #col_strings
	TEQNE	r1, #col_comments
	BEQ	notaGSTSequence
	MOV	r4, r7
	MVN	r0, #0
GSTchklp
	SUB	r0, r0, #1
	ADD	r5, r4, r0
	LDR	r1, [r9, #f_ptr]
	CMP	r5, r1
	BCC	notaGSTSequence
	LDR	r2, [r9, #f_splito]
	ADD	r2, r1, r2
	CMP	r5, r2
	BCC	inbothalfalread
	LDR	r2, [r9, #f_splite]
	ADD	r2, r1, r2
	CMP	r5, r2
	LDRCC	r5, [r9, #f_splits]
	SUBCC	r4, r4, r5
inbothalfalread
	LDRB	r1, [r4, r0]
		; CMP	  R1,#09     : ;BEQ GSTchklp
	CMP	r1, #'>'
	BEQ	notaGSTSequence
	CMP	r1, #' '
	BLT	notaGSTSequence
	CMP	r1, #'"'
	BEQ	notaGSTSequence
	CMP	r1, #127
	BGT	notaGSTSequence
	CMP	r1, #'<'
	BNE	GSTchklp
BACKInEntity
	MOV	r1, #0x0E
	ADD	r5, r6, r3
	ADD	r0, r0, #1
	ADD	r4, r6, r0
	LDR	r2, adrofrsix
	CMP	r4, r2
	STRCSB	r1, [r5, r0]
	ADD	r0, r0, #1
	MOV	r1, #col_angles
	CMN	r0, #0
	BEQ	GupSAway
roundAloop
	ADD	r4, r6, r0
	CMP	r4, r2
	STRCSB	r1, [r5, r0]
	ADD	r0, r0, #1
	CMP	r0, #0
	BLT	roundAloop
GupSAway
	MOV	r1, #col_punct
	ADD	r4, r6, r0
	CMP	r4, r2
	STRCSB	r1, [r5, r0]
	LDMFD	sp!, {r0, r2, r4, r5}
	BCC	AfterColour
	LDR	r1, localrtadr
	CMP	r1, #0
	BEQ	AfterColour
	B	secondendofGST
notaGSTSequence
	LDMFD	sp!, {r0, r2, r4, r5}
	LDR	r1, localrtadr
	CMP	r1, #0
	BEQ	GSTstop
	B	secondendofGST

	; --------------------------


; called when we have found a ')' - check backwards for a corresponding '('
; with R1 = 0 if we should return to AfterColour or 1 for secondendofGSTB
GSTtestBO
	MOV	r1, #0
GSTtestB
	STR	r1, localrtadr			; don't check bacwards if we're before
	CMP	r6, #0				; the start of a physical line
	BLT	GSTstopB			;
	STMFD	sp!, {r0, r2, r4, r5}
	AND	r1, r2, #0xFF			; don't do matching if inside a
	TEQ	r1, #col_strings		; string or a comment
	TEQNE	r1, #col_comments		;
	BEQ	notaGSTSequenceB		;
	MOV	r4, r7
	MVN	r0, #0
GSTchklpB
	SUB	r0, r0, #1
	ADD	r5, r4, r0
	LDR	r1, [r9, #f_ptr]		; fallen off the start of the file
	CMP	r5, r1				;
	BCC	notaGSTSequenceB		;

	LDR	r2, [r9, #f_splito]		; skip the split
	ADD	r2, r1, r2			;
	CMP	r5, r2				;
	BCC	inbothalfalreadB		;
	LDR	r2, [r9, #f_splite]		;
	ADD	r2, r1, r2			;
	CMP	r5, r2				;
	LDRCC	r5, [r9, #f_splits]		;
	SUBCC	r4, r4, r5			;

inbothalfalreadB
	LDRB	r1, [r4, r0]
	CMP	r1, #' '
	BLT	notaGSTSequenceB
	TEQ	r1, #')'
	TEQNE	r1, #'}'
	;TEQNE	r1, #'"'			; is this necessary? we'll be in
						; strings colour for this to be
						; true, surely?
	BEQ	notaGSTSequenceB
	CMP	r1, #127
	BGT	notaGSTSequenceB
	CMP	r1, #'('
	TEQNE	r1, #'{'
	BNE	GSTchklpB
	CMN	r0, #2
	BCS	GSTchklpB

	SUB	R0,R0,#1			; here we've got (...) - check for $
	ADD	r5, r4, r0			;
	LDR	r1, [r9, #f_ptr]		; fallen off the start of the file
	CMP	r5, r1				;
	BCC	notaGSTSequenceB		;
	LDR	r2, [r9, #f_splito]		; skip the split
	ADD	r2, r1, r2			;
	CMP	r5, r2				;
	BCC	bottom$l			;
	LDR	r2, [r9, #f_splite]		;
	ADD	r2, r1, r2			;
	CMP	r5, r2				;
	LDRCC	r5, [r9, #f_splits]		;
	SUBCC	r4, r4, r5			;
bottom$l
	LDRB	r1, [r4, r0]			;
	TEQ	R1,#'$'				;
	BNE	notaGSTSequenceB		;

	MOV	r1, #col_rounds			; OK, we've found a $(...), so colour it
	ADD	r5, r6, r3			;
	ADD	r0, r0, #2			; was 1
	LDR	r2, adrofrsix			;

	;ADD	r4, r6, r0			; commented out 0.05 - it's the
	;CMP	r4, r2				; same as in the loop below
	;STRCSB	r1, [r5, r0]			;
	;ADD	r0, r0, #1			;
	;;MOV	r1, #col_rounds			;
	;CMN	r0, #0				;
	;BEQ	GupSAwayB			;
roundAloopB
	ADD	r4, r6, r0
	CMP	r4, r2
	STRCSB	r1, [r5, r0]
	ADD	r0, r0, #1
	CMP	r0, #0
	BLT	roundAloopB
GupSAwayB
	;MOV	r1, #col_rounds	;  ?
	ADD	r4, r6, r0
	CMP	r4, r2
	STRCSB	r1, [r5, r0]
	LDMFD	sp!, {r0, r2, r4, r5}
	BCC	AfterColour
	LDR	r1, localrtadr
	CMP	r1, #0
	BEQ	AfterColour
	B	secondendofGSTB
notaGSTSequenceB
	LDMFD	sp!, {r0, r2, r4, r5}
	LDR	r1, localrtadr
	CMP	r1, #0
	BEQ	GSTstopB
	B	secondendofGSTB

	; -------------------------


; called when we have a '#'
CommentStart
	LDR	r1, Sol7
	ADD	r1, r1, #1
	CMP	r7, r1
	BEQ	sokinkeysfile
	LDR	r1, [r9, #f_ptr]
	ADD	r1, r1, #2
	CMP	r7, r1
	LDRCSB	r1, [r7, #-2]	;  check for \|...  why?
	CMP	r1, #'\'
	BEQ	BeforeColour
sokinkeysfile
	AND	r1, r2, #0xFF
	CMP	r1, #col_strings	;  REM in quotes?
	BICNE	r2, r2, #0xFF
	ORRNE	r2, r2, #col_comments
	ORRNE	r2, r2, #0x10000000
	B	BeforeColour


; called when we see a "
QuoteBit
	AND	r1, r2, #0xFF
	CMP	r1, #col_comments	; ignore strings in comments
	BEQ	BeforeColour
	AND	r1, r2, #0xFF
	TEQ	r1, #col_strings
	BICNE	r2, r2, #0xFF
	ORRNE	r2, r2, #col_strings
	BNE	BeforeColour
	CMP	r6, #0
	STRGTB	R2,[R6,R3]		; store string colour under terminating "
	BIC	R2,R2,#&FF
	ORR	R2,R2,#col_fg
	B	AfterColour


; tab
TabbingSub
	AND	r1, r2, #0xF
	TEQ	r1, #col_commands
	TEQNE	r1, #col_angles
	ORREQ	r2, r2, #0x0100
	AND	r1, r4, #0x3000		; get tab mode
	TEQ	r1, #0
	TEQEQ	r0, r12, LSR #24
	BEQ	AfterColour
	TEQ	r0, #' '
	BEQ	Branch24
	CMP	r6, #0
	BLT	BeginOfEnd
	MOV	r0, #9			;  tab arrow -> char
	TEQ	r1, #0x1000
	MOVEQ	r0, #' '
	TEQ	r1, #0x3000
	MOVEQ	r0, #'-'
TabLoop
	MOV	r1, #col_controls	; tabs are ctl characters
	STRB	r1, [r6, r3]		; fg
	MOV	r1, #col_bg2
	STRB	r1, [r6, r3,LSL #1]	;  REM wrong?
	STRB	r0, [r6], #1		; store displayed char
	ADD	lr, lr, #1		; next column
	AND	r1, r4, #0x3000
	TEQ	r1, #0x2000
	MOVEQ	r0, #' '
	BIC	r1, r12, #0xFF000000
	TEQ	lr, r1, LSR #12		; last column in window?
	TSTNE	lr, #7			; or reached multiple of 8?
	BNE	TabLoop			; nope
	AND	r0, r4, #0x3000
	TEQ	r0, #0x3000
	MOVEQ	r0, #9			; -----> - now tab char
	STREQB	r0, [r6, #-1]		; so store it
	MOV	r0, r12, LSR #24	; get tab char
	B	BeginOfEnd


;------------- e_prevline -------------

redrawA
	SUBS	r0, r0, #32
	MOVMI	r0, #0
	MOV	pc, lr



; -------- command table lookup --------
beginnchar
	DCD	0			; first char
storedr6flu
	DCD	0
cntcharback
	DCD	0
fullstopsofar
	DCD	0
storedR8
	DCD	0
storedR9
	DCD	0

fullstopspeccase
	LDR	r1, fullstopsofar
	CMP	r1, #0
	ADDEQ	r1, r1, #1
	STREQ	r1, fullstopsofar
	MOV	r1, #'.'
	BEQ	tcloop
	B	notanumberbackedonto

splchkforminus				; called from table search
	ADD	r4, r8, r11
	SUB	R4,R4,#1
	LDR	r1, [r9, #f_ptr]
	LDR	r12, [r9, #f_splito]
	ADD	r12, r1, r12
	CMP	r4, r12
	BCC	inbothalfTC2a
	LDR	r12, [r9, #f_splite]
	ADD	r12, r1, r12
	CMP	r4, r12
	LDRCC	r1, [r9, #f_splits]
	SUBCC	r4, r4, r1
inbothalfTC2a
	LDR	r1, [r9, #f_ptr]
	CMP	r4, r1
	BCC	notANYone
	LDRB	r1, [r4]
	CMP	r1, #32			; make sure ' ' before any '-'
	BGT	tcloop
	MOV	r1, #'-'
	B	notanumberbackedonto

; E r6 -> output buffer  r7 -> input buffer
;
TableChk2
	STR	r6, storedr6flu
	STR	R8,storedR8
	STR	R9,storedR9
	FNJSR	"R4-R12"
	MOV	r1, #0
	STR	r1, fullstopsofar
	MOV	r8, r7			; r8 = current input
	LDR	r1, [r9, #f_ptr]
	LDR	r12, [r9, #f_splito]
	ADD	r12, r1, r12
	CMP	r8, r12
	BCC	ploughonin
	LDR	r12, [r9, #f_splite]
	ADD	r12, r1, r12
	CMP	r8, r12
	LDRCC	r1, [r9, #f_splits]	; skip the split if we're inside it
	ADDCC	r8, r8, r1
ploughonin
	MVN	r11, #0			; -1
tcloop
	SUB	r11, r11, #1		; -2
	ADD	r4, r8, r11
	LDR	r1, [r9, #f_ptr]
	LDR	r12, [r9, #f_splito]
	ADD	r12, r1, r12
	CMP	r4, r12
	BCC	inbothalfTC2
	LDR	r12, [r9, #f_splite]
	ADD	r12, r1, r12
	CMP	r4, r12
	LDRCC	r1, [r9, #f_splits]
	SUBCC	r4, r4, r1
inbothalfTC2
	LDR	r1, [r9, #f_ptr]
	CMP	r4, r1
	BCC	notanumberbackedonto
	LDRB	r1, [r4]		; return bug: this gives us cr on first try
	CMP	r1, #'|'
	CMPNE	r1, #']'
	CMPNE	r1, #'['
	CMPNE	r1, #'}'
	CMPNE	r1, #'{'
	CMPNE	r1, #'@'
	BGT	tcloop

rightatverystart			; check first char is acceptable
	TEQ	r1, #'.'
	BEQ	fullstopspeccase
	TEQ	r1, #'+'
	BEQ	tcloop
	TEQ	r1, #'@'
	TEQNE	r1, #':'		;  REM ok as in C:h.foo
	BEQ	notanumberbackedonto
	TEQ	r1, #'-'
	BEQ	splchkforminus		; make sure there's a ' ' before a '-'
	CMP	r1, #'0'
	BCC	notanumberbackedonto
	CMP	r1, #':'
	BCC	tcloop			; keep going...
		; .gothrough
	CMP	r1, #' '
	BGT	notANYone

notanumberbackedonto
	STR	r1, beginnchar		; keep char /before/ first char to look up
	ADD	r11, r11, #1		; return bug: -1
	ADD	r4, r8, r11		; r4 = start address
	ADD	r11, r11, #1		; return bug: 0
	RSBS	r1, r11, #0		; r1 is number of chars gone back ( =0 )
	BEQ	notANYone		; 0 chars to check in table...
	STR	r1, cntcharback
	LDR	r1, [r9, #f_ptr]
	CMP	r4, r1
	BCC	notANYone		; not in file
	LDR	r12, [r9, #f_splito]
	ADD	r12, r1, r12
	CMP	r4, r12
	BCC	inbothalfTC3
		;  What on earth is this trying to do?
		;  We've got rid of all things below the split -
		;  now, if we're below the split end, we lop off the split size.
		;  Huh? I could understand CS not CC (address -> offset), but
		;  this doesn't make much sense ... however we load directly
		;  from R4 in a minute (LDRB R1,[R4] in inbothalfTC3), so
		;  we don't even want an offset - we want a valid address.
		;  Anything in the split is invalid anyway, so we should either
		;  be going to notANYone (as for < f_ptr, above) or we should
		;  re-adjust to the start of the second part of the buffer.
		;  Which?
		;  Note that there are a few similar points above ...

		; this code is called because we've been searching backwards through
		; the file to find the start of the word. Now we have counted the size
		; of the word and subtracted that from the starting point, so we could end up
		; in the middle of the split. We subtract the split size to cater for that.
		; CC is right because we're going /backwards/ through the split.
	LDR	r12, [r9, #f_splite]
	ADD	r12, r1, r12
	CMP	r4, r12			; in the split?
	LDRCC	r5, [r9, #f_splits]
	SUBCC	r4, r4, r5

inbothalfTC3
	LDRB	r1, [r4]
	FNupper	r1
	CMP	r1, #'A'		; check first char is in table
	BLT	notANYone               ;
	CMP	r1, #'Z'                ;
	BGT	notANYone               ;
	SUB	r1, r1, #'A'		; point to first entry in table starting with
	ADRL	r12, AlphaIndex         ; this letter
	ADD	r1, r12, r1, LSL #2     ;
	LDR	r1, [r1]                ;
	ADRL	r12, TableHere          ;
	ADD	r12, r12, r1            ;

lpa2					; main loop per table entry
	MOV	r8, #0
lpa1					; main loop per table char
	LDRB	r1, [r12, r8]		; load char from table
	CMP	r1, #'z'
	MOVGT	r10, r8
	BGT	gotexactmatch		; table finished - found it
	MOV	r7, r1
	ADD	r5, r4, r8              ; rather inefficient skipping of split
	LDR	r1, [r9, #f_ptr]        ; which doesn't corrupt r4
	LDR	lr, [r9, #f_splito]     ;
	ADD	lr, r1, lr              ;
	CMP	r5, lr                  ;
	BCC	inbothalfTC4            ;
	LDR	lr, [r9, #f_splite]     ;
	ADD	lr, r1, lr              ;
	CMP	r5, lr                  ;
	LDRCC	r1, [r9, #f_splits]     ;
	ADDCC	r5, r5, r1              ;
inbothalfTC4
	LDRB	r1, [r5]		; load char from file
	FNlower	r1			; case insensitive
	CMP	R1,#' '			; allow any ctrls as the command terminator
	MOVLO	R1,#' '                 ;
tabovr1
	ADD	r8, r8, #1		; next table entry
	CMP	r7, r1			; same?
	;BGT	bigger1			; no -
	BGT	couldnotfindit
	BEQ	lpa1
;maybenot
	ADD	r12, r12, r8		; skip to current table char
	SUB	r12, r12, #1
_altered_0
	LDRB	r1, [r12], #1		; skip to next table entry
	CMP	r1, #'z'
	BLE	_altered_0
	LDRB	r1, [r12]
	CMP	r1, #'*'		; exhausted table?
	BNE	lpa2

couldnotfindit				; not found in table
	RSB	r8, r11, #0
	ORR	r2, r2, #0x10000000	;  SOL ...? no brackets...!
	BIC	r2, r2, #0x40000000	;  a command yet flags...

	LDR	r1, beginnchar		; first char to find
	TEQ	r1, #'-'		; option/switch
	SUBEQ	R11,R11,#1
	LDREQ	R1,cntcharback
	ADDEQ	R1,R1,#1
	STREQ	R1,cntcharback
	MOVEQ	r1, #col_switches
	BEQ	ChooseColour2
	;  deliberate fall through...
notANYone
	FNRTS

;bigger1
;	CMP	r8, #1
;	BEQ	couldnotfindit
;	B	maybenot


Prefixbit
	RSB	r10, r11, #0
	CMP	r1, #'.'
	ADDEQ	r10, r10, #1
	TEQ	r9, #com_cfile
	MOVEQ	r1, #col_cfile
	TEQ	r9, #com_header
	MOVEQ	r1, #col_header
	TEQ	r9, #com_object
	MOVEQ	r1, #col_object
	TEQ	r9, #com_assembler
	MOVEQ	r1, #col_assembler
	B	ChooseColour2

gotexactmatch
	ORR	r2, r2, #0x40000000	;  a command yet flags...
	ORR	r2, r2, #0x10000000	;  START OF LINE FLAG...
	BL	CheckRoutine
	TEQ	r9, #com_cfile
	TEQNE	r9, #com_header
	TEQNE	r9, #com_object
	TEQNE	r9, #com_assembler
	BEQ	Prefixbit

	LDR	R1,beginnchar		; commands only coloured as such
        TEQ	R1,#'-'			;
        BEQ	minusfirst$l		;
	TEQ	R1,#9			; if preceeded by ' ' '->' or '@'
	TEQNE	R1,#' '			; consider !Run
	TEQNE	R1,#'@'			;
	TEQNE	R1,#'%'			; for aliases
	FNRTS	NE
	TEQ	r9, #com_morecmds
	MOVEQ	r1, #col_morecmds	;  gerph style...
	MOVNE	r1, #col_commands

ChooseColour2
	LDR	r9, storedr6flu         ; before the start of the physical line
	CMP	r9, #0                  ;
	BLE	notANYone               ;
	AND	r9, r2, #0xFF		; don't colour commands if in strings or comments
	CMP	r9, #col_numbers	;
	CMPNE	r9, #col_strings        ;
	BEQ	notANYone               ;
	ADD	r9, r6, r3
	LDRB	r9, [r9, r11]		;  REM QUICK FIX...
	CMP	r9, #col_strings	;
	FNRTS	EQ                      ;
	MOV	r9, #0
	ADD	r7, r6, r11             ; r6 = output buffer, r11 = number of chars back (-ve)
	ADD	r6, r7, r3		; r3 = w_txtw
	LDRB	r5, [r6, r9]
	CMP	r5, #col_strings
	FNRTS	EQ
	LDR	r11, adrofrsix
lasdwA
	ADD	r4, r7, r9
	CMP	r4, r11
	BCC	beforesolhereargh	; off the start of the line
lasdwA1
	ADD	r4, r7, r9
	CMP	r4, r11
	STRCSB	r1, [r6, r9]
beforesolhereargh
	ADD	r9, r9, #1
	LDR	r4, cntcharback
	CMP	r9, r4
	FNRTS	CS
	CMP	r9, r8
	BLT	lasdwA
	CMP	r9, r10
	BLT	lasdwA1
	MOV	r1, #0xEA00
colouringrapidexit
	FNRTS

; ---- checking for - before commands ----
					; we had a minus first - check it's
minusfirst$l			        ; preceeded by whitespace or ';'
	PUSH	"R8,R9"			; keep current colour
	LDR	R8,storedR8
	LDR	R9,storedR9
	LDR	R14,[R8,#w_cr]		;
	AND	R14,R14,#&FF            ;
        SUB	R4,R4,#1
minusloop$l
        SUB	R4,R4,#1
	LDR	r1, [r9, #f_ptr]
	CMP	r4, r1
	BCC	iscommand$l		; off the start of the file - it is a command
	LDR	r12, [r9, #f_splito]
	ADD	r12, r1, r12
	CMP	r4, r12
	BCC	bothalfminus$l
	LDR	r12, [r9, #f_splite]
	ADD	r12, r1, r12
	CMP	r4, r12			; in the split?
	LDRCC	r5, [r9, #f_splits]
	SUBCC	r4, r4, r5
bothalfminus$l
        LDRB	R1,[R4]
        TEQ	R1,#' '
        TEQNE	R1,#9
        BEQ	minusloop$l
        TEQ	R1,R14
        TEQNE	R1,#';'
        BNE	isntcommand$l

iscommand$l
	PULL	"R8,R9"
	TEQ	R9,#com_morecmds
	MOVEQ	R1,#col_morecmds
	MOVNE	R1,#col_commands
	B	ChooseColour2

isntcommand$l
	LDR	R1,cntcharback		; colour the '-' as well
	ADD	R1,R1,#1                ;
	STR	R1,cntcharback          ;
	SUB	R11,R11,#1		;
	MOV	R1,#col_switches
	PULL	"R8,R9"
	B	ChooseColour2




CheckRoutine
	ADD	r1, r12, r8
	SUB	r1, r1, #1
_altered_1
	LDRB	r9, [r1], #1
	CMP	r9, #'z'
	BLE	_altered_1
NotAThen
	BIC	r2, r2, #0x08000000
	MOV	pc, lr

Data47	DCD	0

Branch208
	LDR	r11, Data47
	MOV	pc, lr



; --------- e_char -----------

charchar
	STMFD	sp!, {lr}
	MOV	r1, #0
FromMJE4
	CMP	r1, r5
	BGE	FromMJE5
	LDRB	r0, [r7, r1]
	TEQ	r0, #'>'
	TEQNE	r0, #')'
	TEQNE	r0, #'}'
	TEQNE	r0, #'.'
	ADDNE	r1, r1, #1
	BNE	FromMJE4
	CMP	r5, #2
	ADDCS	r1, r1, #1
	BCS	FromMJE4
	BL	FromMJE6
	SUB	r5, r5, r1
	ADD	r7, r7, r1
	TEQ	r0, #'>'
	BLEQ	FromMJE9
	TEQ	r0, #')'
	BLEQ	FromMJE10
	TEQ	r0, #'}'
	BLEQ	FromMJE10C
	TEQ	r0, #'.'
	BLEQ	Abbreviation
	SUB	r5, r5, #1
	ADD	r7, r7, #1
	MOV	r1, #0
	B	FromMJE4
FromMJE5
	BL	FromMJE6
	LDMFD	sp!, {pc}
FromMJE6
	CMP	r1, #0
	MOVLE	pc, lr
	STMFD	sp!, {r1-r10, lr}
	MOV	r5, r1
	MOV	r9, #Zap_CallMode
	BL	FromMJE27
	LDMFD	sp!, {r1-r10, pc}
FromMJE9
	STMFD	sp!, {r1-r10, lr}
	LDR	r0, [r10, #12]
	MOV	r1, #'<'
	MOV	r2, #'>'
	BL	FromMJE18
	BLEQ	FromMJE11
	MOV	r5, #1
	MOV	r9, #Zap_CallMode
	BL	FromMJE27
	LDMFD	sp!, {r1-r10, pc}
FromMJE10
	STMFD	sp!, {r1-r10, lr}
	LDR	r0, [r10, #12]
	MOV	r1, #'('
	MOV	r2, #')'
	BL	FromMJE18
	BLEQ	FromMJE11
	MOV	r5, #1
	MOV	r9, #Zap_CallMode
	BL	FromMJE27
	LDMFD	sp!, {r1-r10, pc}
FromMJE10C
	STMFD	sp!, {r1-r10, lr}
	LDR	r0, [r10, #12]
	MOV	r1, #'{'
	MOV	r2, #'}'
	BL	FromMJE18
	BLEQ	FromMJE11
	MOV	r5, #1
	MOV	r9, #Zap_CallMode
	BL	FromMJE27
	LDMFD	sp!, {r1-r10, pc}


; command abbrrviation
Abbreviation
	STMFD	sp!, {r0-r12, lr}
	MOV	r0, #0x81		; check for escape?
	MOV	r1, #0x8F               ;
	MOV	r2, #0xFF               ;
	SWI	XOS_Byte                ;
	BCS	asnormaldot
	ADRL	r0, w_formmb		; check Complete is ticked
	LDR	r0, [r0, #0x08]         ;
	TST	r0, #(1 << 25)          ;
	BEQ	asnormaldot             ;
	MOV	r0, #0
	STR	r0, startslash
	;STR	r0, isentity
	LDR	r0, [r10, #12]
	SUB	lr, r0, #1
	STR	lr, storedofsofeow
	MOV	r1, #'('
		; MOV	  R2,#ASC"?"
	BL	checkbackone
	BEQ	firstabbrev

asnormaldot
	MOV	r5, #1
	MOV	r9, #Zap_CallMode
	BL	FromMJE27
	LDMFD	sp!, {r0-r12, pc}

beepandexit
		;  REM stop full
	LDMFD	sp, {r0-r12, lr}
	ADR	r7, insstrtst
	MOV	r5, #1
	MOV	r9, #Zap_CallMode
	BL	FromMJE27
realbeepandexit
		; SWI	  &107
	LDMFD	sp!, {r0-r12, pc}

firstabbrev
	ADRL	r0, TableHere
		; LDR	  0,locoftablethree
	LDR	r1, storedofsofsow
	LDR	r2, storedofsofeow
	SUB	r2, r2, r1
	ADRL	r3, AlphaIndex
	BL	getadrofabrcmd
		;  REM returns adress in r7, length in r5.
	BEQ	beepandexit
	LDR	r1, inshash
	LDR	r2, delhash
	ADD	r2, r2, #1
	CMP	r1, r2
	BLE	beepandexit
	B	insrtstfhre

insrtstfhre
	MOV	r2, #31	;  max value
	ADR	r3, deldatahere
	ADRL	r5, w_formmb
	LDR	r5, [r5, #0x08]
_altered_2
	LDRB	r1, [r7, r2]
	STRB	r1, [r3, r2]
	SUBS	r2, r2, #1
	BPL	_altered_2
	FNcall	Zap_StartOp
	LDR	r2, delhash
	ADD	r2, r2, #1
	LDR	r1, storedofsofsow
	MOV	r0, #0x2
	FNcall	Zap_Command
	LDR	r2, inshash
	ADR	r3, deldatahere
	LDR	r1, storedofsofsow
	MOV	r0, #0x1
	FNcall	Zap_Command

	FNcall	Zap_StopOp
	LDMFD	sp!, {r0-r12, pc}

deldatahere
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0

insstrtst
	=	"...."

; table lookup for abbreviations
; E r0 -> table  r2 = length of word?  r3 -> table index
getadrofabrcmd
	STMFD	sp!, {r8-r12, lr}
	MOV	r6, r3
	MOV	r3, r0
	MOV	r4, r1
	MOV	r5, r2
	MOV	r0, r4
	BL	FromMJE29		; get a char
	FNupper	r0
	CMP	r0, #'A'
	BLT	rapidleaving
	CMP	r0, #'Z'
	BGT	rapidleaving
	SUB	r0, r0, #'A'		; get table offset of 1st table entry
	ADD	r11, r6, r0, ASL #2
	LDR	r11, [r11]
	ADD	r11, r11, r3		; get address of 1st entry

_altered_3				; loop per
	MVN	r12, #0
_altered_4
	ADD	r12, r12, #1
	ADD	r0, r4, r12
	BL	FromMJE29
	FNlower	R0
	MOV	r2, r0
findnextincc
	LDRB	r1, [r11, r12]
	CMP	r1, #'{'		; found it
	BCS	fndcmdend2
	FNlower	R1
	CMP	r1, r2
	BNE	fndcmdend
dontcomparejn
	CMP	r12, r5			; got as far as the .?
	BLT	_altered_4
	STR	r12, delhash
	MOV	r7, r11
	MOV	r12, #0

loop4
	ADD	r12, r12, #1
	LDRB	r1, [r11, r12]
	CMP	r1, #' '
	CMPNE	r1, #'{'
	BLT	loop4
	CMP	r1, #' '
	ADDEQ	r11, r11, r12
	LDREQB	r1, [r11, #1]
	STR	r1, endtermhere
	STR	r12, inshash
	MOVS	r5, #8
	LDMFD	sp!, {r8-r12, pc}

fndcmdend
	MOV	r0, r2
	FNlower	R0
	FNlower	R1
	CMP	r0, r1
	BEQ	loop3
	CMP	r12, #0
	BEQ	rapidleaving

loop3					; find next entry
	ADD	r12, r12, #1
	LDRB	r1, [r11, r12]
	CMP	r1, #'{'
	BCC	loop3

fndcmdend2
	ADD	r12, r12, #1
	ADD	r11, r11, r12
	B	_altered_3
rapidleaving
	MOVS	r5, #0
	LDMFD	sp!, {r8-r12, pc}


; cursor bracket matching
FromMJE11
	STMFD	sp!, {r0-r7, lr}
	LDR	r4, [r10, #12]
	STR	r0, [r10, #12]
	LDR	lr, [r12, #0]
	ADD	lr, lr, #Zap_ReflectCaret
	STMFD	sp!, {lr}
	MOV	lr, pc
	LDMFD	sp!, {pc}
	SWI	XOS_ReadMonotonicTime
	MOV	r3, r0
	BL	FromMJE26
	ADD	r3, r3, r0
FromMJE12
	MOV	r0, #0x98
	MOV	r1, #0
	SWI	XOS_Byte
	BCC	FromMJE13
	SWI	XOS_ReadMonotonicTime
	CMP	r0, r3
	BLT	FromMJE12
FromMJE13
	STR	r4, [r10, #12]
	LDR	lr, [r12, #0]
	ADD	lr, lr, #Zap_ReflectCaret
	STMFD	sp!, {lr}
	MOV	lr, pc
	LDMFD	sp!, {pc}
	LDMFD	sp!, {r0-r7, pc}
FromMJE18
	STMFD	sp!, {r3, r4, lr}
	MOV	r3, r0
	MOV	r4, #1
_altered_5
	SUBS	r3, r3, #1
	BLT	FromMJE20
	MOV	r0, r3
	BL	FromMJE29
	TEQ	r0, r2
	ADDEQ	r4, r4, #1
	BEQ	_altered_5
	CMP	r2, #'>'
	TEQEQ	r0, #' '
	BEQ	FromMJE20a
	TEQ	r0, r1
	BNE	_altered_5
	SUBS	r4, r4, #1
	BNE	_altered_5
FromMJE20
	MOV	r0, r3
	LDMFD	sp!, {r3, r4, pc}
FromMJE20a
	MOVS	r0, #1
	LDMFD	sp!, {r3, r4, pc}
FromMJE20b
	MOVS	r0, #0
	LDMFD	sp!, {r3, r4, pc}
storedofsofsow
	DCD	0
storedofsofeow
	DCD	0
delhash
	DCD	0
inshash
	DCD	0
endtermhere
	DCD	0
startslash
	DCD	0
;isentity
;	DCD	0



checkbackone
	STMFD	sp!, {r3, r4, lr}
	SUB	r3, r0, #1
_altered_6
	STR	r3, storedofsofsow
	SUBS	r3, r3, #1
	BLT	FromMJE20b
	MOV	r0, r3
	BL	FromMJE29
	CMP	r0, #'@'
	BLE	FromMJE20b
	TEQ	r0, r1
	BNE	_altered_6
	B	FromMJE20
fndspaloc
	DCD	0
checkbacktwo
	STMFD	sp!, {r3, r4, lr}
	MOV	lr, #0
	STR	lr, fndspaloc
	MOV	r3, r0
	MOV	r4, #1
_altered_7
	SUBS	r3, r3, #1
	BLT	FromMJE20a
	MOV	r0, r3
	BL	FromMJE29
	TEQ	r0, r2
	ADDEQ	r4, r4, #1
	BEQ	_altered_7
	LDR	lr, fndspaloc
	CMP	lr, #0
	BNE	overspecchars
	CMP	r0, #' '
	STREQ	r0, fndspaloc
	ADDEQ	lr, r3, #1
	STREQ	lr, storedofsofsow
	LDR	lr, fndspaloc
	CMP	lr, #0
	BNE	overspecchars
	TEQ	r0, #'>'
	TEQNE	r0, #'"'
	TEQNE	r0, #'/'
	BEQ	FromMJE20a
overspecchars
	TEQ	r0, r1
	BNE	_altered_7
	SUBS	r4, r4, #1
	BNE	_altered_7
	LDR	lr, fndspaloc
	CMP	lr, #0
	BEQ	FromMJE20a
	B	FromMJE20b
checkbackthree
	STMFD	sp!, {r3, r4, lr}
	MOV	r3, r0
	MOV	r4, #1
_altered_8
	STR	r3, storedofsofsow
	SUBS	r3, r3, #1
	BLT	FromMJE20a
	MOV	r0, r3
	BL	FromMJE29
	TEQ	r0, r2
	ADDEQ	r4, r4, #1
	BEQ	_altered_8
	TEQ	r0, #'>'
	TEQNE	r0, #'"'
	TEQNE	r0, #'/'
	BEQ	FromMJE20a
	CMP	r0, #33
	BCC	FromMJE20a
	TEQ	r0, r1
	BNE	_altered_8
	SUBS	r4, r4, #1
	BNE	_altered_8
	B	FromMJE20
checkbackent
	STMFD	sp!, {r3, r4, lr}
	MOV	r3, r0
	MOV	r4, #1
_altered_9
	STR	r3, storedofsofsow
	SUBS	r3, r3, #1
	BLT	FromMJE20a
	MOV	r0, r3
	BL	FromMJE29
	TEQ	r0, r2
	ADDEQ	r4, r4, #1
	BEQ	_altered_9
	CMP	r0, #'&'
	BCC	FromMJE20a
	TEQ	r0, r1
	BNE	_altered_9
	SUBS	r4, r4, #1
	BNE	_altered_9
	B	FromMJE20
FromMJE26
		;  REM get delay
	STMFD	sp!, {r1, r2, lr}
	MOV	r0, #0
	ADRL	r1, w_formmb
	LDR	r1, [r1, #0x08]
	ADRL	r2, w_formmb + 4
	LDRB	r2, [r2]
	TST	r1, #(1 << 26)
	MOVNE	r0, r2
	LDMFD	sp!, {r1, r2, pc}

Zap_insertstuff
	STMFD	sp!, {r7, lr}
	MOV	r0, #1
	LDR	lr, [r12, #0]
	ADD	lr, lr, #Zap_DoCommand
	STMFD	sp!, {lr}
	MOV	lr, pc
	LDMFD	sp!, {pc}
	LDMFD	sp!, {r7, pc}
FromMJE27
	STMFD	sp!, {r9, r11, lr}
	LDR	r9, [r11, #4]	;  REM mode word...
	LDMFD	sp!, {r11}
	LDR	lr, [r12, #0]
	ADD	lr, lr, #Zap_BaseMode
	STMFD	sp!, {lr}
	MOV	lr, pc
	LDMFD	sp!, {pc}
	LDMFD	sp!, {r11, pc}
FromMJE28
	LDR	r0, [r10, #12]
	SUBS	r0, r0, #1
	MOVLT	r0, #0
	MOVLT	pc, lr
FromMJE29
	STMFD	sp!, {lr}
	LDR	lr, [r9, #52]
	CMP	r0, lr
	LDRCS	lr, [r9, #60]
	ADDCS	r0, r0, lr
	LDR	lr, [r9, #0]
	LDRB	r0, [lr, r0]
	LDMFD	sp!, {pc}
FromMJE30
	LDRB	r2, [r1], #1
	CMP	r2, #0x20
	MOVCC	r2, #0
	STRB	r2, [r0], #1
	BCS	FromMJE30
	SUB	r0, r0, #1
	MOVS	pc, lr
	MOV	r1, r0
	MOV	r0, #0
FromMJE31
	LDRB	r2, [r1, r0]
	ADD	r0, r0, #1
	CMP	r2, #0x20
	BCS	FromMJE31
	MOVS	pc, lr
FromMJE32
	TEQ	r8, #0
	LDRNE	r0, [r8, #40]
	MOVNE	pc, lr
	STMFD	sp!, {r1, lr}
	MOV	r1, #3
	LDR	lr, [r12, #0]
	ADD	lr, lr, #0x48
	STMFD	sp!, {lr}
	MOV	lr, pc
	LDMFD	sp!, {pc}
	LDMFD	sp!, {r1, pc}
FromMJE33
	TEQ	r8, #0
	LDRNE	r0, [r8, #92]
	MOVNE	pc, lr
	STMFD	sp!, {r1, lr}
	MOV	r1, #2
	LDR	lr, [r12, #0]
	ADD	lr, lr, #Zap_ReadVar
	STMFD	sp!, {lr}
	MOV	lr, pc
	LDMFD	sp!, {pc}
	LDMFD	sp!, {r1, pc}
GetModeWord
	STMFD	sp!, {r0-r2, lr}
	LDR	r1, [r11, #4]
	LDR	r2, [r12, #0]
	ADD	r2, r2, #Zap_GetModeWord
	MOV	lr, pc
	MOV	pc, r2
	MOV	r7, r0
	LDMFD	sp!, {r0-r2, pc}
PutModeWord
	STMFD	sp!, {r0-r2, lr}
	LDR	r1, [r11, #4]
	LDR	r2, [r12, #0]
	ADD	r2, r2, #Zap_PutModeWord
	MOV	lr, pc
	MOV	pc, r2
	LDMFD	sp!, {r0-r2, pc}
	STMFD	sp!, {r0-r2, lr}	;  REM ????
	LDR	r1, [r11, #8]
	B	FromMJE35
	STMFD	sp!, {r0-r2, lr}
	LDR	r1, [r11, #4]
	B	FromMJE35
	STMFD	sp!, {r0-r2, lr}
	LDR	r1, [r11, #0]
FromMJE35
	MOV	r0, r7
	LDR	r2, [r12, #0]
	ADD	r2, r2, #0x0168
	MOV	lr, pc
	MOV	pc, r2
	LDMFD	sp!, {r0-r2, pc}


		; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

tohaveajollygoodtime			; called when we've finished a physical line, but
	STMFD	sp!, {lr}		; we're mid-way through a logical one
	BL	checkbackwardsnow
	LDR	lr, [r9, #f_ptr]
	LDR	r0, [r9, #f_splito]
	ADD	r0, r0, lr
	CMP	r7, r0
	LDREQ	r0, [r9, #f_splits]
	ADDEQ	r0, r0, r7
	MOVNE	r0, r7
	LDR	r1, [r9, #f_bufl]
	ADD	r1, lr, r1
	CMP	r0, r1
	LDRCCB	r0, [r0]		;  Hmm...(Beyond end...?)
	AND	r1, r12, #0xFF		;  REM end character... yes! At last...
	TEQ	r0, r1			; INSTR(degiewCHR$ l R EM  ! the same ength as the width
	ADDEQ	r7, r7, #1
	ADDEQ	r11, r11, #1
	LDMFD	sp!, {lr}
	B	tohaveajollygoodback


tocheckbackwardsnow			; check backwards from cr to find a command
					; at this point r7 -> after cr char
	ADD	r11, r11, #1		; inc logical line number
	BIC	r2, r2, #0xCF000000	;  REM START OF LINE FLAGS...xxx
	BIC	r2, r2, #0x00F00000
	STMFD	sp!, {lr}
	BL	checkbackwardsnow
	LDMFD	sp!, {lr}
	B	backcheckbackwardsnow

checkbackwardsnow
	FNJSR	"R0,R2,R7"
	AND	r1, r2, #0xFF
	TEQ	r1, #col_comments
	TEQNE	r1, #col_strings
	BEQ	endcheckbackwardsnow	; ignore colouring in comments or strings
	CMP	r0, #'{'
	BCS	endcheckbackontoent	; not A-Za-z etc
alltizfine
	ADD	r7, r7, #1		; (return bug: this puts us 2 into the split)
	BL	TableChk2
	SUB	r7, r7, #1
endcheckbackontoent
	ADD	r7, r7, #1		; update input pointer for next line
	TEQ	r1, #col_comments
	BEQ	secondendofGSTB
	MOV	r1, #1
	B	GSTtest
secondendofGST
	MOV	r1, #1
	B	GSTtestB
secondendofGSTB
endcheckbackwardsnow
	FNRTS


; -------- FLAGSTOGGLE command ----------

	DCD	0x8017
Cmdhtmlflagstoggle
	STMFD	sp!, {lr}
	LDR	r10, [r0]
	ADRL	r1, modenumberlocal
	LDR	r1, [r1]
	STMFD	sp!, {r1-r11}
	FNcall	Zap_GetModeWord
	LDMFD	sp!, {r1-r11}
	MOV	r6, r0
	LDR	r7, [r6, #0xC]
	CMP	r2, #15
	BEQ	tickquery
	MOV	r5, #0
	AND	r1, r10, #0xFF
	BL	execute
	MOV	r1, r10, LSR #8
	AND	r1, r1, #0xFF
	TST	r1, #0x80
	BLNE	execute
	MOV	r1, r10, LSR #16
	AND	r1, r1, #0xFF
	TST	r1, #0x80
	BLNE	execute
	MOV	r1, r10, LSR #24
	AND	r1, r1, #0xFF
	TST	r1, #0x80
	BLNE	execute
	STR	r7, [r6, #0xC]
	ADRL	r0, w_formmb
	STR	r7, [r0, #8]
	LDMFD	sp!, {pc}

execute	AND	r2, r1, #0x1F
	CMP	r2, #20
	ORREQ	r5, r5, #1
	CMP	r2, #28
	CMPNE	r2, #29
	CMPNE	r2, #30
	ORREQ	r5, r5, #2	;  REM only 2 needed...?
	CMP	r2, #31
	ORREQ	r5, r5, #0x1C
	CMP	r2, #27
	CMPNE	r2, #24
	CMPNE	r2, #19
	ORREQ	r5, r5, #0x08
	MOV	r3, #1
	MOV	r3, r3, LSL r2
	MOV	r2, #0
	MOV	r4, #0
	MOV	r1, r1, LSR #5
	AND	r1, r1, #3
	CMP	r1, #1
	MOVEQ	r2, r3
	CMP	r1, #2
	MOVEQ	r4, r3
	BIC	r7, r7, r2
	ORR	r7, r7, r4
	EOR	r7, r7, r3
	MOV	pc, lr

tickquery
	AND	r2, r10, #0x1F
	MOV	r3, #1
	MOV	r3, r3, LSL r2
	TST	r7, r3
	MOVNE	r0, #1
	MOVEQ	r0, #0
	LDMFD	sp!, {pc}


;---------- e_interrogate ----------

mode_interrogate
	CMP	r0, #25			; default SAVEANDRUN behaviour?
	MOVEQ	r0, #0			; yes please
	MOVEQ	pc, lr
	STMFD	sp!, {r9, r11, lr}
	MOV	r11, #e_interrogate
	BL	basemode
	LDMFD	sp!, {r9, r11, pc}


	; must make sure the following text is at least 26*4 bytes long!
AlphaIndex
	=	10, "Greetings from The Mandala Centre."
	=	10, "Please feel free place any additional commands in the space provided"
	ALIGN

;------------ command table -----------

; now in aphabetical order!

	DCD	0x2A2A0A2E
TableHere
	=	"as ",		com_commands
	=	"amu",		com_commands ; new 0.09
	=	"autoindent ",	com_commands
	=	"aux ",		com_commands
	=	"bison ",	com_commands
	=	"blockid ",	com_commands
	=	"c++ ",		com_commands
	=	"c++.",		com_cfile
	=	"c.",		com_cfile
	=	"cc ",		com_commands
	=	"cdir ",	com_commands
	=	"cfront ",	com_commands
	=	"cmhg ",	com_commands
	=	"cmunge ",	com_commands ; new 0.07
	=	"copy ",	com_morecmds
	=	"cpp.",		com_cfile
	=	"create ",	com_morecmds
	=	"decaof ",	com_commands
	=	"delete ",	com_morecmds
	=	"diff ",	com_commands
	=	"drlink ",	com_commands
	=	"echo ",	com_morecmds
	=	"find ",	com_commands
	=	"gcc ",		com_commands
	=	"h.",		com_header
        =	"ifthere ",	com_morecmds ; new 0.07
	=	"libfile ",	com_commands
	=	"link ",	com_commands
	=	"mv ",		com_morecmds
	=	"o.",		com_object
	=	"objasm ",	com_commands
	=	"objsize ",	com_commands
	=	"remove ",	com_commands
	=	"rm ",		com_morecmds
	=	"run ",		com_morecmds
	=	"s.",		com_assembler
	=	"sed ",		com_commands
	=	"settype ",	com_morecmds
	=	"squeeze ",	com_commands
	=	"stoh ",	com_morecmds
	;=	"TOANSI ",	com_commands ; removed 0.07
	;=	"TOPCC ",	com_commands ;
	=	"wipe ",	com_morecmds ; new 0.07
	=	"wordstr ",	com_commands
	=	"yUm ",		com_commands ; these are never matched because we search for a
	=	"zEn ",		com_commands ; lower case command
	=	"**", 10

	END
