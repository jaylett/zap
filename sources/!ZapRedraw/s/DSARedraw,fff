; Contains code for direct screen access redraw
; $Id: DSARedraw,fff,v 1.6.2.2 2001/07/01 04:25:48 ds Exp $

 GET h.ZapRedHdr
 GET h.ZapRedraw
 GET h.Cache

 EXPORT redraw_area_dsa
 EXPORT redraw_raster
 EXPORT convert_bitmap
 EXPORT convert_bitmap_char
 EXPORT cached_char_size

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Fast redraw of an area				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R1=redraw block R2=extension sub R3=private word

redraw_area_dsa
 FNJSR "R1-R12"
 BL check_dsa_workarea		; ensure we have workarea
 FNRTS VS			; out of memory
 LDR R0,[R1,#r_workarea]
 STR R2,[R0,#a_ext1]
 STR R3,[R0,#a_ext2]
 LDR R5,[R1,#r_screen]		; address of screen start
 TEQ R5,#0
 BNE gotaddr$l			; screen address specified
 PUSH "R1"
 ADR R0,vdublk$l
 LDR R1,[R1,#r_workarea]	; workarea
 ADD R1,R1,#a_temp1		; place to read it
 SWI XOS_ReadVduVariables
 LDR R5,[R1]			; screen address
 PULL "R1"
 FNRTS VS
gotaddr$l			; R5=screen address
 LDR R0,[R1,#r_caddr]
 CMP R0,#&8000			; font handle?
 BLLO handle_to_redraw		; yes - update r_cbpl r_cbpc r_charw r_charh
				; and possibly r_flags b1 (if b5 set)
 LDR R9,[R1,#r_bpl]		; bytes per raster line
 LDR R7,[R1,#r_cbpl]		; bytes per cache line
 LDR R0,[R1,#r_miny]
 LDR R8,[R1,#r_maxy]
 SUBS R8,R8,R0			; number of rasters to do
 FNRTS LE			; don't allow trivial case
 MLA R5,R9,R0,R5		; start of first raster
 LDR R10,[R1,#r_charh]		; height of a character in pixs
 LDR R11,[R1,#r_linesp]		; line spacing in pixs
 ADD R11,R10,R11		; total line height in pixs
 MOV R10,R10,LSL#8		; put flags in bottom bits of R10
 LDR R0,[R1,#r_flags]		; redraw flags
 TST R0,#rf_doubleheight
 MOVNE R10,R10,LSL#1
 MOVNE R11,R11,LSL#1		; double line height
 ORRNE R10,R10,#1		; b0 of R10=double height flag
 MOV R0,R11			; actual line spacing
 BL calculate_dsa		; pre-calculate the x values
 FNRTS VS
 MOV R12,R2			; current y offset in line
 MOV R2,R0			; first line to print
 LDR R0,[R1,#r_scrolly]
 CMP R0,#0			; in the top margin?
 BPL nom$l			; nope

 PUSH "R3"
 ADR R3,null$l			; set up colours for a null line
 BL calculate_x_scroll
 MOV R4,#0			; clear the raster
mloop$l				; draw the top margin
 BL redraw_raster		; draw it
 SUBS R8,R8,#1			; 1 less raster to do in area
 BEQ donefrommargin$l		; all done
 ADD R5,R5,R9			; next line
 LDR R0,[R1,#r_scrolly]
 ADDS R0,R0,#1			; 1 less raster in margin
 STR R0,[R1,#r_scrolly]
 BMI mloop$l
 PULL "R3"

nom$l
 LDR R0,[R1,#r_caddr]
 CMP R0,#&8000			; is it a handle?
 BLLO handle_to_caddr		; yes - get address
 LDR R7,[R1,#r_workarea]
 STR R0,[R7,#a_spr1]		; save initial caddr
 LDR R7,[R1,#r_cbpl]		; restore r7
 TST R10,#1
 MOVEQ R4,R12
 MOVNE R4,R12,LSR#1		; number of whole lines done
 MLA R4,R7,R4,R0		; cache offset
nextline$l
 LDR R3,[R2],#4			; get the offset for this line
 CMP R3,#0
 BEQ endline$l			; run out of text to print
 LDR R0,[R1,#r_data]		; data start
 ADD R3,R0,R3			; address of start of text
 BL calculate_x_scroll		; find first character & R6 col
nextraster$l
 CMP R12,R10,LSR#8		; are we still within the character
 MOVCS R4,#0			; draw background if not
 BL redraw_raster		; draw the line
 SUBS R8,R8,#1			; done one more
 BLE done$l			; finished
 BIC R0,R10,R12			; b0 1 only if R10=1 R12=0
 TST R0,#1			; if set then don't move on
 ADDEQ R4,R4,R7			; increment table address
 ADD R5,R5,R9			; increment screen address
 ADD R12,R12,#1			; increment number of lines done
 CMP R12,R11
 BCC nextraster$l		; more to do
 LDR R0,[R1,#r_caddr]		; reset to start of cache
 CMP R0,#&8000			; is it a font handle?
 BLLO handle_to_caddr		; yes - get its address
 MOV R4,R0
 MOV R12,#0			; now at zero line offset
 B nextline$l
endline$l
 ADR R3,null$l
 BL calculate_x_scroll		; set up for a null line
 MOV R4,#0			; draw background
blank$l
 BL redraw_raster
 ADD R5,R5,R9			; increment screen address
 SUBS R8,R8,#1			; done one more
 BGT blank$l
 BL remove_dsa_workarea		; free workarea in in cache
 FNRTS

donefrommargin$l		; reached end of area inside top margin
 PULL "R3"
done$l
 BL remove_dsa_workarea		; free workarea in in cache
 FNRTS

null$l = "                                         ",0,2,0
 ALIGN
vdublk$l DCD 148,-1		; vdu screen start

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Calculate dsa arguments				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=actual line height in pixs (inc linesp and doubling)
;  R1=redraw block
;X R0=address (in r_data) of first line
;  R2=y pixel scroll offset in first line
;  workarea+a_x1 to a_x5 filled in #

; r_scrollx will be valid, unless it's -ve, in which case we're at the start
; of the line inside the left margin. Since this is special-cased in
; redraw_raster we can just pretend it's 0 here. (but we then need to subtract
; it from the last character to draw)
; same goes for r_scrolly and the top margin

calculate_dsa
 FNJSR "R1,R3-R7"
 MOV R7,R0			; save actual line height
 MOV R4,R1			; save redraw block
 LDR R5,[R4,#r_workarea]	; work area base
 LDR R0,[R4,#r_scrollx]		; x scroll in pixels
 LDR R1,[R4,#r_charw]		; width
 MOV R6,R1			; save character width
 CMP R0,#0
 MOVMI R0,#0			; correct for margin
 BL div_mod
 STR R0,[R5,#a_x5]		; 1st visible character number
 STR R2,[R5,#a_x1]		; 1st character pixel offset

 CMP R2,#0
 RSBNE R2,R2,R6			; number left in first char ;OK!
 LDR R14,[R4,#r_maxx]
 LDR R0,[R4,#r_minx]
 SUB R0,R14,R0			; width in pixels to draw
 LDR R14,[R4,#r_scrollx]
 CMP R14,#0
 ADDMI R0,R0,R14		; subtract margin if drawing it
 SUBS R1,R2,R0			;
 MOVGE R2,R0			; clip number left in char (if eg scrolling by < charw)
 ADDGE R1,R14,R1
 STRGE R1,[R4,#r_scrollx]	; less margin if exceeds maxx
 STR R2,[R5,#a_x2]		; first char pix do (may be 0) ; OK...?
 SUB R0,R0,R2			; pixels left to do after first char ; sub
 MOV R1,R6
 BL div_mod
 STR R0,[R5,#a_x3]		; number of whole characters
 STR R2,[R5,#a_x4]		; number of pixels for last char

 LDR R0,[R4,#r_scrolly]
 CMP R0,#0			; correct for top margin
 MOVMI R0,#0
 MOV R1,R7			; actual line height
 BL div_mod			; R2=y pixel scroll offset
 MOVS R1,R0			; number of lines to skip
 LDR R0,[R4,#r_data]		; first line
 FNRTS EQ			; none to skip
skipline$l
 LDR R14,[R0]
 TEQ R14,#0			; reached end of data ?
 FNRTS EQ			; yes
 ADD R0,R0,#4
 SUBS R1,R1,#1
 BGT skipline$l
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Calculate x scoll character and colours		    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=redraw block (workarea setup) R3=start of text line
;X R1 saved
;  R3 incremented to first 'drawable character'.
;  R6=for/bac/font to pass to redraw raster |

calculate_x_scroll
 FNJSR "R1-R2,R4"
 MOV R14,R3			; save text start
 LDR R0,[R1,#r_workarea]
 LDR R0,[R0,#a_x5]		; scroll offset in chars
 LDR R2,[R1,#r_for]		; start foreground
 ; MOV R4,R2,LSR #24
 LDR R4,[R1,#r_caddr]		; calculate initial substyle
 CMP R4,#&8000			; if using font handles
 ANDLO R4,R4,#&FF
 MOVHS R4,#0
 LDR R3,[R1,#r_bac]		; start background
 MOV R1,R14			; start of text
 [ MARGINS = EMPTY
 TEQ R0,#0			; use r_for r_bac etc if in margin
 BLNE find_character		; move to nth char
 |
 BL find_character		; move to nth char
 ]
 ORR R6,R2,R3,LSL#16		; colour mask for redraw
 ORR R6,R6,R4,LSL#24		; add in font mask...
 MOV R3,R1			; new first char
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Fast redraw of a single raster			    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;local_font_stored
; DCD 0

;E R1=redraw block
;  R3=address of text to use for this line (from first vis char)
;  R4=character defn table offset so use top row of character
;     or 0 to clear the raster to background colour
;  R5=screen address of start of raster line
;  R6=start col b0-b15=for b16-b23=bac b24-31=substyle
;  r_workarea a_x1 to a_x4 and a_ext1,a_ext2 setup.
;X Raster line redrawn |

redraw_raster
 FNJSR "R1-R12"
 MOV R11,R6,LSR#16		; background
 BIC R10,R6,R11,LSL#16		; foreground
 ;MOV R9,R6,LSR #8		; font...
 ;STR R9,local_font_stored	; hmm...
 AND R10,R10,#&FF
 AND R11,R11,#&FF
 MOV R9,R6			; temporarily... ;-(
 LDR R0,[R1,#r_palette]
 LDR R10,[R0,R10,LSL#2]
 LDR R11,[R0,R11,LSL#2]		; get bit masks
 LDR R12,[R1,#r_bpp]
 LDR R2,[R1,#r_workarea]	; R2=workarea values
 LDR R0,[R1,#r_minx]
 MOV R0,R0,LSL R12		; number of bits from lhs
 ADD R5,R5,R0,LSR#3
 BIC R5,R5,#3			; get address of first word
 AND R6,R0,#&1F			; bit offset within the word
 LDR R7,[R5]			; fill the output buffer
	RSB	R0,R6,#32
	MOV	R7,R7,LSL R0	; blank from first new bit
	MOV	R7,R7,LSR R0
 CMP R12,#6			; 0-5 bpp supported
 MOVCS R12,#-1			; set bpp to -1 if not known
 LDR R8,[R1,#r_charw]
 TEQ R8,#8
 MOVNE R12,#-1			; set to -1 if not width 8 character
 CMP R4,#0
 ADDEQ R12,R12,#7		; -1 -> 6 if clearing the raster

 LDRNE R0,[R1,#r_caddr]		; are we using font handles?
 CMPNE R0,#&8000
 BHS ok$l
 BL handle_to_caddr
 ;;LDR R8,[R2,#a_spr1]
 SUB R8,R4,R0			; current char offset
 LDR R0,[R1,#r_caddr]
 BIC R0,R0,#&FF
 ORR R0,R0,R9,LSR #24		; patch in initial style mask
 BL handle_to_caddr
 STR R0,[R2,#a_spr1]		; keep initial caddr for 0,9 and 0,10 routines
 ADD R4,R0,R8			; get initial char offset

ok$l
 LDR R0,[R1,#r_flags]
 TST R0,#rf_extroutine
 MOVNE R0,#0
 BLNE call_extension		; start of line call to extension

 LDR R9,[R1,#r_scrollx]	; r_minx]
 CMP R9,#0
 RSBMI R9,R9,#0			; number of pixels to clear
 LDRMI R0,[R1,#r_bpp]
 MOVMI R9,R9,LSL R0		; number of _bits_ to clear
 BLMI redraw_raster_any_clear	; draw the left margin

 LDR R9,[R2,#a_x1]		; first character pixel offset
 TEQ R9,#0
 BEQ aligned$l			; first character aligned
 LDR R8,[R2,#a_x2]		; number of pixs in first char
 CMP R8,#0
 BLE end$l			; nothing left to do
 PUSH "R2,R12"
 BL call_redraw_raster_pixel	; draw end of first character
 PULL "R2,R12"
aligned$l
 LDR R8,[R2,#a_x3]		; number of whole chars to do
 CMP R8,#0
 BLE lastchar$l
 PUSH "R2,R12"
 BL call_redraw_raster_main
 PULL "R2,R12"
lastchar$l
 LDR R8,[R2,#a_x4]
 CMP R8,#0
 BLE end$l			; nothing left to do
 MOV R9,#0
 BL call_redraw_raster_pixel	; draw start of last character
end$l
 TEQ R6,#0
 FNRTS EQ			; finished at the start of a word
 LDR R2,[R5]
 MOV R2,R2,LSR R6		; clear bottom R6 bits (mask)
 ORR R7,R7,R2,LSL R6
 STR R7,[R5]			; write back last word
 FNRTS

; This code makes sure that the start of the line is redrawn properly
; even if there is a margin.
; It *tries* to clear the margin so that selections don't /appear/ to go
; into it :(

;startoflbug
; PUSH "R0,R2,R3,R9,R10,R11,R12"
; LDR R14,[R1,#r_bac]
; ;LDR R10,[R1,#r_palette]
; ;LDR R11,[R10,R14,LSL #2]
; ;MOV R10,R11
; ADR R3,unplottmp
; ;MOV R12,#6
; BL call_redraw_raster_pixel	; draw end of first character
; PULL "R0,R2,R3,R9,R10,R11,R12"
; B aligned$l
;unplottmp
; = "    "

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Fast redraw of part of a character raster		    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=redraw block R3=address of text R4=char defn table
;  R5=screen address R6=bit offset in buffer R7=buffer
;  R8=number of pixels to write >0 (within a single character)
;  R9=pixel offset within the char to start at
;  R10=foreground mask R11=background mask
;  R12=sub to call resolution+clear or not
;X R0,R2,R8-R9,R12 corrupted
;  R1,R4 preserved
;  R3,R5-R7,R10-R11 updated

call_redraw_raster_pixel
 ADD PC,PC,R12,LSL#2
 B redraw_raster_pixel_any	; offset -1 (arbitrary bpp and width)
 B redraw_raster_pixel_any	; offset 0  (width 8 characters)
 B redraw_raster_pixel_any	;	 1  (4 colours - width 8 pixels)
 B redraw_raster_pixel_2	;	 2  (16 colours - width 8 pixels)
 B redraw_raster_pixel_3	;	 3  (256 colours - width 8 pixels)
 B redraw_raster_pixel_any	;	 4  (32k colours - width 8 pixels)
 B redraw_raster_pixel_any	;	 5  (16M colours - width 8 pixels)
 B clear_raster_pixel_any	;	 6  (clear arbitrary bpp)
 B clear_raster_pixel_any	; offset 7  (clear 2 colours - width 8 pixels)
 B clear_raster_pixel_any	;	 8  (clear 4 colours - width 8 pixels)
 B clear_raster_pixel_2		;	 9  (clear 16 colours - width 8 pixels)
 B clear_raster_pixel_3		;	10  (clear 256 colours - width 8 pixels)
 B clear_raster_pixel_any	;	11  (clear 32k colours - width 8 pixels)
 B clear_raster_pixel_any	;	12  (clear 16M colours - width 8 pixels)

;redraw_raster_pixel_0
; FNJSR
; LDRB R0,[R3],#1		; get next char
; TEQ R0,#0
; BLEQ redraw_control_code
; LDR R12,[R1,#r_charh]
; MUL R0,R12,R0
; LDRB R0,[R4,R0]		; get bitmap
; AND R2,R10,R0			; R2=foreground bit
; BIC R0,R11,R0,LSL#24		; R0=background bit in top byte
; ORR R0,R2,R0,LSR#24		; R0=end bitmap with top bits clr
; MOV R2,#1
; MOV R2,R2,LSL R8
; SUB R2,R2,#1			; mask of num of bits to write
; MOV R0,R0,LSR R9		; shift to first pixel
; AND R0,R0,R2			; bits to put in
; ORR R7,R7,R0,LSL R6		; mask in
; ADD R6,R6,R8
; CMP R6,#32
; FNRTS CC			 ; finished
; STR R7,[R5],#4
; SUB R6,R6,R8
; RSB R6,R6,#32			; number of bits written
; MOV R7,R0,LSR R6
; RSB R6,R6,R8
; FNRTS
;
;clear_raster_pixel_0
; FNJSR
; LDRB R0,[R3],#1		; get next char
; TEQ R0,#0
; BLEQ redraw_control_code
; MOV R2,#1
; MOV R2,R2,LSL R8
; SUB R2,R2,#1			; mask of num of bits to write
; AND R0,R11,R2			; bits to put in
; ORR R7,R7,R0,LSL R6		; mask in
; ADD R6,R6,R8
; CMP R6,#32
; FNRTS CC			 ; finished
; STR R7,[R5],#4
; SUB R6,R6,R8
; RSB R6,R6,#32			; number of bits written
; MOV R7,R0,LSR R6
; RSB R6,R6,R8
; FNRTS
;
;redraw_raster_pixel_1
; FNJSR
; LDRB R0,[R3],#1		; get next char
; TEQ R0,#0
; BLEQ redraw_control_code
; LDR R12,[R1,#r_charh]
; MUL R0,R12,R0
; TST R4,#2
; BIC R14,R4,#3
; LDR R0,[R14,R0,LSL#1]		; get bitmap
; MOVEQ R0,R0,LSL#16
; MOV R0,R0,LSR#16		; get in bottom 16 bits
; AND R2,R10,R0			; R2=foreground bit
; BIC R0,R11,R0,LSL#16		; R0=background bit in top bytes
; ORR R0,R2,R0,LSR#16		; R0=end bitmap with top bits clr
; MOV R8,R8,LSL#1
; MOV R9,R9,LSL#1		; convert from pixels -> bits
; MOV R2,#1
; MOV R2,R2,LSL R8
; SUB R2,R2,#1			; mask of num of bits to write
; MOV R0,R0,LSR R9		; shift to first pixel
; AND R0,R0,R2			; bits to put in
; ORR R7,R7,R0,LSL R6		; mask in
; ADD R6,R6,R8
; CMP R6,#32
; FNRTS CC			 ; finished
; STR R7,[R5],#4
; SUB R6,R6,R8
; RSB R6,R6,#32			; number of bits written
; MOV R7,R0,LSR R6
; RSB R6,R6,R8
; FNRTS
;
;clear_raster_pixel_1
; FNJSR
; LDRB R0,[R3],#1		; get next char
; TEQ R0,#0
; BLEQ redraw_control_code
; MOV R8,R8,LSL#1
; MOV R2,#1
; MOV R2,R2,LSL R8
; SUB R2,R2,#1			; mask of num of bits to write
; AND R0,R11,R2			; bits to put in
; ORR R7,R7,R0,LSL R6		; mask in
; ADD R6,R6,R8
; CMP R6,#32
; FNRTS CC			 ; finished
; STR R7,[R5],#4
; SUB R6,R6,R8
; RSB R6,R6,#32			; number of bits written
; MOV R7,R0,LSR R6
; RSB R6,R6,R8
; FNRTS

redraw_raster_pixel_2
 FNJSR
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 LDR R12,[R1,#r_charh]
 MUL R0,R12,R0
 LDR R0,[R4,R0,LSL#2]		; get bitmap
 AND R2,R10,R0			; R2=foreground bit
 BIC R0,R11,R0			; R0=background
 ORR R0,R2,R0			; R0=end bitmap
 MOV R8,R8,LSL#2
 MOV R9,R9,LSL#2		; pixlels -> bits
	RSB	R2,R8,#32
 MOV R0,R0,LSR R9		; shift to first pixel
	MOV	R0,R0,LSL R2
	MOV	R0,R0,LSR R2	; do mask
 ORR R7,R7,R0,LSL R6		; mask in
 ADD R6,R6,R8
 CMP R6,#32
 FNRTS CC			 ; finished
 STR R7,[R5],#4
 SUB R6,R6,R8
 RSB R6,R6,#32			; number of bits written
 MOV R7,R0,LSR R6
 RSB R6,R6,R8
 FNRTS

clear_raster_pixel_2
 FNJSR
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 MOV R8,R8,LSL#2
	RSB	R2,R8,#32
	MOV	R0,R11,LSL R2
	MOV	R0,R0,LSR R2	; bits to put in
 ORR R7,R7,R0,LSL R6		; mask in
 ADD R6,R6,R8
 CMP R6,#32
 FNRTS CC			 ; finished
 STR R7,[R5],#4
 SUB R6,R6,R8
 RSB R6,R6,#32			; number of bits written
 MOV R7,R0,LSR R6
 RSB R6,R6,R8
 FNRTS

redraw_raster_pixel_3
 FNJSR
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 LDR R12,[R1,#r_charh]
 MUL R0,R12,R0
 ADD R0,R4,R0,LSL#3		; address of bitmap
 LDMIA R0,{R12,R14}
 AND R2,R10,R12			; R2=foreground bit
 BIC R0,R11,R12			; R0=background bit
 ORR R12,R2,R0			; R12=first bitmap
 AND R2,R10,R14
 BIC R0,R11,R14
 ORR R14,R2,R0			; R14=second bitmap
 MOV R8,R8,LSL#3
 MOV R9,R9,LSL#3		; pixlels -> bits
 CMP R9,#32			; does it start in second word?
 SUBCS R9,R9,#32
 MOVCS R12,R14			; if so then shift to first word
 MOV R12,R12,LSR R9
 RSB R0,R9,#32
 ORR R12,R12,R14,LSL R0
 MOV R14,R14,LSR R9		; shift bitmap to start of 1st word
 RSB R0,R6,#32			; conjugate shift
 CMP R8,#32			; do we have to copy in > 1 word?
 ORRCS R7,R7,R12,LSL R6
 STRCS R7,[R5],#4
 MOVCS R7,R12,LSR R0
 SUBCS R8,R8,#32		; do the first word
 MOVCS R12,R14			; and shift down the data
	RSB	R2,R8,#32
	MOV	R0,R12,LSL R2
	MOV	R0,R0,LSR R2	; bits to put in
 ORR R7,R7,R0,LSL R6		; mask in
 ADD R6,R6,R8
 CMP R6,#32
 FNRTS CC			 ; finished
 STR R7,[R5],#4
 SUB R6,R6,R8
 RSB R6,R6,#32			; number of bits written
 MOV R7,R0,LSR R6
 RSB R6,R6,R8
 FNRTS

clear_raster_pixel_3
 FNJSR
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 MOV R8,R8,LSL#3
 RSB R0,R6,#32			; conjugate shift
 CMP R8,#32			; do we have to copy in > 1 word?
 ORRCS R7,R7,R11,LSL R6
 STRCS R7,[R5],#4
 MOVCS R7,R11,LSR R0
 SUBCS R8,R8,#32		; do the first word
	RSB	R2,R8,#32
	MOV	R0,R11,LSL R2
	MOV	R0,R0,LSR R2	; bits to put in
 ORR R7,R7,R0,LSL R6		; mask in
 ADD R6,R6,R8
 CMP R6,#32
 FNRTS CC			; finished
 STR R7,[R5],#4
 SUB R6,R6,R8
 RSB R6,R6,#32			; number of bits written
 MOV R7,R0,LSR R6
 RSB R6,R6,R8
 FNRTS

 LOCAL

redraw_raster_pixel_any
 FNJSR
 LDRB R0,[R3],#1
 TEQ R0,#0
 BLEQ redraw_control_code
 LDR R2,[R1,#r_cbpc]
 MLA R2,R0,R2,R4		; address of bitmap
 LDR R0,[R1,#r_bpp]
 MOV R8,R8,LSL R0		; number bits to write
 MOV R9,R9,LSL R0		; first bit offset
	ADD	R0,R9,R2,LSL #3	; bit address of bitmap (less top 3 bits)
	ADD	R2,R2,R9,LSR #3	; byte address of bitmap
	ANDS	R0,R0,#&1F	; bit offset within word
 BEQ aligned$l			; word aligned
 RSB R9,R0,#32			; number of bits from this word
 CMP R9,R8
 MOVGE R9,R8			; clip with number to do
 SUB R8,R8,R9			; number left to do afterwards
 BL redraw_raster_any_write	; write these and align R2
	MOV	R0,#0
aligned$l
 MOVS R9,R8			; number of bits to write
 BLNE redraw_raster_any_write	; write these
 FNRTS

clear_raster_pixel_any
 FNJSR
 LDRB R0,[R3],#1
 TEQ R0,#0
 BLEQ redraw_control_code
 LDR R0,[R1,#r_bpp]
 MOV R9,R8,LSL R0		; number bits to clear
	FNPULL
	B	redraw_raster_any_clear

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Fast redraw of part of whole characters rasters	    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R1=redraw block R3=address of text R4=char defn table
;  R5=screen address R6=bit offset in buffer R7=buffer
;  R8=number of characters to write >0
;  R10=foreground mask R11=background mask
;  R12=resolution to call + clear or not
;X R0,R2,R8-R9,R12 corrupted
;  R1,R4 preserved
;  R3,R5-R7,R10-R11 updated

call_redraw_raster_main
 CMP	R12, #6
 BHS	dispatch$l		; clear or something; if -ve, not 8 width
 LDR	R0, [R1, #r_charh]
 TEQ	R0, #16
 ADDEQ	R12, R12, #13
 TEQNE	R0, #8
 MOVNE	R12, #-1
dispatch$l
 ADD PC,PC,R12,LSL#2
 B redraw_raster_main_any	; offset -1 (arbitrary bpp and width)
 B redraw_raster_main_any	; offset 0  (8*8 at 0 bpp etc)
 B redraw_raster_main_any
 B redraw_raster_main_8_2	; 16 cols
 B redraw_raster_main_8_3	; 256 cols
 B redraw_raster_main_8_4
 B redraw_raster_main_8_5
 B clear_raster_main_any	; offset 6
 B clear_raster_main_any	; offset 7
 B clear_raster_main_any
 B clear_raster_main_2		; 16 cols
 B clear_raster_main_3		; 256 cols
 B clear_raster_main_4
 B clear_raster_main_5
 B redraw_raster_main_any	; offset 13  (8*16 at 0 bpp etc)
 B redraw_raster_main_any
 B redraw_raster_main_16_2	; 16 cols
 B redraw_raster_main_16_3	; 256 cols
 B redraw_raster_main_16_4
 B redraw_raster_main_16_5


; LOCAL
;
;redraw_raster_main_0
; FNJSR
; ADR R9,addr$l
; ADR R12,subs$l
; BL redraw_modify
;loop$l
; LDRB R0,[R3],#1		; get next char
; TEQ R0,#0
; BLEQ redraw_control_code
;addr$l
; LDRB R0,[R4,R0,LSL#3]		; get bitmap DON'T MOVE!
; AND R2,R10,R0			; R2=foreground bit
; BIC R0,R11,R0,LSL#24		; R0=background bit in top byte
; ORR R0,R2,R0,LSR#24		; R0=end bitmap with top bits clr
; ORR R7,R7,R0,LSL R6		; mask in
; ADD R6,R6,#8
; CMP R6,#32
; BCS overflow$l
; SUBS R8,R8,#1
; BGT loop$l
; FNRTS
;overflow$l
; STR R7,[R5],#4			; save word
; RSB R6,R6,#40			; num of bits written
; MOV R7,R0,LSR R6		; start of new buffer
; RSB R6,R6,#8			; amount in buffer
; SUBS R8,R8,#1
; BGT loop$l
; FNRTS
;subs$l
; LDRB R0,[R4,R0,LSL#3]
; LDRB R0,[R4,R0,LSL#4]
; LDR R12,[R1,#r_charh]
; MUL R0,R12,R0
; LDRB R0,[R4,R0]
; MOV PC,R14
;
; LOCAL
;
;clear_raster_main_0
; FNJSR
;loop$l
; LDRB R0,[R3],#1		; get next char
; TEQ R0,#0
; BLEQ redraw_control_code
; AND R0,R11,#&FF		; background mask
; ORR R7,R7,R0,LSL R6		; mask in
; ADD R6,R6,#8
; CMP R6,#32
; BCS overflow$l
; SUBS R8,R8,#1
; BGT loop$l
; FNRTS
;overflow$l
; STR R7,[R5],#4			; save word
; RSB R6,R6,#40			; num of bits written
; MOV R7,R0,LSR R6		; start of new buffer
; RSB R6,R6,#8			; amount in buffer
; SUBS R8,R8,#1
; BGT loop$l
; FNRTS
;
; LOCAL
;
;redraw_raster_main_1
; FNJSR
; ADR R9,addr$l
; ADR R12,subs$l
; BL redraw_modify
;loop$l
; LDRB R0,[R3],#1		; get next char
; TEQ R0,#0
; BLEQ redraw_control_code
; TST R4,#2
; BIC R9,R4,#3
;addr$l
; LDR R0,[R9,R0,LSL#4]		; get bitmap DON'T MOVE!
; MOVEQ R0,R0,LSL#16
; MOV	R0,R0,LSR#16		; bottom 2 bytes are bitmap
; AND R2,R10,R0			; R2=foreground bit
; BIC R0,R11,R0,LSL#16		; R0=background bit in top bytes
; ORR R0,R2,R0,LSR#16		; R0=end bitmap with top bits clr
; ORR R7,R7,R0,LSL R6		; mask in
; ADD R6,R6,#16
; CMP R6,#32
; BCS overflow$l
; SUBS R8,R8,#1
; BGT loop$l
; FNRTS
;overflow$l
; STR R7,[R5],#4			; save word
; RSB R6,R6,#48			; num of bits written
; MOV R7,R0,LSR R6		; start of new buffer
; RSB R6,R6,#16			; amount in buffer
; SUBS R8,R8,#1
; BGT loop$l
; FNRTS
;subs$l
; LDR R0,[R9,R0,LSL#4]
; LDR R0,[R9,R0,LSL#5]
; LDR R12,[R1,#r_charh]		; NB Note importance of flags and fact
; MUL R0,R12,R0			; that bitmap may not be half word aligned!
; ADD R9,R4,R0,LSL#1
; LDRB R0,[R9],#1
; LDRB R9,[R9]
; ADD R0,R0,R9,LSL#8
; ADD R0,R0,R0,LSL#16		; duplicate so flags don't matter
; MOV PC,R14
;
; LOCAL
;
;clear_raster_main_1
; FNJSR
; MOV R9, #&FF00
; ORR R9,R9,#&FF			; set up mask
;loop$l
; LDRB R0,[R3],#1		; get next char
; TEQ R0,#0
; BLEQ redraw_control_code
; AND R0,R11,R9
; ORR R7,R7,R0,LSL R6		; mask in
; ADD R6,R6,#16
; CMP R6,#32
; BCS overflow$l
; SUBS R8,R8,#1
; BGT loop$l
; FNRTS
;overflow$l
; STR R7,[R5],#4			; save word
; RSB R6,R6,#48			; num of bits written
; MOV R7,R0,LSR R6		; start of new buffer
; RSB R6,R6,#16			; amount in buffer
; SUBS R8,R8,#1
; BGT loop$l
; FNRTS

 LOCAL

redraw_raster_main_8_2
 FNJSR
 RSB R9,R6,#32
loop$l
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 LDR R0,[R4,R0,LSL#5]		; get bitmap DON'T MOVE!
 AND R2,R10,R0			; R2=foreground bit
 BIC R0,R11,R0			; R0=background bit
 ORR R0,R2,R0			; R0=end bitmap
 ORR R7,R7,R0,LSL R6		; mask in
 STR R7,[R5],#4			; save word
 MOV R7,R0,LSR R9		; start of new buffer
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

redraw_raster_main_16_2
 FNJSR
 RSB R9,R6,#32
loop$l
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 LDR R0,[R4,R0,LSL#6]		; get bitmap DON'T MOVE!
 AND R2,R10,R0			; R2=foreground bit
 BIC R0,R11,R0			; R0=background bit
 ORR R0,R2,R0			; R0=end bitmap
 ORR R7,R7,R0,LSL R6		; mask in
 STR R7,[R5],#4			; save word
 MOV R7,R0,LSR R9		; start of new buffer
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

clear_raster_main_2
 FNJSR
 RSB R9,R6,#32
loop$l
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 ORR R7,R7,R11,LSL R6		; mask in
 STR R7,[R5],#4			; save word
 MOV R7,R11,LSR R9		; start of new buffer
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

redraw_raster_main_8_3
 FNJSR
 RSB R9,R6,#32
loop$l
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 ADD R0,R4,R0,LSL#6		; R0=address of bitmap substituted HERE!
 LDMIA R0,{R12,R14}		; get bitmap
 AND R2,R10,R12			; R2=foreground bit
 BIC R0,R11,R12			; R0=background bit
 ORR R12,R2,R0			; R12=first bitmap
 AND R2,R10,R14
 BIC R0,R11,R14
 ORR R14,R2,R0			; R14=second bitmap
 ORR R0,R7,R12,LSL R6		; NB Don't need R0 see 4 below
 MOV R12,R12,LSR R9
 ORR R12,R12,R14,LSL R6
 MOV R7,R14,LSR R9		; shuffle round
 STMIA R5!,{R0,R12}		; save output
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

redraw_raster_main_16_3
 FNJSR
 RSB R9,R6,#32
loop$l
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 ADD R0,R4,R0,LSL#7		; R0=address of bitmap substituted HERE!
 LDMIA R0,{R12,R14}		; get bitmap
 AND R2,R10,R12			; R2=foreground bit
 BIC R0,R11,R12			; R0=background bit
 ORR R12,R2,R0			; R12=first bitmap
 AND R2,R10,R14
 BIC R0,R11,R14
 ORR R14,R2,R0			; R14=second bitmap
 ORR R0,R7,R12,LSL R6		; NB Don't need R0 see 4 below
 MOV R12,R12,LSR R9
 ORR R12,R12,R14,LSL R6
 MOV R7,R14,LSR R9		; shuffle round
 STMIA R5!,{R0,R12}		; save output
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

clear_raster_main_3
 FNJSR
 RSB R9,R6,#32
loop$l
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 ORR R0,R7,R11,LSL R6
 MOV R7,R11,LSR R9
 STMIA R5!,{R0,R11}		; save output
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

redraw_raster_main_8_4
 FNJSR
 RSB R9,R6,#32
loop$l
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 ADD R0,R4,R0,LSL#7		; address of bitmap DON'T MOVE!
 LDMIA R0!,{R12,R14}		; get first two words of bitmap
 AND R2,R10,R12			; R2=foreground bit
 BIC R12,R11,R12		; background bit
 ORR R12,R2,R12			; R12=first bitmap
 AND R2,R10,R14
 BIC R14,R11,R14
 ORR R14,R2,R14			; R14=second bitmap
 ORR R7,R7,R12,LSL R6
 MOV R12,R12,LSR R9
 ORR R12,R12,R14,LSL R6		; prepare next two words for output
 STMIA R5!,{R7,R12}		; save output
 MOV R7,R14,LSR R9		; new buffer contents
 LDMIA R0!,{R12,R14}		; get last two words of bitmap
 AND R2,R10,R12			; R2=foreground bit
 BIC R12,R11,R12		; background bit
 ORR R12,R2,R12			; R12=first bitmap
 AND R2,R10,R14
 BIC R14,R11,R14
 ORR R14,R2,R14			; R14=second bitmap
 ORR R7,R7,R12,LSL R6
 MOV R12,R12,LSR R9
 ORR R12,R12,R14,LSL R6		; prepare next two words for output
 STMIA R5!,{R7,R12}		; save output
 MOV R7,R14,LSR R9		; new buffer contents
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

redraw_raster_main_16_4
 FNJSR
 RSB R9,R6,#32
loop$l
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 ADD R0,R4,R0,LSL#8		; address of bitmap DON'T MOVE!
 LDMIA R0!,{R12,R14}		; get first two words of bitmap
 AND R2,R10,R12			; R2=foreground bit
 BIC R12,R11,R12		; background bit
 ORR R12,R2,R12			; R12=first bitmap
 AND R2,R10,R14
 BIC R14,R11,R14
 ORR R14,R2,R14			; R14=second bitmap
 ORR R7,R7,R12,LSL R6
 MOV R12,R12,LSR R9
 ORR R12,R12,R14,LSL R6		; prepare next two words for output
 STMIA R5!,{R7,R12}		; save output
 MOV R7,R14,LSR R9		; new buffer contents
 LDMIA R0!,{R12,R14}		; get last two words of bitmap
 AND R2,R10,R12			; R2=foreground bit
 BIC R12,R11,R12		; background bit
 ORR R12,R2,R12			; R12=first bitmap
 AND R2,R10,R14
 BIC R14,R11,R14
 ORR R14,R2,R14			; R14=second bitmap
 ORR R7,R7,R12,LSL R6
 MOV R12,R12,LSR R9
 ORR R12,R12,R14,LSL R6		; prepare next two words for output
 STMIA R5!,{R7,R12}		; save output
 MOV R7,R14,LSR R9		; new buffer contents
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

clear_raster_main_4
 FNJSR
 RSB R9,R6,#32
loop$l				; NB Background R11 will change
 LDRB R0,[R3],#1		; Don't seed! get next char
 TEQ R0,#0
 BLEQ redraw_control_code	; set new background
 ORR R0,R7,R11,LSL R6
 MOV R2,R11
 MOV R14,R11
 MOV R7,R11,LSR R9		; seed the buffer
 STMIA R5!,{R0,R2,R11,R14}	; write the four words output
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

redraw_raster_main_8_5		; NB R6,R7 irrelevant here!
 FNJSR
loop$l
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 ADD R0,R4,R0,LSL#8		; address of bitmap DO NOT MOVE!
 LDMIA R0!,{R7,R9,R12,R14}	; get first four
 AND R2,R10,R7
 BIC R7,R11,R7			; must do bics etc for fonts/merge
 ORR R7,R2,R7
 AND R2,R10,R9
 BIC R9,R11,R9
 ORR R9,R2,R9
 AND R2,R10,R12			; R2=foreground bit
 BIC R12,R11,R12		; background bit
 ORR R12,R2,R12			; R12=first bitmap
 AND R2,R10,R14
 BIC R14,R11,R14
 ORR R14,R2,R14			; R14=second bitmap
 STMIA R5!,{R7,R9,R12,R14}
 LDMIA R0!,{R7,R9,R12,R14}	; get first four
 AND R2,R10,R7
 BIC R7,R11,R7			; must do bics etc for fonts/merge
 ORR R7,R2,R7
 AND R2,R10,R9
 BIC R9,R11,R9
 ORR R9,R2,R9
 AND R2,R10,R12			; R2=foreground bit
 BIC R12,R11,R12		; background bit
 ORR R12,R2,R12			; R12=first bitmap
 AND R2,R10,R14
 BIC R14,R11,R14
 ORR R14,R2,R14			; R14=second bitmap
 STMIA R5!,{R7,R9,R12,R14}
 MOV R7,#0			; new buffer contents
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

redraw_raster_main_16_5		; NB R6,R7 irrelevant here!
 FNJSR
loop$l
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code
 ADD R0,R4,R0,LSL#9		; address of bitmap DO NOT MOVE!
 LDMIA R0!,{R7,R9,R12,R14}	; get first four
 AND R2,R10,R7
 BIC R7,R11,R7			; must do bics etc for fonts/merge
 ORR R7,R2,R7
 AND R2,R10,R9
 BIC R9,R11,R9
 ORR R9,R2,R9
 AND R2,R10,R12			; R2=foreground bit
 BIC R12,R11,R12		; background bit
 ORR R12,R2,R12			; R12=first bitmap
 AND R2,R10,R14
 BIC R14,R11,R14
 ORR R14,R2,R14			; R14=second bitmap
 STMIA R5!,{R7,R9,R12,R14}
 LDMIA R0!,{R7,R9,R12,R14}	; get first four
 AND R2,R10,R7
 BIC R7,R11,R7			; must do bics etc for fonts/merge
 ORR R7,R2,R7
 AND R2,R10,R9
 BIC R9,R11,R9
 ORR R9,R2,R9
 AND R2,R10,R12			; R2=foreground bit
 BIC R12,R11,R12		; background bit
 ORR R12,R2,R12			; R12=first bitmap
 AND R2,R10,R14
 BIC R14,R11,R14
 ORR R14,R2,R14			; R14=second bitmap
 STMIA R5!,{R7,R9,R12,R14}
 MOV R7,#0			; new buffer contents
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

clear_raster_main_5		; R6,R7 always 0
 FNJSR
loop$l				; NB Background R11 will change
 LDRB R0,[R3],#1		; Don't seed! get next char
 TEQ R0,#0
 BLEQ redraw_control_code	; set new background
 MOV R0,R11
 MOV R2,R11
 MOV R14,R11
 STMIA R5!,{R0,R2,R11,R14}	; write first 4 words output
 STMIA R5!,{R0,R2,R11,R14}	; write last four words output
 SUBS R8,R8,#1
 BGT loop$l
 FNRTS

 LOCAL

redraw_raster_main_any
 FNJSR
 LDR R12,[R1,#r_charw]
 LDR R0,[R1,#r_bpp]
 MOV R12,R12,LSL R0		; width in bits
loop$l
 LDRB R0,[R3],#1		; get char
 TEQ R0,#0
 BLEQ redraw_control_code
 LDR R2,[R1,#r_cbpc]
 MLA R2,R0,R2,R4		; address of bitmap
	MOV	R0,R2,LSL #3	; bit addr of bitmap (no need to mask yet)
 MOV R9,R12			; number of bits to write
 BL redraw_raster_any_write
 SUBS R8,R8,#1			; done another character
 BGT loop$l
 FNRTS

 LOCAL

clear_raster_main_any
 FNJSR
 LDR R12,[R1,#r_charw]
 LDR R0,[R1,#r_bpp]
 MOV R12,R12,LSL R0		; width in bits
loop$l
 LDRB R0,[R3],#1		; get char
 TEQ R0,#0
 BLEQ redraw_control_code
 MOV R9,R12			; number of bits to clear
 BL redraw_raster_any_clear
 SUBS R8,R8,#1			; done another character
 BGT loop$l
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Redraw raster any size subs				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R2=bit address of bitmap line
;  R5-R7=output buffering
;  R9=number of bits to write>0. If R2 is not word aligned (ie
;  mult of 32) then the bitmap cannot cross a word boundry.
;  R10-R11=colour masks
;X R0,R9 corrupted R5-R7 updated, all else saved |
;  If R2 not aligned on input then aligned to next word on
;  output (mult of 32).

redraw_raster_any_write
 FNJSR
	ANDS	R0,R0,#&1F
 BNE notaligned$l		; not word aligned
aligned$l			; bitmap aligned on a word boundry (main)
 LDR R0,[R2],#4			; get next word of bitmap
 AND R14,R10,R0			; foreground
 BIC R0,R11,R0			; background
 ORR R0,R0,R14			; stuff to write
 SUBS R9,R9,#32			; do a word
 BLT end$l			; not a whole word
 ORR R7,R7,R0,LSL R6
 STR R7,[R5],#4
 RSB R14,R6,#32
 MOV R7,R0,LSR R14
 BGT aligned$l			; word aligned
 FNRTS				; finished
notaligned$l			; no aligned (eg first/last characters)
	LDMIA	R2!,{R14}	; get the word
	BIC	R2,R2,#3	; move to *start* of next word
 MOV R0,R14,LSR R0		; shift down
 AND R14,R10,R0			; foreground
 BIC R0,R11,R0			; background
 ORR R0,R14,R0			; stuff to write
 SUB R9,R9,#32
end$l
 ADDS R9,R9,#32			; R0=data to write
 FNRTS LE			; already finished
 MOV R14,#1
 MOV R14,R14,LSL R9
 SUB R14,R14,#1			; mask
 AND R0,R0,R14			; mask out rubbish
 ORR R7,R7,R0,LSL R6
 ADD R6,R6,R9
 CMP R6,#32			; overflowed?
 FNRTS CC
 STR R7,[R5],#4
 SUB R6,R6,R9
 RSB R6,R6,#32			; number of bits written
 MOV R7,R0,LSR R6
 RSB R6,R6,R9
 FNRTS

 LOCAL

;E R5-R7=output buffering
;  R9=number of bits to clear>0.
;  R11=background mask
;X R0,R9 corrupted R5-R7 updated, all else saved |
;  Bits cleared to background colour.

redraw_raster_any_clear
 CMP R6,#0
 BEQ aligned$l			; output word aligned
 RSB R0,R6,#32			; number of bits to do 1 .. 31
 CMP R0,R9
 BGT end$l			; bits will strictly fit in R7
 ORR R7,R7,R11,LSL R6
 STR R7,[R5],#4
 MOV R6,#0
 MOV R7,#0			; fill up the first word
 SUBS R9,R9,R0			; number to do
 MOVEQ PC,R14
aligned$l
 SUBS R9,R9,#32			; do another word
 BLT tidyup$l			; not a full word
 STR R11,[R5],#4
 BGT aligned$l
 MOV PC,R14
tidyup$l
 ADD R9,R9,#32			; num to do 1 ... 31
end$l
 MOV R0,#1			; with R6+R9<32
 MOV R0,R0,LSL R9
 SUB R0,R0,#1			; mask
 AND R0,R0,R11
 ORR R7,R7,R0,LSL R6		; bung it in
 ADD R6,R6,R9
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Convert control codes to a character			    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=redraw block
;  R3=address of next character (after 0 just read)
;  R4=char defn table/0 if raster being cleared
;  R10=foreground mask R11=background mask
;X R0=character to print
;  R3-R4,R10-R11 updated if necessary
;  R1-R2,R5-R9,R12 preserved

redraw_control_code
 LDRB R0,[R3],#1		; get next character
 CMP R0,#(control_end-control_start)/4
 ADDCC PC,PC,R0,LSL#2		; jump to code for this option
 MOV PC,R14			; return if invalid
control_start
 MOV PC,R14			; send the zero byte
 B control_code_1		; change colour
 B control_code_2		; line terminator
 B control_code_3		; extended character
 B control_code_4		; merged character
 B control_code_5		; finished merged character
 B control_code_6		; change foreground
 B control_code_7		; change background
 B control_code_8		; cursor merge character
 B control_code_9		; change substyle
 B control_code_10		; change substyle
control_end

control_code_1
 LDRB R10,[R3],#1		; new for num
 LDRB R11,[R3],#1		; new bac num
 LDR R0,[R1,#r_palette]
 LDR R10,[R0,R10,LSL#2]
 LDR R11,[R0,R11,LSL#2]		; change colour
 LDR R0,[R1,#r_flags]
 TST R0,#rf_extroutine
 MOVNE R0,#1
 BNE call_extension_plus
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BEQ redraw_control_code	; new control code
 MOV PC,R14			; do this char

control_code_2
 ADR R3,terminating_string	; spaces to finish off with
 MOV R0,#&20			; space
 MOV PC,R14

terminating_string
 = "                                              ",0,2,0
 ALIGN

control_code_3
 FNJSR
 LDRB R0,[R3],#1		; low byte
 LDRB R14,[R3],#1		; high byte
 ADD R0,R0,R14,LSL #8		; full character
 FNRTS				; do this character

control_code_4
 FNJSR "R2,R5-R9"
 BL get_merge_args
 CMN R6,#1
 FNRTS EQ			; merge aborted
 TEQ R4,#0
 FNRTS EQ			; in the middle of line spacing
 LDR R5,[R1,#r_workarea]	; place to store data
 STR R3,[R5,#a_stack1]		; save string to get back on
 STR R4,[R5,#a_stack2]		; save char defn table
 STR R10,[R5,#a_stack3]
 STR R11,[R5,#a_stack4]		; old masks
 ADD R5,R5,#64			; place for the bitmap
 MOV R2,R4			; char defn table for mask char
 LDR R0,[R1,#r_flags]
 TST R0,#rf_extroutine
 MOVNE R0,#4
 BLNE call_extension
 BL merge_characters		; merge them together
 MOV R4,R5			; new bitmap table
 MOV R0,#0			; character to print
 MVN R10,#0			; foreground =-1
 MOV R11,#0			; background =0
 ADR R3,cc4_string
 FNRTS
cc4_string
 = 0,5				; string to restore pointers
 ALIGN

control_code_5
 LDR R0,[R1,#r_workarea]
 LDR R3,[R0,#a_stack1]		; restore pointers
 LDR R4,[R0,#a_stack2]
 LDR R10,[R0,#a_stack3]
 LDR R11,[R0,#a_stack4]		; old masks
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BEQ redraw_control_code
 MOV PC,R14

control_code_6
 LDRB R10,[R3],#1		; new for num
 LDR R0,[R1,#r_palette]
 LDR R10,[R0,R10,LSL#2]
 LDR R0,[R1,#r_flags]
 TST R0,#rf_extroutine
 MOVNE R0,#6
 BNE call_extension_plus
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BEQ redraw_control_code	; new control code
 MOV PC,R14			; do this char

control_code_7
 LDRB R11,[R3],#1		; new for num
 LDR R0,[R1,#r_palette]
 LDR R11,[R0,R11,LSL#2]
 LDR R0,[R1,#r_flags]
 TST R0,#rf_extroutine
 MOVNE R0,#7
 BNE call_extension_plus
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BEQ redraw_control_code	; new control code
 MOV PC,R14			; do this char

control_code_8
 FNJSR "R2,R5-R9"
 BL get_merge_args
 CMN R6,#1			; EQ = merge aborted
 TEQNE R4,#0
 FNRTS EQ			; in the middle of line spacing
 LDR R5,[R1,#r_workarea]	; place to store data
 STR R3,[R5,#a_stack1]		; save string to get back on
 STR R4,[R5,#a_stack2]		; save char defn table
 STR R10,[R5,#a_stack3]
 STR R11,[R5,#a_stack4]		; old masks
 ADD R5,R5,#64			; place for the bitmap
 MOV R2,R4			; char defn table for mask char
 CMP R7,#5                      ; }
 ADDLS R7,R7,#&100		; } new code - this may break apps (not if they've been
				;   using these codes properly) but this is *much* more
				;   sensible than requiring 0,3,l,h sequences for all
				;   cursor characters - cl (0,8,f,b,c,0,3,l,h = 1 char!)
 LDR R0,[R1,#r_flags]
 TST R0,#rf_extroutine
 MOVNE R0,#8
 BLNE call_extension		; tell extension subs
 CMP R7,#&100
 BCC cc8_1			; swap for/bac cols
 MOV R8,R9			; set all to background colour
 BL merge_characters		; merge them together
 MOV R4,R5			; new bitmap table
 MOV R0,#0			; character to print
 MVN R10,#0			; foreground =-1
 MOV R11,#0			; background =0
cc8_end
 ADR R3,cc4_string		; restore cached vals
 FNRTS
cc8_1
 MOV R10,R8
 MOV R11,R9
 MOV R0,R6
 B cc8_end

 LOCAL

control_code_9
 CMP R4,#0
 LDRNE R0,[R1,#r_caddr]
 CMPNE R0,#&8000		; are we using handles?
 BHS nohandle$l
 FNJSR "R11"
 BIC R0,R0,#&FF
 LDRB R11,[R3]			; new font style...
 ORR R0,R0,R11
 BL handle_to_caddr
 LDR R11,[R1,#r_workarea]
 ADD R11,R11,#a_spr1
 SWP R14,R0,[R11]		; get old caddr and store new

;  PUSH		"R1,R2,R12"
;  BL		get_r12
;  FNLDR		R1,cache_addr
;  FNLDR		R2,cache_size
;  ADD		R2,R2,R1
;  CMP		R0,R1
;  CMPLO		R2,R0
;  DEBUG		R0,LO
;  BEEP		HS
;  PULL		"R1,R2,R12"

 SUB R14,R4,R14			; current cache offset
 ADD R4,R0,R14			; new cache address
 FNPULL
nohandle$l
 ADD R3,R3,#1
 LDR R0,[R1,#r_flags]
 TST R0,#rf_extroutine
 MOVNE R0,#9
 BNE call_extension_plus
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BEQ redraw_control_code	; new control code
 MOV PC,R14			; do this char

 LOCAL

control_code_10
 LDRB R10,[R3],#1		; new for num
 LDRB R11,[R3],#2		; new bac num
 ;ADD R3,R3,#1
 LDR R0,[R1,#r_palette]
 LDR R10,[R0,R10,LSL#2]
 LDR R11,[R0,R11,LSL#2]		; change colour
 LDR R0,[R1,#r_caddr]
 CMP R4,#0
 CMPNE R0,#&8000		; are we using handles?
 BHS nohandle$l
 FNJSR "R11"
 BIC R0,R0,#&FF
 LDRB R11,[R3,#-1]		; new font style...
 ORR R0,R0,R11
 BL handle_to_caddr
 LDR R11,[R1,#r_workarea]
 ADD R11,R11,#a_spr1
 SWP R14,R0,[R11]		; get old caddr and store new
 SUB R14,R4,R14			; current cache offset
 ADD R4,R0,R14			; new cache address
 FNPULL
nohandle$l
 LDR R0,[R1,#r_flags]
 TST R0,#rf_extroutine
 MOVNE R0,#10
 BNE call_extension_plus
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BEQ redraw_control_code	; new control code
 MOV PC,R14			; do this char
 ;LDRB R0,[R3],#1		; new font style... discarded...!
 ;ADD R3,R3,#1
 ;LDR R0,[R1,#r_flags]
 ;TST R0,#1<<2
 ;MOVNE R0,#9
 ;BNE call_extension_plus
 ;LDRB R0,[R3],#1		; get next char
 ;TEQ R0,#0
 ;BEQ redraw_control_code	; new control code
 ;MOV PC,R14			; do this char

;E R3=pointer to first merge arg
;X R3=pointer to start of next code
;  R8/R9=palette entries for mask characters
;  R6/R7=base/mask character or R6=-1 if already done
;  R0,R3-R4,R10-R11 set up to new vals if already done

get_merge_args
 FNJSR
 LDRB R8,[R3],#1		; alt for num
 LDRB R9,[R3],#1		; alt bac num
 LDR R0,[R1,#r_palette]
 LDR R8,[R0,R8,LSL#2]
 LDR R9,[R0,R9,LSL#2]		; alt cols
 LDRB R0,[R3],#1		; get next char
 TEQ R0,#0
 BLEQ redraw_control_code	; get base character
 ADR R14,cc4_string
 TEQ R14,R3
 BEQ gma_1
 MOV R6,R0			; base character
 LDRB R0,[R3],#1		; get mask character
 TEQ R0,#0
 BLEQ redraw_control_code
 MOV R7,R0			; mask character
 ADR R14,cc4_string
 TEQ R14,R3
 MVNEQ R6,#0			; set to -1 if this was a merge
 FNRTS
gma_1
 STMFD R13!,{R0-R4}		; save the vals
 LDR R4,[R1,#r_workarea]
 LDR R1,[R4,#a_stack1]		; string we were on
 LDRB R0,[R1],#1
 TEQ R0,#0
 BLEQ to_skip_control_char
 STR R1,[R4,#a_stack1]		; skipped the second argument
 LDMFD R13!,{R0-R4}		; restore vals
 MVN R6,#0			; abort
 FNRTS

to_skip_control_char
 FNJSR "R4"
 BL skip_control_char
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Call extension code					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=extension number + in a redraw control code sub

call_extension_plus
 PUSH "R14"
 BL call_extension
 PULL "R14"
 LDRB R0,[R3],#1
 TEQ R0,#0
 BEQ redraw_control_code
 MOV PC,R14

;E R0=extension number R1=redraw block R2-R11=parameters
;X R0-R11 as returned by extension mode sub |

call_extension
 STMFD R13!,{R12,R14}
 LDR R12,[R1,#r_workarea]
 LDR R14,[R12,#a_ext1]		; address of extension sub
 LDR R12,[R12,#a_ext2]		; extension sub private word
	STMFD	R13!,{R14}	; save on stack
 MOV R14,PC			; return address
 LDMFD R13!,{PC}		; call the sub
 LDMFD R13!,{R12,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Find cached character size SWI			    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=bpp R2=charw R3=charh
;X R2=cbpl R3=cbpc with R2 rounded to 1,2,multiple of 4

cached_char_size
 MOV R2,R2,LSL R0		; width in pixels
 CMP R2,#8
 MOVLE R2,#1
 BLE ccs_0
 CMP R2,#16
 MOVLE R2,#2
 BLE ccs_0
 ADD R2,R2,#31			; round up
 MOV R2,R2,LSR#5		; number of words
 MOV R2,R2,LSL#2		; number of bytes
ccs_0
 MUL R3,R2,R3			; multiply by height
 MOV PC,R14			; end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Convert bitmap SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=redraw block (uses r_bpp r_charw r_charh r_caddr
;		    r_cbpl r_cbpc to write to)
;  R2=first char R3=last char (inc) R4=source bitmap (1-1)
;X r_caddr written to |

convert_bitmap
 FNJSR "R1-R9"
 MOV R8,R2			; save first char
 ADD R9,R3,#1			; save last char (+1)
 MOV R0,#0			; 1 bit per pixel
 LDR R2,[R1,#r_charw]
 LDR R3,[R1,#r_charh]
 BL cached_char_size		; find source char sizes R2,R3
 LDR R5,[R1,#r_caddr]		; start of cache
 LDR R0,[R1,#r_cbpc]		; bytes per character
 MLA R5,R8,R0,R5		; pointer to first dest char
 MLA R4,R8,R3,R4		; pointer to first source char
 SUBS R9,R9,R8			; number of chars to cache
 FNRTS LE
 LDR R7,[R1,#r_bpp]		; bpp to convert to
 CMP R7,#0
 BLE cb_copy			; just copy the bitmap
 MOV R0,#1
 MOV R6,R0,LSL R7		; number of bits per pixel
 MOV R6,R0,LSL R6		; 2^number of bits
 SUB R6,R6,#1			; bit mask (n ones)
 LDR R3,[R1,#r_cbpl]		; bytes per cache line
cb_loop
 BL convert_bitmap_char
 SUBS R9,R9,#1
 BGT cb_loop
 FNRTS
cb_copy
 MOV R1,R4			; source
 MOV R2,R5			; dest
 MUL R3,R9,R3			; number of bytes
 BL move_bytes
 FNRTS

;E R1=redraw block giving character size r_charw r_charh
;  R2=bytes per cache line for source character
;  R3=bytes per cache line for dest char
;  R4=pointer to source character
;  R5=pointer to destination character
;  R6=bit mask to insert (at most the bottom 2^R7 bits set)
;  R7=Log_2 number of bits per pixel (1-5 not 0!)
;X Ones in the source character replaced by R6 in the dest
;  Zeros replaced by 2^R7 zeros
;  R4,R5 updated to start of next character |

convert_bitmap_char
 FNJSR "R8-R12"
 LDR R8,[R1,#r_charh]		; height of the character count
cbc_line_loop
 MOV R9,R3			; bytes per cache line in dest
 MOV R11,R4			; pointer to source buffer
 ADR R14,cbc_return
 CMP R7,#6
 ADDCC PC,PC,R7,LSL#2		; dispatch
 B cbc_return			; no good
 B cbc_return			; zero unsupported
 B convert_bitmap_1		; 2 bpp
 B convert_bitmap_2		; 4 bpp
 B convert_bitmap_3		; 8 bpp
 B convert_bitmap_4		; 16 bpp
 B convert_bitmap_5		; 32 bpp
cbc_return
 ADD R4,R4,R2			; move to next source line
 SUBS R8,R8,#1			; dec number of lines
 BGT cbc_line_loop
 FNRTS

;  Convert bitmap subs
;E R5=pointer to dest buffer
;  R9=counter of number of bytes to write to dest
;  R11=pointer to source character
;X R5 updated to start of next line
;  R0,R9-R12 corrupted all else saved |

convert_bitmap_1
 LDRB R10,[R11],#1		; get next 8 pixels
 MOV R0,#0
 MOV R12,#8
cb1_loop
 MOVS R10,R10,LSR#1
 ORRCS R0,R0,R6
 MOV R0,R0,ROR#2
 MOVS R10,R10,LSR#1
 ORRCS R0,R0,R6			; do two pixels
 MOV R0,R0,ROR#2
 SUBS R12,R12,#2
 BGT cb1_loop
 MOV R0,R0,ROR#16		; done 16 bits
 STRB R0,[R5],#1		; save first byte
 SUBS R9,R9,#2			; done 2 bytes
 MOVMI PC,R14			; only needed to do one
 MOV R0,R0,LSR#8
 STRB R0,[R5],#1		; second byte
 BGT convert_bitmap_1
 MOV PC,R14

convert_bitmap_2
 LDRB R10,[R11],#1		; get next 8 pixels
 MOV R0,#0			; clear buffer
 MOV R12,#8			; pixel count
cb2_loop
 MOVS R10,R10,LSR#1
 ORRCS R0,R0,R6
 MOV R0,R0,ROR#4
 MOVS R10,R10,LSR#1
 ORRCS R0,R0,R6			; do two pixels
 MOV R0,R0,ROR#4
 SUBS R12,R12,#2
 BGT cb2_loop
 SUBS R9,R9,#4			; done 4 bytes
 BMI cbc_not_full_word		; save various bytes
 STR R0,[R5],#4			; write next word
 BGT convert_bitmap_2
 MOV PC,R14

convert_bitmap_3
 LDRB R10,[R11],#1		; get next 8 pixels
 MOV R12,#8			; pixel count (4 fills a word)
cb3_loop
 MOV R0,#0			; clear buffer
 MOVS R10,R10,LSR#1
 ORRCS R0,R0,R6
 MOV R0,R0,ROR#8
 MOVS R10,R10,LSR#1
 ORRCS R0,R0,R6
 MOV R0,R0,ROR#8
 MOVS R10,R10,LSR#1
 ORRCS R0,R0,R6
 MOV R0,R0,ROR#8
 MOVS R10,R10,LSR#1
 ORRCS R0,R0,R6
 MOV R0,R0,ROR#8		; do 4 pixels = 1 word
 SUBS R9,R9,#4			; done 4 bytes
 BMI cbc_not_full_word		; save various bytes
 STR R0,[R5],#4			; write next word
 MOVEQ PC,R14			; finished
 SUBS R12,R12,#4		; done 4 pixels
 BGT cb3_loop
 B convert_bitmap_3

convert_bitmap_4
 LDRB R10,[R11],#1		; get next 8 pixels
 MOV R12,#8			; pixel count (2 fills a word)
cb4_loop
 MOV R0,#0			; clear buffer
 MOVS R10,R10,LSR#1
 ORRCS R0,R0,R6
 MOV R0,R0,ROR#16
 MOVS R10,R10,LSR#1
 ORRCS R0,R0,R6
 MOV R0,R0,ROR#16
 SUBS R9,R9,#4			; done 4 bytes
 BMI cbc_not_full_word		; save various bytes
 STR R0,[R5],#4			; write next word
 MOVLE PC,R14			; finished
 SUBS R12,R12,#2		; done 2 pixels
 BGT cb4_loop
 B convert_bitmap_4

convert_bitmap_5
 LDRB R10,[R11],#1		; get next 8 pixels
 MOV R12,#8			; pixel count (1 fills a word)
cb5_loop
 MOVS R10,R10,LSR#1
 MOVCC R0,#0
 MOVCS R0,R6
 SUBS R9,R9,#4			; done 4 bytes
 STR R0,[R5],#4			; write next word
 MOVLE PC,R14			; finished
 SUBS R12,R12,#1		; done 1 pixel
 BGT cb5_loop
 B convert_bitmap_5

cbc_not_full_word
 STRB R0,[R5],#1
 TST R9,#1
 MOVNE PC,R14			; only needed to do one byte
 MOV R0,R0,LSR#8
 STRB R0,[R5],#1
 MOV PC,R14			; written the two bytes

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Merge characters					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=redraw block giving size of character row
;  R2=character defn table for mask character
;  R4=character defn table for base character
;  R5=address of output buffer
;  R6=base character
;  R7=mask character (cursor char - use alt cols if this set)
;  R8/R9=alternate for/bac col masks
;  R10/R11=standard for/bac col masks
;X One line of cached character merged. |
;  If either R6 or R7 were -1 then returns (already merged)

merge_characters
 CMN R6,#1
 CMNNE R7,#1
 MOVEQ PC,R14
 FNJSR "R1-R7"
 LDR R0,[R1,#r_cbpc]
 MLA R6,R0,R6,R4
 MLA R7,R0,R7,R2		; character addresses
 LDR R2,[R1,#r_cbpl]
mc_0
 SUBS R2,R2,#4			; 4 bytes left?
 BLT mc_2
 LDR R3,[R6],#4			; R3=base
 LDR R4,[R7],#4			; R4=mask
 MVN R1,R3
 BIC R1,R1,R4
 AND R1,R1,R11			; background (normal)
 BIC R0,R3,R4
 AND R0,R0,R10
 ORR R1,R1,R0			; add in background (normal)
 BIC R0,R4,R3
 AND R0,R0,R9
 ORR R1,R1,R0			; add in background (alternate)
 AND R0,R3,R4
 AND R0,R0,R8
 ORR R1,R1,R0			; add in foreground (alternate)
 STR R1,[R5],#4			; one byte of output
 B mc_0
mc_2
 ADDS R2,R2,#4
 FNRTS LE
mc_1
 LDRB R3,[R6],#1		; R3=base
 LDRB R4,[R7],#1		; R4=mask
 MVN R1,R3
 BIC R1,R1,R4
 AND R1,R1,R11			; background (normal)
 BIC R0,R3,R4
 AND R0,R0,R10
 ORR R1,R1,R0			; add in background (normal)
 BIC R0,R4,R3
 AND R0,R0,R9
 ORR R1,R1,R0			; add in background (alternate)
 AND R0,R3,R4
 AND R0,R0,R8
 ORR R1,R1,R0			; add in foreground (alternate)
 STRB R1,[R5],#1		; one byte of output
 SUBS R2,R2,#1
 BGT mc_1
 FNRTS

 END
