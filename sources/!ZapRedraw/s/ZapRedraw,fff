; ZapRedraw
; $Id: ZapRedraw,fff,v 1.15 2002/11/16 21:24:16 christian Exp $
;
; (C) D.H.Symes 1993-1996, Zap Developers 1997-1999

 GET h.ZapRedHdr
 GET h.Version
 GET h.Commands
 GET h.Cache
 GET h.Messages
 GET h.SWIs
 GET h.DSARedraw
 GET h.VFRedraw
 GET h.VDURedraw

 EXPORT div_mod
 EXPORT find_character
 EXPORT skip_control_char
 EXPORT move_bytes
 EXPORT strcopy
 EXPORT strcpy
 EXPORT strcasecmp
 EXPORT strlen

 EXPORT add_vdu_bitmaps
 EXPORT read_vdu_vars
 EXPORT read_system_chars
 EXPORT cache_font_chars

 EXPORT get_r12

; module header

 AREA |!!!Module_Header_Area|,CODE,READONLY

 ENTRY

Module_header
Start_code		DCD 0
Initialisation_code	DCD init_code
Finalisation_code	DCD final_code
Service_call_handler	DCD service_code
Title_string		DCD title_string
Help_string		DCD help_string
Command_keyword_tab	DCD command_table

 [ |zap$|="Zap"

SWI_chunk_number	DCD &48480		; actual SWI number

 |

SWI_chunk_number	DCD &48440		; text X SWI number

 ]

SWI_handler_code	DCD swi_code
SWI_decoding_table	DCD swi_table
SWI_decoding_code	DCD 0
Messages_File		DCD messages_filename
Module_Flags		DCD module_flags

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; TITLES AND COMMAND TABLES				       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

help_string = |zap$|,"Redraw",9
	    = version,"(00 Jan 0000)"
 [ BUILD > ""
		= " ",BUILD
  [ (BUILD:RIGHT:1 < "0" :LOR: BUILD:RIGHT:1 > "9") :LAND: patch_level <> ""
		= "-",patch_level
  ]
 |
  [ test_flag
		= " [TEST"
   [ patch_level <> ""
		= " ",patch_level
   ]
		= "]"
  |
   [ patch_level <> ""
		= " patch-",patch_level
   ]
  ]
 ]
	    = " © Zap Developers",0

title_string = |zap$|:CC:"Redraw",0

		ALIGN

messages_filename  ;= |zap$|:CC:"FontsMessages:Messages",0
		   = "ZapFontsMessages:Messages",0
		ALIGN

module_flags	DCD	1				; 32bit safe!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Swi table						    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

swi_table
 = |zap$|,"Redraw",0
 = "RedrawArea",0		; 0	0
 = "GetPaletteEntry",0		; 1	1
 = "RedrawRaster",0		; 2	2
 = "ConvertBitmap",0		; 3	3
 = "PrepareDataLine",0		; 4	4
 = "AddCursor",0		; 5	5
 = "FindCharacter",0		; 6	6
 = "MoveBytes",0		; 7	7
 = "CachedCharSize",0		; 8	8
 = "ConvBitmapChar",0		; 9	9
 = "CreatePalette",0		; 10	a
 = "InsertChar",0		; 11	b
 = "ReadSystemChars",0		; 12	c
 = "ReverseBitmaps",0		; 13	d
 = "ReadVduVars",0		; 14	e
 = "GetRectangle",0		; 15	f
 = "AddVduBitmaps",0		; 16	10
 = "CacheFontChars",0		; 17	11
 = "SpriteSize",0		; 18	12
 = "RedrawWindow",0		; 19	13
 = "Divide",0			; 20	14
 = "PlotRectangle",0		; 21	15
 = "AddCursorSmart",0		; 22	16
 = "FindFont",0			; 23	17
 = "LoseFont",0			; 24	18
 = "ReadCharSize",0		; 25	19
 = "Version",0			; 26	1a
 = "ListFonts",0		; 27	1b
 = "UpdateWindow",0		; 28	1c
 = "ReadFontInfo",0		; 29	1d
 = "ReadModeBPP",0		; 30	1e
 = 0
 ALIGN


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; initialisation / finalisation code			    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		LOCAL

init_code	FNJSR
		LDR	R0,[R12]
		TEQ	R0,#0
		BNE	reinit$l			; after a non-fatal finalisation
		MOV	R0,#6				; claim workspace
		MOV	R3,#workspace_size
		SWI	XOS_Module
		FNRTS	VS
		STR	R2,[R12]
		MOV	R12,R2

		MOV	R0,#0				; clear it
		MOV	R1,#workspace_size
loop$l		STR	R0,[R2],#4
		SUBS	R1,R1,#4
		BNE	loop$l

	; Check for ViewFinder.
		SUB	R13,R13,#12
		ADR	R0,viewfinder_1_29
		SWI	XOS_CLI			; Is the module there?
		MOVVS	R0,#0			; If not, stop now
		BVS	set_vf_flag
		ADR	R0,viewfinder_1_41
		SWI	XOS_CLI			; Is it v1.41 or later?
		MOVVC	R0,#vf_is_present:OR:vf_mode_has_changed
						; If so, assume active
		BVC	set_vf_flag
		ADR	R0,vf_enable_var	; Read Viewfinder$Enable
		MOV	R1,R13
		MOV	R2,#11
		MOV	R3,#0
		MOV	R4,#0
		SWI	XOS_ReadVarVal
		MOVVS	R4,#2			; Not found? Don't use VF
		CMP	R4,#2
		MOVHS	R0,#0
		BHS	set_vf_flag
		CMP	R4,#1			; Right. Now is VF in use?
		LDREQ	R0,[R13]
		MOVNE	R0,#0
		STRNEB	R0,[R13,R2]
		MOVNE	R0,#10
		MOVNE	R1,R13
		SWINE	XOS_ReadUnsigned
		MOVVS	R2,#0			; Not number? Don't use VF
		MOVS	R0,R2			; non-0 = use VF
		MOVNE	R0,#vf_is_present:OR:vf_mode_has_changed
set_vf_flag	STR	R0,[R12,#viewfinder_select]
		ADD	R13,R13,#12
		STR	R12,[R12,#viewfinder_draw_R12]
		ADRL	R1,vf_draw_swi
			; ADR here may trigger a linker bug (Norcroft)
		STR	R1,[R12,#viewfinder_draw_code]
		TEQ	R0,#vf_is_present
		MOVNE	R0,#6
		ADDNE	R1,R12,#viewfinder_direct_call
		MOVNE	R2,#16
		SWINE	XViewFinder_Info	; we don't care if this fails

		MOV	R1,R12				; initialise fake redraw block
		ADD	R0,R12,#buffer
		STR	R0,[R1,#r_workarea]
		BL	read_vdu_vars			; init cache vdu vars

		ADRVC	R0,messages_filename
		BLVC	messages_init			; open messages file
		FNRTS	VS
		BL	init_cache			; init DA

reinit$l	ADR	R0,cb$l				; add callback routine
		MOV	R1,R12
		SWI	XOS_AddCallBack
		FNRTS

cb$l		FNJSR	"R1"				; PRMs are useless. Are we in SVC mode?
		LDR	R1,service_ZapRedrawStarted
		SWI	XOS_ServiceCall
		FNRTS


viewfinder_1_29
		=	"%RMEnsure ViewFinder 1.29",0
viewfinder_1_41
		=	"%RMEnsure ViewFinder 1.41",0
vf_enable_var	=	"ViewFinder$Enable",0

		LOCAL

		[ |zap$|="Zap"
service_ZapRedrawStarted DCD &48480
service_ZapRedrawDying	 DCD &48481
		|
service_ZapRedrawStarted DCD &48440
service_ZapRedrawDying	 DCD &48441
		]

; kill the module, if allowed
final_code	TEQ	R10,#0
		MOVEQ	PC,R14				; non-fatal
		FNJSR					; svc mode
		LDR	R12,[R12]
		BL	check_kill_cache		; ok to kill the cache?
		FNRTS	VS				; nope
		LDR	R1,service_ZapRedrawDying
		SWI	XOS_ServiceCall
		TEQ	R1,#0
		FNPULL	EQ
		BEQ	error_cantdie			; in s.Cache
		BL	messages_kill			; close messages file
		BLVC	kill_cache			; kill cache if empty
		MOVVC	R0,#7				; free workspace
		MOVVC	R2,R12
		SWIVC	XOS_Module
		MOV	R0,#0
		STR	R0,[R12]			; null private word
		FNRTS


; service call handler - listens to Service_ModeChange

service_table	&	0
		&	service_dispatch
		&	&46
		&	0

		&	service_table
service_code	MOV	R0,R0
		TEQ	R1,#&46
		MOVNE	PC,R14
service_dispatch
		LDR	R12,[R12]
		B	mode_change


get_r12		LDR	R12,local_r12
		MOV	PC,R14

local_r12	DCD	0				; yuck

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SWI code						    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

; SWI handler code entry point
; should I MOVS on returning incase user mode? X form

swi_code
 LDR R12,[R12]
 STR R12,local_r12		; eugh
 CMP R11,#(end$l-start$l)/4
 ADDCC PC,PC,R11,LSL#2
 B unknown$l
start$l
 B redraw_area			; 0
 B get_palette_entry
 B redraw_raster_select
 B convert_bitmap
 B prepare_data_line
 B add_cursor			; 5
 B find_character
 B move_bytes
 B cached_char_size		; 8
 B convert_bitmap_char
 B create_palette		; 10
 B insert_char
 B read_system_chars
 B reverse_bitmaps
 B read_vdu_vars
 B get_rectangle		; 15
 B add_vdu_bitmaps		; 16
 B cache_font_chars
 B sprite_size
 B redraw_window
 B div_mod
 B plotrect
 B add_cursor_smart
 B find_font
 B lose_font
 B read_char_size
 B version_swi
 B list_fonts
 B update_window
 B read_font_info
 B read_mode_bpp
end$l
unknown$l ERROR err_ukswi,"UKSWI"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get palette entry SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=colour number (0->2^R1-1)
;  R1=r_bpp
;X R0=colour number duplicated to fill out word

get_palette_entry
 CMP R1,#6
 ADDCC PC,PC,R1,LSL#2		; jump table
 MOV PC,R14
 ORR R0,R0,R0,LSL#1		; 1bbp
 ORR R0,R0,R0,LSL#2		; 2bpp
 ORR R0,R0,R0,LSL#4		; 4bpp
 ORR R0,R0,R0,LSL#8		; 8bpp
 ORR R0,R0,R0,LSL#16		; 16bpp
 MOV PC,R14			; 32bpp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Redraw area SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=redraw block R2=extension sub R3=private word

redraw_area
 ;SWI &107
 LDR R0,[R1,#r_flags]
 TST R0,#rf_vdu
 BEQ redraw_area_dsa		; direct screen access
 B redraw_area_vdu		; vdu mode


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Version SWI						    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; read the version of the module
; E
; X R0 = version number  R1 -> div_mod  R2 -> move_bytes
version_swi	MOV	R0,#version_number		; version number (decimal * 100)
		ADR	R1,div_mod
		ADRL	R2,move_bytes
		MOV	PC,R14


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Division/Modulo - optimised routine written by Darren Salt ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=numerator	  R1=denominator
;X R0=R0 DIV R1	  R2=R0 MOD R1	  R1 corrupted R3 corrupted if r1 > 39 |

;div_mod
; MOV R2,#0			; clear remainder
; RSB R1,R1,#0			; negate denom
; MOV R3,#32
; TST R0,#&FF000000		; dispose of zero bytes
; MOVEQ R0,R0,LSL #8
; SUBEQ R3,R3,#8
; TST R0,#&FF000000
; MOVEQ R0,R0,LSL #8
; SUBEQ R3,R3,#8
; TST R0,#&FF000000
; MOVEQ R0,R0,LSL #8
; SUBEQ R3,R3,#8
; ADDS R0,R0,R0			; double numerator
div_mod	CMP	R1,#33
	ADDLO	PC,PC,R1,LSL #2
	B	divbyn
	B	divby0
	B	divby1
	B	divby2
	B	divby3
	B	divby4
	B	divby5
	B	divby6
	B	divby7
	B	divby8
	B	divby9
	B	divby10
	B	divby11
	B	divby12
	B	divby13
	B	divby14
	B	divby15
	B	divby16
	B	divby17
	B	divby18
	B	divby19
	B	divby20
	B	divby21
	B	divby22
	B	divby23
	B	divby24
	B	divby25
	B	divby26
	B	divby27
	B	divby28
	B	divby29
	B	divby30
	B	divby31
	B	divby32
;	B	divby33
;	B	divby34
;	B	divby35
;	B	divby36
;	B	divby37
;	B	divby38
;	B	divby39
divby0	MOV	R2,#0
	MVN	R0,#1<<31	; error!
	MOV	PC,R14
divby1	MOV	R2,#0
	MOV	PC,R14
divby2	AND	R2,R0,#1
	MOV	R0,R0,LSR #1
	MOV	PC,R14
divby3	ADD	R1,R0,R0,LSR #2
	ADD	R1,R1,R1,LSR #4
	ADD	R1,R1,R1,LSR #8
	ADD	R1,R1,R1,LSR #16
	MOV	R1,R1,LSR #2
	RSB	R2,R1,R1,LSL #2
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#3
	CMP	R2,#3
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#3
	MOV	R0,R1
	MOV	PC,R14
divby4	AND	R2,R0,#3
	MOV	R0,R0,LSR #2
	MOV	PC,R14
divby5	SUB	R1,R0,R0,LSR #2
	ADD	R1,R1,R1,LSR #4
	ADD	R1,R1,R1,LSR #8
	ADD	R1,R1,R1,LSR #16
	MOV	R1,R1,LSR #2
	ADD	R2,R1,R1,LSL #2
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#5
	CMP	R2,#5
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#5
	MOV	R0,R1
	MOV	PC,R14
divby6	ADD	R1,R0,R0,LSR #2
	ADD	R1,R1,R1,LSR #4
	ADD	R1,R1,R1,LSR #8
	ADD	R1,R1,R1,LSR #16
	MOV	R1,R1,LSR #3
	RSB	R2,R1,R1,LSL #2
	SUBS	R2,R0,R2,LSL #1
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#6
	CMP	R2,#6
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#6
	MOV	R0,R1
	MOV	PC,R14
divby7	MOV	R1,R0,LSR #1
	ADD	R1,R1,R1,LSR #3
	ADD	R1,R1,R1,LSR #6
	ADD	R1,R1,R1,LSR #12
	ADD	R1,R1,R1,LSR #24
	MOV	R1,R1,LSR #2
	RSB	R2,R1,R1,LSL #3
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#7
	CMP	R2,#7
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#7
	MOV	R0,R1
	MOV	PC,R14
divby8	AND	R2,R0,#7
	MOV	R0,R0,LSR #3
	MOV	PC,R14
divby9	SUB	R1,R0,R0,LSR #3
	ADD	R1,R1,R1,LSR #6
	ADD	R1,R1,R1,LSR #12
	ADD	R1,R1,R1,LSR #24
	MOV	R1,R1,LSR #3
	ADD	R2,R1,R1,LSL #3
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#9
	CMP	R2,#9
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#9
	MOV	R0,R1
	MOV	PC,R14
divby10	SUB	R1,R0,R0,LSR #2
	ADD	R1,R1,R1,LSR #4
	ADD	R1,R1,R1,LSR #8
	ADD	R1,R1,R1,LSR #16
	MOV	R1,R1,LSR #3
	ADD	R2,R1,R1,LSL #2
	SUBS	R2,R0,R2,LSL #1
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&0A
	CMP	R2,#&0A
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&0A
	MOV	R0,R1
	MOV	PC,R14
divby11	SUB	R1,R0,R0,LSR #2
	SUB	R1,R1,R0,LSR #5
	ADD	R1,R1,R0,LSR #7
	ADD	R1,R1,R1,LSR #10
	ADD	R1,R1,R1,LSR #20
	MOV	R1,R1,LSR #3
	RSB	R2,R1,R1,LSL #2
	RSB	R2,R1,R2,LSL #2
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&0B
	CMP	R2,#&0B
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&0B
	MOV	R0,R1
	MOV	PC,R14
divby12	ADD	R1,R0,R0,LSR #2
	ADD	R1,R1,R1,LSR #4
	ADD	R1,R1,R1,LSR #8
	ADD	R1,R1,R1,LSR #16
	MOV	R1,R1,LSR #4
	RSB	R2,R1,R1,LSL #2
	SUBS	R2,R0,R2,LSL #2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&0C
	CMP	R2,#&0C
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&0C
	MOV	R0,R1
	MOV	PC,R14
divby13	MOV	R1,R0,LSR #1
	ADD	R1,R1,R0,LSR #3
	SUB	R1,R1,R0,LSR #7
	SUB	R1,R1,R0,LSR #9
	ADD	R1,R1,R1,LSR #12
	ADD	R1,R1,R1,LSR #24
	MOV	R1,R1,LSR #3
	RSB	R2,R1,R1,LSL #2
	ADD	R2,R1,R2,LSL #2
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&0D
	CMP	R2,#&0D
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&0D
	MOV	R0,R1
	MOV	PC,R14
divby14	MOV	R1,R0,LSR #1
	ADD	R1,R1,R1,LSR #3
	ADD	R1,R1,R1,LSR #6
	ADD	R1,R1,R1,LSR #12
	ADD	R1,R1,R1,LSR #24
	MOV	R1,R1,LSR #3
	RSB	R2,R1,R1,LSL #3
	SUBS	R2,R0,R2,LSL #1
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&0E
	CMP	R2,#&0E
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&0E
	MOV	R0,R1
	MOV	PC,R14
divby15	MOV	R1,R0,LSR #1
	ADD	R1,R1,R1,LSR #4
	ADD	R1,R1,R1,LSR #8
	ADD	R1,R1,R1,LSR #16
	MOV	R1,R1,LSR #3
	RSB	R2,R1,R1,LSL #4
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&0F
	CMP	R2,#&0F
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&0F
	MOV	R0,R1
	MOV	PC,R14
divby16	AND	R2,R0,#15
	MOV	R0,R0,LSR #4
	MOV	PC,R14
divby17	SUB	R1,R0,R0,LSR #4
	ADD	R1,R1,R1,LSR #8
	ADD	R1,R1,R1,LSR #16
	MOV	R1,R1,LSR #4
	ADD	R2,R1,R1,LSL #4
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&11
	CMP	R2,#&11
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&11
	MOV	R0,R1
	MOV	PC,R14
divby18	SUB	R1,R0,R0,LSR #3
	ADD	R1,R1,R1,LSR #6
	ADD	R1,R1,R1,LSR #12
	ADD	R1,R1,R1,LSR #24
	MOV	R1,R1,LSR #4
	ADD	R2,R1,R1,LSL #3
	SUBS	R2,R0,R2,LSL #1
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&12
	CMP	R2,#&12
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&12
	MOV	R0,R1
	MOV	PC,R14
divby19	SUB	R1,R0,R0,LSR #3
	SUB	R1,R1,R0,LSR #5
	SUB	R1,R1,R0,LSR #9
	ADD	R1,R1,R0,LSR #12
	ADD	R1,R1,R0,LSR #14
	ADD	R1,R1,R1,LSR #18
	MOV	R1,R1,LSR #4
	ADD	R2,R1,R1,LSL #2
	RSB	R2,R1,R2,LSL #2
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&13
	CMP	R2,#&13
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&13
	MOV	R0,R1
	MOV	PC,R14
divby20	SUB	R1,R0,R0,LSR #2
	ADD	R1,R1,R1,LSR #4
	ADD	R1,R1,R1,LSR #8
	ADD	R1,R1,R1,LSR #16
	MOV	R1,R1,LSR #4
	ADD	R2,R1,R1,LSL #2
	SUBS	R2,R0,R2,LSL #2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&14
	CMP	R2,#&14
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&14
	MOV	R0,R1
	MOV	PC,R14
divby21	SUB	R1,R0,R0,LSR #2
	ADD	R1,R1,R1,LSR #6
	ADD	R1,R1,R1,LSR #12
	ADD	R1,R1,R1,LSR #24
	MOV	R1,R1,LSR #4
	ADD	R2,R1,R1,LSL #2
	ADD	R2,R1,R2,LSL #2
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&15
	CMP	R2,#&15
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&15
	MOV	R0,R1
	MOV	PC,R14
divby22	SUB	R1,R0,R0,LSR #2
	SUB	R1,R1,R0,LSR #5
	ADD	R1,R1,R0,LSR #7
	ADD	R1,R1,R1,LSR #10
	ADD	R1,R1,R1,LSR #20
	MOV	R1,R1,LSR #4
	RSB	R2,R1,R1,LSL #2
	RSB	R2,R1,R2,LSL #2
	SUBS	R2,R0,R2,LSL #1
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&16
	CMP	R2,#&16
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&16
	MOV	R0,R1
	MOV	PC,R14
divby23	SUB	R1,R0,R0,LSR #2
	SUB	R1,R1,R0,LSR #4
	ADD	R1,R1,R0,LSR #7
	ADD	R1,R1,R1,LSR #11
	ADD	R1,R1,R1,LSR #22
	MOV	R1,R1,LSR #4
	RSB	R2,R1,R1,LSL #2
	RSB	R2,R1,R2,LSL #3
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&17
	CMP	R2,#&17
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&17
	MOV	R0,R1
	MOV	PC,R14
divby24	ADD	R1,R0,R0,LSR #2
	ADD	R1,R1,R1,LSR #4
	ADD	R1,R1,R1,LSR #8
	ADD	R1,R1,R1,LSR #16
	MOV	R1,R1,LSR #5
	RSB	R2,R1,R1,LSL #2
	SUBS	R2,R0,R2,LSL #3
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&18
	CMP	R2,#&18
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&18
	MOV	R0,R1
	MOV	PC,R14
divby25	MOV	R1,R0,LSR #1
	ADD	R1,R1,R0,LSR #3
	ADD	R1,R1,R0,LSR #6
	SUB	R1,R1,R0,LSR #11
	SUB	R1,R1,R0,LSR #13
	SUB	R1,R1,R0,LSR #16
	ADD	R1,R1,R1,LSR #20
	MOV	R1,R1,LSR #4
	RSB	R2,R1,R1,LSL #2
	ADD	R2,R1,R2,LSL #3
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&19
	CMP	R2,#&19
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&19
	MOV	R0,R1
	MOV	PC,R14
divby26	MOV	R1,R0,LSR #1
	ADD	R1,R1,R0,LSR #3
	SUB	R1,R1,R0,LSR #7
	SUB	R1,R1,R0,LSR #9
	ADD	R1,R1,R1,LSR #12
	ADD	R1,R1,R1,LSR #24
	MOV	R1,R1,LSR #4
	RSB	R2,R1,R1,LSL #2
	ADD	R2,R1,R2,LSL #2
	SUBS	R2,R0,R2,LSL #1
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&1A
	CMP	R2,#&1A
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&1A
	MOV	R0,R1
	MOV	PC,R14
divby27	MOV	R1,R0,LSR #1
	ADD	R1,R1,R0,LSR #3
	SUB	R1,R1,R0,LSR #5
	SUB	R1,R1,R0,LSR #10
	SUB	R1,R1,R0,LSR #12
	ADD	R1,R1,R0,LSR #14
	ADD	R1,R1,R1,LSR #18
	MOV	R1,R1,LSR #4
	RSB	R2,R1,R1,LSL #3
	RSB	R2,R1,R2,LSL #2
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&1B
	CMP	R2,#&1B
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&1B
	MOV	R0,R1
	MOV	PC,R14
divby28	MOV	R1,R0,LSR #1
	ADD	R1,R1,R1,LSR #3
	ADD	R1,R1,R1,LSR #6
	ADD	R1,R1,R1,LSR #12
	ADD	R1,R1,R1,LSR #24
	MOV	R1,R1,LSR #4
	RSB	R2,R1,R1,LSL #3
	SUBS	R2,R0,R2,LSL #2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&1C
	CMP	R2,#&1C
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&1C
	MOV	R0,R1
	MOV	PC,R14
divby29	MOV	R1,R0,LSR #1
	ADD	R1,R1,R0,LSR #4
	SUB	R1,R1,R0,LSR #6
	ADD	R1,R1,R0,LSR #8
	ADD	R1,R1,R0,LSR #10
	SUB	R1,R1,R0,LSR #15
	SUB	R1,R1,R0,LSR #18
	ADD	R1,R1,R0,LSR #20
	SUB	R1,R1,R0,LSR #22
	SUB	R1,R1,R0,LSR #24
	ADD	R1,R1,R1,LSR #28
	MOV	R1,R1,LSR #4
	RSB	R2,R1,R1,LSL #3
	ADD	R2,R1,R2,LSL #2
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&1D
	CMP	R2,#&1D
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&1D
	MOV	R0,R1
	MOV	PC,R14
divby30	MOV	R1,R0,LSR #1
	ADD	R1,R1,R1,LSR #4
	ADD	R1,R1,R1,LSR #8
	ADD	R1,R1,R1,LSR #16
	MOV	R1,R1,LSR #4
	RSB	R2,R1,R1,LSL #4
	SUBS	R2,R0,R2,LSL #1
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&1E
	CMP	R2,#&1E
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&1E
	MOV	R0,R1
	MOV	PC,R14
divby31	MOV	R1,R0,LSR #1
	ADD	R1,R1,R1,LSR #5
	ADD	R1,R1,R1,LSR #10
	ADD	R1,R1,R1,LSR #20
	MOV	R1,R1,LSR #4
	RSB	R2,R1,R1,LSL #5
	SUBS	R2,R0,R2
	SUBMI	R1,R1,#1
	ADDMI	R2,R2,#&1F
	CMP	R2,#&1F
	ADDGE	R1,R1,#1
	SUBGE	R2,R2,#&1F
	MOV	R0,R1
	MOV	PC,R14
divby32	AND	R2,R0,#31
	MOV	R0,R0,LSR #5
	MOV	PC,R14
;divby33	SUB	R1,R0,R0,LSR #5
;	ADD	R1,R1,R1,LSR #10
;	ADD	R1,R1,R1,LSR #20
;	MOV	R1,R1,LSR #5
;	ADD	R2,R1,R1,LSL #5
;	SUBS	R2,R0,R2
;	SUBMI	R1,R1,#1
;	ADDMI	R2,R2,#&21
;	CMP	R2,#&21
;	ADDGE	R1,R1,#1
;	SUBGE	R2,R2,#&21
;	MOV	R0,R1
;	MOV	PC,R14
;divby34	SUB	R1,R0,R0,LSR #4
;	ADD	R1,R1,R1,LSR #8
;	ADD	R1,R1,R1,LSR #16
;	MOV	R1,R1,LSR #5
;	ADD	R2,R1,R1,LSL #4
;	SUBS	R2,R0,R2,LSL #1
;	SUBMI	R1,R1,#1
;	ADDMI	R2,R2,#&22
;	CMP	R2,#&22
;	ADDGE	R1,R1,#1
;	SUBGE	R2,R2,#&22
;	MOV	R0,R1
;	MOV	PC,R14
;divby35	SUB	R1,R0,R0,LSR #3
;	ADD	R1,R1,R0,LSR #5
;	ADD	R1,R1,R0,LSR #7
;	ADD	R1,R1,R1,LSR #12
;	ADD	R1,R1,R1,LSR #24
;	MOV	R1,R1,LSR #5
;	ADD	R2,R1,R1,LSL #3
;	RSB	R2,R1,R2,LSL #2
;	SUBS	R2,R0,R2
;	SUBMI	R1,R1,#1
;	ADDMI	R2,R2,#&23
;	CMP	R2,#&23
;	ADDGE	R1,R1,#1
;	SUBGE	R2,R2,#&23
;	MOV	R0,R1
;	MOV	PC,R14
;divby36	SUB	R1,R0,R0,LSR #3
;	ADD	R1,R1,R1,LSR #6
;	ADD	R1,R1,R1,LSR #12
;	ADD	R1,R1,R1,LSR #24
;	MOV	R1,R1,LSR #5
;	ADD	R2,R1,R1,LSL #3
;	SUBS	R2,R0,R2,LSL #2
;	SUBMI	R1,R1,#1
;	ADDMI	R2,R2,#&24
;	CMP	R2,#&24
;	ADDGE	R1,R1,#1
;	SUBGE	R2,R2,#&24
;	MOV	R0,R1
;	MOV	PC,R14
;divby37	SUB	R1,R0,R0,LSR #3
;	SUB	R1,R1,R0,LSR #7
;	SUB	R1,R1,R0,LSR #9
;	SUB	R1,R1,R0,LSR #11
;	ADD	R1,R1,R0,LSR #13
;	SUB	R1,R1,R0,LSR #18
;	ADD	R1,R1,R0,LSR #21
;	ADD	R1,R1,R0,LSR #25
;	ADD	R1,R1,R0,LSR #27
;	MOV	R1,R1,LSR #5
;	ADD	R2,R1,R1,LSL #3
;	ADD	R2,R1,R2,LSL #2
;	SUBS	R2,R0,R2
;	SUBMI	R1,R1,#1
;	ADDMI	R2,R2,#&25
;	CMP	R2,#&25
;	ADDGE	R1,R1,#1
;	SUBGE	R2,R2,#&25
;	MOV	R0,R1
;	MOV	PC,R14
;divby38	SUB	R1,R0,R0,LSR #3
;	SUB	R1,R1,R0,LSR #5
;	SUB	R1,R1,R0,LSR #9
;	ADD	R1,R1,R0,LSR #12
;	ADD	R1,R1,R0,LSR #14
;	ADD	R1,R1,R1,LSR #18
;	MOV	R1,R1,LSR #5
;	ADD	R2,R1,R1,LSL #2
;	RSB	R2,R1,R2,LSL #2
;	SUBS	R2,R0,R2,LSL #1
;	SUBMI	R1,R1,#1
;	ADDMI	R2,R2,#&26
;	CMP	R2,#&26
;	ADDGE	R1,R1,#1
;	SUBGE	R2,R2,#&26
;	MOV	R0,R1
;	MOV	PC,R14
;divby39	SUB	R1,R0,R0,LSR #2
;	ADD	R1,R1,R0,LSR #4
;	ADD	R1,R1,R0,LSR #7
;	ADD	R1,R1,R1,LSR #12
;	ADD	R1,R1,R1,LSR #24
;	MOV	R1,R1,LSR #5
;	ADD	R2,R1,R1,LSL #2
;	RSB	R2,R1,R2,LSL #3
;	SUBS	R2,R0,R2
;	SUBMI	R1,R1,#1
;	ADDMI	R2,R2,#&27
;	CMP	R2,#&27
;	ADDGE	R1,R1,#1
;	SUBGE	R2,R2,#&27
;	MOV	R0,R1
;	MOV	PC,R14
divbyn
 MOV R2,#0			; clear remainder
 RSB R1,R1,#0			; negate denom
 MOV R3,#32
 TST R0,#&FF000000		; dispose of zero bytes
 MOVEQ R0,R0,LSL #8
 SUBEQ R3,R3,#8
 TST R0,#&FF000000		; dispose of zero bytes
 MOVEQ R0,R0,LSL #8
 SUBEQ R3,R3,#8
 TST R0,#&FF000000		; dispose of zero bytes
 MOVEQ R0,R0,LSL #8
 SUBEQ R3,R3,#8
 ADDS R0,R0,R0			; double numerator
div_mod_1
 ADCS R2,R1,R2,LSL#1
 SUBCC R2,R2,R1
 ADCS R0,R0,R0
 ADCS R2,R1,R2,LSL#1
 SUBCC R2,R2,R1
 ADCS R0,R0,R0
 ADCS R2,R1,R2,LSL#1
 SUBCC R2,R2,R1
 ADCS R0,R0,R0
 ADCS R2,R1,R2,LSL#1
 SUBCC R2,R2,R1
 ADCS R0,R0,R0
 SUB R3,R3,#4
 TEQ R3,#0
 BNE div_mod_1			; DO NOT CORRUPT CARRY
 MOV PC,R14

;old_div_mod
; MOV R2,#0			; clear remainder
; ADDS R0,R0,R0			; double numerator
; RSB R1,R1,#0			; negate denom
; MOV R3,#32
;div_mod_1
; ADCS R2,R1,R2,LSL#1
; SUBCC R2,R2,R1
; ADCS R0,R0,R0
; ADCS R2,R1,R2,LSL#1
; SUBCC R2,R2,R1
; ADCS R0,R0,R0
; ADCS R2,R1,R2,LSL#1
; SUBCC R2,R2,R1
; ADCS R0,R0,R0
; ADCS R2,R1,R2,LSL#1
; SUBCC R2,R2,R1
; ADCS R0,R0,R0
; SUB R3,R3,#4
; TEQ R3,#0
; BNE div_mod_1			; DO NOT CORRUPT CARRY
; MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Skip one control code					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=pointer to start of control sequence R2=for R3=bac R4=font
;X R1-R4 updated
;  R0>0 if it was a character
;  R0=0 if we've reached the line end
;  R0<0 if this didn't count as a character

; Note that for backwards compatability with earlier versions of
; ZapRedraw, if no 0,9 or 0,10 characters are encountered, R4 is preserved.

skip_control_char
 LDRB R0,[R1],#1		; get next char
 CMP R0,#(skip_ctrl_end-skip_ctrl_start)/4
 ADDCC PC,PC,R0,LSL#2
 MOV PC,R14			; was a char (unknown)
skip_ctrl_start
 B skip_ctrl_0
 B skip_ctrl_1			; change col
 B skip_ctrl_2			; file end
 B skip_ctrl_3			; extend
 B skip_ctrl_4			; merge
 MOV PC,R14			; 5=recall stacked point
 B skip_ctrl_6			; change for
 B skip_ctrl_7			; change bac
 B skip_ctrl_4			; cursor merge
 B skip_ctrl_9			; font change
 B skip_ctrl_10			; font and colour change
skip_ctrl_end

skip_ctrl_0
 MOV R0,#1			; is a char
 MOV PC,R14

skip_ctrl_1
 LDRB R2,[R1],#1		; new for
 LDRB R3,[R1],#1		; new bac
 MVN R0,#0			; not a char
 MOV PC,R14

skip_ctrl_2
 SUB R1,R1,#2
 MOV R0,#0			; reached line end
 MOV PC,R14

skip_ctrl_3
 ADD R1,R1,#2
 MOV PC,R14

skip_ctrl_4
 FNJSR
 ADD R1,R1,#2			; skip the cols
 LDRB R0,[R1],#1		; next char
 TEQ R0,#0
 BLEQ skip_control_char
 LDRB R0,[R1],#1		; and mask character
 TEQ R0,#0
 BLEQ skip_control_char
 FNRTS

skip_ctrl_6
 LDRB R2,[R1],#1		; new for
 MVN R0,#0			; not a char
 MOV PC,R14

skip_ctrl_7
 LDRB R3,[R1],#1		; new bac
 MVN R0,#0			; not a char
 MOV PC,R14

skip_ctrl_9
 LDRB R4,[R1],#1		; new font
 MVN R0,#0			; not a char
 MOV PC,R14

skip_ctrl_10
 LDRB R2,[R1],#1		; new for
 LDRB R3,[R1],#1		; new bac
 LDRB R4,[R1],#1		; new font
 MVN R0,#0			; not a char
 MOV PC,R14

; space save above...?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Prepare data line for drawing				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=colour to use for ctrl chars / -1 if none
;  R1=redraw block giving start for/bac cols & flags to say if R7 is used
;  R2=input string
;  R3=foreground mask
;  R4=background mask
;  R5=input length
;  R6=dest buffer (size 6*R5+16)
;  R7=substyle list (not supplied if b3 of r_flags is zero)
;X R0=highest char code used
;  R5=length of output string

; internally:
;    R0 = temp
;    R1 = printable char
;    R2-R4 as input
;    R5 = input bytes remaining
;    R6 = destination
;    R7 = substyle list / 0
;    R8 = current fg
;    R9 = current bg
;   R10 = current style
;   R11 = temp
;   R12 -> module workspace including buffer

; prepare_data_line workspace (in buffer)
		^	:INDEX:buffer
pdlws_ctl_col	#	4				; control colour
pdlws_max	#	4				; highest used char
pdlws_last_ctl	#	4				; pointer to end of last control sequence
pdlws_output	#	4				; pointer to end of last control sequence

prepare_data_line
		FNJSR	"R1-R4,R6-R11"

		STR	R0,[R12,#pdlws_ctl_col]		; keep control colour
		MOV	R0,#&20				; init highest char
		STR	R0,[R12,#pdlws_max]
		STR	R6,[R12,#pdlws_last_ctl]	; last control sequence pointer
		STR	R6,[R12,#pdlws_output]		; output buffer start

		LDRB	R8,[R1,#r_for]			; read initial colours
		LDRB	R9,[R1,#r_bac]

		LDR	R10,[R1,#r_flags]		; and initial style if present
		TST	R10,#rf_substyles
		MOVEQ	R7,#0
		MOVEQ	R10,#0
		BEQ	loop$l

		LDR	R10,[R1,#r_caddr]		; get initial style from font handle
		CMP	R10,#&8000
		ANDLO	R10,R10,#&FF
		MOVHS	R10,#0

loop$l		LDRB	R1,[R2],#1			; get input character

		LDR	R0,[R12,#pdlws_ctl_col]		; use ctl colour if < 32
		CMN	R0,#0				; and ctl colour > -1
		CMPGE	R1,#&20				;
		LDRGEB	R0,[R3],#1			; check fg colour same
		ADDLT	R3,R3,#1
		TEQ	R0,R8
		MOVNE	R8,R0
		BNE	new_fg$l

		LDRB	R0,[R4],#1			; check bg colour same
		TEQ	R0,R9
		MOVNE	R9,R0
		BNE	new_bg$l

		TEQ	R7,#0				; check style same
		MOVEQ	R0,#0
		LDRNEB	R0,[R7],#1
		TEQ	R0,R10
		MOVNE	R10,R0
		BNE	new_style$l

storechar$l	TEQ	R1,#0                           ; 0 -> 0,0
		STREQB	R1,[R6],#1
		STRB	R1,[R6],#1
		LDR	R11,[R12,#pdlws_max]		; update highest char
		CMP	R0,R11
		STRHI	R0,[R12,#pdlws_max]

		SUBS	R5,R5,#1
		BNE	loop$l

		LDR	R11,[R12,#pdlws_last_ctl]
shorten_loop$l	CMP	R6,R11				; strip space characters from the end
		BLS	done$l
		LDRB	R0,[R6,#-1]!
		TEQ	R0,#' '
		BEQ	shorten_loop$l
		ADD	R6,R6,#1

done$l		MOV	R0,#0				; terminate with 0,2
		STRB	R0,[R6],#1
		MOV	R0,#2
		STRB	R0,[R6],#1

		LDR	R0,[R12,#pdlws_output]		; get the output length
		SUB	R5,R6,R0

		LDR	R0,[R12,#pdlws_max]		; and the hightest printable character
		FNRTS


; new foreground colour (and possibly bg and style)
new_fg$l	TEQ	R7,#0
		MOVEQ	R0,#0				; check style same
		LDRNEB	R0,[R7],#1
		TEQ	R0,R10
		MOVNE	R10,R0
		BNE	new_fg_and_style$l

		LDRB	R0,[R4],#1			; cehck bg same
		TEQ	R0,R9
		MOVNE	R9,R0
		BNE	new_fg_and_bg$l

		MOV	R0,#0				; only fg changing
		STRB	R0,[R6],#1			; use 0,6,f
		MOV	R0,#6
		STRB	R0,[R6],#1
		STRB	R8,[R6],#1
		B	aftercode$l

; new fg and bg (but not style)
new_fg_and_bg$l	MOV	R0,#0				; use 0,1,f,b
		STRB	R0,[R6],#1
		MOV	R0,#1
		STRB	R0,[R6],#1
		STRB	R8,[R6],#1
		STRB	R9,[R6],#1
		B	aftercode$l

; new bg colour (and possibly style, but not fg)
new_bg$l	TEQ	R7,#0
		MOVEQ	R0,#0				; check style same
		LDRNEB	R0,[R7],#1
		TEQ	R0,R10
		MOVNE	R10,R0
		BNE	new_style$l

		MOV	R0,#0				; use 0,7,b
		STRB	R0,[R6],#1
		MOV	R0,#7
		STRB	R0,[R6],#1
		STRB	R9,[R6],#1
		B	aftercode$l

; new fg and style, and possibly bg
new_fg_and_style$l
		LDRB	R9,[R4],#1

; new fg, bg and style
new_style$l	MOV	R0,#0				; use 0,10,f,b,s
		STRB	R0,[R6],#1
		MOV	R0,#10
		STRB	R0,[R6],#1
		TST	R10,#(1<<3)			; check inverse bit
		STRNEB	R9,[R6],#1
		STRNEB	R8,[R6],#1
		STREQB	R8,[R6],#1
		STREQB	R9,[R6],#1
		STRB	R10,[R6],#1

; we've written a control sequence. keep a note of where
aftercode$l	STR	R6,[R12,#pdlws_last_ctl]
		B	storechar$l			; store the actual character



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Add cursor SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=dest string
;  R1=redraw block giving inital r_for and r_bac
;  R2=offset in source string
;  R3=cursor len
;  R4=cursor string (low bytes)
;  R5=source string 0,2 terminated
;  R6=foreground colour to swap cursor for/bac cols on / -1
;  R7=b0-b7  = high bytes of cursor chars
;     b8-b15 = control code to use 4/8 (4 default)
;     b16-b23= cursor for
;     b24-b31= cursor bac
;X R0=new dest string end (after 0,2)
;  Input string lengthened if off the end
;  (length grows by at most R2+9*R3) #

; We do this by setting up the appropriate call to the new-style
; add cursor routine (Zap_AddCursorSmart, below).
add_cursor
 CMP R6,#-1
 MOVEQ R6,#0
 ANDNE R6,R6,#0xff
 ORRNE R6,R6,#(1:SHL:30)
 B add_cursor_smart

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Add cursor SWI (new-style)				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=dest string
;  R1=redraw block giving inital r_for and r_bac
;  R2=offset in source string
;  R3=cursor len
;  R4=cursor string (low bytes)
;  R5=source string 0,2 terminated
;  R6=b0-b7   foreground colour to find
;     b8-b15  background colour to find
;     b16-b29 reserved
;     b30 => foreground colour is present
;     b31 => background colour is present
;
;     If we find given fg col, set fg = curbg, bg = curfg
;     If not and we find given bg col, set bg = curfg (fg
;     remains as what it is)
;
;     This is typically used to invert cursor colours in
;     a selection. The background matching is to allow
;     some characters in a selection to have a different
;     foreground colour and still get the appropriate cursor
;     colour for the background.
;  R7=b0-b7  = high bytes of cursor chars
;     b8-b15 = control code to use 4/8 (4 default)
;     b16-b23= cursor for
;     b24-b31= cursor bac
;X R0=new dest string end (after 0,2)
;  Input string lengthened if off the end
;  (length grows by at most R2+9*R3) #

add_cursor_smart
 FNJSR "R1-R10"
 MOV R10,R7			; save the cursor colours
 MOV R9,R6			; save swap colour
 MOV R6,R0			; dest string
 MOV R7,R3			; save cursor len count
 MOV R0,R2			; num chars to skip
 LDR R2,[R1,#r_for]
 LDR R3,[R1,#r_bac]		; set up initial colours
ac_0
 MOV R1,R5			; start of string
 PUSH "R4"
 BL find_character
 PULL "R4"
 FNRTS VS
 SUB R8,R0,R1			; length of this char/-ve
 PUSH "R2-R3"
 SUB R3,R1,R5			; num to move
 MOV R1,R5
 MOV R2,R6
 ADD R5,R5,R3
 ADD R6,R6,R3
 BL move_bytes			; copy in first bit of string
 PULL "R2-R3"
 CMP R8,#0
 BLE ac_2			; we've run out of data
 BL ac_write_cur
 PUSH "R2-R3"
 MOV R1,R5
 MOV R2,R6
 MOV R3,R8
 BL move_bytes			; copy in the old character
 PULL "R2-R3"
 ADD R5,R5,R8
 ADD R1,R6,R8
 LDRB R0,[R4],#1		; next cursor char
 AND R14,R10,#&FF		; high byte
 ORR R0,R0,R14,LSL#8
 BL insert_char			; insert mask character
 MOV R6,R1
 MOV R0,#0			; num of chars to skip now 0
 SUBS R7,R7,#1
 BGT ac_0			; do another
 MVN R0,#0
 MOV R1,R5
 PUSH "R4"
 BL find_character		; get to end
 PULL "R4"
 FNRTS VS
 SUB R8,R1,R5			; length of rest of string
 MOV R1,R5
 MOV R2,R6
 ADD R3,R8,#2			; copy 0,2 as well
 ADD R6,R6,R3			; new end
 BL move_bytes
 MOV R0,R6
 FNRTS
ac_2
 RSBS R8,R8,#0			; num of chars left to skip
 BLE ac_3
 MOV R0,#&20			; add extra spaces
ac_4
 STRB R0,[R6],#1
 SUBS R8,R8,#1
 BGT ac_4
ac_3
 BL ac_write_cur
 MOV R0,#&20
 STRB R0,[R6],#1		; base character
 MOV R1,R6
 LDRB R0,[R4],#1
 AND R14,R10,#&FF
 ORR R0,R0,R14,LSL#8
 BL insert_char			; insert mask character
 MOV R6,R1
 SUBS R7,R7,#1			; next byte of cursor
 BGT ac_3
 MOV R0,#0
 STRB R0,[R6],#1
 MOV R0,#2
 STRB R0,[R6],#1
 MOV R0,R6
 FNRTS

;E R2/R3=for and bac R6=buffer pointer R10=cols
;  R9=swapcol (b0-b7 fg, b8-b15 bg, b30 => fg, b31 => bg)
;  See not at add_cursor_smart, above.
;X 0,<code>,f,b written to the buffer, R6 updated.

 LOCAL

ac_write_cur
 FNJSR "R1,R4"
 AND R1,R9,#0xff		; fg to find
 MOV R4,R9,LSR #8
 AND R4,R4,#0xff		; bg to find

 MOV R0,#0
 STRB R0,[R6],#1

 MOV R0,R10,LSR#8
 AND R0,R0,#&FF			; control code number
 TEQ R0,#8
 MOVNE R0,#4			; default
 STRB R0,[R6],#1

 TST R9,#(1:SHL:30)
 BEQ not_fg$l
 CMP R2,R1			; foreground match?
 BNE not_fg$l
 MOV R0,R10,LSR #24
 STRB R0,[R6],#1		; set fg to cursor bg
 MOV R0,R10,LSR #16
 STRB R0,[R6],#1		; set bg to cursor fg
 FNRTS

not_fg$l
 TST R9,#(1:SHL:31)
 BEQ not_bg$l
 CMP R3,R4			; background match?
 BNE not_bg$l
 STRB R2,[R6],#1		; use existing fg
 MOV R0,R10,LSR #16
 STRB R0,[R6],#1		; set bg to cursor fg
 FNRTS

not_bg$l
 MOV R0,R10,LSR#16		; set fg to cursor fg, bg to cursor bg
 STRB R0,[R6],#1
 MOV R0,R10,LSR#24
 STRB R0,[R6],#1
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Move bytes SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R1=source address
;  R2=destination address
;  R3=number of bytes
;X bytes moved FAST from R1 to R2 with data always preserved R0-R3 corrupt |
;  it is careful not to look beyond the start/end of the data

move_bytes
 CMP R3,#0
 CMPNE R2,R1
 BCC down$l			; move down starting from start of data
 MOVEQ PC,R14			; data not being moved, or no data to move
; move up starting from end of data
up$l				; MOVE BYTES UP (from end)
 ADD R1,R1,R3			; end of source
 ADD R2,R2,R3			; end of dest
 TST R2,#3
 BNE ualign$l
ualigned$l			; destination (R2) now word aligned
 TST R1,#3
 BNE uslow$l			; source not word align so need to shift
 SUBS R3,R3,#8*4
 BLT uf32$l			; up fast less than 32 bytes
 STMFD R13!,{R4-R11}
a$l
 LDMDB R1!,{R4-R11}
 STMDB R2!,{R4-R11}
 SUBS R3,R3,#8*4
 BGE a$l			; copy 32 bytes at a time
 LDMFD R13!,{R4-R11}
uf32$l				; copy R3+32 bytes
 ADDS R3,R3,#7*4
 BLT uf4$l			; up fast less than 4 bytes
b$l
 LDR R0,[R1,#-4]!
 SUBS R3,R3,#4
 STR R0,[R2,#-4]!
 BGE b$l			; copy 4 bytes at a time
uf4$l
 ADDS R3,R3,#4			; number of bytes remaining
 MOVEQ PC,R14			; none
 LDR R0,[R1,#-4]!		; load next 4 (ok as R1,R2 both aligned)
c$l
 MOV R0,R0,ROR#24
 STRB R0,[R2,#-1]!


 SUBS R3,R3,#1
 BGT c$l			; copy remaining bytes
 MOV PC,R14
ualign$l
 LDRB R0,[R1,#-1]!
 SUBS R3,R3,#1
 STRB R0,[R2,#-1]!
 MOVEQ PC,R14
 TST R2,#3
 BNE ualign$l			; copy bytes 'till dest aligned
 B ualigned$l
uslow$l				; dest (R2) aligned, source (R1) not
 STMFD R13!,{R12,R14}
 AND R12,R1,#3			; byte offset of last read byte (1-3)
 LDR R14,[R1,-R12]!
 MOV R12,R12,LSL#3		; number of bits not read in [R1]
 RSB R0,R12,#32			; number of bits already read in [R1]
 MOV R14,R14,LSL R0		; fill input buffer (R14)
 SUBS R3,R3,#8*4
 BLT us32$l			; up slow less than 32 bytes
 STMFD R13!,{R4-R11}
 CMP R12,#16
 BEQ d_16$l
 BGT d_24$l
d_8$l
 LDMDB R1!,{R4-R11}
 SUBS R3,R3,#8*4
 ORR R14,R14,R11,LSR #8		; copy 32 bytes at a time shifting
 MOV R11,R11,	 LSL #24
 ORR R11,R11,R10,LSR #8
 MOV R10,R10,	 LSL #24
 ORR R10,R10,R9, LSR #8
 MOV R9, R9,	 LSL #24
 ORR R9, R9, R8, LSR #8
 MOV R8, R8,	 LSL #24
 ORR R8, R8, R7, LSR #8
 MOV R7, R7,	 LSL #24
 ORR R7, R7, R6, LSR #8
 MOV R6, R6,	 LSL #24
 ORR R6, R6, R5, LSR #8
 MOV R5, R5,	 LSL #24
 ORR R5, R5, R4 ,LSR #8
 STMDB R2!,{R5-R11,R14}
 MOV R14,R4,LSL #24
 BGE d_8$l
 B d_done$l
d_16$l
 LDMDB R1!,{R4-R11}
 ORR R14,R14,R11,LSR #16	; copy 32 bytes at a time shifting
 MOV R11,R11,	 LSL #16
 ORR R11,R11,R10,LSR #16
 MOV R10,R10,	 LSL #16
 ORR R10,R10,R9, LSR #16
 MOV R9, R9,	 LSL #16
 ORR R9, R9, R8, LSR #16
 MOV R8, R8,	 LSL #16
 ORR R8, R8, R7, LSR #16
 MOV R7, R7,	 LSL #16
 ORR R7, R7, R6, LSR #16
 MOV R6, R6,	 LSL #16
 ORR R6, R6, R5, LSR #16
 MOV R5, R5,	 LSL #16
 ORR R5, R5, R4 ,LSR #16
 STMDB R2!,{R5-R11,R14}
 MOV R14,R4,LSL #16
 SUBS R3,R3,#8*4
 BGE d_16$l
 B d_done$l
d_24$l
 LDMDB R1!,{R4-R11}
 ORR R14,R14,R11,LSR #24	; copy 32 bytes at a time shifting
 MOV R11,R11,	 LSL #8
 ORR R11,R11,R10,LSR #24
 MOV R10,R10,	 LSL #8
 ORR R10,R10,R9, LSR #24
 MOV R9, R9,	 LSL #8
 ORR R9, R9, R8, LSR #24
 MOV R8, R8,	 LSL #8
 ORR R8, R8, R7, LSR #24
 MOV R7, R7,	 LSL #8
 ORR R7, R7, R6, LSR #24
 MOV R6, R6,	 LSL #8
 ORR R6, R6, R5, LSR #24
 MOV R5, R5,	 LSL #8
 ORR R5, R5, R4 ,LSR #24
 STMDB R2!,{R5-R11,R14}
 MOV R14,R4,LSL #8
 SUBS R3,R3,#8*4
 BGE d_24$l
d_done$l
 LDMFD R13!,{R4-R11}
us32$l				; up slow less than R3+32 bytes
 ADDS R3,R3,#7*4
 BLT us4$l			; up slow less than 4 bytes
 STMFD R13!,{R4}
e$l
 LDR R4,[R1,#-4]!
 SUBS R3,R3,#4
 ORR R14,R14,R4,LSR R12
 STR R14,[R2,#-4]!
 MOV R14,R4,LSL R0
 BGE e$l			; copy one word at a time
 LDMFD R13!,{R4}
us4$l
 ADDS R3,R3,#4			; number of bytes left
 LDMEQFD R13!,{R12,PC}
 ADD R1,R1,R12,LSR#3		; address of last byte used
f$l
 LDRB R14,[R1,#-1]!		; get next byte (don't read too far)
 SUBS R3,R3,#1
 STRB R14,[R2,#-1]!		; put next byte
 BGT f$l
 LDMFD R13!,{R12,PC}
down$l				; MOVE BYTES DOWN (from start)
 TST R2,#3
 BNE dalign$l			; ensure output (R2) aligned
daligned$l			; R2 now aligned
 TST R1,#3
 BNE dslow$l			; source not aligned
 SUBS R3,R3,#8*4
 BLT df32$l			; less than 32 to move
 STMFD R13!,{R4-R11}
g$l
 LDMIA R1!,{R4-R11}
 STMIA R2!,{R4-R11}
 SUBS R3,R3,#8*4
 BGE g$l			; move 32 bytes at a time
 LDMFD R13!,{R4-R11}
df32$l
 ADDS R3,R3,#7*4
 BLT df4$l			; less than 4 bytes to move
h$l
 LDR R0,[R1],#4
 SUBS R3,R3,#4
 STR R0,[R2],#4
 BGE h$l			; shift 4 bytes at a time
df4$l
 ADDS R3,R3,#4			; number of bytes left
 MOVEQ PC,R14
 LDR R0,[R1],#4			; load next 4 (ok as both aligned)
i$l
 STRB R0,[R2],#1
 MOV R0,R0,ROR#8
 SUBS R3,R3,#1
 BGT i$l			; copy the remaining bytes
 MOV PC,R14
dalign$l
 LDRB R0,[R1],#1
 SUBS R3,R3,#1
 STRB R0,[R2],#1
 MOVEQ PC,R14
 TST R2,#3
 BNE dalign$l			; word align the destination
 B daligned$l
dslow$l				; dest (R2) aligned, source (R1) not
 STMFD R13!,{R12,R14}
 AND R12,R1,#3			; byte offset of first unread byte (1-3)
 BIC R1,R1,#3			; address of first not fully read word
 MOV R12,R12,LSL#3		; number of bits read from !R1
 RSB R14,R12,#32		; number of bits not read from !R1
 LDR R0,[R1],#4
 MOV R0,R0,LSR R12		; fill the input buffer (R0)
 SUBS R3,R3,#8*4
 BLT ds32$l			; less than 32 bytes left
 STMFD R13!,{R4-R11}
 CMP R14,#16
 BEQ j_16$l
 BGT j_24$l
j_8$l
 LDMIA R1!,{R4-R11}
 ORR R0, R0, R4, LSL #8	; copy 32 bytes at a time with shifting
 MOV R4, R4,	 LSR #24
 ORR R4, R4, R5, LSL #8
 MOV R5, R5,	 LSR #24
 ORR R5, R5, R6, LSL #8
 MOV R6, R6,	 LSR #24
 ORR R6, R6, R7, LSL #8
 MOV R7, R7,	 LSR #24
 ORR R7, R7, R8, LSL #8
 MOV R8, R8,	 LSR #24
 ORR R8, R8, R9, LSL #8
 MOV R9, R9,	 LSR #24
 ORR R9, R9, R10,LSL #8
 MOV R10,R10,	 LSR #24
 ORR R10,R10,R11,LSL #8
 STMIA R2!,{R0,R4-R10}
 MOV R0,R11,LSR #24
 SUBS R3,R3,#8*4
 BGE j_8$l
 B j_done$l
j_16$l
 LDMIA R1!,{R4-R11}
 ORR R0, R0, R4, LSL #16	; copy 32 bytes at a time with shifting
 MOV R4, R4,	 LSR #16
 ORR R4, R4, R5, LSL #16
 MOV R5, R5,	 LSR #16
 ORR R5, R5, R6, LSL #16
 MOV R6, R6,	 LSR #16
 ORR R6, R6, R7, LSL #16
 MOV R7, R7,	 LSR #16
 ORR R7, R7, R8, LSL #16
 MOV R8, R8,	 LSR #16
 ORR R8, R8, R9, LSL #16
 MOV R9, R9,	 LSR #16
 ORR R9, R9, R10,LSL #16
 MOV R10,R10,	 LSR #16
 ORR R10,R10,R11,LSL #16
 STMIA R2!,{R0,R4-R10}
 MOV R0,R11,LSR #16
 SUBS R3,R3,#8*4
 BGE j_16$l
 B j_done$l
j_24$l
 LDMIA R1!,{R4-R11}
 ORR R0, R0, R4, LSL #24	; copy 32 bytes at a time with shifting
 MOV R4, R4,	 LSR #8
 ORR R4, R4, R5, LSL #24
 MOV R5, R5,	 LSR #8
 ORR R5, R5, R6, LSL #24
 MOV R6, R6,	 LSR #8
 ORR R6, R6, R7, LSL #24
 MOV R7, R7,	 LSR #8
 ORR R7, R7, R8, LSL #24
 MOV R8, R8,	 LSR #8
 ORR R8, R8, R9, LSL #24
 MOV R9, R9,	 LSR #8
 ORR R9, R9, R10,LSL #24
 MOV R10,R10,	 LSR #8
 ORR R10,R10,R11,LSL #24
 STMIA R2!,{R0,R4-R10}
 MOV R0,R11,LSR #8
 SUBS R3,R3,#8*4
 BGE j_24$l
j_done$l
 LDMFD R13!,{R4-R11}
ds32$l				; less than 32 bytes left
 ADDS R3,R3,#7*4
 BLT ds4$l			; less than 4 left
 STMFD R13!,{R11}
k$l
 LDR R11,[R1],#4
 SUBS R3,R3,#4
 ORR R0,R0,R11,LSL R14
 STR R0,[R2],#4
 MOV R0,R11,LSR R12
 BGE k$l			; copy 4 bytes at a time
 LDMFD R13!,{R11}
ds4$l
 ADDS R3,R3,#4			; number of bytes left
 LDMEQFD R13!,{R12,PC}
 SUB R1,R1,R14,LSR#3		; address of first unused byte
l$l
 LDRB R0,[R1],#1		; get next byte - don't read off end
 SUBS R3,R3,#1
 STRB R0,[R2],#1
 BGT l$l			; copy remaining bytes
 LDMFD R13!,{R12,PC}

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ; Find character SWI					    ;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ;E R0=number of chars to skip or -1 to move to the end
; ;  R1=string start R2=Foreground colour R3=Background colour R4=Font
; ;X R1=next print char (or the 0,2 if reached that first)
; ;  R0>R1  => Character was found and R0 is the end
; ;  R0=<R1 => Reached end first. R1-R0 characters left to skip
; ;  R2-R4 updated |

find_character
 FNJSR "R5-R6"
 MOV R5,R0			; save num of chars to skip
fc_1
 MOV R6,R1			; save char start
 LDRB R0,[R1],#1		; get next char
 TEQ R0,#0
 BLEQ skip_control_char
 CMP R0,#0
 BMI fc_1			; wasn't a character
 BEQ fc_2			; reached line end
 SUBS R5,R5,#1
 BCS fc_1			; was R5>=1 - if so skip more
 MOV R0,R1			; end of the char
 MOV R1,R6			; start of the char
 FNRTS
fc_2
 SUB R0,R1,R5			; we had R4 (>=0) left to look for
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create palette SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=b0 set to change wimp nos to &BBGGRRXX
;     b1 set to change &BBGGRRXX to masks
;  R1=redraw block (r_bpp and r_workarea (&80) used)
;  R2=source palette
;  R3=dest for masks (may equal source)
;  R4=number of entries
;X Palette created #

create_palette
 FNJSR "R1-R8"
 MOV R5,R1			; save redraw block
 ;LDR R6,[R5,#r_workarea]	; wimp palette &BBGGRRXX
 ADD R6,R12,#buffer		; use our own workspace
 MOV R7,R0			; save reason code
 MOV R1,R6
 MOV R8,R2
 LDR R2,true$l
 SWI XWimp_ReadPalette		; read the 20 word palette
 FNRTS VS
 LDR R1,[R5,#r_bpp]		; bits per pixel
cp_loop
 LDR R0,[R8],#4			; get next colour
 TST R7,#1
; BEQ cp_1			; don't convert wimp->24 bit
 LDRNE R0,[R6,R0,LSL#2]		; get palette entry for it
; LDR R14,cp_mask
; BIC R0,R0,R14,LSR#4		; clear bottom nibbles
; AND R14,R0,R14			; get top nibbles
; ORR R0,R0,R14,LSR#4		; duplicate top nibbles
cp_1
 TST R7,#2
 BEQ cp_2			; don't convert 24 bit->mask
 SWI XColourTrans_ReturnColourNumber
 FNRTS VS
 BL get_palette_entry		; R0=mask
 FNRTS VS
cp_2
 STR R0,[R3],#4
 SUBS R4,R4,#1
 BGT cp_loop
 FNRTS
;cp_mask
; DCD &F0F0F000
true$l = "TRUE"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Insert Char SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=char R1=string
;X R1 updated |

insert_char
 CMP R0,#&100
 BCS ic_0
 TEQ R0,#0
 STREQB R0,[R1],#1
 STRB R0,[R1],#1
 MOV PC,R14
ic_0
 STRB R0,[R1,#2]
 MOV R0,R0,LSR#8
 STRB R0,[R1,#3]
 MOV R0,#0
 STRB R0,[R1],#1
 MOV R0,#3
 STRB R0,[R1],#3
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read System Character Definitions SWI			    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=output buffer R1=red block giving 16 byte workarea
;X system chars &20-&FF read to the block #

read_system_chars
 FNJSR "R1-R9"
 MOV R3,R0			; R3=output buffer
 ;LDR R1,[R1,#r_workarea]	; 16 byte work area
 ;ADD R1,R1,#3			; R1=work (with +1 is word aligned)
 ADD R1,R12,#buffer		; use our own workspace
 ADD R1,R1,#3
 ADR R0,init_def_masks
 LDMIA R0,{R4-R6}		; R4-R6=masks
 MOV R2,#&20			; character number
 ADD R3,R3,R2,LSL#3		; output posn
init_defs_loop
 STRB R2,[R1]
 MOV R0,#10
 SWI XOS_Word			; read the defn
 FNRTS VS
 LDR R8,[R1,#1]			; R1+1 is word aligned
 BL bit_reverse
 STR R8,[R3],#4
 LDR R8,[R1,#5]			; R1+5 is word aligned
 BL bit_reverse
 STR R8,[R3],#4
 ADD R2,R2,#1
 CMP R2,#&100
 BCC init_defs_loop
 FNRTS
init_def_masks
 DCD &0F0F0F0F			; swap nibbles
 DCD &33333333			; swap 2 bits
 DCD &55555555			; swap 1 bits

;E R4-R6=bit reverse masks R8=4 bytes to bit reverse
;X bits reversed in each byte |

bit_reverse
 AND R0,R8,R4			; get bottom nibbles
 AND R8,R4,R8,LSR#4		; get top nibbles and shift down
 ORR R8,R8,R0,LSL#4		; flipped nibbles
 AND R0,R8,R5
 AND R8,R5,R8,LSR#2
 ORR R8,R8,R0,LSL#2		; same for two bit pairs
 AND R0,R8,R6
 AND R8,R6,R8,LSR#1
 ORR R8,R8,R0,LSL#1		; same for one bits.
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Reverse Bitmaps SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=source R2=dest R3=num of bytes

reverse_bitmaps
 FNJSR "R1-R8"
 ADR R0,init_def_masks
 LDMIA R0,{R4-R6}		; R4-R6=masks
rb_1
 SUBS R3,R3,#4
 FNRTS LT
 LDR R8,[R1],#4
 BL bit_reverse
 STR R8,[R2],#4
 B rb_1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read VDU vars SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=redraw block with 64 byte work area.
;X r_bpl,r_bpp,r_magx,r_magy,r_xsize,r_ysize filled in #
;  r_screen set to 0.

read_vdu_vars
 FNJSR "R1-R4"
 MOV R2,R1			; save red block
 ADR R0,rvv_d1
 ;LDR R1,[R2,#r_workarea]
 ADD R1,R12,#buffer		; use our own buffer
 SWI XOS_ReadVduVariables
 FNRTS VS
 LDR R3,[R1]			; XEig (log2 of num of xos per pix)
 LDR R0,[R1,#12]		; Log2bpp (log2 bits per pixel)
 LDR R4,[R1,#24]		; Log2bpc (log2 bytes per char/8)
 SUB R4,R4,R0			; diff due to double pixel modes
 SUB R3,R3,R4			; log2 of xos per hardware pixel
 STR R0,[R2,#r_bpp]		; save new bpp
 STR R3,[R2,#r_magx]
 LDR R0,[R1,#4]			; YEig (log2 of num of yos per pix)
 STR R0,[R2,#r_magy]
 LDR R0,[R1,#8]			; bytes per line
 STR R0,[R2,#r_bpl]
 LDR R0,[R1,#16]
 ADD R0,R0,#1
 STR R0,[R2,#r_xsize]		; screen width
 LDR R0,[R1,#20]
 ADD R0,R0,#1
 STR R0,[R2,#r_ysize]		; height
 MOV R0,#0
 STR R0,[R2,#r_screen]
 MOV R4,R2			; save redraw block
 MOV R0,#135
 SWI XOS_Byte			; read screen mode
 FNRTS VS
 STR R2,[R4,#r_mode]
 FNRTS
rvv_d1
 DCD 4				; XEig
 DCD 5				; YEig
 DCD 6				; Bytes per line
 DCD 9				; Log2BPP
 DCD 11				; Xlimit in pixels-1
 DCD 12				; Ylimit in pixels-1
 DCD 10				; Log2BPC
 DCD -1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get rectangle SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=block as returned by Wimp_RedrawArea R1=redraw block
;  r_magx,r_magy,r_xsize,r_ysize filled in.
;X r_minx-maxy and r_scrollx,scrolly filled in |

get_rectangle
 FNJSR "R1-R7"
 MOV R4,R0			; save redraw area block
 LDR R5,[R1,#r_magx]
 LDR R6,[R1,#r_magy]
 LDR R7,[R1,#r_ysize]
 LDR R2,[R4,#28]		; scn min os x
 MOV R0,R2,ASR R5
 STR R0,[R1,#r_minx]
 LDR R0,[R4,#36]		; scn max os x
 MOV R0,R0,ASR R5
 STR R0,[R1,#r_maxx]
 LDR R3,[R4,#40]		; scn max os y
 MOV R0,R3,ASR R6
 RSB R0,R0,R7
 STR R0,[R1,#r_miny]
 LDR R0,[R4,#32]		; scn min os y
 MOV R0,R0,ASR R6
 RSB R0,R0,R7
 STR R0,[R1,#r_maxy]
 LDR R0,[R4,#4]			; x min
 SUB R2,R2,R0			; x os offset in vis area
 LDR R0,[R4,#20]		; x scroll
 ADD R2,R2,R0			; x os offset in work area
 MOV R0,R2,ASR R5
 STR R0,[R1,#r_scrollx]
 LDR R7,[R4,#16]		; y max
 SUB R3,R3,R7			; y os offset in vis area
 LDR R7,[R4,#24]		; y scroll
 ADD R3,R3,R7			; y os offset in work area
 RSB R3,R3,#0			; y os downward
 MOV R7,R3,ASR R6		; y pix signed
 STR R7,[R1,#r_scrolly]

 LDR R3,[R1,#r_flags]
 TST R3,#rf_rtol
 BNE rtol$l

margin$l
 LDR R3,[R1,#r_flags]		; subtract left margin if present
 TST R3,#rf_extend		; is length present?
 FNRTS EQ			; nope
 LDR R3,[R1,#r_length]
 CMP R3,#r_lmargin		; do we have left margin parameter?
 FNRTS LO
 LDR R2,[R1,#r_lmargin]
 SUB R0,R0,R2
 STR R0,[R1,#r_scrollx]

 CMP R3,#r_tmargin		; do we have the top margin?
 FNRTS LO
 LDR R2,[R1,#r_tmargin]
 SUB R0,R7,R2
 STR R0,[R1,#r_scrolly]

 FNRTS

rtol$l
 PUSH "R1"
 LDR R0,[R4,#0]			; handle
 ADD R1,R12,#buffer
 STR R0,[R1],#1			; no icons
 SWI XWimp_GetWindowInfo
 FNRTS VS
 LDR R0,[R1,#51]		; wa maxx (b0 set)
 PULL "R1"
 LDR R2,[R4,#4]			; visible minx
 ADD R2,R2,R0
 LDR R0,[R4,#20]		; scrollx
 SUB R2,R2,R0			; screen coords of wa maxx
 LDR R3,[R4,#36]		; rectangle maxx
 SUB R0,R2,R3
 MOV R0,R0,ASR R5
 STR R0,[R1,#r_scrollx]
 B margin$l


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Add Vdu Bitmaps SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=redraw block (r_height/r_width)
;  r_workarea=64 bytes + room for sprite ??? is this true?
;  R2=first char R3=last char (inc) R4=bitmap at 1 bpp to convert
;X Extra characters in the interval created #

add_vdu_bitmaps
 FNJSR "R1-R8"
 MOV R5,R2			; R5=first char
 MOV R6,R3			; R6=last char
 LDR R7,[R1,#r_charw]		; R7=char width
 LDR R8,[R1,#r_charh]		; R8=char height
 MOV R2,R7
 MOV R3,R8
 MOV R0,#0
 BL cached_char_size		; R2=bpl R3=bpc
adb_0
 CMP R5,R6
 FNRTS GT
 TEQ R5,#0
 MOV R0,#&30
 BEQ adb_copy_char		; handle 0
 CMP R5,#&20
 ADDCC R0,R5,#&40
 BCC adb_copy_char		; handle 1-&1F
 CMP R5,#&7F
 MOVCC R5,#&7F
 BCC adb_0			; skip &20-&7F
 MVN R0,#0
 BEQ adb_create_char		; create &7F
 SUBS R0,R5,#&100
 MOVCC R5,#&100
 BCC adb_0			; skip &80-&FF
adb_create_char
 CMP R0,#(adb_end-adb_start)/4
 MOVGE R0,#&40			; do an "@" if it goes off the end
 BGE adb_copy_char
 PUSH "R1-R8"
 MLA R4,R5,R3,R4
 BL adb_create_sub
 PULL "R1-R8"
 ADD R5,R5,#1
 B adb_0
adb_copy_char
 PUSH "R1-R3"
 MLA R1,R0,R3,R4		; source
 MLA R2,R5,R3,R4		; dest
 BL move_bytes
 PULL "R1-R3"
 ADD R5,R5,#1
 B adb_0

;E R0=number of char to create - &100 (or -1 for &7F)
;  R2=bpl R3=bpc R4=char address R7=charw R8=charh
;X Character cached R0-R8 corrupted |

adb_create_sub
 ADD PC,PC,R0,LSL#2
 B adb_7F
adb_start
 B adb_100
 B adb_101
 B adb_102
 B adb_103
 B adb_104
 B adb_105
adb_end

adb_7F
 MOV R0,#&FF
 STRB R0,[R4],#1
 SUBS R3,R3,#1
 BGT adb_7F
 MOV PC,R14

adb_100
 FNJSR
 BL adb_row
 SUBS R8,R8,#2
 FNRTS LE
adb_100_loop
 BL adb_clear
 BL adb_left
 SUBS R8,R8,#1
 BGT adb_100_loop
 BL adb_row
 FNRTS

adb_101
 FNJSR
 BL adb_row
 SUBS R8,R8,#2
 FNRTS LE
adb_101_loop
 BL adb_clear
 SUBS R8,R8,#1
 BGT adb_101_loop
 BL adb_row
 FNRTS

adb_102
 FNJSR
 BL adb_row
 SUBS R8,R8,#2
 FNRTS LE
adb_102_loop
 BL adb_clear
 BL adb_right
 SUBS R8,R8,#1
 BGT adb_102_loop
 BL adb_row
 FNRTS

adb_103
 FNJSR
 BL adb_row
 SUBS R8,R8,#2
 FNRTS LE
adb_103_loop
 BL adb_clear
 BL adb_right
 BL adb_left
 SUBS R8,R8,#1
 BGT adb_103_loop
 BL adb_row
 FNRTS

adb_104
 FNJSR
 SUBS R8,R8,#1
 FNRTS LE
adb_104_loop
 BL adb_clear
 SUBS R8,R8,#1
 BGT adb_104_loop
 BL adb_row
 FNRTS

adb_105
 FNJSR
adb_105_loop
 BL adb_clear
 BL adb_left
 SUBS R8,R8,#1
 BGT adb_105_loop
 FNRTS

adb_row
 MOV R0,#&FF
 MOV R5,R2
adb_row_loop
 STRB R0,[R4],#1
 SUBS R5,R5,#1
 BGT adb_row_loop
 MOV PC,R14

adb_clear
 MOV R0,#0
 MOV R5,R2
adb_clear_loop
 STRB R0,[R4],#1
 SUBS R5,R5,#1
 BGT adb_clear_loop
 MOV PC,R14

adb_left
 LDRB R0,[R4,-R2]
 ORR R0,R0,#1
 STRB R0,[R4,-R2]
 MOV PC,R14

adb_right
 SUB R5,R4,R2			; start of the row
 SUB R6,R7,#1			; offset of last col
 ADD R5,R5,R6,LSR#3		; byte containg last col
 AND R6,R6,#7			; col offset in char
 MOV R0,#1
 MOV R0,R0,LSL R6		; mask
 LDRB R6,[R5]
 ORR R6,R6,R0
 STRB R6,[R5]
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Hourglass control					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0-R9=args R10=address of sub
;X R0-R9=returned args & sub executed with long_op on
;  errors handled #

do_longop
 FNJSR "R11"
 MOV R11,R0
 BL long_op_on
 FNRTS VS
 MOV R0,R11
 MOV R14,PC
 MOV PC,R10			; call the sub
 BVS do10
 MOV R11,R0			; save output
 BL long_op_off
 FNRTS VS
 MOV R0,R11			; output
 FNRTS
do10
 ADDS R11,R0,#0			; save error and clv
 BL long_op_off			; switch off hourglass
 MOV R0,R11
 FNRTV

;X Hourglass on and escape enabled #

long_op_on
 FNJSR "R1,R2"
 SWI XHourglass_On
 MOVVC R0,#229
 MOVVC R1,#0			; new escape state
 MOVVC R2,#0
 SWIVC XOS_Byte			; enable escape
 FNRTS

;X Hourglass off and escape disabled #

long_op_off
 FNJSR "R1,R2"
 SWI XHourglass_Off
 MOVVC R0,#229
 MOVVC R1,#1
 MOVVC R2,#0
 SWIVC XOS_Byte			; disable escape
 MOVVC R0,#124
 SWIVC XOS_Byte			; clear escape condition
 FNRTS

;E R0=numerator R1=denominator
;X percentage shown on hourglass #

long_op_display
 FNJSR "R1-R3"
 MOV R2,#100
 MUL R0,R2,R0
 BL div_mod
 CMP R0,#99
 MOVCS R0,#99
 SWI XHourglass_Percentage
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Cache font chars sub					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=1 => R1=redraw block. Setup

;	   r_bpp,r_caddr,r_cbpl,r_cbpc,r_charw,r_charh
;	   r_workarea = 64+size for spritearea
;	   r_for,r_bac,r_palette 24 bit colours.
;	   r_mode=mode to create sprite in
;  R0=2 => R1=redraw block. Caches it in mode 0.
;  R2=font name R3=size in points
;  R4/R5 are x,y os offsets in box to plot at (from bot left)
;  R6-R7 is range of characters to cache (inclusive).
;X Font characters cached. Hourglass shown.

cache_font_chars
 FNJSR "R10"
 ADR R10,cache_font_chars_sub
 BL do_longop			; do with hourglass on
 FNRTS

cache_font_chars_sub
 FNJSR "R1-R11"
 MOV R10,R1			; R10=redraw block
 LDR R11,[R10,#r_workarea]	; R11=workarea
 MOV R8,R2			; font name
 STR R3,[R11,#a_x1]		; font size
 STR R4,[R11,#a_stack1]
 STR R5,[R11,#a_stack2]		; save x,y offsets
 MOV R5,R0			; reason code
 CMP R6,R7
 FNRTS GT			; already cached
 ADD R0,R11,#&40		; sprite area
 BL sprite_create		; create the sprite
 FNRTS VS
 MOV R9,R0			; save bytes per line of sprite
 MOV R0,#&81
 ADD R1,R11,#&40
 BL sprite_output		; send output to sprite
 FNRTS VS
 BL font_cache_chars		; cache the chars
 BVS fo23
 MOV R0,#0
 BL sprite_output		; restore output
 FNRTS
fo23
 ADDS R5,R0,#0			; clv
 MOV R0,#0
 BL sprite_output		; restore output
 MOV R0,R5
 FNRTV

;E R5=cache mode
;  R6-R7=characters to cache inclusive R6=<R7<=255
;  R8=font name
;  R9=bytes per sprite line
;  R10=redraw block
;  R11=workspace (fontsize/x off/y off/bac mask)
;  R11+&40=sprite area
;  Output has been redirected to the sprite
;X Characters cached #

font_cache_chars
 FNJSR "R1-R11"
 BL font_findfont
 FNRTS VS
 LDR R2,[R10,#r_for]
 AND R2,R2,#&FF
 LDR R1,[R10,#r_bac]
 LDR R0,[R10,#r_palette]
 LDR R1,[R0,R1,LSL#2]
 LDR R2,[R0,R2,LSL#2]		; bac and for 24 bit cols
 BL sprite_set_cols
 BVS fo25
fo24
 SWI XOS_WriteI+16		; clear graphics area
 BVS fo25
 ADD R1,R11,#a_temp1
 MOV R2,#1<<4			; use os coords
 LDR R3,[R11,#a_stack1]
 LDR R4,[R11,#a_stack2]		; os offsets to plot at
 MOVS R0,R6
 MOVEQ R0,#'0'			; zero byte
 CMP R0,#&20			; still a ctrl char?
 ADDCC R0,R0,#&40
 TEQ R0,#&7F
 BEQ fo26			; skip delete
 STR R0,[R1]			; save char
 SWI XFont_Paint		; paint char into sprite
 BLVC font_cache_character	; copy the character to the cache
 MOVVC R0,R6			; num
 MOVVC R1,#&100
 BLVC long_op_display		; show %age
 BVS fo25
fo26
 ADD R6,R6,#1			; next char
 CMP R6,R7
 BLE fo24
 MOV R0,R8			; font handle
 SWI XFont_LoseFont
 FNRTS
fo25
 ADDS R1,R0,#0
 MOV R0,R8
 SWI XFont_LoseFont
 MOV R0,R1
 FNRTV

;E R6=character to cache R9=bytes per sprite line
;  R10=redraw block R11+&40=sprite area
;X Character defn copied.

font_cache_character
 FNJSR "R1-R4"
 LDR R4,[R10,#r_charh]		; number of lines to cache
 LDR R2,[R10,#r_caddr]		; start address of cache
 LDR R0,[R10,#r_cbpc]
 MLA R2,R0,R6,R2		; address of this character
 LDR R3,[R10,#r_cbpl]		; bytes per output cache line
 ADD R1,R11,#&50		; start of the sprite
 LDR R0,[R1,#&20]		; offset of sprite image
 ADD R1,R1,R0			; sprite image
fcc_loop
 PUSH "R1-R3"
 BL move_bytes
 PULL "R1-R3"
 ADD R1,R1,R9
 ADD R2,R2,R3
 SUBS R4,R4,#1
 BGT fcc_loop
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Redraw window SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=redraw block as returned by wimp R1=Zap redraw block
;X window area redrawn #

redraw_window
 FNJSR "R1-R3"
 MOV R2,R0			; save wimp redraw block
 MOV R3,R1			; save zap redraw block
 MOV R1,R2			; wimp redraw block
 SWI XWimp_RedrawWindow
 FNRTS VS
rw_1
 TEQ R0,#0
 FNRTS EQ
 MOV R0,R2
 MOV R1,R3
 BL get_rectangle
 BLVC redraw_area
 MOVVC R1,R2
 SWIVC XWimp_GetRectangle
 BVC rw_1
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Update window SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=redraw block R1=Zap redraw block
;X window area redrawn #

update_window
 FNJSR "R1-R3"
 MOV R2,R0			; save wimp redraw block
 MOV R3,R1			; save zap redraw block
 MOV R1,R2			; wimp redraw block
 SWI XWimp_UpdateWindow
 BVC rw_1
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read mode BPP SWI					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;X R0 = ln2 (mode bpp), adjusted for ViewFinder

read_mode_bpp
 FNJSR "R1-R3"
 BL viewfinder_test_text
 MOVNE R0,#0
 FNRTS NE
 MOV R0,#-1
 MOV R1,#9
 SWI XOS_ReadModeVariable
 MOVVC R0,R2
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Strings						    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Copy strings

;E R1=dest R2=source (copy till <32 and zero added)
;X R0=0 R1=end of dest (after 0) R2=char after terminator |

strcopy
 LDRB R0,[R2],#1
 CMP R0,#32
 STRCSB R0,[R1],#1
 BCS strcopy
 MOV R0,#0
 STRB R0,[R1],#1
 MOV PC,R14

;E R1=dest R2=source (copy till <32 and add no zero)
;X R0=terminatior R1=end of dest R2=char after terminator |

strcpy
 LDRB R0,[R2],#1
 CMP R0,#32
 STRCSB R0,[R1],#1
 BCS strcpy
 MOVCC PC,R14

 LOCAL


; compares two strings case insesnsitive
; E r0,r1 -> strings
; X Z = same  r1 -> after r1's terminator  r0 preserved
; null pointers are handled and are equivalent
strcasecmp
  FNJSR "R0,R2-R4"			; preserve
  TEQ R0,#0
  TEQEQ R1,#0
  FNRTS EQ
  TEQ R0,#0
  TEQNE R1,#0
  BNE loop$l
  CMP R14,#0				; clear Z
  FNRTS
loop$l
  LDRB R2,[R0],#1			; load char
  LDRB R3,[R1],#1			;
  CMP R2,#31				; fin?
  CMPLS R3,#31				; other one fin also?
  BHI nope$l				; nope
  MOVS R0,#0				; yes - set Z
  FNRTS					; done
nope$l
  CMP R2,#'z'				; lower than z?
  RSBLSS R4,R2,#'a'			; and higher than a?
  BICLS R2,R2,#&20			; yes - make upper case
  CMP R3,#'z'				; same for other
  RSBLSS R4,R3,#'a'			;
  BICLS R3,R3,#&20			;
  ;STMFD R13!,{R0}
  ;MOV R0,R2
  ;SWI XOS_WriteC
  ;MOV R0,R3
  ;SWI XOS_WriteC
  ;LDMFD R13!,{R0}
  CMP R2,R3				; same?
  BEQ loop$l				; try again
  FNRTS					; no - return ne

  LOCAL


; find the length of a string
; E r0 -> string
; X r1 = length
strlen
 FNJSR "R0"
 MOV R1,#-1
loop$l
 ADD R1,R1,#1
 LDRB R14,[R0],#1
 CMP R14,#32
 BHS loop$l
 FNRTS

 LOCAL


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; End							    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 END
