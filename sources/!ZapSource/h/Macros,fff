; Macros used in Zap assembly
; $Id: Macros,fff,v 1.2 2000/02/22 15:04:01 james Exp $

; count in-core storage
	GBLA InCoreTotal
InCoreTotal SETA 0

	MACRO
$la	INCORE $a
InCoreTotal SETA InCoreTotal+$a
$la
	MEND

; local labels use label$l to get a local label and LOCAL to start a new
; area

	GBLA LocalCount
	GBLS l
LocalCount SETA 1
l	SETS "x$LocalCount"

; increment local variable number

	MACRO
	LOCAL
LocalCount SETA LocalCount+1
l	SETS "x$LocalCount"
	MEND

; start of sub. If you specify a list of registers then these are stored as
; well and will be pulled on an RTS.

	GBLS StackedRegs

	MACRO
$la	FNJSR $a
StackedRegs SETS "$a"
$la
	[ StackedRegs=""
	STMFD R13!,{R14}
	|
	STMFD R13!,{$StackedRegs,R14}
	]
	MEND

; end of sub + pull all stacked registers

	MACRO
$la	FNRTS $cc
$la
	[ StackedRegs=""
	LDM$cc.FD R13!,{PC}
	|
	LDM$cc.FD R13!,{$StackedRegs,PC}
	]
	MEND

; just pulls stacked registers and R14

	MACRO
$la	FNPULL $cc
$la
	[ StackedRegs=""
	LDM$cc.FD R13!,{R14}
	|
	LDM$cc.FD R13!,{$StackedRegs,R14}
	]
	MEND

; end of sub saving flags + pull all stacked registers

	MACRO
$la	FNRTSS $cc
$la
	[ StackedRegs=""
	LDM$cc.FD R13!,{PC}^
	|
	LDM$cc.FD R13!,{$StackedRegs,PC}^
	]
	MEND

; end sub with an error + pull all stacked registers (must not contain R0)

	MACRO
$la	FNRTV	$cc
$la
	[ StackedRegs=""
	LDM$cc.FD R13!,{R14}
	|
	LDM$cc.FD R13!,{$StackedRegs,R14}
	]
	ORR$cc.S PC,R14,#Vbit
	MEND

; end sub *without* an error + pull all stacked registers

	MACRO
$la	FNRTVC $cc
$la
	[ StackedRegs=""
	LDM$cc.FD R13!,{R14}
	|
	LDM$cc.FD R13!,{$StackedRegs,R14}
	]
	BIC$cc.S PC,R14,#Vbit
	MEND

; define a zero terminated string

	MACRO
$la	FNS $a
$la	= $a,0
	ALIGN
	MEND

; long adds $a=$b+#$c fixed length, $c must be word aligned

	MACRO
$la	FNADD $a,$b,$c,$cc
$la	ADD$cc $a,$b,#($c:AND:&000003FF)
	ADD$cc $a,$a,#($c:AND:&FFFFFC00)
	MEND

; ADR between files. $a=destination register $b=label of the word contaning
; the module offset to ADR to. R12 must be set up. Uses R14.

	MACRO
$la	FNADR $a,$b
$la	LDR $a,[R12,#env_modstart]	; start address of the module
	LDR R14,$b			; offset in the module we want
	ADD $a,$a,R14			; address in the module we want
	MEND

; Call a Zap entry point ($a=name of entry point as in ZapLibrary)

	MACRO
$la	FNcall $a,$r
 [ "$r">""
$la	LDR $r,[R12]
	MOV R14,PC
	ADD PC,$r,#$a
 |
$la	LDR R14,[R12]
	ADD R14,R14,#$a
	STMFD R13!,{R14}
	MOV R14,PC
	LDMFD R13!,{PC}
 ]
	MEND

	MACRO
$la	FNcallc $a,$cc,$r
 [ "$r">""
$la	LDR$cc $r,[R12]
	MOV$cc R14,PC
	ADD$cc PC,$r,#$a
 |
$la	LDR$cc R14,[R12]
	ADD$cc R14,R14,#$a
	STM$cc.FD R13!,{R14}
	MOV$cc R14,PC
	LDM$cc.FD R13!,{PC}
 ]
	MEND

	MACRO
$la	FNjump $a,$r
 [ "$r">""
$la	LDR $r,[R12]
	ADD PC,$r,#$a
 |
$la	STMFD R13!,{R14,PC}
	LDR R14,[R12]
	ADD R14,R14,#$a
	STR R14,[R13,#4]
	LDMFD R13!,{R14,PC}
 ]
	MEND

; Produce a general purpose error sub generating the given error $a

	MACRO
$la	ERR $a
$la	ADD R0,PC,#0			; address of the error message
	B lookup_error			; return with an error
	DCD ENUM			; error number
	= "$a",0			; error message
	ALIGN
	MEND

	MACRO
$la	ERRlit $a
$la	ADD R0,PC,#0			; address of the error message
	ORRS PC,R14,#1<<28		; return with an error
	DCD ENUM			; error number
	= "$a",0			; error message
	ALIGN
	MEND

; Push a register list $a onto the stack

	MACRO
$la	PUSH $a,$cc
$la	STM$cc.FD R13!,{$a}
	MEND

; Pull a register list $a from the stack

	MACRO
$la	PULL $a,$cc
$la	LDM$cc.FD R13!,{$a}
	MEND

; Pulls a register list $a from the stack, leaving the SP alone...

	MACRO
$la	PULLS $a,$cc
$la	LDM$cc.FD R13,{$a}
	MEND

; Divide...

	MACRO
$la	DIVIDE  $a,$b,$c,$d
	LOCAL
$la     CMP     $b,#0
        MOVEQ   $b,#1
        MOV     $d,#1
div1A$l CMP     $a,$b,ASL #1
        MOVGE   $b,$b,ASL #1
        MOVGE   $d,$d,ASL #1
        BGE     div1A$l
        MOV     $c,#0
div2A$l CMP     $a,$b
        SUBGE   $a,$a,$b
        ADDGE   $c,$c,$d
        MOV     $b,$b,LSR #1
        MOVS    $d,$d,LSR #1
        BNE     div2A$l

	LOCAL

	MEND

; Logging information
;
; Tim liked to use Zephyr - however this is really only useful for immediate debugging
; purposes. It also relies on Wimp Messages, and so can't be used from interrupt code,
; exception handlers and so on.
; The advantage of SysLog is that it does priorities, and is designed for background
; logging. This can sensibly be running constantly in any release of Zap (just set the logging
; level really low), or turned off (if <Zap$Log> isn't set, !SysLog won't be loaded or used).
;
; These macros return VS on error, but it is advised to clear this before returning to the Zap
; central loop.
;
; Priorities are as follows (SysLog default is 125):
;
;  0	exceptions
;  10	fatal errors
;  20	non-fatal errors
;  50	warnings
;  100	Zap status (eg: starting, stopping)
;  110  File ops (eg: loading, saving)
;  120	Window ops (eg: creation, deletion)
;  130  Font ops (these may be removed once we've figured out what's wrong here)
;  150	Minor status (eg: loading modules)
;  200  Memory management
;
; These are bases; so you can add small amounts for less important things within that class.
; (Only really relevant for warnings and less important things.)

LOG_ALWAYS	*	0
LOG_EXCEPTION	*	0
LOG_FATAL	*	10
LOG_ERROR	*	20
LOG_WARNING	*	50
LOG_STATUS	*	100
LOG_FILE	*	110
LOG_WINDOW	*	120
; Above here will be logged by default
LOG_FONT	*	130
LOG_MINOR	*	150
; The following in particular has several levels within the class.
; LOG_MEMORY gives broad strokes (DA/heap claim and kill, and things like claim_list_block).
; LOG_MEMORY + 1 gives some more detail on mass memory ops.
; LOG_MEMORY + 2 gives all claim/free/ensure/extend heap ops (warning: several per second even when idle!).
; LOG_MEMORY + 3 gives some more detail on heap ops.
LOG_MEMORY	*	200

	GBLA	LogCount
	GBLS	LC
LogCount SETA	0
LC	SETS	"log$LogCount"

	MACRO
$la	SYSLOGF	$t,$p
$la
 [ LOGGING = SYSLOG
        STMFD   R13!,{R0-R3,R8-R12,R14}
        LDR	R0,[R12,#zap_logname]
        CMP	R0,#0
        BEQ	jump$LC
        ADR     R1,text$LC
        MOV     R2,#$p
        MOV     R3,R13
        SWI     XSysLog_LogFormatted
        B       jump$LC
text$LC	=       "$t",0
        ALIGN
jump$LC	LDMFD   R13!,{R0-R3,R8-R12,R14}

LogCount SETA	LogCount+1
LC	SETS	"log$LogCount"
 ]
        MEND

	MACRO
$la	SYSLOG	$t,$p
$la
 [ LOGGING = SYSLOG
	STMFD	R13!,{R0-R2,R14}
        LDR	R0,[R12,#zap_logname]
        CMP	R0,#0
        BEQ	jump$LC
	ADR	R1,text$LC
	MOV	R2,#$p
	SWI	XSysLog_LogMessage
	B	jump$LC
text$LC	=	"$t",0
	ALIGN
jump$LC	LDMIA	R13!,{R0-R2,R14}

LogCount SETA	LogCount+1
LC	SETS	"log$LogCount"
 ]
	MEND

; end of macros

	END
