; Contains mode entry points for Throwback mode.
; And subroutines for creating and entering text into a throwback file.
; $Id: Mode11,fff,v 1.1.2.10 1999/10/07 15:15:12 james Exp $

 GET h.ZapHeader
 GET h.Messages
 GET h.Strings
 GET h.CreateWind
 GET h.CreateFile
 GET h.AlterTxt
 GET h.Heap
 GET h.Redraw
 GET h.ModeBits
 GET h.Cursors
 GET h.Commands
 GET h.Execute
 GET h.Menus

 EXPORT mode_table_11
 EXPORT new_link_entry
 EXPORT create_throwback
 EXPORT add_throwback_entry
 EXPORT insert_line_number
 EXPORT mode11_insprepare
 EXPORT mode11_inspostpare

 EXPORT CmdTHROWBACKflagstoggle

 IMPORT mode3_author
 IMPORT modes_start
 IMPORT modes_end
 IMPORT cln_readc
 IMPORT test_shiftctrl
 IMPORT mode_data
 IMPORT test_input
 IMPORT get_input_caret
 IMPORT find_caret_pos

 IMPORT CmdBYTEWORDflagstoggle

MODE11_COLNUMBS * 9+8

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Redraw format of throwback mode - general colour mode		;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The throwback mode has it's own clnphy etc and handles control
; codes as follows
;
; 0 = ignore (does nothing - ends strings for 1-7)
; 1-7 = hide following string (string terminated with 0)
; 8=reserved (highlight next character?)
; 9=tab
; 10=line feed
; 11-16 reserved
; 17=change foreground colour to next byte
; 18=change background colour to next byte
; 19-31=reserved
; 32-255 standard ascii characters

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Throwback mode						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mode_table_11
 DCD mode_table_11
 DCD mode11_title
 DCD mode3_author
 DCD 0
 DCD 11+emode_UsesMessageTrans
 DCD mode11_init
 DCD 0
 DCD mode11_table_end-mode_table_11

 DCD 0				;postload
 DCD 0				;presave
 DCD 0				;loading
 DCD modes_start
 DCD modes_end
 DCD 0
 DCD 0				;mode6_linecol
 DCD mode11_lineoff
 DCD 0				;mode6_clnlog
 DCD 0				;mode6_clnphy
 DCD 0				;mode6_clnoff
 DCD 0				;mode6_nextline
 DCD mode11_minus
 DCD mode11_minus
 DCD mode11_minus
 DCD mode11_minus
 DCD mode11_minus
 DCD mode11_minus
 DCD mode11_redrawline		;mode6_redrawline
 DCD 0				;mode6_redrawlnum
 DCD Null
 DCD mode11_delete
 DCD Null
 DCD mode11_return
 DCD 0				;mode6_renumber
 DCD 0				;mode5_saveandrun
 DCD 0				;mode6_linestart
 DCD 0				;mode6_lineend
 DCD 0				;mode6_linenext
 DCD 0				;mode6_lineprev
 DCD 0				;mode6_copy
 DCD 0				;mode6_joinline
 DCD 0				;mode6_splitline
 DCD 0				;mode11_aligncaret
 DCD 0 ; mode11_command
 DCD 0				;mode5_compile
 DCD 0				;format text
 DCD 0				;mode5_run
 DCD 0				;mode5_runandquit
 DCD 0				;mode5_basic
 DCD 0				;mode6_search
 DCD 0				;mode6_replace
 DCD 0				;mode6_selection
 DCD mode11_click
 DCD mode11_message
 DCD 0
 DCD 0				; list fns
 DCD 0				; prevline
 DCD 0				; Open window
 DCD mode11_interrogate		; Answer all Zap's questions...
mode11_table_end

mode11_title FNS ("Throwback")

 LOCAL

mode11_redrawline
	FNJSR	"R4,R12"
	STR	R4,mode11_locstsp5
	LDR	R0,mode11_locstsp1
	CMP	R0,R7
	BNE	linestart$l
	LDR	R2,mode11_locstsp2
reentry$l
	LDR	R4,[R8,#w_txtw]
	MOV	R3,#0
redrawloop$l
	CMP	R7,R10
	BLCS	red_overflow
	LDRVCB	R0,[R7],#1
	BVS	return$l
	TEQ	R0,#10
	BEQ	eol$l
	TEQ	R0,#9
	BEQ	redrawtab$l
nottab$l
	MOVS	R14,R2,LSR #28
	BNE	special$l
normal$l
	STRB	R2,[R6,R4]		; put fg colour
	MOV	R14,#1
	STRB	R14,[R6,R4,LSL #1]	; put bg colour
	STRB	R0,[R6],#1		; put character
	ADD	R3,R3,#1		; counter
redrawnext$l
	LDR	R1,[R8,#w_bpl]
	CMP	R3,R1
	BLT	redrawloop$l
	CMP	R7,R10
	BLCS	red_overflow
	LDRVCB	R0,[R7]
	MOVVS	R0,#0
	CMP	R0,#10
	BEQ	avoidlf$l
return$l
	STR	R7,mode11_locstsp1
	STR	R2,mode11_locstsp2
	ADD	R11,R11,#1		; logical line counter
	FNRTSS				; ret without error

avoidlf$l
	ADD	R7,R7,#1
eol$l	MVN	R0,#0
	STR	R0,mode11_locstsp1
	ADD	R11,R11,#1	; logical line counter
	FNRTSS			; ret without error

special$l
	CMP	R14,#(S2$l-S1$l)/4
	ADDLO	PC,PC,R14,LSL #2
	B	normal$l
S1$l	B	normal$l		; 0
	B	test_past_spaces1$l	; 1
	B	test_past_number$l	; 2
	B	test_past_spaces2$l	; 3
	B	test_past_word$l	; 4
	B	test_second_space$l	; 5
	B	test_colon$l		; 6
	B	test_set_fgnd$l		; 7
S2$l

test_past_spaces1$l	; spaces preceding line number or address
	TEQ	R0,#32
	TEQNE	R0,#9
	EORNE	R2,R2,#(1:EOR:2)<<28
	B	normal$l

test_past_number$l	; line number or address
	SUB	R1,R0,#'0'
	CMP	R1,#10
	MOVLO	R1,#0
	SUBHS	R1,R1,#17
	CMP	R1,#6
	EORHS	R2,R2,#(2:EOR:3)<<28
	B	normal$l

test_past_spaces2$l	; spaces following line number or address
	TEQ	R0,#32
	TEQNE	R0,#9
	BEQ	normal$l
	MOV	R2,#2
	ADR	R1,tokens_num$l
	PUSH	"R0,R7"
	SUB	R7,R7,#1
	BL	lookup$l	; check for warning, error or serious error
	PULL	"R0,R7"
	B	normal$l

test_past_word$l	; warning, error, serious error ('type text')
	TEQ	R0,#32
	MOVEQ	R2,R2,LSL #8
	ORREQ	R2,R2,#2:OR:5<<28
	TEQ	R0,#9
	MOVEQ	R2,#2
	B	normal$l

test_second_space$l
	TEQ	R0,#32
	TEQNE	R0,#9
	MOVEQ	R2,#2		; is a space - past type text
	MOVNE	R2,R2,LSR #8	; otherwise we're not yet past it
	ANDNE	R2,R2,#&FF
	ORRNE	R2,R2,#4<<28
	B	normal$l

test_colon$l
	TEQ	R0,#':'
	ORREQ	R2,R2,#7<<28
	B	normal$l

test_set_fgnd$l
	MOV	R2,#2
	B	normal$l

; pointer into the (loaded) messages file, colour list
; token name (12 chrs). Total entry length is 20 bytes.
tokens_num$l
	& 0,14 :OR: 4<<28
	= "zap_tb_warn",0
	& 0,15 :OR: 4<<28
	= "zap_tb_erro",0
	& 0,16 :OR: 4<<28
	= "zap_tb_seri",0
	& 0,0

redrawtab$l
	LDR	R1,mode11_locstsp5
	ANDS	R1,R1,#&3000
	BEQ	nottab$l
	CMP	R6,#0
	BLT	redrawnext$l
	MOV	R0,#9
	TEQ	R1,#&1000
	MOVEQ	R0,#' '
	TEQ	R1,#&3000
	MOVEQ	R0,#'-'
redrawtabloop$l
	MOV	R1,#8
	STRB	R1,[R6,R4]
	MOV	R1,#1
	STRB	R1,[R6,R4,LSL #1]
	STRB	R0,[R6],#1
	TEQ	R0,#9
	MOVEQ	R0,#' '
	ADD	R3,R3,#1
	AND	R1,R3,#7
	TEQ	R1,#7
	TEQEQ	R0,#'-'
	MOVEQ	R0,#9
	TEQ	R1,#0
	BNE	redrawtabloop$l
	MOV	R0,#' '
	TEQ	R1,#&3000
	MOVEQ	R0,#9			; Tab
	STREQB	R0,[R6,#-1]		; Colour
	B	redrawnext$l

linestart$l
	STR	R6,mode11_locstsp3
	STR	R7,mode11_locstsp4
	MOV	R2,#2
	ADR	R1,tokens_sol$l
	BL	lookup$l
	BEQ	reentry$l
	PUSH	"R6,R7,R10"
	MOV	R6,#0
skipspcs$l
	CMP	R7,R10		; match against token
	BLHS	red_overflow
	BVS	notnum$l
	LDRB	R0,[R7],#1
	TEQ	R0,#32
	TEQNE	R0,#9
	BEQ	skipspcs$l
isitanum$l
	SUB	R0,R0,#'0'
	CMP	R0,#10
	MOVLO	R0,#0
	SUBHS	R0,R0,#17
	CMP	R0,#6
	BHS	notnum$l
	ADD	R6,R6,#1
	CMP	R7,R10		; match against token
	BLHS	red_overflow
	LDRVCB	R0,[R7],#1
	BVC	isitanum$l
notnum$l
	CMP	R6,#0
	MOVNE	R2,#7 :OR: 1<<28
	PULL	"R6,R7,R10"
	B	reentry$l

; pointer into the (loaded) messages file, colour list
; token name (12 chrs). Total entry length is 20 bytes.
; (Needs work to cope with ZapSpell - internationalise that first, though)
tokens_sol$l
	& 0,11 :OR: 6<<28
	= "zap_tb_srcf",0
	& 0,10 :OR: 6<<28
	= "zap_tb_errs",0
	& 0,9 :OR: 6<<28
	= "zap_tb_info",0
	& 0,13
	= "zap_tb_line",0
	& 0,12 :OR: 6<<28
	= "zap_tb_srch",0
	& 0,0

; E R1=tokens list (eg. tokens_sol$l)
; X Z clear, or Z set & R2 = text colour
lookup$l
	FNJSR	"R1,R6,R7,R10"
lookup_loop$l
	LDMIA	R13,{R1,R6,R7,R10}	; (leave on stack)
	LDR	R0,[R1]
	CMP	R0,#0
	BEQ	lookup_get$l
lookup_got$l
	MOV	R1,R0
lookup_cmp$l
	CMP	R7,R10		; match against token
	BLHS	red_overflow
	BVS	nomatch$l
	LDRB	R14,[R1],#1
	LDRB	R0,[R7],#1
	TEQ	R14,#10		; stop at LF or '%' (in token): match found
	TEQNE	R14,#'%'
	BEQ	matched$l
	TEQ	R0,R14
	BEQ	lookup_cmp$l
nomatch$l			; match failed
	LDMIA	R13,{R1,R6,R7,R10}
	ADD	R1,R1,#20
	STR	R1,[R13]
	LDR	R0,[R1,#4]
	TEQ	R0,#0		; more to do?
	BNE	lookup_loop$l
	TEQ	R0,#1		; no match - return Z clear
	FNRTS
matched$l			; (Z set)
	LDR	R2,[R13]
	LDR	R2,[R2,#4]
	TEQ	R2,R2
	FNRTS
lookup_get$l
	ADD	R0,R1,#8
	BL	lookup_token_R0
	ADRVS	R0,null$l
	STR	R0,[R1]
	B	lookup_got$l
null$l	&	10

mode11_locstsp1 & 0
mode11_locstsp2 & 0
mode11_locstsp3 & 0
mode11_locstsp4 & 0
mode11_locstsp5 & 0

mode11_cols
 = "zap_m_tbcols",0
 ALIGN

mode11_init
 TEQ R1,#einit_ModeMenu
 BEQ mode11_menu
 TEQ R1,#einit_ColoursSubmenu
 ADREQ R1,mode11_cols
 TEQ R1,#einit_ModeStarted
 BEQ init_throwback
 TEQ R1,#einit_DeleteModifiedFile
 MVNEQ R1,#0			; kill the file
 MOVEQ PC,R14
 TEQ R1,#einit_ZapDying
 MOVNE PC,R14
 FNJSR
 BL kill_throwback
 MOVVC R0,#-1			; don't kill module
 FNRTS

mode11_menu
	FNJSR	"R0"
	MOV	R0,#10
	BL	read_menu_handle	; create the mode menu
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start/End throwback registration			     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;X task claimed throwback |

init_throwback
 STMFD R13!,{R0,R1,R8,R14}
 FNLDR R0,wimp_task
 SWI XDDEUtils_ThrowbackRegister; &62585
 MOV R8,#0
 ;MVN R0,#0
 ;MOV R1,#11
 ;FNcall Zap_ModeColourNum
 MOV R0,#MODE11_COLNUMBS
 MOV R1,#11
 BL mode_colour_num
; FNcall Zap_ModeColourNum	; change palette size
 CMP R0,#MODE11_COLNUMBS
 ;BEQ mode11_dontchangeathing
 BLNE mode11_UnkPreColBit	; define them
mode11_dontchangeathing
 LDMFD R13!,{R0,R1,R8,PC}^	; return no error

kill_throwback
 STMFD R13!,{R1,R14}
 FNLDR R0,wimp_task
 TEQ R0,#0
 CMNNE R0,#1
 LDMEQFD R13!,{R1,PC}		; task dead
 SWI XDDEUtils_ThrowbackUnRegister ; &62586
 MVN R0,#0			; don't kill module yet
 LDMFD R13!,{R1,PC}^

mode11_UnkPreColBit
 FNJSR "R1-R4"
 ADR R3,mode11_DefaultColours
 MOV R1,#11			; modenumber
mode11_PreZModColBit
 MOV R2,#&09			; start colours
mode11_ZModColBit
 LDR  R0,[R3],#4
 BL mode_colour
; BL mode_colour_num		; ??????????
; FNcall Zap_ModeColour		; Read colour definitions
 FNRTS VS
 ADD R2,R2,#1
 TEQ R2,#MODE11_COLNUMBS	; max colours
 BNE mode11_ZModColBit
 FNRTS

mode11_DefaultColours		; Colour Numbers :
	&	&00BBFF10	;  9 'Information for file'
	&	&00EEEE10	; 10 'Errors in file'
	&	&FFBB0010	; 11 'Source file'
	&	&BBBBBB10	; 12 'Search string'
	&	&BBEEEE50	; 13 'Line' headers
	&	&00BBFF10	; 14 Type = 'Warning'
	&	&0000DD30	; 15 Type = 'Error'
	&	&2222DDB0	; 16 Type = 'Serious error'

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Line moving subs					      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mode11_linenext
 STMFD R13!,{R1-R3,R14}
 MOV R2,R0
 LDR R3,[R9,#f_len]
li10
 CMP R2,R3
 MOVCS R0,R3
 LDMCSFD R13!,{R1-R3,PC}
 MOV R0,R2
 BL cln_readc
 ADD R2,R2,#1
 TEQ R0,#&0A
 BNE li10
 MOV R0,R2
 LDMFD R13!,{R1-R3,PC}

mode11_lineprev
 STMFD R13!,{R1-R2,R14}
 SUB R2,R0,#1			; first char to look at
li11
 CMP R2,#0
 MOVMI R0,#0
 LDMMIFD R13!,{R1-R2,PC}
 MOV R0,R2
 BL cln_readc
 TEQ R0,#&0A
 SUBNE R2,R2,#1
 BNE li11
 ADD R0,R2,#1
 LDMFD R13!,{R1-R2,PC}

 LOCAL

mode11_click
 FNJSR "R1-R9"
 TST R4,#1
 BNE mode11_adjdelentry		; adjust pressed
 TEQ R1,#2
 BEQ jump$l			; double click so jump to match
 TEQ R1,#3
 BEQ tofront$l			; third click wants match to come to front
 TEQ R1,#1
 BLEQ default_click		; if single click
 FNRTS
jump$l
 BL test_shiftctrl		; get status in R1
 MOVVC R5,R1			; save shift status
 BLVC find_offset
 BLVC jump_to_match		; jump to the match
 FNRTS VS
 TST R5,#1
 BLNE discard_file
 FNRTS
tofront$l
 MOV R1,R8
 FNLDR R0,car_cursor
 LDR R0,[R0,#c_wind]
 BL conv_wind_off		; set up R8/R9
 CMP R1,R8			; don't bring to front if this window...!?
 FNRTS EQ
 CMP R8,#0
 MOVNE R0,#3
 BLNE open_a_window
 FNRTS

mode11_adjdelentry
 TST R4,#8			; drag?
 FNRTS NE			; don't do this if so
 CMP R1,#0			; simple drag?
 FNRTS EQ			; don't do this if so
 BL check_if_tb_file
 FNRTS MI
 LDR R14,[R9,#f_flags]
 ANDS R14,R14,#&110
 BNE readonlyfile
 CMP R1,#&FF
 FNRTS CS			; not a single adjust click
 BL find_offset			; find file offset in R0
; FNcall Zap_FindOffset		; find file offset in R0
 FNRTS VS
 ADR R14,mode11_locstsp1
 STMIA R14,{R0,R8,R9}
 BL get_to_match
 CMP R0,#0			; clicked on a match line?
 BMI mode11_adjfname		; if not on a sensible line...
 ADR R14,mode11_locstsp1
 LDMIA R14,{R0,R8,R9}
 BL delete_match
justrts$l
 FNRTS

readonlyfile
 CMP R1,#0
 BLE justrts$l
 TST R4,#8
 BLEQ pre_input
 B justrts$l

mode11_adjfname			; delete the whole entry
 BL start_operation
 FNRTS VS
 ADR R14,mode11_locstsp1
 LDMIA R14,{R0,R8,R9}
 STMFD R13!,{R0,R8,R9}		; copy mode11_locstsp{1,2,3} to stack
loop0$l
 LDMFD R13,{R0,R8,R9}
 ADD R0,R0,#1
 STR R0,[R13]
 LDR R1,[R9,#f_len]
 CMP R0,R1
 BCS adjret$l
 BL get_to_match
 CMP R0,#0			; clicked on a match line?
 BMI loop0$l			; if not on a sensible line...
 LDR R9,[R13,#8]
 LDR R7,[R9,#f_links]		; start of table
 ADD R7,R7,R0,LSL #4
 LDR R1,[R7,#4]
 SUB R7,R1,#4
find$l
 LDR R0,[R7,#4]!
 CMP R0,#-1
 BNE find$l
 SUB R7,R7,R1
 MOV R7,R7,LSR #2		; number of entries to delete
loop1$l
 LDMIA R13,{R0,R8,R9}
 BL delete_match
 BVS adjret$l
 CMP R0,#1
 BHI adjret$l			; buffer deleted? return
 MOVLO R2,#0			; set R2 to 1 if an entry was deleted
 MOVEQ R2,#1
 LDMIA R13,{R0,R8,R9}
 ADD R0,R0,#1
 STR R0,[R13]
 LDR R1,[R9,#f_len]
 CMP R0,R1
 MOVCS R7,R2			; cause loop exit if at EOF
 SUBS R7,R7,R2			; more to delete?
 BNE loop1$l
adjret$l
 ADD R13,R13,#12
 BL stop_operation
 FNRTS

mode11_return
 LDR R0,[R10,#c_off]
 B jump_to_match

mode11_delete
 LDR R0,[R10,#c_off]
 B delete_match

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Throwback entry points				      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mode11_lineoff
 MOV R0,#0			; zero column offset
 LDR R1,[R8,#w_bpl]		; make caret width of line
 MOV PC,R14

mode11_minus
 MVN R2,#1			; don't do anything
 MOV PC,R14

;E R0=file offset of click/return press R8/R9
;X File loaded if not already in memory, line numbers converted
;  to file offsets if not already done, point jumped to #

jump_to_match
 STMFD R13!,{R1-R11,R14}
 BL check_if_tb_file
 LDMMIFD R13!,{R1-R11,PC}
 STR R0,mode11_locstsp1
 STR R8,mode11_locstsp2
 STR R9,mode11_locstsp3
 BL get_to_match
 CMP R0,#0			; clicked on a match line?
 BMI throwback_afilename	; if not on a sensible line...
 BL get_links_entry		; set up R6-R7
 CMP R7,#0			; valid click ?
 LDMMIFD R13!,{R1-R11,PC}
 BL get_linked_file		; set up R8-R9
 BLVC convert_links		; convert lines to offsets
 LDMVSFD R13!,{R1-R11,PC}
 BL offset_to_match
 CMP R6,#0			; invalid offset?
 LDMMIFD R13!,{R1-R11,PC}
 FNLDR R10,car_cursor
 MOV R0,R6
 BL goto_file_offset
; FNcall Zap_JumptoOffset,R11
 LDMVSFD R13!,{R1-R11,PC}
 LDR R0,[R7,#12]		; flags
 TST R0,#2
 BLNE dospell
 LDMFD R13!,{R1-R11,PC}

check_if_tb_file		; works by checking for /any/ links...
 FNJSR
 LDR R14,[R9,#f_cmode]
 CMP R14,#11
 MOVNES R14,#-1
 FNRTS

 ;f_links]
 ;CMP R14,#0
 ;BLE nottbfile$l
 ;LDR R14,[R14]
 ;CMP R14,#0
 ;FNRTS
;nottbfile$l
 ;MOVS R14,#-1
 ;FNRTS

dospell
 ADR R0,spellcmdnamed
 B command_string

spellcmdnamed
 = "SPELL",0,0,0

throwback_afilename
 LDR R0,mode11_locstsp1
 LDR R8,mode11_locstsp2
 LDR R9,mode11_locstsp3
 ADD R0,R0,#1
 STR R0,mode11_locstsp1
 LDR R1,[R9,#f_len]
 CMP R0,R1
 BCS throwback_beep_then
 BL get_to_match
 CMP R0,#0			; clicked on a match line?
 BMI throwback_afilename	; if not on a sensible line...
 BL get_links_entry		; set up R6-R7
 CMP R7,#0
 BMI throwback_afilename	; not a valid click.
 BL get_linked_file		; set up R8-R9
 BLVC convert_links		; convert lines to offsets
 BLVC offset_to_match
 ;CMP R6,#0			; invalid offset?
 ;LDMMIFD R13!,{R1-R11,PC}
 ;BMI throwback_beep_then
 ;MOV R1,#5			; cursor block
 ;FNcall Zap_ReadVar
 ;LDMVSFD R13!,{R1-R11,PC}
 ;MOV R10,R0			; cursor
 ;MOV R0,R6
 ;FNcall Zap_JumptoOffset
 ;LDMVSFD R13!,{R1-R11,PC}
 LDMFD R13!,{R1-R11,PC}

throwback_beep_then
 BL Beep
 LDMFD R13!,{R1-R11,PC}

;E R0=file offset of click R8/R9
;X File contents looked at and R0=file offset (in links list) (or -1 - TT)
;  R1=match line offset (for that file) / R0=-1 for none |
;  R2=start of file header offset
;  R3=start of line with click
;  R4=start of line after click

get_to_match
 STMFD R13!,{R5-R6,R14}
 MOV R6,#0			; file header offset
 MOV R4,#0			; file count
 MOV R5,#0			; line count
 MOV R3,#0			; current offset
 LDR R2,[R9,#f_len]
 MOV R1,#0			; state 0=header 1=text
 CMP R0,R2
 MOVCC R2,R0			; match offset
ge11
 MOV R0,R3
 BL mode11_linenext
 CMP R2,R0
 BCC ge13			; match was on last line
 ADD R5,R5,#1			; inc line count
 SUBS R0,R0,R3			; length of last line
 ADD R3,R3,R0			; next line
 CMP R0,#1
 BGT ge11			; line not empty
 BLT ge12			; at end of file (no increment)
 EORS R1,R1,#1			; change state
 ADDEQ R4,R4,#1			; moved onto next file
 MOVEQ R6,R3			; save start of file header
 MOV R5,#0			; zero line count
 B ge11
ge12
 MVN R0,#0
 LDMFD R13!,{R5-R6,PC}
ge13
 TEQ R1,#0
 BEQ ge12			; in header
 MOV R1,R5			; match offsets
 MOV R2,R6			; start of file header
 MOV R14,R0			; start of line afterwards
 SUB R0,R0,R3
 CMP R0,#1
 BLE ge12			; in empty line
 MOV R0,R4
 MOV R4,R14			; line after
 LDMFD R13!,{R5-R6,PC}

;E R0=file offset in links R1=line offset in file
;X R7=links entry address/-1 if not valid
;  R6=match off in list (not validated) |

get_links_entry
 STMFD R13!,{R1,R14}
 LDR R7,[R9,#f_links]		; start of table
va1
 LDR R14,[R7]
 CMP R14,#0
 BMI va2
 SUBS R0,R0,#1
 ADDPL R7,R7,#16
 BPL va1			; not reached our file yet
 LDRB R0,[R7,#13]		; flags
 SUBS R6,R1,R0			; offset in list
 LDMPLFD R13!,{R1,PC}
va2
 MVN R7,#0
 LDMFD R13!,{R1,PC}

;E R7=links entry address
;X R8/R9=assosiated file #

get_linked_file
 FNJSR ;"R11"
 LDR R0,[R7,#8]			; file offset
 CMP R0,#0
 BPL va3			; found
 LDR R0,[R7]			; file name
 BL find_file
; FNcall Zap_FindFile,R11	; find the file
; FNRTS VS
 BLVC get_file_off
; FNcall Zap_GetFileOff,R11
; FNRTS VS
 STRVC R0,[R7,#8]		; file offset
 FNRTS
va3
 BL conv_file_off
; FNcall Zap_ConvFileOff,R11	; set up R9
; FNRTS VS
 BLVC find_window
; FNcall Zap_FindWindow,R11	; find a window in R9
 FNRTS

;E R7=links table entry R8-R9=assosiated file
;X line number links converted to file offsets #

convert_links
 LDR R0,[R7,#12]		; get flags
 TST R0,#1
 MOVEQ PC,R14			; already as offsets
 STMFD R13!,{R1-R11,R14}
 LDR R6,[R7,#4]			; links table
co13
 LDR R0,[R6]
 CMP R0,#0
 BMI co14			; finished
 SUBS R0,R0,#1
 MOVMI R0,#0			; line offset starting from 0
 MOV R11,#e_clnlog
 BL call_mode
; FNcall Zap_CallMode		; find file off
 LDMVSFD R13!,{R1-R11,PC}
 STR R0,[R6],#4
 B co13
co14
 LDR R0,[R7,#12]
 BIC R0,R0,#1			; links are as offset
 STR R0,[R7,#12]
 LDMFD R13!,{R1-R11,PC}

;E R7=links table entry (converted) R6=entry offset
;X R6=file offset of match / -1 if invalid |

offset_to_match
 STMFD R13!,{R1,R14}
 LDR R1,[R7,#4]			; list of offsets
of1
 LDR R0,[R1],#4
 CMP R0,#0
 MVNMI R6,#0			; invalid
 LDMMIFD R13!,{R1,PC}
 SUBS R6,R6,#1
 BPL of1
 MOV R6,R0
 LDMFD R13!,{R1,PC}

;typeofdeletion
; EQUD 0

 LOCAL

;E R0=offset in throwback buffer R8/R9=throwback buffer
;X The match this represents deleted from the throwback file #
;  R0=0 if nothing deleted, 1 if one entry deleted, 2 if buffer auto-deleted

delete_match
 STMFD R13!,{R1-R11,R14}
 BL get_to_match		; find match file and set R1-R5
 CMP R0,#0			; valid file?
 MOVMI R7,#-1
 BLPL get_links_entry		; set R6=match offset in list R7
 CMP R7,#0			; valid offset?
 MOVMI R0,#0
 LDMMIFD R13!,{R1-R11,PC}	; return 0
 BL delete_link
 ;STR R0,typeofdeletion
 LDMVSFD R13!,{R1-R11,PC}
 CMP R0,#1			; invalid?
 LDMLOFD R13!,{R1-R11,PC}	; return 0
 MOVEQ R1,R3
 MOVEQ R2,R4			; start/end for link
 MOVHI R1,R2
 ADDHI R2,R4,#1			; start/end for file
 LDR R0,[R9,#f_len]
 CMP R2,R0
 MOVCS R2,R0			; clip to file end
 SUBGE R1,R1,#1			; to avoid a bug...?!
 CMP R1,#0
 MOVMI R1,#0			; to avoid another bug.
 SUB R2,R2,R1			; length
; BL mode11_insprepare
 MOV R0,#&12			; delete block
 BL command_primative
; FNcall Zap_DoCommand,R11
; BL mode11_inspostpare
 LDMVSFD R13!,{R1-R11,PC}
 LDRB R0,[R8,#w_format]
 STR R0,[R9,#f_cmode]		; claim the file so deletes ok
 ADD R0,R8,R0,LSL #2
 LDR R0,[R0,#w_mode0]		; load our mode word
 TST R0,#mode11_AutoDelete
 MOVEQ R0,#0			; cause return if not auto-delete
 LDRNE R0,[R9,#f_links]		; else check if there are still links
 LDRNE R0,[R0]
 CMP R0,#0			; +ve if there are, or not auto-deleting
 MOVPL R0,#1
 LDMPLFD R13!,{R1-R11,PC}	; return NE
 BL discard_file
 MOVVC R0,#2			; return 2
 LDMFD R13!,{R1-R11,PC}

;E R7=pointer to link entry R6=link offset (not validated)
;X R0=0 => Link was invalid
;  R0=1 => Link deleted and some links remain on this file
;  R0=2 => Link deleted and link entry also deleted

delete_link
 STMFD R13!,{R1-R3,R14}
 LDR R1,[R7,#4]			; links list
de18
 LDR R0,[R1],#4
 CMP R0,#0
 MOVMI R0,#0			; link was invalid
 LDMMIFD R13!,{R1-R3,PC}
 SUBS R6,R6,#1
 BPL de18			; not reached it yet
de19
 LDR R0,[R1],#4
 STR R0,[R1,#-8]		; copy down next offset
 CMP R0,#0
 BPL de19			; 'till end of list
 LDR R1,[R7,#4]
 LDR R0,[R1]
 CMP R0,#0
 MOVPL R0,#1			; some links left
 LDMPLFD R13!,{R1-R3,PC}
 LDR R0,[R7]
 BL heap_free
; FNcall Zap_Free,R2
 LDRVC R0,[R7,#4]
 BLVC heap_free
; FNcallc Zap_Free,VC,R2	; free that link entry
 LDMVSFD R13!,{R1-R3,PC}
 ADD R1,R7,#16			; source
 MOV R2,R7			; dest
 MOV R3,R7
de32
 LDR R0,[R3,#16]!
 CMP R0,#0
 BPL de32
 SUB R3,R3,R1
 ADD R3,R3,#4			; amount to move
 SWI XZapRedraw_MoveBytes ; BL move_bytes
; FNcall Zap_MoveBytes
 MOV R0,#2
 LDMFD R13!,{R1-R3,PC}

;mode11_command
; B command_primative		; do the original command

local_insdelmsgflg
 DCD 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DDE wimp poll messages			       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; R1=message block R2=message number

mode11_message
 TEQ R3,#17
 MOVNE PC,R14
 SUB R0,R2,#&40000
 TEQ R0,#&C2
 BEQ init_throwback		; DDE may be starting
 TEQ R0,#&C3
 BEQ init_throwback		; Srcedit may be quitting
 SUB R0,R2,#&42000
 SUB R0,R0,#&00580		; DDE message?
 CMP R0,#7
 ADDLO PC,PC,R0,LSL#2		; dispatch
 MOV PC,R14			; ignore
 MOV PC,R14			; DDEutils_ThrowbackStart
 MOV PC,R14			; DDEutils_ProcessingFile
 B DDEutils_ErrorsIn
 B DDEutils_ErrorDetails
 B finish_throwback		; DDEutils_ThrowbackEnd
 B DDEutils_InfoforFile
 B DDEutils_InfoDetails

DDEutils_ErrorsIn
 ADD R0,R1,#20			; file name
; B dde_fname ; fall through

;E R0=filename
;X filename save in throw_name

dde_fname
 STMFD R13!,{R1-R2,R14}
 MOV R2,R0			; save string
 BL str_len
 ADD R1,R0,#1
 FNLDR R0,throw_name
 BL heap_ensure
 FNSTR R0,throw_name,VC
 MOVVC R1,R0
 BLVC strcopy			; copy in name
 LDMFD R13!,{R1-R2,PC}

 LOCAL

DDEutils_ErrorDetails
 FNJSR "R1-R11"
 LDR R14,[R1,#24]		; severity
 CMP R14,#1
 ADRLT R2,warn$l
 ADREQ R2,error$l
 ADRGT R2,serious$l
 ORR R2,R2,#1<<31
 ADR R3,err$l
 ORR R3,R3,#1<<31
 MOV R4,#-1
 MOV R5,#1			; line numbers not offsets
 ADD R5,R5,#1<<16		; throwback
 ADD R5,R5,#1<<8		; a line of header info
 ADR R6,header$l
 ORR R6,R6,#1<<31
 ADR R7,after$l
 LDR R0,[R1,#20]		; line number
 BL process_entry		; add to links list + header
 FNRTS VS
 ADD R3,R1,#28			; error string start
 MOV R0,R3			; may contain tabs!
 BL str_len
 MOV R2,R0
 LDR R1,[R9,#f_len]
 SUB R1,R1,#1			; put in before the final return
; BL mode11_insprepare
 MOV R0,#&11
 BL execute_command		; enter description
; BL mode11_inspostpare
 FNRTS
err$l	  = "zap_tb_errs",0
after$l	  = 0
header$l  = "zap_tb_hdrl",0
warn$l	  = "zap_tb_warn",0
error$l	  = "zap_tb_erro",0
serious$l = "zap_tb_seri",0
 ALIGN

DDEutils_InfoforFile
 ADD R0,R1,#20
 B dde_fname

 LOCAL

DDEutils_InfoDetails
 FNJSR "R1-R11"
 ADD R2,R1,#28			; info string start
 ADR R3,info$l
 ORR R3,R3,#1<<31
 MOV R4,#-1
 MOV R5,#1			; line numbers not offsets
 ORREQ R5,R5,#2<<16		; info
 ADD R5,R5,#1<<8		; a line of header info
 ADR R6,header$l
 ORR R6,R6,#1<<31
 ADR R7,after$l
 LDR R0,[R1,#20]		; line number
 BL process_entry		; add link and set R8/R9
 FNRTS
info$l	 = "zap_tb_info"
after$l  = 0
header$l = "zap_tb_infl",0
 ALIGN


;E R1=message block containg task handle of sender (at #4)
;X R8/R9=throwback file used by this task/CS if none |

get_throwback
 FNJSR
 MOV R0,#-1
 FNSTR R0,throw_file		; clear throwback file
 LDR R0,[R1,#4]
 BL find_throwback_file		; is one being used?
 FNRTS VS
 FNLDR R0,throw_file		; the file offset
 CMP R0,#-1			; CS if none (-1)
 FNRTS CS
 BL conv_wind_off
; FNcall Zap_ConvWindOff,R9	; set up R8/R9 from the window offset
 ADDS R0,R0,#0			; clc
 FNRTS

;E R1=message block
;X finishes off current throw_file if one exists #

finish_throwback
 FNJSR "R8-R9"
 BL get_throwback
; FNRTS CS			; none
 LDRCC R0,[R9,#f_flags]
 BICCC R0,R0,#1<<3		; unaltered
 STRCC R0,[R9,#f_flags]
 BLCC new_file_title
; FNcall Zap_NewFileTitle
 FNRTS

 LOCAL

;E R0=file offset/line
;  R1=wimp block of message (containg task handle of sender)
;  R2-R6=data of throwback entry to add (as for add_throwback_entry)
;  R7=wimp message block (to get task handle of sender)
;X R8/R9=file word added to links list & new header added if
;  this is a 'new' error file #

process_entry
 FNJSR "R1,R10"
 MOV R10,R0			; save data word
 BL get_throwback		; set up R8/R9 (returned)
 BCC exists$l			; file already exits
 MOV R0,#throwback_TaskHandle	; default
 LDR R1,[R1,#4]			; task handle of message sender
 BL create_throwback		; create a file
 FNRTS VS
 FNSTR R0,throw_file		; save throwback window
 MOV R0,#11
 STR R0,[R9,#f_cmode]		; throwback window
 STR R1,[R9,#f_source]		; this was the source
exists$l
 MOV R0,R10			; restore data word
 FNLDR R1,throw_name		; file name
 BL add_throwback_entry
 FNRTS

;E R0=task handle of task sending the throwback message
;X throw_file set to the window offset of a valid throwback
;  file if there is already one.

find_throwback_file
 STMFD R13!,{R1,R10,R14}
 MOV R1,R11			; workspace address
 ADR R10,find_throwback_file_sub
 BL do_allwindow
; FNcall Zap_AllWindow		; try each window in turn
 LDMFD R13!,{R1,R10,PC}

find_throwback_file_sub
 FNJSR
 LDR R14,[R9,#f_cmode]
 TEQ R14,#11
 LDREQ R14,[R9,#f_source]
 TEQEQ R14,R0
 FNRTS NE
 BL get_wind_off
; FNcall Zap_GetWindOff
 STR R0,[R1,#throw_file]
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create a throwback file					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=suggested width of window / 0 to use default width
;  b31 => R1 is throwback filename, b30 => R1 is task handle, look
;  it up to get filename, b29 => R1 is a token, look it up (if b31 set)
;X R0=window offset of window R8/R9=newly created throwback window
;  R1 preserved
;  (not cmode 11 that's reserved for throwback protocol files)
;  (however, if c_source is 0...)
flags$l
 & 0
titledata$l
 & 0

create_throwback
 FNJSR "R1-R4,R10-R11"
; ADDS R10,R0,#0
 AND R11,R0,#(throwback_Filename :OR: throwback_TaskHandle :OR: throwback_FilenameIsToken)
 STR R11,flags$l		; save flags
 STR R1,titledata$l
 BICS R10,R0,#(throwback_Filename :OR: throwback_TaskHandle :OR: throwback_FilenameIsToken)
	 			; save suggested width of window
 BEQ width$l
 MOV R8,#0			; config setting
 MOV R0,#-1			; read
 MOV R1,#11
 MOV R2,#0
 BL mode_data			; R0=width b0-b15
 MOVVC R11,R0			; save old value
 MOVVC R0,R0,LSR#16
 ORRVC R0,R10,R0,LSL#16
 BLVC mode_data			; write
width$l				; width done (in R10)
 MOVVC R0,#&FF0
 ORRVC R0,R0,#&F			; text
 MOVVC R1,#1
 MOVVC R2,#0			; turn off undo
 MOVVC R3,#&FF
 ORRVC R3,R3,#1<<31
 MOVVC R4,#11
 ORRVC R4,R4,#1<<31		; force mode 11
 BLVC create_file		; R8/R9=new file
 BLVC restore$l
 BLVC get_wind_off
 MOV R10,R0			; preserve
 LDR R11,flags$l
 TST R11,#throwback_Filename
 BEQ not_filename$l
 LDR R0,titledata$l
 TST R11,#throwback_FilenameIsToken
 BEQ done_lookup$l
 BL lookup_token_R0
 BVS return$l
done_lookup$l
 BL new_file_name
 BLVC new_file_title
 ; Setting the title may fail, but we still have a valid throwback window
return$l
 MOV R0,R10			; restore
 FNRTSS
not_filename$l
 TST R11,#throwback_TaskHandle
 FNRTS EQ
 PUSH "R1-R6"			; R0 already preserved in R10
 SUB R13,R13,#20		; space for message
 LDR R0,tasknamerq$l
 LDR R1,titledata$l
 STR R1,[R13,#20]
 MOV R1,R13
 MOV R2,#0			; broadcast
 MOV R3,#24			; message length
 ADR R5,tasknameis$l
 MOV R6,R10			; window offset of window
 BL message_send
 ADD R13,R13,#20
 PULL "R1-R6"
 B return$l			; never set just yet
tasknamerq$l
 & (0x400c6 :OR: sendmessage_CallOnReply :OR: sendmessage_SendMessage)
tasknameis$l			; only called on reply
 FNJSR
 MOV R0,R11
 BL conv_wind_off		; \X R8/R9
 ADD R0,R1,#28			; task name
 BL new_file_name
 BLVC new_file_title
 FNRTS
restore$l
 TEQ R10,#0			; default used?
 MOVEQ PC,R14
 FNJSR "R8-R9"
 MOV R8,#0
 MOV R0,R11
 MOV R1,#11
 STR R1,[R9,#f_cmode]		; may be in wrong place...
 MOV R2,#0
 STR R2,[R9,#f_source]
 BL mode_data
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Add a throwback entry						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=file offset or line number of line with info on it
;     set b31 to supress this being printed automatically.
;     [THIS BREAKS WITH -VE OFFSETS/LINE NOS]
;  R1=filename (of the file that R0 is an offset in)
;  R2=information string to print after the line number (eg "Bad syntax")
;     b31 set if tokenised
;  R3=string to precede filename  (eg "Errors in file:")
;     b31 set if tokenised
;  R4=file offset of linked file / -1 if may not be loaded
;  R5=flags to use for the new entry (see f_links #12)
;  R6=string to precede new info block (eg "Line num  Error")
;     b31 set if tokenised
;  R7=string to go after filename (eg 10,"Search string: fred") / 0 for none
;     b31 set if tokenised
;  R8/R9=throwback window to add entry to
;X Throwback entry added and new title block given if file (or flags)
;  have changed KB #
;  The line number field is 10 characters wide if not supressed.

add_throwback_entry
 FNJSR "R1,R10-R11"
 MOV R10,R0			; save line number/file offset
 BIC R0,R0,#1<<31		; clear flag
 BL new_link_entry		; R0=0 for same block 1 for new block
 MOVVC R11,R0			; save this
 FNRTS VS
 PUSH "R10"
 BL find_caret_pos		; input caret / point
 BLVC start_operation
 LDRVC R0,[R10,#c_off]
 PULL "R10"
; BLVC mode11_insprepare
 FNRTS VS
 LDR R14,[R9,#f_len]
 CMP R0,R14
 BGE add$l
unlink$l			; unlink cursor
 LDR R0,[R9,#f_flags]
 ORR R0,R0,#1<<14		; unlink
 STR R0,[R9,#f_flags]
add$l
 LDR R0,[R9,#f_len]
 SUBS R0,R0,#1
 MOVMI R0,#10
 BLPL cln_readc			; is the last chr an LF?
 TEQ R0,#10
 ADRNE R0,ret$l
 BLNE insert_string		; ensure that buffer is LF-terminated
 BVS enderror$l
 LDR R1,[R13]			; restore R1 from stack
 TEQ R11,#0
 BEQ entry$l			; just add next entry line
 LDR R0,[R9,#f_len]
 CMP R0,#0
 ADRNE R0,ret$l
 BLNE insert_string		; add blank line if needed
 ; f$l
 BVS end$l
a$l
 ; TST R5,#2			; minus 1 = no linennumber...
 ; BNE b$l
 MOV R0,R3			; "Errors in file" (or similar text...)
 BL insert$l
 MOVVC R0,R1			; filename
 BLVC insert_string
 ;TST R5,#2
 ;BNE b$l
 MOVVC R0,R7
 ;CMP R0,#0
 ;BEQ b$l
 BLVC insert$l			; "Search string: fred"
;b$l
 ;TST R5,#2
 ;BNE e$l
 ADRVC R0,ret2$l		; end + leave blank line
 BLVC insert_string
;e$l
 MOVVC R0,R6
 ;CMP R0,#0
 ;BEQ c$l
 BLVC insert$l			; "Line num  Error"
;d$l
 ;TST R5,#2
 ;BNE c$l
 ;TST R5,#2			; minus 1 = no linennumber...
 ;BNE entry$l ; b$l		; no juice...
 ADRVC R0,ret$l
 BLVC insert_string		; move to next line
;c$l
entry$l				; now ready to insert entry
 MOVVC R0,R10			; line number
 MOVVC R1,#0			; flags
 BVS end$l
 ;TST R5,#2			; minus 1 = no linennumber...
 ;BNE end$l
 TST R0,#1<<31
 BLEQ insert_line_number
 ; BL mode11_insprepare
 MOVVC R0,R2			; error details
 BLVC insert$l
 ADRVC R0,ret$l
 BLVC insert_string
end$l				; may be at error here
 ; BL mode11_inspostpare
 LDR R11,[R9,#f_flags]
 BIC R11,R11,#1<<14
 STR R11,[R9,#f_flags]		; relink even if error
enderror$l
 BL stop_operation
 FNRTS
insert$l
 TST R0,#1<<31
 BEQ insert_string
 FNJSR "R1-R3"
 BIC R1,R0,#1<<31
 FNLDR R2,wimp_data
 MOV R3,#256
 BL lookup_token_gs
 MOVVC R0,R2
 ADDVS R0,R0,#4
 FNPULL
 B insert_string
ret2$l = 10
ret$l = 10,0
 ALIGN

 LOCAL

;tw_insert_string
; FNJSR
; ;MOV R14,#-1
; ;STR R14,local_insdelmsgflg
; BL insert_string		; move to next line
; FNRTS

;E R0=line number
;  R1=flags b0  => number is in hex
;	    b8+ => offset back from the end of file to insert it
;  R8/R9=throwback file
;X line number+2sp printed in first column KB #

insert_line_number
 FNJSR "R1-R5"
 MOV R5,R1			; save flags
 MOV R3,R0			; save line
 FNLDR R4,wimp_kbdbuf		; buffer
 MOV R0,#&20
 MOV R1,R4
 MOV R2,#&80
 BL strstr			; clear buffer to spaces
 MOV R0,R3			; line num
 ADD R1,R4,#&20			; bit into buffer
 MOV R2,#&10
 TST R5,#1
 BNE hex$l
 SWI XOS_ConvertInteger4	; decimal
 B done$l
hex$l
 SWI XOS_ConvertHex8
done$l
 FNRTS VS
 MOV R0,#&20
 STRB R0,[R1]
 STRB R0,[R1,#1]
 MOV R0,#0
 STRB R0,[R1,#2]		; add two spaces and terminator
 SUB R3,R1,#8			; start of number-1
 MOV R2,#10			; length
 LDR R1,[R9,#f_len]
 SUB R1,R1,R5,LSR#8
 MOV R0,#&11
; BL mode11_insprepare
 BL execute_command		; type the line number in the file
; BL mode11_inspostpare
 FNRTS

mode11_insprepare
 STR R14,local_insdelmsgflg
 MOV PC,R14

mode11_inspostpare
 FNJSR
 MOV R14,#0
 STR R14,local_insdelmsgflg
 FNRTS

;E R0=entry word (file offset or line number)
;  R1=filename (of file that R0 is an offset in)
;  R4=file off of linked file/-1 if not loaded
;  R5=flags to use for new entry
;  R9=file link should be added to (the throwback file)
;X Entry word added to links table. #
;  R0=0 => link added to end list
;  R0=1 => new entry added to list (with flags R5,file R4)

new_link_entry
 FNJSR "R1-R11"
 MOV R10,R0			; save word
 MOV R11,R1			; save file
 LDR R8,[R9,#f_links]		; buffer
 MOV R7,#0			; buffer offset
ne15
 LDR R0,[R8,R7]
 CMP R0,#0
 ADDGT R7,R7,#16
 BGT ne15			; get to end of list
 TEQ R7,#0
 BEQ ne16			; add new entry
 SUB R7,R7,#16			; last entry
 ADD R1,R8,R7
 LDR R0,[R1,#12]		; flags
 TEQ R0,R5
 BNE ne21			; new flags (eg diff mode/lns)
 LDR R1,[R8,R7]
 MOV R2,R11			; filename
 BL strCMP
 MOVEQ R11,#0			; link added to last file
 ADDEQ R8,R8,R7			; address
 BEQ ne17			; add link
ne21
 ADD R7,R7,#16
ne16
 MOV R0,R8
 ADD R1,R7,#24
 BL heap_ensure
 FNRTS VS
 STR R0,[R9,#f_links]
 ADD R8,R0,R7			; new link list entry
 MVN R0,#0
 STR R0,[R8,#16]		; add new stop
 STR R5,[R8,#12]		; new flags
 STR R4,[R8,#8]			; linked file
 MOV R0,#4
 BL heap_claim
 FNRTS VS
 STR R0,[R8,#4]			; linked list buffer
 MVN R14,#0
 STR R14,[R0]			; null buffer
 MOV R0,R11
 BL str_len
 ADD R0,R0,#1
 BL heap_claim
 FNRTS VS
 STR R0,[R8]			; filename buffer
 MOV R1,R0
 MOV R2,R11
 BL strcopy			; copy file name
 MOV R11,#1			; created new entry flag
ne17
 LDR R7,[R8,#4]			; linked list
 MOV R6,#0			; buffer offset
ne18
 LDR R0,[R7,R6]
 CMP R0,#0
 ADDPL R6,R6,#4
 BPL ne18			; go to end of list
 ADD R1,R6,#12			; amount needed
 ADD R1,R1,#&1F
 BIC R1,R1,#&1F			; round up to &20 boundry
 MOV R0,R7
 BL heap_ensure
 STRVC R0,[R8,#4]
 ADDVC R7,R0,R6			; new end of table
 STRVC R10,[R7],#4		; save word
 MVNVC R0,#0
 STRVC R0,[R7]			; add stop
 MOVVC R0,R11			; flags
 FNRTS

mode11_interrogate
 CMP R0,#11
 MOVEQ PC,R14
 CMP R0,#14
 MOVEQ R0,#4
 MOVEQ PC,R14
 CMP R0,#0
 CMPNE R0,#3
 MOVEQ R0,R1
 MOVEQ PC,R14
 CMP R0,#12
 CMPNE R0,#2
 CMPNE R0,#5 ; ConfineH
 CMPNE R0,#6 ; ConfineV
 CMPNE R0,#7 ; Free click
 CMPNE R0,#8 ; Smart cursors
 CMPNE R0,#13
 CMPNE R0,#23
 CMPNE R0,#24
 MOVEQ R0,#0
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; cln subs							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R4=current offset in buffer
;  R5=start address of buffer
;  R6=logical line num
;  R7=physical line num
;  R8=window block
;  R9=file block
;  R10=split offset in buffer
;  R11=file length
;X R0-R2 corrupted
;  R3=column reached
;  R4-R11 preserved/updated
;  Moves onto next physical line

;mode11_clnforward
; FNJSR "R8-R9"
; MOV R3,#0			; current column
; LDR R8,[R8,#w_bpl]		; end column
; LDR R9,[R8,#w_splite]
; ADD R9,R5,R9			; address of second half of split
; SUB R4,R4,#1
;next$l
; ADD R4,R4,#1			; next character
;loop$l
; CMP R4,R11
; FNRTS CS			; reached the end of the file
; SUBS R0,R4,R10			; offset into second half of split
; LDRCCB R0,[R5,R4]
; LDRCSB R0,[R9,R0]		; get the next byte
; CMP R0,#&20
; BCC ctrl$l			; control character
;char$l				; ordinary character
; CMP R3,R8
; ADDCC R3,R3,#1
; BCC next$l
; FNRTS				; run out of room
;ctrl$l
; ADD PC,PC,R0,LSL#2
; DCD 0
; B loop$l			; ignore 0
; B skip$l			; 1 = skip string
; B skip$l
; B skip$l
; B skip$l
; B skip$l
; B skip$l
; B skip$l			; 7 = skip
; B char$l			; 8 = ignore
; B tab$l			; 9
; B end$l			; 10 = end of line
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l			; 16
; B skip1$l			; set foregound col
; B skip2$l			; set background col
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l
; B char$l			; 31
;skip$l				; skip string
; ADD R4,R4,#1
; CMP R4,R11
; FNRTS CS			; reached the end of the file
; SUBS R0,R4,R10			; offset into second half of split
; LDRCCB R0,[R5,R4]
; LDRCSB R0,[R9,R0]		; get the next byte
; TEQ R0,#0
; BNE skip$l
; B next$l
;tab$l
; ADD R3,R3,#8
; BIC R3,R3,#7
; CMP R3,R8
; MOVGT R3,R8
; FNRTS GT			; off the end of the line
; B next$l

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Commands							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 DCD c_NoR8 :OR: c_NoR9 :OR: c_Param_Words :OR: c_DecrementR1 :OR: c_TickableMenuEntry
CmdTHROWBACKflagstoggle
	MOV	R1,#11		; mode number
	B	CmdBYTEWORDflagstoggle

 END
