; Contains code for handling extension modes.
; $Id: ModeBits,fff,v 2.17 2003/01/28 16:47:32 christian Exp $

 GET h.ZapHeader
 GET h.Messages
 GET h.Fonts
 GET h.Mode0
 GET h.CreateFile
 GET h.CreateWind
 GET h.Search
 GET h.Strings
 GET h.Redraw
 GET h.Heap
 GET h.AlterTxt
 GET h.Commands
 GET h.TMTVars
 GET h.Mode4
 GET h.Version
 GET h.StartUp
 GET h.Menus

 IMPORT err23
 IMPORT read_given_config_block
 IMPORT remove_external_object
 IMPORT create_menu_structure
 IMPORT are_we_initialising
 IMPORT init_basemap

 EXPORT init_modes
 EXPORT init_comms
 EXPORT call_mode
 EXPORT call_given_mode
 EXPORT call_base_mode
 EXPORT call_given_base_mode
 EXPORT broadcast
 EXPORT read_mode
 EXPORT isthisaclonebase
 EXPORT kill_modes
 EXPORT kill_commands
 EXPORT add_new_mode
 EXPORT read_var
 EXPORT write_var
 EXPORT choose_mode_format
 EXPORT find_file_mode
 EXPORT get_file_mode
 EXPORT cln_phy
 EXPORT cln_log
 EXPORT cln_off
 EXPORT cln_count
 EXPORT cln_lineoff
 EXPORT cln_linecol
 EXPORT cln_txt_splus
 EXPORT new_mode
 EXPORT mode_colour
 EXPORT mode_colour_all
 EXPORT mode_data
 EXPORT issue_service
 EXPORT find_mode_number
 EXPORT test_mode_name
 EXPORT find_ext_mode
 EXPORT get_mode_params
 EXPORT modes_start
 EXPORT modes_end
 EXPORT get_mode_word
 EXPORT put_mode_word
 EXPORT read_conf_mode_data
 EXPORT create_modedata
 EXPORT create_modedata_block
 EXPORT mode_colour_num
 EXPORT make_default_mode
 EXPORT post_load
 EXPORT pre_save
 EXPORT mode_name
 EXPORT load_mode_module
 EXPORT loaddisasmwithcare
 EXPORT loaddisasm
 EXPORT loadhidepointer
 EXPORT loadflashcar
 EXPORT loadlineeditor
 EXPORT loadiclear
 EXPORT checkseeifdisasmloaded
 EXPORT checkseeiflineeditorloaded
 EXPORT checkseeifFTEloaded
 EXPORT getmoduleversionnumber
 EXPORT kill_if_on_kill_list
 EXPORT init_kill_list
 EXPORT add_filter
 EXPORT remove_filter


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Mode loading / initialisation				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R10=mode number for which a module table pointer exists
;X 1. New Zap dispatch table created
; 2. Mode's e_init called with R1=1 (mode about to start up)
	FNAME	init_a_mode
init_a_mode
	FNJSR	"R1-R11"
	MOV	R0,R10
	BL	read_mode		; R0=unlinked table pointer
	FNRTS	VS
	ADDS	R9,R0,#0		; unlinked module table pointer
	FNRTS	LE			; mode not valid
	LDR	R8,[R9,#e_module]
	SUB	R8,R9,R8		; R8=module start address
	MOV	R1,#0
	MOV	R2,#0
find$l					; find the module in the OS list
	MOV	R0,#12
	SWI	XOS_Module		; get workspace pointer in R4
	BLVS	err$l			; Mode table corrupt
	FNRTS	VS
	TEQ	R3,R8
	BNE	find$l			; not matched yet
	FNADR	R6,ext1$l		; start of mode table 0
	LDR	R6,[R6,#e_len]		; R6=length of unliked mode table
	MOV	R0,R6,LSL#1		; 2 words per entry
	BL	heap_claim		; claim the Zap dispatch table
	FNRTS	VS
	MOV	R7,R0			; dispatch table (don't write 'till complete)
	STR	R8,[R7]			; module address
	STR	R4,[R7,#4]		; module workspace
	LDR	R0,[R9,#e_mode+1]	; mode it wanted to be + flags
	ORR	R2,R10,R0,LSL #8	; add mode actually is
	STR	R2,[R7,#2*e_mode]	; actual mode number + flags
	MOV	R0,R6,LSR #2		; one byte per entry
	BL	heap_claim
	FNRTS	VS
	STR	R0,[R7,#d_epointtable]
	MOV	R11,R0			; mode entry point supplier table (mode nos.)
	LDR	R0,[R9,#e_basemode]
	STR	R0,[R7,#2*e_basemode]	; basemode number
	STR	R10,[R7,#d_clonebasemode] ; clone basemode number
	LDR	R0,[R9,#e_title]
	ADD	R0,R0,R8
	STR	R0,[R7,#2*e_title]	; title
	MOV	R0,#-1
	STR	R0,[R7,#d_variabletable] ; per-mode variable table
	LDR	R0,[R9,#e_author]
	ADD	R0,R0,R8
	STR	R0,[R7,#2*e_author]	; author
	LDR	R0,[R9,#e_init]
	ADD	R0,R0,R8
	STR	R0,[R7,#2*e_init]	; initialise sub
	STR	R4,[R7,#2*e_init+4]	; workspace

	LDR	R0,[R9,#e_menu]
	TEQ	R0,#0
	BEQ	mok$l
	ADD	R0,R0,R8
	TST	R2,#emode_MenuFile
	BNE	mok$l
	TST	R2,#emode_UsesMessageTrans
	MOVNE	R1,#0
	MOVNE	R2,R8
	BLNE	expand_menu		; expand menu if internationalised
mok$l	STRVC	R0,[R7,#2*e_menu]	; menu pointer /0
	MOVVS	R2,#0
	STRVS	R2,[R7,#2*e_menu]

	MOVVC	R2,R4			; save module workspace
	LDRVC	R5,[R9,#e_len]		; length of valid data in table
	MOVVC	R4,#&20			; start of subs
	LDRVC	R0,[R9,#e_basemode]	; basemode
	BLVC	read_mode		; R1=linked basemode table
	FNRTS	VS
	MOV	R3,R1			; linked table (may be invalid - mode 0)
entry$l					; next entry loop
	CMP	R4,R6			; have we reached the table end?
	BCS	end$l
	CMP	R4,R5
	BCS	usebase$l		; off end of table
	LDR	R0,[R9,R4]
	CMP	R0,#0
	BLE	usebase$l		; use basemode offset
	ADD	R0,R8,R0		; address of sub
	MOV	R1,R2			; workspace pointer
	ORR	R10,R10,R10,LSL #8
	B	fillin$l
usebase$l				; use the basemode value for this offset
	CMP	R3,#&8000		; NOW check if R3 valid
	BLE	err2$l			; base mode not valid
	FNRTS	VS
	ADD	R14,R3,R4,LSL#1		; basemode entry
	LDMIA	R14,{R0,R1}		; address and workspace
	LDR	R14,[R3,#2*e_mode+4]
	LDRB	R14,[R14,R4,LSR #2]	; supplying mode
	ORR	R10,R14,R10,LSL #8
fillin$l				; R0,R1=sub,workspace ptr
	ADD	R14,R7,R4,LSL#1
	STMIA	R14,{R0,R1}		; save the entry
	STRB	R10,[R11,R4,LSR #2]	; and the supplier
	MOV	R10,R10,LSR #8
	ADD	R4,R4,#4		; next sub
	B	entry$l			; loop
end$l					; table completed
	FNADD	R14,R12,mode_store
	ADD	R14,R14,R10,LSL#3
	STR	R7,[R14,#4]		; write the address of the linked table
	MOV	R0,R10			; mode number
	MOV	R1,#1			; about to start mode
	MOV	R11,#e_init		; (menus and options word not yet set up)
	BL	call_given_mode		; OK...
	FNRTS
ext1$l  DCD	mode_table_0
err$l	ERR	"zap_e_badextntab"
err2$l  ERR	"zap_e_badbase"


	LOCAL

;E R10=mode number
;X Config file block for this mode read and opt_moden,opt_modedata updated
; (don't do for windows until after e_init 2!)
	FNAME	init_mode_config
init_mode_config
	FNJSR	"R1,R6-R10"
	MOV	R0,#2			; mode block
	MOV	R1,R10
	BL	read_given_config_block ; read the block if it exists
	FNRTS	VS
	CMN	R0,#1
	MOVEQ	R0,#3
	BLEQ	read_given_config_block
	FNRTS	VS
	FNLDR	R0,opt_modedata
	LDR	R0,[R0,R10,LSL#2]
	CMP	R0,#0
	FNRTS	GT			; mode block already set up
	MOV	R8,R10			; mode
	ADR	R9,default$l		; default block
	MOV	R10,#12			; length (old format)
	BL	read_conf_mode_data	; set up the default block
	FNRTS
default$l
	DCD	77+&12010000
	DCD	&97070077
	DCD	&B


	LOCAL

;X All newly initialsed modes have their e_init entry points called with
; R1=2 (started up). All modes in the module must have been started up.
; Don't copy options to window block 'till after this
	FNAME	init_modes_init
init_modes_init
	FNJSR	"R1-R11"		; some inits may corrupt registers :(
	ADR	R9,init_mode_list
a$l
	LDRB	R10,[R9],#1
	TEQ	R10,#&FF
	FNRTS	EQ			; finished
	MOV	R0,#version_major*100+version_minor ; *** Zap version number ***
	MOV	R1,#11			; advise vsn no >= 136
	MOV	R11,#e_init
	BL	call_given_mode
	MOVVC	R0,R10			; mode number
	MOVVC	R1,#2			; started mode
	MOVVC	R11,#e_init
	BLVC	call_given_mode
	BVC	a$l
	FNRTS


	LOCAL

;X It looks through the list of modes and all modes that have been loaded
; (module table address set up) but not but initialised (linked table
; address not set up) are initialised, ready to go.
	FNAME	init_modes
init_modes				; /the/ problem routine...
	FNJSR	"R1,R9-R10"
	MOV	R10,#0			; current mode (note: must set up in order)
	ADR	R9,init_mode_list	; keep a list of loaded modes
a$l
	MOV	R0,R10
	BL	read_mode
	FNRTS	VS
	CMP	R0,#0
	BLE	next$l			; no mode loaded in this slot
	CMP	R1,#0
	BGT	next$l			; mode already set up and running
	STRB	R10,[R9],#1		; this is a new mode
	BL	init_a_mode		; create dispatch table for this mode
	BLVC	init_mode_config	; read the config block (or default)
	FNRTS	VS
next$l
	ADD	R10,R10,#1
	CMP	R10,#max_mode
	BCC	a$l
	MOV	R0,#&FF
	STRB	R0,[R9]			; terminate list
	BL	init_modes_init		; call e_init with R1=2 to init options
	FNRTS	VS			; blocks
	ADR	R10,init_mode_window
	BL	do_allwindow		; update open windows options blocks
	BLVC	init_mode_menu		; initialise the menus - a problem?
	FNRTS


	LOCAL

;E R0=clone mode number
; R1=clone base mode number
;X Mode initialised if necessary
	FNAME	init_mode
init_mode
	FNJSR	"R1-R3,R9-R10"
	MOV	R10,R0
	BL	read_mode
	FNRTS	VS
	CMP	R0,#0
	FNRTS	LE			; no mode loaded in this slot
	CMP	R1,#0
	FNRTS	GT			; mode already set up and running
	ORR	R0,R10,#&FF00
	STR	R0,init_mode_list	; this is a new mode
	BL	init_a_mode		; create dispatch table for this mode
	FNRTS	VS
	MOV	R0,R10			; clone mode
	MOV	R3,R0
	BL	read_mode
	MOV	R2,R1
	LDR	R0,[R13]		; clone base mode
base$l  BL	read_mode
	LDR	R0,[R1,#d_clonebasemode]
	TEQ	R0,R3
	MOVNE	R3,R0
	BNE	base$l
	STR	R3,[R2,#d_clonebasemode] ; write the clone base mode number
	BL	init_mode_config	; read the config block (or default)
	BLVC	init_modes_init		; call e_init with R1=2 to init options
	ADRVC	R10,init_mode_window
	BLVC	do_allwindow		; update open windows options blocks
	BLVC	init_mode_menu		; initialise the menus - a problem?
	FNRTS

init_mode_list
	%	(max_mode+1)		; &FF terminated list of modes being loaded
	ALIGN


	LOCAL

;E R8/R9=window
;X Options blocks for newly create modes set up for this window
	FNAME	init_mode_window
init_mode_window
	FNJSR	"R1-R4"
	ADR	R3,init_mode_list	; list of the new modes
a$l					; next mode
	LDRB	R4,[R3],#1
	TEQ	R4,#&FF
	FNRTS	EQ
	MOV	R0,R4
	FNLDR	R1,opt_modedata
	LDR	R2,[R8,#w_modedata]
	BL	create_modedata_block
	MOVVC	R0,R4
	ADDVC	R1,R12,#opt_modebase
	BLVC	copy_a_mode_buffer
	BVC	a$l
	FNRTS


;X All newly initialised modes have their e_menus looked at and set up
	FNAME	init_mode_menu
init_mode_menu
	FNJSR	"R1-R3,R10-R11"
	ADR	R3,init_mode_list	; list of the new modes
loop$l
	LDRB	R10,[R3],#1		; get next mode
	TEQ	R10,#&FF
	FNRTS	EQ			; finished
	MOV	R11,#e_init
	MOV	R1,#7
	MOV	R0,R10
	BL	call_given_mode		; see if it's got a new menu
	FNRTS	VS
	MOV	R2,R1			; save the new menu pointer
	MOV	R0,R10
	BL	read_mode		; R1=linked address
	TEQ	R2,#7
	BNE	got$l
	LDR	R0,[R0,#e_mode]		; see if it's a filename
	TST	R0,#emode_MenuFile
	BNE	file$l
	LDR	R0,[R1,#2 * e_menu]	; get pointer to menu
	CMP	R0,#0
	BEQ	loop$l			; none!
	PUSH	"R1"
	LDR	R1,[R1]			; module address (base for offsets)
	BL	create_menu_structure
	PULL	"R1"
	FNRTS	VS
	MOV	R2,R0
	B	got$l

file$l	LDR	R0,[R1,#2 * e_menu]
	SYSLOGF	"calling load_file with %0s",0
	BL	load_menu
	LDR	R2,[R0,#4]		; handle 0
	BL	heap_free

got$l	STR	R2,[R1,#2 * e_menu]	; fix new menu pointer
	B	loop$l			; next mode


	LOCAL

;E R0=filename of module to load with * command on end / 0 if loaded
; Bit 31 set if no * command present
;X Module loaded and all modes/command tables it contains installed #
	FNAME	load_mode_module
load_mode_module
	FNJSR	"R1-R2"			; was 1-2
	ADDS	R1,R0,#0
	FNRTS	EQ			; filename is null (already loaded)
	TST	R1,#1 << 31
	BICNE	R1,R1,#1 << 31
	BNE	load$l			; only module name given
	BL	str_len
	ADD	R0,R1,R0
	ADD	R0,R0,#1		; address of * command
	LDRB	R14,[R0]
	CMP	R14,#&20
	BLE	load$l
	PUSH	"R0"
	ADR	R0,saveobeydir$l
	SWI	XOS_CLI
	PULL	"R0"
	SWI	XWimp_StartTask		; execute it (non null) ('s OK...)
	ADR	R0,restoreobeydir$l
	SWI	XOS_CLI
load$l
	FNLDR	R2,com_number		; save current number of command tables
	MOV	R0,#1
	SWI	XOS_Module		; load the module
	MOVVC	R0,R1
	BLVC	remove_external_object  ; prevent it from being reloaded
	FNRTS	VS
	BL	are_we_initialising
	BLNE	init_modes		; initialise all new modes
	MOVVC	R0,R2
	BLVC	init_comms
	FNRTS
saveobeydir$l
	=	"%Set Obey$Dir_Prev <Obey$Dir>",0
restoreobeydir$l
	=	"%Set Obey$Dir <Obey$Dir_Prev>",0
	ALIGN


	LOCAL

;E R0=first command table to initialise
;X Command tables between R0 and com_number initialised #
	FNAME	init_comms
init_comms
	FNJSR	"R1-R11"
	FNADD	R10,R12,command_store	; start of list
	FNLDR	R11,com_number		; number of command tables
	ADD	R11,R10,R11,LSL #2	; last table
	ADD	R10,R10,R0,LSL #2	; current table
next$l
	CMP	R10,R11			; reached the end?
	FNRTS	GE
	LDR	R0,[R10],#4		; get table address
	LDR	R14,[R0,#4]		; find the service call offset
	CMP	R14,#0
	BLE	next$l			; none
	LDR	R1,[R0]			; find offset from module start
	SUB	R0,R0,R1		; address of module start
	ADD	R9,R0,R14		; offset of service call handler
	MOV	R1,#1
	MOVS	R14,PC			; return address
	MOV	PC,R9			; call the service call with R1=1
	MOVVC	R1,#2
	FNRTS	VS
	MOVS	R14,PC			; return address
	MOV	PC,R9			; call the service call with R1=2
	BVC	next$l
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Calling a mode entry point				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

do_call_mode
	PULL	"R0-R2,PC"

;E R0-R10=args R8=wind block giving mode R11=entry point offset
;X R0-R11=as returned by the sub (R11 usually subs workspace)
	FNAME	call_mode
call_mode
	FNJSR				; save return address
	BL	call_pre_filters
	FNRTS	EQ
	PUSH	"R11"
	PUSH	"R0-R2,R14,PC"		; save args and two blanks
	TEQ	R8,#0
	FNLDRB  R0,opt_format,EQ	; default mode
	LDRNEB  R0,[R8,#w_format]	; display mode
	ADD	R1,R12,#(mode_store+4):AND:&FF00
	ADD	R1,R1,#(mode_store+4):AND:&00FF ; start of list + 4
	LDR	R0,[R1,R0,LSL #3]	; mode dispatch table in R0
	LDR	R2,[R0,#2*e_mode+4]
	LDRB	R2,[R2,R11,LSR #2]	; mode supplying the entry point
	LDR	R1,[R0,R11,LSL #1]!	; address of the sub + save
	LDR	R11,[R0,#4]		; workspace pointer to use
	STR	R1,[R13,#12]		; overwrite the blanks with the address
	STR	R2,[R13,#16]		;   and the mode number
	BL	do_call_mode		; restore args and call the sub (R14=ret)
	PUSH	"R11"
	LDR	R11,[R13,#8]
	BL	call_post_filters
	PULL	"R11,R14"
	PULL	"R14,PC"		; return


;E R0-R9=args R10=mode number to call R11=entry point offset
;X R0-R11=as returned by sub & mode called if valid (returns o/w)
	FNAME	call_given_mode
call_given_mode
	FNJSR				; save return address
	PUSH	"R0-R2,R14,PC"		; save args and two blanks
	ADD	R1,R12,#(mode_store+4):AND:&FF00
	ADD	R1,R1,#(mode_store+4):AND:&00FF ; start of list + 4
	LDR	R0,[R1,R10,LSL #3]	; mode dispatch table in R0
	CMP	R0,#0			; do nothing if mode blank
	PULL	"R0-R2,R14",EQ
	LDRNE	R2,[R0,#2*e_mode+4]
	LDRNEB	R2,[R2,R11,LSR #2]	; mode supplying the entry point
	LDRNE	R1,[R0,R11,LSL #1]!	; address of the sub + save
	LDRNE	R11,[R0,#4]		; workspace pointer to use
	STRNE	R1,[R13,#12]		; overwrite the blanks with the address
	STRNE	R2,[R13,#16]		;   and the mode number
	BLNE	do_call_mode		; restore args and call the sub (R14=ret)
	PULL	"R14,PC"		; return


	LOCAL

; NOW OBSOLETE!!
call_base_mode
	FNJSR	"R1-R7"
	ADR	R0,obsolete$l
	ADR	R4,callbasemode$l
	BL	lookup_error
	FNRTS
obsolete$l
	&	0
	=	"zap_e_obsolete",0
callbasemode$l
	=	"Zap_CallBaseMode",0
	ALIGN


;E R0-R7=args R8=window R9=mode calling R10=arg R11=e_ offset
;X R9 set up to file block then entry point called
; R0-R11 as returned by sub #
	FNAME	call_given_base_mode
call_given_base_mode
	FNJSR				; save return address
	PUSH	"R0-R2,R14,PC"		; save args and two blanks
	ADD	R1,R12,#(mode_store+4):AND:&FF00
	ADD	R1,R1,#(mode_store+4):AND:&00FF ; start of list + 4
	LDR	R0,[R1,R9,LSL #3]	; linked table
	LDR	R0,[R0,#2*e_basemode]	; base mode
	LDR	R0,[R1,R0,LSL #3]	; linked table
	LDR	R2,[R0,#2*e_mode+4]
	LDRB	R2,[R2,R11,LSR #2]	; mode supplying the entry point
	LDR	R1,[R0,R11,LSL #1]!	; address of the sub + save
	LDR	R11,[R0,#4]		; workspace pointer
	STR	R1,[R13,#12]		; address to jump to
	STR	R2,[R13,#16]		;   and the mode number
	LDR	R0,[R8,#w_file]		; file block offset
	FNLDR	R9,file_list
	ADD	R9,R9,R0,LSL #f_shift	; create file block pointer
	BL	do_call_mode		; restore args and call the sub (R14=ret)
	PULL	"R14,PC"		; return


	LOCAL

;E R1-R9=args R11=entry point offset
;X each valid mode called with R0=mode number on entry #
	FNAME	broadcast
broadcast
	FNJSR	"R1-R10"
	MOV	R10,#0			; start mode
next$l
	PUSH	"R11"
	MOV	R0,R10
	BL	call_given_mode
	PULL	"R11"
	FNRTS	VS
	ADD	R10,R10,#1
	CMP	R10,#max_mode
	BCC	next$l
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read mode name, number, table pointer			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=mode number
;X R0=unlinked table pointer/0 R1=linked table pointer/0 if invalid #
	FNAME	read_mode
read_mode
	FNJSR
	MOV	R1,#0
	CMP	R0,#max_mode
	MOVHS	R0,#0			; not a valid mode
	FNADD	R14,R12,mode_store,LO
	ADDLO	R14,R14,R0,LSL #3
	LDMLOIA R14,{R0,R1}
	FNRTS


	LOCAL

;E R0=mode number
;X R2=mode name string/ VS if not found #
	FNAME	mode_name
mode_name
	FNJSR	"R1"
	BL	read_mode		; R1=linked table pointer
	FNRTS	VS
	CMP	R1,#0
	BLLE	err$l
	LDRVC	R2,[R1,#e_title*2]	; mode name address
	FNRTS
err$l	ERR	"zap_e_badmoden"


	LOCAL

;E R0=mode number
;X Z set if mode is the clone base of (or is!) the current mode
; R0=current mode R14=menu mode
	FNAME	isthisaclonebase
isthisaclonebase
	FNJSR	"R1-R3"
	TEQ	R8,#0
	FNLDRB  R3,opt_format,EQ	; get current mode number
	LDRNEB  R3,[R8,#w_format]
	TEQ	R3,R0			; same mode?
	BEQ	ret$l
	MOV	R2,R0
	MOV	R0,R3
	BL	read_mode
	LDR	R0,[R1,#d_clonebasemode] ; get clone base of current mode
	TEQ	R0,R2			; same mode?
	MOV	R0,R3			; get current mode anyway
	ADDNE	R3,R3,#1
ret$l	FNLDR	R14,menu_mode
	TEQ	R14,#0
	MOVMI	R14,R0
	TEQ	R0,R3			; restore Z flag
	FNRTS


	LOCAL

;X kill extension modes and command tables WB #
	FNAME	kill_modes
kill_modes
	FNJSR	"R1-R11"
	FNADD	R7,R12,mode_store	; mode pointer
	MOV	R10,#0			; current mode
loop$l
	LDR	R9,[R7,#4]		; linked table
	CMP	R9,#0
	BLE	next$l			; no mode on this number
	CMP	R10,#11
	CMPNE	R10,#4			; in Zap...?
	BLE	next$l
	LDR	R8,[R9]			; module address
	MOV	R0,R10			; mode assigned to module
	MOV	R1,#0			; reason code quit
	MOV	R11,#e_init
	BL	call_given_mode		; can I kill the module ?
	FNRTS	VS
	CMP	R0,#-1
	BEQ	next$l			; don't kill
	MOV	R0,R8
	BL	add_to_kill_list	; kill_module
	FNRTS	VS
next$l
	ADD	R7,R7,#8
	ADD	R10,R10,#1
	CMP	R10,#max_mode
	BCC	loop$l			; do the next mode
	FNRTS


	FNAME	kill_commands
kill_commands
	FNJSR	"R1-R11"
	FNADD	R7,R12,command_store	; start on the commands
	FNLDR	R10,com_number		; number of command tables
comloop$l
	CMP	R10,#0			; finished (zap mode table...?)
	FNRTS	LE
	SUB	R10,R10,#1
	LDR	R9,[R7],#4		; address of command table
	LDR	R8,[R9]
	SUB	R8,R9,R8		; module address
	LDR	R0,[R9,#4]		; service call offset
	CMP	R0,#0
	BLE	comloop$l		; none - don't kill
	ADD	R0,R8,R0		; service call entry point
	MOV	R1,#0			; dying
	MOVS	R14,PC
	MOV	PC,R0			; call the handler
	CMP	R0,#-1
	MOVNE	R0,R8
	BLNE	add_to_kill_list	; kill it off
	B	comloop$l


	LOCAL

;E R0=address of mode table (probably in SVC mode)
;X mode table added to list #
;  (Internal: returns the mode number in R0)
	FNAME	add_new_mode
add_new_mode
	FNJSR	"R1-R4"
	MOV	R4,R0			; save table address
	FNADD	R2,R12,mode_store	; mode blocks (2 words each)
	LDR	R1,[R4,#e_mode]		; mode & flags
	AND	R0,R1,#emode_ModeMask	; mode it wants to become
	TST	R1,#emode_ForceModeNumber
	BNE	end$l			; force this mode
	MOV	R3,R0			; save the mode
next$l
	LDR	R14,[R2,R0,LSL #3]	; get pointer
	TEQ	R14,#0
	BEQ	end$l			; mode free
	ADD	R0,R0,#1
	CMP	R0,#max_mode
	MOVCS	R0,#0			; cycle
	TEQ	R0,R3			; back to where we started?
	BNE	next$l			; if not try next mode
	BL	err$l			; too many modes
	FNRTS
end$l					; R0=mode it is being assigned to
	STR	R4,[R2,R0,LSL #3]	; new table pointer
	FNRTS

err$l	ERR	"zap_e_manymodes"



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; read/write zap vars						  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	FNAME	read_var
read_var
	FNJSR
	BL	conv_var_number
	FNRTS	VS
	TEQ	R0,#0			; -ve if w_*
	LDRPL	R0,[R12,R0]
	FNRTS	PL
	TEQ	R8,#0
	FNLDR	R0,key_default,EQ	; read key_default if R8=0
	LDRNEB  R0,[R8,-R0]
	FNRTS

	FNAME	write_var
write_var
	FNJSR	"R2"
	MOV	R2,R0			; save value to write
	BL	conv_var_number
	FNRTS	VS
	TEQ	R0,#0			; -ve if w_*
	STRPL	R2,[R12,R0]
	FNRTS	PL
	TEQ	R8,#0
	STRNEB  R2,[R8,-R0]		; write only if R8<>0
	FNRTS


	LOCAL

;E R1=variable number
;X R0=variable offset from R12 #
	FNAME	conv_var_number
conv_var_number
	FNJSR
	CMP	R1,#&100
	BCC	co13
	SUB	R0,R1,#&100
	CMP	R0,#max_mode
	MOVCC	R0,R0,LSL #2
	ADDCC	R0,R0,#opt_modebase
	BLCS	err$l
	FNRTS
co13
	CMP	R1,#(var_list_end-var_list):SHR:2
	BLCS	err$l
	ADRVC	R14,var_list
	LDRVC	R0,[R14,R1,LSL #2]
	FNRTS
err$l	ERR	"zap_e_badvarnum"

var_list
	DCD	scn_xos
	DCD	scn_yos
	DCD	opt_flags
	DCD	opt_format
	DCD	wimp_task
	DCD	car_cursor
	DCD	car_input
	DCD	car_selection
	DCD	wind_num
	DCD	file_num
	DCD	car_mode
	DCD	wimp_version
	DCD	-:INDEX:w_defaultmap
	DCD	-:INDEX:w_basemap
	DCD	key_last
	DCD	key_lastcom
	DCD	mini_ptr
	DCD	mini_bufl
	DCD	mini_len
	DCD	mini_off
	DCD	mini_mark
	DCD	yank_ptr
	DCD	yank_len
	DCD	-:INDEX:w_currentmap
	DCD	opt_res8
	DCD	opt_tab
	DCD	opt_addr
	DCD	opt_stline
	DCD	opt_linesp
	DCD	env_start
	DCD	env_top
	DCD	wimp_iconbar
	DCD	wimp_timeformat
	DCD	wimp_dateformat
	DCD	key_flags
	DCD	wimp_kbdbuf
	DCD	opt_info
var_list_end


	LOCAL

;E R8/R9
;X R0=wimp_modelist block for the installed mode
;  w_* updated according to file type of file
;      (eg forced to given mode, basemap set, etc.)
;  e_postload and e_start called #
	FNAME	choose_mode_format
choose_mode_format
	FNJSR	"R1,R10-R11"
	LDR	R0,[R9,#f_load]		; load address
	BL	calc_ftype
	STRCC	R0,[R8,#w_addr]		; force start address if valid
	BCC	setaddr$l
	SUB	R14,R0,#&F00
	TEQ	R14,#&FA		; module
	TEQNE	R14,#&FC		; utility
	MOVEQ	R14,#&0
	STREQ	R14,[R8,#w_addr]	; set module+util files address
	TEQ	R14,#&F8		; absolute
	TEQNE	r14,#&d3		; absolute (debugable)
	MOVEQ	R14,#&8000
	STREQ	R14,[R8,#w_addr]	; set absolute files address
setaddr$l
	MOV	r0,#0
	BL	get_file_mode		; find mode number to use
	FNRTS	VS			; (must be valid)
	PUSH	"R0-R12"
	MOV	R0,#einterrogate_ModeType ; special checks for Throwback and TaskWindow
	MOV	R11,#e_interrogate
	LDR	R10,[R9,#f_cmode]
	BL	call_given_mode
	TEQ	R0,#modetype_TaskWindow
	TEQNE	R0,#modetype_Throwback
	PULL	"R0-R12"
	LDREQ	R10,[R9,#f_cmode]
	MOV	R1,#0			; new file (just loaded)
	STRB	R10,[R8,#w_format]	; force this mode
	MOV	R10,R0			; save wimp_modelist blk pointer
	BL	post_load		; doctor file for this mode
	BLVC	init_basemap
	MOVVC	R0,#0
	MOVVC	R11,#e_start
	BLVC	call_mode		; set up w_format for this mode
	BLVC	checkforautosoftwrap	; check the file
	MOVVC	R0,R10			; modelist block (containing the command)
	FNRTS


	LOCAL

; finds the mode to load a given file in using filetype and path matches
;E R0 = load address (containing filetype)
;  R1 = filename / 0 if none to test
;  R2 = flag which indicates whether the mode is needed or not
;X R0 = wimp_modelist block for this file
;  If R2 on entry == 0
;    R10 = mode num used for this filetype (loaded if needed) #
;  If R2 on entry != 0
;    R10 = pointer to the mode name (mode may not be loaded)
; (see rk_mode for format of wimp_modelist) #
	FNAME	find_file_mode
find_file_mode
	FNJSR	"R1-R9,R11"
	MOV	R11,R2
	MOV	R7,R1			; keep a copy of filename ptr + flags
	FNLDR	R14,opt_format
	TST	R14,#1<<31
	BNE	default$l		; mode forced
	BL	calc_ftype		; get filetype
	MOVCC	R0,#&1000		; untyped file
	MOV	R2,R0			; save the file type
	FNLDR	R10,wimp_modelist	; start of the list
	MOVS	R9,R1			; filename / 0 if none
	BEQ	type$l			; none
	MOV	R0,R9
	BL	str_len			; find length of the file name
	MOV	R8,R0			; length
type$l					; check file type main loop
	LDR	R3,[R10]		; block length
	CMP	R3,#0
	BLE	default$l		; end of list
	ADD	R3,R10,R3		; start of next block
	LDR	R0,[R10,#4]		; filetype to match
	BIC	R0,R0,#&FF000000	; remove flags
	CMP	R0,#&1000
	BHI	typematched$l		; always matches
	TEQ	R0,R2
	MOVNE	R10,R3
	BNE	type$l			; no match
typematched$l
	LDRB	R0,[R10,#16]		; first char of string
	TEQ	R0,#0
	BNE	fname$l			; string to match
matched$l				; block R10 matches
	ADD	R0,R10,#16		; filename to match
	BL	str_len
	ADD	R1,R10,#17
	ADD	R0,R1,R0		; start of mode name to use
	TEQ	R11,#0
	BNE	end$l			; just wanted mode name
	BL	find_mode_number	; get the mode number (loading if needed)
	FNRTS	VS
	CMP	R0,#0
	BMI	default$l		; mode doesn't exist
end$l					; R0=mode pointer or mode name
	MOV	R1,R0
	MOV	R0,R10			; matching block
	MOV	R10,R1			; mode number/name
	FNRTS
default$l				; file type forced or no match found
	ADR	R0,defblk$l		; default block
	FNLDRB  R10,opt_format		; default mode
	TEQ	R11,#0
	ADRNE	R10,deftxt$l		; default mode name
	FNRTS
fname$l					; check filename matches
	CMP	R9,#0
	MOVLE	R10,R3
	BLE	type$l			; no filename given (so no match)
	PUSH	"R5,R8"
	MOV	R5,#1<<29		; don't expand macros
	MOV	R8,#0			; no window
	ADD	R0,R10,#16		; search string
	BL	search_init		; set up the search tree
	PULL	"R5,R8"
	FNRTS	VS
	PUSH	"R1-R4"
	MOV	R0,#0			; node offset
	MOV	R1,#-1			; reset
	MOV	R2,R8			; filename length
	MOV	R3,#0			; flags
	FNLDR	R4,fnd_tree		; search tree
	BL	wildcard_match		; set up tree
loop$l					; loop through all possible matches
	MOV	R0,#0
	MOV	R1,#0
	BL	wildcard_match
	CMP	R0,#0
	PULL	"R1-R4",MI
	MOVMI	R10,R3
	BMI	type$l			; run out of matches
	TEQ	R0,R8			; is end of match at and of name
	BNE	loop$l			; try again
	PULL	"R1-R4"
	B	matched$l		; found the match
defblk$l				; default modelist block (not auto load!)
	DCD	&14,&FFF,0,0
	=	0
deftxt$l
	=	"Text",0
	ALIGN

; as above, but also uses FileID matching
;E R0 == 0 for mode number, != 0 for mode name R8/R9
;X as for find_file_mode
	FNAME	get_file_mode
get_file_mode
	FNJSR	"R1-R7"
	MOV	R6,R0			; R6 != 0 if caller wants mode name
	TEQ	R9,#0
	BEQ	nomatch$l
	LDR	R0,[R9,#f_load]
	LDR	R1,[R9,#f_name]
	MOV	R2,R6
	BL	find_file_mode
	FNRTS	VS
	FNLDR	R14,opt_format
	TST	R14,#1<<31
	BNE	nomatch$l		; mode forced
	TEQ	R10,#0
	ADR	R2,deftxt$l
	TEQNE	R10,R2			; if text mode is indicated,
	BEQ	is_text_mode$l		;   we're interested
	TEQ	R6,#0
	FNRTS	EQ
	PUSH	"R0"
	MOV	R1,R10
	BL	strCMP
	PULL	"R0"
	FNRTS	NE
is_text_mode$l
	; Ensure that the split isn't in the area to be searched
	LDR	r0,[r9,#f_splito]
	CMP	r0,#1024
	MOVLO	r0,#1024
	MOVLO	r1,#0
	BLLO	split_buffer
	; Look for the end of the first non-blank line within the first 1K
	; If not found, return
	LDR	r0,[r9,#f_ptr]
	LDR	r2,[r9,#f_len]
	MOV	r1,#0			; current offset
	TEQ	r2,#0
	BEQ	nomatch$l		; nothing to do if the buffer's empty
	LDRB	r3,[r8,#w_cr]
	MOV	r4,#0			; line start offset
	CMP	r2,#1024
	MOVHS	r2,#1024
findeol$l
	LDRB	r5,[r0,r1]
	TEQ	r5,r3			; Line end?
	BEQ	foundeol$l		; ... yes
	ADD	r1,r1,#1		; ... no
	TEQ	r1,r2
	BNE	findeol$l		; Keep going until EOF or 1K searched
	B	nomatch$l		; Nothing found, so return text mode
foundeol$l
	CMP	r4,r5			; Test for empty line
	ADD	r4,r5,#1		; Update line start offset
	BEQ	findeol$l		; If EQ, line is empty; try again
	PUSH	"r4"			; stack this (search start offset)
	FNLDR	r7,wimp_fileid
findmatch$l
	LDR	r0,[r7]
	TEQ	r0,#0			; If no more to check,
	PULL	"r14",EQ		;   unstack the search start offset
	BEQ	nomatch$l		;   and return, saying text mode
	LDR	r0,[r7,#4]
	ADD	r0,r7,r0		; Point R0 at the regex
	MOV	r1,#2
	LDR	r3,[r13]		; Get the search start offset
	MOV	r4,#-1			; Searching backwards from here
	MOV	r5,#2_01100111 << 24	; \cmds, no macros, case sensitive
	ORR	r5,r5,#1 << 22
	BL	search_data
	CMP	r0,#0
	BLT	trynext$l
	CMP	r1,r3			; End of match must be at/beyond LF
	BHS	foundmode$l
trynext$l
	LDR	r0,[r7]
	ADD	r7,r7,r0
	B	findmatch$l
foundmode$l
	PULL	"r14"			; unstack/discard the search pos
	ADD	r0,r7,#8
	TEQ	R6,#0
	BLEQ	find_mode_number	; get the mode number (if req)
	FNRTS	VS
	MOVS	r10,r0
	ADRPL	r0,defblk$l
	FNRTS	PL
nomatch$l
	ADR	r0,defblk$l
	TEQ	R6,#0
	FNLDRB  r10,opt_format,EQ	; default mode
	ADDNE	r10,r0,#deftxt$l-defblk$l ; or text mode
	FNRTS

eol$l	=	"\\n",0
	ALIGN


;E R1=create block R8 (giving mode)
;X block filled with default opening window for current mode |
	FNAME	get_mode_params
get_mode_params
	FNJSR	"R2-R3"
	FNLDR	R3,wimp_sizelist
	LDRB	R2,[R8,#w_format]	; current mode
ge15
	LDR	R0,[R3]
	CMP	R0,#0
	ADRMI	R3,ge_d0		; default table
	BMI	ge16
	TEQ	R0,R2
	ADDNE	R3,R3,#32
	BNE	ge15			; loop until match
	ADD	R3,R3,#4		; start of offsets
ge16
	FNLDR	R2,scn_xos		; screen width

	LDR	R0,[R3]
	MUL	R0,R2,R0
	MOV	R0,R0,ASR#16
	STR	R0,[R1]

	LDR	R0,[R3,#8]
	MUL	R0,R2,R0
	MOV	R0,R0,ASR #16
	STR	R0,[R1,#8]

	FNLDR	R2,scn_yos

	LDR	R0,[R3,#4]
	MUL	R0,R2,R0
	MOV	R0,R0,ASR #16
	STR	R0,[R1,#4]

	LDR	R0,[R3,#12]
	MUL	R0,R2,R0
	MOV	R0,R0,ASR #16
	STR	R0,[R1,#12]

	FNRTS
ge_d0
	DCD	&2999
	DCD	&4800
	DCD	&D000
	DCD	&C800



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONVERT LINE NUMBER TO TEXT OFFSET & VICA VERSA	     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=phy ln R8/R9 (uses e_clnphy)
;X R0=file off R1=log ln # (R0/R1 off end of file o/w)
	FNAME	cln_phy
cln_phy
	FNJSR	"R11"
	MOV	R11,#e_clnphy
	BL	call_mode
	FNRTS

;E R0=log ln R8/R9 (uses e_clnlog)
;X R0=file off R1=phy ln # (R0/R1 off end of file o/w)
	FNAME	cln_log
cln_log
	FNJSR	"R11"
	MOV	R11,#e_clnlog
	BL	call_mode
	FNRTS

;E R0=file off R8/R9 (uses e_clnoff)
;X R0=phy ln R1=file off of phy line R2=log ln # (if R0 off end of file
; then vals set to an 'imaginary' char at end of file)
	FNAME	cln_off
cln_off
	FNJSR	"R11"
	MOV	R11,#e_clnoff
	BL	call_mode
	FNRTS


	LOCAL

;E R8/R9
;X R0=length of longest logical line in file less than w_bpl #
	FNAME	cln_count
cln_count
	FNJSR	"R1-R11"
	MOV	R2,R9
	LDR	R3,[R8,#w_bpl]
	LDR	R4,[R8,#w_tabc]
	LDR	R5,[R8,#w_cr]		; set up standard vars
	MOV	R6,#0
	MOV	R7,#0
	MOV	R9,#0			; start of text
	MOV	R10,#0			; longest phy line
a$l
	BL	cln_FORWARD		; move forward a phy line
	BVS	fileend$l
	CMP	R8,R10
	MOVHI	R10,R8			; update longest line
	CMP	R10,R3
	BCC	a$l			; if still less than max then loop
	B	end$l
fileend$l
	CMP	R8,R10			; clears the V flag
	MOVHI	R10,R8			; special case of last line with no 0A
end$l
	MOV	R0,R10			; longest line
	FNRTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONVERT LINE NUMBER FOR CURSOR POSITIONING		      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=file off of line R1=file off R8/R9 (uses e_lineoff)
;X R0=col offset (exc margin) on screen R1=caret width #
	FNAME	cln_lineoff
cln_lineoff
	FNJSR	"R11"
	MOV	R11,#e_lineoff
	BL	call_mode
	FNRTS

;E R0=file off of line R1=screen col (exc margin) R8/R9 (uses e_linecol)
;X R0=file off of nearest char (on or to left) #
	FNAME	cln_linecol
cln_linecol
	FNJSR	"R11"
	MOV	R11,#e_linecol
	BL	call_mode
	FNRTS

;E R0=file off R8/R9
;X R0=off of next word |
	FNAME	cln_txt_splus
cln_txt_splus
	FNJSR	"R1-R2"
	MOV	R1,R0
	BL	mode0_splus
	MOV	R0,R1
	FNRTS



;E R0=new display mode R8/R9 / R8=0 for main menu change
;X Display mode set to R0 #
	FNAME	new_mode
new_mode
	FNJSR	"R7-R11"
	MOV	R7,R0			; save new mode
	CMP	R7,#max_mode
	BLGE	err23
	FNRTS	VS
	ADD	R11,R12,#(mode_store+4):AND:&FF00
	ADD	R11,R11,#(mode_store+4):AND:&00FF ; start of list + 4
	LDR	R14,[R11,R7,LSL #3]
	CMP	R14,#0
	BLLE	err23			; no such mode
	FNRTS	VS
	TEQ	R8,#0
	FNLDRB  R10,opt_format,EQ
	BEQ	change_anyway$l
	LDRNEB  R10,[R8,#w_format]	; current mode
	TEQ	R10,R0
	FNRTS	EQ			; return if same mode
change_anyway$l
	MOV	R11,#e_end
	BL	call_mode		; inform old mode that we're changing mode
	BLVC	save_window_status	; save window status
	FNRTS	VS
	MOV	R10,R7			; new mode
	TEQ	R8,#0
	FNLDR	R0,opt_format+1,EQ
	LDRNE	R0,[R8,#w_format+1]	; get old format
	ORR	R0,R10,R0,LSL #8	; switch to new mode
	FNSTR	R0,opt_format,EQ
	STRNE	R0,[R8,#w_format]	; save new format
	BLNE	init_basemap		; select basemap
	MOV	R0,#1
	MOV	R11,#e_start
	BL	call_mode		; tell new mode to set up its options
	FNRTS	VS
	BL	checkforautosoftwrap	; check the file
	TEQ	R8,#0
	BLNE	create_title		; update title header data
	BLVC	new_window_status	; recreate window
	FNRTS


;E R1=mode number R8=window/0
;X R0=mode word
	FNAME	get_mode_word
get_mode_word
	FNJSR
	TEQ	R8,#0
	ADDEQ	R14,R12,#opt_modebase
	ADDNE	R14,R8,#w_mode0
	LDR	R0,[R14,R1,LSL #2]
	FNRTS

;E R0=word R1=mode number R8=window/0
	FNAME	put_mode_word
put_mode_word
	FNJSR
	TEQ	R8,#0
	ADDEQ	R14,R12,#opt_modebase
	ADDNE	R14,R8,#w_mode0
	STR	R0,[R14,R1,LSL #2]
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Colour handling					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R0=colour to write R1=mode number/-1 for all modes
; R2=zap colour number R8=window / 0 for default.
;X Colour written to all mode(s) #
	FNAME	mode_colour_all
mode_colour_all
	CMP	R1,#-1
	BNE	mode_colour		; just do the one colour
	FNJSR	"R1-R3"
	MOV	R1,#0			; current mode
	MOV	R3,R0			; save colour

a$l	MOV	R0,R3
	BL	mode_colour
	FNRTS	VS
	ADD	R1,R1,#1
	CMP	R1,#max_mode
	BCC	a$l
	FNRTS


	LOCAL

;E R1=service call number R2-R9=data
;X service call issued to all command tables #
	FNAME	issue_service
issue_service
	FNJSR	"R10-R11"
	FNLDR	R11,com_number		; number of command tables
	FNADD	R10,R12,command_store	; start of list
next$l
	CMP	R11,#0
	FNRTS	LE
	SUB	R11,R11,#1
	LDR	R0,[R10],#4		; get table address
	LDR	R14,[R0,#4]		; find the service call offset
	CMP	R14,#0
	BLE	next$l			; none
	PUSH	"R1"
	LDR	R1,[R0]			; find offset from module start
	SUB	R0,R0,R1		; address of module start
	PULL	"R1"
	ADD	R0,R0,R14		; offset of service call handler
	MOVS	R14,PC			; return address
	MOV	PC,R0			; call the service call
	BVC	next$l
	FNRTS


	LOCAL

;E R0=pointer to mode name terminated by <= spaces
;X R0=number of this mode / -1 if not found #
; (loads the mode if need be)
	FNAME	find_mode_number
find_mode_number
	FNJSR	"R1-R7,R10"
	MOV	R10,R0			; save mode name
	BL	test_mode_name		; is it already loaded?
	FNRTS	VS
	CMP	R0,#0
	FNRTS	GE			; yes
	MOV	R0,R10
	BL	find_ext_mode
	BEQ	tryclones$l
	LDR	R0,[R0,#-4]		; name of module to load
	BL	load_mode_module
	MOVVC	R0,R10
	BLVC	test_mode_name		; try again!
	FNRTS
tryclones$l				; warning: horrible
	MOV	R1,R10
	BL	find_clone_mode_entry
	TEQ	R0,#0
	MOVEQ	R0,#-1			; return if not found
	FNRTS	EQ
	MOV	R10,R1			; case-correct clone name
	BL	find_mode_number	; load the clone base mode (recursion!)
	FNRTS	VS
	TEQ	R0,#0
	FNRTS	MI			; return if failed to load the base mode
	MOV	R4,R0			; save base mode number
	BL	read_mode
	LDR	R3,[R0,#e_mode]
	TST	R3,#emode_MayBeCloned
	BEQ	notcloneable$l
	MOV	R3,R0			; unlinked table address
	MOV	R0,R10
	BL	find_config_block
	TEQ	R0,#0
	BNE	hasblock$l
noblock$l
	FNLDR	R6,wimp_config
	ORR	R0,R4,#1<<30
	LDR	R1,[R13]
	BL	write_config_block	; clone & no mode block -> make from base
	FNRTS	VS
hasblock$l
	MOV	R0,R10
	BL	str_len
	LDR	R1,[R3,#e_len]
	ADD	R0,R0,R1
	ADD	R0,R0,#1
	BL	heap_claim
	FNRTS	VS
	LDR	R1,[R3,#e_len]
copy$l  SUBS	R1,R1,#4		; copy the unlinked table
	LDR	R14,[R3,R1]
	STRNE	R14,[R0,R1]
	BNE	copy$l
	ADD	R14,R14,R0		; fiddle e_module
	SUB	R14,R14,R3
	STR	R14,[R0,#e_module]
	LDR	R1,[R0,#e_len]
	MOV	R2,R10
	ADD	R14,R14,R1
	ADD	R1,R1,R0
	STR	R14,[R0,#e_title]	; fiddle e_title
	PUSH	"R0"
	BL	strcopy			; copy the name
	PULL	"R0"
	BL	add_new_mode
	MOVVC	R1,R4
	BLVC	init_mode
	FNRTS	VS
	MOV	R0,R10
	BL	test_mode_name
	CMP	R0,#0
	MOVLT	R0,#-1
	FNRTS
notcloneable$l
	ADR	R0,badclonebase$l
	LDR	R4,[R1,#e_title*2]
	BL	lookup_error
	FNRTS
badclonebase$l
	&	0
	FNS	("zap_e_badclonebase")


	LOCAL

;E R0=pointer to a mode name terminated by <= space
;X R0=number of this mode if already loaded / -1 if not yet loaded #
	FNAME	test_mode_name
test_mode_name
	FNJSR	"R1-R10"
	MOV	R10,R0			; save mode name pointer
	ADD	R7,R12,#(mode_store+4):AND:&FF00
	ADD	R7,R7,#(mode_store+4):AND:&00FF ; start of list + 4
	MOV	R6,#0			; mode number
loop$l
	LDR	R0,[R7],#8		; load mode linked table
	CMP	R0,#0
	BLE	next$l			; no mode here
	MOV	R2,R10
	LDR	R1,[R0,#2*e_title]	; name of mode
	BL	strCMPstr		; case insensitive
	BNE	next$l			; no match
	LDRB	R0,[R0]			; character after the match
	CMP	R0,#&20
	BGT	next$l			; not a terminator
	MOV	R0,R6			; mode number
	FNRTS
next$l
	ADD	R6,R6,#1
	CMP	R6,#max_mode
	BCC	loop$l
	MOV	R0,#-1			; not found
	FNRTS


	LOCAL

;E R0=mode name
;X R0=pointer to next mode in external list, ie. [R0,#-4]=module name
;    or 0 (+EQ) if not found
	FNAME	find_ext_mode
find_ext_mode
	FNJSR	"R1-R5"
	MOV	R5,R0
	FNLDR	R4,ext_modes		; list of externally stored modes
loop$l  LDR	R0,[R4]
	TEQ	R0,#0
	FNRTS	EQ			; reached end of ext_modes list
	MOV	R0,R4
	BL	str_len			; get length of string
	MOV	R1,R4			; string pointer
	MOV	R2,R5			; mode name being searched for
	ADD	R4,R4,R0
	ADD	R4,R4,#12
	BIC	R4,R4,#3		; skip terminator and pointer
	BL	strCMPstr
	BNE	loop$l			; doesn't match start
	LDRB	R0,[R0]
	CMP	R0,#'!'
	BHS	loop$l			; didn't match
	MOV	R0,R4
	FNRTS


	LOCAL

;E R0=address of the module's start ('s name??)
; The module /may/ not be present... if so this routine /should/ try to
; fail gracefully.
;X Module is killed WB #
	FNAME	kill_module
kill_module
	FNJSR	"R1-R2"
	LDR	R1,[R0,#&10]		; offset of module title
	ADD	R2,R0,R1		; address of module title
	FNLDR	R1,wimp_block
	BL	strcopy			; copy name to wimp block
	MOV	R0,#4			; (so don't get any crashes!!)
	FNLDR	R1,wimp_block
	SWI	XOS_Module		; kill the module
	SUBS	R14,R14,R14		; clv...
	FNRTS


;E R0=address of the module
;X Module kill list is set up... WB #
	FNAME	init_kill_list
init_kill_list
	FNJSR	"R1-R2"
	FNLDR	R1,wimp_block
	MOV	R2,#-1
	STR	R2,[R1,#&40]
	FNRTS


;E R0=address of the module
;X Module is added to kill list... WB #
	FNAME	add_to_kill_list
add_to_kill_list
	FNJSR	"R1-R2"
	FNLDR	R1,wimp_block
	ADD	R1,R1,#&40
loop$l
	LDR	R2,[R1],#4
	CMP	R2,R0
	FNRTS	EQ
	CMP	R2,#-1
	BNE	loop$l
	STR	R0,[R1,#-4]
	MOV	R2,#-1
	STR	R2,[R1]
	FNRTS


;E R0=address of the module
;X Module is added to kill list...
	FNAME	kill_if_on_kill_list
kill_if_on_kill_list
	FNJSR	"R1"
	FNLDR	R1,wimp_block
	ADD	R1,R1,#&40
loop2$l
	LDR	R0,[R1],#4
	CMP	R0,#-1
	FNRTS	EQ
	BL	kill_module
	B	loop2$l


	LOCAL

;E R8=window/0 for options
;X Set up wimp_format/wimp_flags (restore mode word) #
	FNAME	modes_start
modes_start
	FNJSR	"R1-R7"
	TEQ	R8,#0
	FNLDRB  R1,opt_format,EQ
	LDRNEB  R1,[R8,#w_format]	; mode number
	MVN	R0,#0			; read
	MOV	R2,#0
	BL	mode_data
	MOV	R3,R0			; R3 = mode word 0
	MVN	R0,#0			; read
	MOV	R2,#1
	BL	mode_data
	MOV	R2,R0			; R2 = mode word 1
	; w_flags
	TEQ	R8,#0
	FNLDR	R0,opt_flags,EQ
	LDRNE	R0,[R8,#w_flags]
	LDR	R1,wflags_mask$l
	BIC	R0,R0,R1
	TST	R3,#1<<17
	ORRNE	R0,R0,#flags_AutoWidth
	AND	R1,R3,#7<<19
	ORR	R0,R0,R1,LSR #10	; tab mode bits
	TST	R3,#1<<22
	ORRNE	R0,R0,#flags_HexEntry
	TST	R3,#1<<23
	ORRNE	R0,R0,#flags_InsertMode
	TST	R2,#1<<12
	ORRNE	R0,R0,#flags_LineWrap
	TST	R2,#1<<13
	ORRNE	R0,R0,#flags_WordWrap
	TEQ	R8,#0
	FNSTR	R0,opt_flags,EQ
	STRNE	R0,[R8,#w_flags]
	; w_format
	TEQ	R8,#0
	FNLDR	R0,opt_format,EQ
	LDRNE	R0,[R8,#w_format]
	LDR	R1,wformat_mask$l
	BIC	R0,R0,R1
	AND	R1,R3,#1<<16:OR:1<<18	; auto indent, strip spaces
	ORR	R0,R0,R1
	AND	R1,R3,#&FF<<24
	ORR	R0,R0,R1,LSR #16	; line nos, line edit, tab entry, non std
	TST	R2,#1<<8
	ORRNE	R0,R0,#format_BigEndian
	AND	R1,R2,#&7F<<21
	ORR	R0,R0,R1		; mouse clicks, wrap type, cursor control
	TEQ	R8,#0
	FNSTR	R0,opt_format,EQ
	STRNE	R0,[R8,#w_format]
	; w_info
	MOV	R1,R2,LSL #(32-11)	; line no. width, colon, font substyles,
	BIC	R1,R1,#1<<8		; infinite wrap, line select, spell,
	MOV	R0,R1,LSR #(32-11)	; strong softwrap, block edit
	ORR	R0,R0,R2,LSR #16	; buttons bits
	FNSTR	R0,opt_info,EQ
	STRNE	R0,[R8,#w_info]
	FNRTS


wflags_mask$l
	&	flags_AutoWidth:OR:flags_TabMode:OR:flags_InsertTabsAsSpaces:OR:flags_HexEntry:OR:flags_InsertMode:OR:flags_LineWrap:OR:flags_WordWrap

TEMP_WFORMAT_1  *	format_AutoIndent:OR:format_StripSpaces:OR:format_ShowLineNumbers:OR:format_LinesAreLines:OR:format_LinesBase:OR:format_LinesPhysical
TEMP_WFORMAT_2  *	format_TabDisplayFormat:OR:format_LineOrStreamEdit:OR:format_NonStandardEdit
TEMP_WFORMAT_3  *	format_BigEndian:OR:format_CursorFreeClick:OR:format_AutoSoftWrap:OR:format_CursorConfineV:OR:format_CursorConfineRight
TEMP_WFORMAT_4  *	format_CursorSmart:OR:format_WindowWrap:OR:format_SoftWrap

wformat_mask$l
	&	TEMP_WFORMAT_1:OR:TEMP_WFORMAT_2:OR:TEMP_WFORMAT_3:OR:TEMP_WFORMAT_4


;E R8=window/0 for options
;X Saved the current options in flags/format (save_mode_word) #
	FNAME	modes_end
modes_end
	FNJSR	"R1-R5"
	TEQ	R8,#0
	FNLDR	R3,opt_flags,EQ
	LDRNE	R3,[R8,#w_flags]	; R3 = flags
	FNLDR	R4,opt_format,EQ
	LDRNE	R4,[R8,#w_format]	; R4 = format
	FNLDR	R5,opt_info,EQ
	LDRNE	R5,[R8,#w_info]		; R5 = info
	; mode word 0
	MOV	R0,#-1			; read
	AND	R1,R4,#255		; R1 = mode
	MOV	R2,#0			; word 0
	BL	mode_data
	MOV	R0,R0,LSL #16		; clear top 16 bits
	AND	R14,R4,#format_AutoIndent:OR:format_StripSpaces
	ORR	R0,R14,R0,LSR #16
	TST	R3,#flags_AutoWidth
	ORRNE	R0,R0,#1<<17
	AND	R14,R3,#flags_TabMode:OR:flags_InsertTabsAsSpaces
	ORR	R0,R0,R14,LSL #10
	TST	R3,#flags_HexEntry
	ORRNE	R0,R0,#1<<22
	TST	R3,#flags_InsertMode
	ORRNE	R0,R0,#1<<23
	AND	R14,R4,#&FF00		; display bits of w_format
	ORR	R0,R0,R14,LSL #16
	BL	mode_data		; write
	; mode word 1
	MOV	R0,R5,LSL #(32-11)
	MOV	R0,R0,LSR #(32-11)
	BIC	R0,R0,#1<<8
	TST	R4,#format_BigEndian
	ORRNE	R0,R0,#1<<8
	TST	R3,#flags_LineWrap
	ORRNE	R0,R0,#1<<12
	TST	R3,#flags_WordWrap
	ORRNE	R0,R0,#1<<13
	AND	R14,R4,#&7F<<21		; mouse clicks, wrap type, cursor control
	ORR	R0,R0,R14
	AND	R14,R5,#&F<<12		; buttons bits
	ORR	R0,R0,R14,LSL #16
	MOV	R2,#1
	BL	mode_data
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Zap handled mode data						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; opt_modedata and w_modedata point to a block of Zap hals )
; Blocks are stored in the Config file by having a -1 terminating the list of
; mode data words so you know how long it is.

;E R0=value to write / -1 to read
; R1=mode number R2=variable number R8=window/0
;X R0=value read/old value
	FNAME	mode_data
mode_data				; read/write a mode data value
	FNJSR	"R1-R2"
	TEQ	R8,#0
	LDRNE	R14,[R8,#w_modedata]
	FNLDR	R14,opt_modedata,EQ	; pointer to the list
	LDR	R1,[R14,R1,LSL #2]	; pointer to data for this mode
	ADD	R1,R1,#4		; address of mode data word 0
	LDR	R14,[R1,R2,LSL #2]	; old value
	CMP	R0,#-1
	STRNE	R0,[R1,R2,LSL #2]	; new value
	MOV	R0,R14			; old value
	FNRTS


	LOCAL

;E R0=colour to write / -1 to read
;    b0-b7=0-15 => write this wimp colour number
;    b0-b7>15	=> write this word (with 24 bit colour and Zap style)
; R1=mode number
; R2=Zap colour number R8=window / 0 for default.
;X R0=old value, -1 if mode doesn't exist WB #
	FNAME	mode_colour
mode_colour				; read/write colour & style
	FNJSR	"R1-R3"
	TEQ	R8,#0
	LDRNE	R14,[R8,#w_modedata]
	FNLDR	R14,opt_modedata,EQ	; pointer to the list
	LDR	R1,[R14,R1,LSL #2]	; pointer to data for this mode
	CMP	R1,#0
	MOVLE	R0,#-1
	FNRTS	LE			; doesn't exist (eg mode_colour_all)
	LDR	R14,[R1]		; length word
	ADD	R2,R2,R14,LSR #24	; number of data words to skip
	MOV	R2,R2,LSL#2		; num of bytes to skip
	ADD	R2,R2,#4		; total offset
	BIC	R14,R14,#&FF000000	; total length of the block
	CMP	R2,R14
	BLCS	err$l			; off end of block
	FNRTS	VS
	ADD	R3,R1,R2		; pointer to the word
	LDR	R2,[R3]			; read the old value
	CMP	R0,#-1
	MOVEQ	R0,R2
	FNRTS	EQ			; just reading it
	ANDS	R14,R0,#&FF
	CMP	R14,#&10
	BCS	a$l
	FNLDR	R1,wimp_block
	SWI	XWimp_ReadPalette	; read the palette
	FNRTS	VS
	AND	R0,R0,#&FF
	LDR	R0,[R1,R0,LSL #2]	; get the palette entry &BxGxRxxx
	LDR	R14,d$l
	AND	R0,R0,R14
	ORR	R0,R0,R0,LSR #4		; duplicate the nibble
	ORR	R0,R0,#&10		; base style

a$l	STR	R0,[R3]			; R0=24 bit palette entry to write
	MOV	R0,R2			; old value
	FNRTS

err$l	ERR	"zap_e_badcolrnum"
d$l	DCD	&F0F0F000


	LOCAL

;E R0=number of colours/-1 to read R1=mode number R8=window/0 for options
;X R0=old value / read value
; Number of colours available for a given mode in the palette is
; read/written. If opt mode block not available on reading then length of
; menu list is used as a default.
; (colours not given default values)
	FNAME	mode_colour_num
mode_colour_num
	FNJSR	"R1-R5,R10-R11"
	TEQ	R8,#0
	LDRNE	R3,[R8,#w_modedata]
	FNLDR	R3,opt_modedata,EQ	; pointer to the list
	MOV	R10,R1			; save the mode number
	LDR	R1,[R3,R1,LSL #2]!	; pointer to the data for this mode
	CMP	R1,#0
	BLE	def$l			; not available - use default
	LDR	R2,[R1]			; length word
	MOV	R4,R2,LSR #22		; length of modedata stuff
	ADD	R4,R4,#4		; with word at start
	BIC	R2,R2,#&FF000000	; total block length
	SUB	R2,R2,R4		; colour data length
	CMP	R0,#-1
	BEQ	a$l
	MOV	R0,R0,LSL #2		; new length of colour data
	SUB	R5,R0,R2		; change in length
	LDR	R0,[R1]
	ADD	R0,R0,R5
	STR	R0,[R1]			; undate length word
	MOV	R0,R1			; heap_block
	MOV	R1,R5			; signed change
	BL	heap_extend		; change the size
	FNRTS	VS
	STR	R0,[R3]			; new block pointer
a$l	MOV	R0,R2,LSR #2		; old number of colours
	FNRTS

def$l	CMP	R0,#-1			; use default
	TEQEQ	R8,#0
	BLNE	err$l			; only accept read of options size
	MOVVC	R1,#6
	MOVVC	R11,#e_init
	BLVC	call_given_mode
	FNRTS	VS
	MOV	R0,#9			; standard 9 Zap colours
	CMP	R1,#&8000
	FNRTS	LT

b$l	LDRB	R14,[R1],#1		; count loop
	TEQ	R14,#0
	FNRTS	EQ
	ADD	R0,R0,#1		; got a new colour
c$l	LDRB	R14,[R1],#1
	TEQ	R14,#0
	BNE	c$l
	B	b$l

err$l	ERR	"zap_e_badcolrblk"


	LOCAL

;E R0=source mode data block pointer (eg opt_modedata)
;X R0=duplicated block (eg to put in w_modedata on a new view/window)
	FNAME	create_modedata
create_modedata
	FNJSR	"R1-R5"
	MOV	R1,R0			; source block pointer
	MOV	R5,#max_mode		; number of modes to do
	MOV	R0,R5,LSL #2
	BL	heap_claim
	FNRTS	VS
	MOV	R2,R0			; destination block pointer
a$l					; mode loop
	SUBS	R5,R5,#1		; next mode
	MOVMI	R0,R2
	FNRTS	MI			; finished
	MOV	R0,R5
	BL	create_modedata_block
	BVC	a$l
	FNRTS


;E R0=mode number
;  R1=source mode data block pointer (eg opt_modedata)
;  R2=destination mode data pointer (eg w_modedata)
;X Block for this mode copied if it was valid #
;  Zero/-ve value copied if it wasn't valid
	FNAME	create_modedata_block
create_modedata_block
	FNJSR	"R1-R3"
	LDR	R1,[R1,R0,LSL #2]	; address of source block
	ADD	R2,R2,R0,LSL #2		; address of pointer of dest block
	CMP	R1,#0
	STRLE	R1,[R2]			; clear dest pointer in this case! (freeing)
	FNRTS	LE			; source mode absent/not valid
	LDR	R3,[R1]			; block sizes
	BIC	R3,R3,#&FF000000	; total block size
	MOV	R0,R3
	BL	heap_claim
	STRVC	R0,[R2]			; save the destination block
	MOVVC	R2,R0
	SWIVC	XZapRedraw_MoveBytes	; copy the block
	FNRTS


	LOCAL

;E R8=mode R9=start of Zap (config) block for this mode R10=length (!(R9-4))
;  Unsupported options blocks must be 0
;X Options block read and stored (WB used for palette)
;  Unsupported options have default values inserted.
;  NB Old format block used in default file also so must be supported
	FNAME	read_conf_mode_data
read_conf_mode_data
	FNJSR	"R1-R5,R9-R10"
	MOV	R3,#defend$l-default$l  ; length of default mode data block
	TEQ	R10,#12
	BEQ	old$l			; old format
	MOV	R1,R9
a$l
	LDR	R0,[R1],#4
	CMP	R0,#-1
	BNE	a$l			; count the number of mode words
	SUB	R4,R1,R9		; size of mode data part (inc the -1)
	SUB	R10,R10,R4		; size of colour data
	ADD	R0,R10,R3		; size of all data
	ADD	R0,R0,#4		; with size word
	ADD	R2,R0,R3,LSL #22	; length + num of words << 24
	BL	heap_claim		; claim the block
	FNRTS	VS
	MOV	R4,R0			; save the block start
	STR	R2,[R0],#4		; write length word
	MOV	R2,R0			; dest
	ADR	R1,default$l		; shadow source
	PUSH	"R2"
b$l
	LDR	R0,[R9]
	CMP	R0,#-1
	LDREQ	R0,[R1],#4
	ADDNE	R9,R9,#4
	ADDNE	R1,R1,#4
	STR	R0,[R2],#4
	SUBS	R3,R3,#4
	BGT	b$l			; still more to do
	PULL	"R1"
	LDR	R0,[R1,#8]		; mode data variable 2
	TST	R0,#&FF000000		; number of colours == 0?
	ANDEQ	R0,R0,#&FF		; if so, set these defaults:
	ORREQ	R0,R0,#&10000		; display block = 0, printer block = 1
	ORREQ	R0,R0,R10,LSL #22	; number of colours exc. extra system colours
	STREQ	R0,[R1,#8]
clrd$l
	ADD	R1,R9,#4		; start of colour data
	MOV	R3,R10			; length of colour dta
	SWI	XZapRedraw_MoveBytes	; BL move_bytes			; copy the block
	B	end$l
old$l					; old format block (1word+16 nibbles)
	MOV	R0,#-1
	MOV	R1,R8
	PUSH	"R8"
	MOV	R8,#0
	BL	mode_colour_num		; R0=number of colours
	PULL	"R8"
	MOVVC	R10,R0,LSL #2		; save size of colour data
	ADDVC	R0,R10,R3		; size of all data
	ADDVC	R0,R0,#4		; with size word
	ADDVC	R2,R0,R3,LSL #22	; length + num of words << 24
	BLVC	heap_claim		; claim the block
	FNRTS	VS
	MOV	R4,R0			; save the block start
	STR	R2,[R0],#4		; write length word
	MOV	R2,R0			; dest
	LDR	R0,[R9],#4
	STR	R0,[R2],#4		; write the first mode data word
	ADR	R1,default$l+4		; start of rest of data
c$l
	SUBS	R3,R3,#4
	LDRGT	R0,[R1],#4
	STRGT	R0,[R2],#4
	BGT	c$l
	FNLDR	R1,wimp_block
	SWI	XWimp_ReadPalette	; read palette to R1
	FNRTS	VS
	LDMIA	R9,{R3,R5}		; get the colour nibbles
	LDR	R9,mask$l
d$l
	AND	R0,R3,#&F		; wimp colour number
	LDR	R0,[R1,R0,LSL #2]	; palette entry
	AND	R0,R0,R9
	ORR	R0,R0,R0,LSR #4
	ORR	R0,R0,#&10
	STR	R0,[R2],#4
	MOV	R3,R3,LSR #4
	ORR	R3,R3,R5,LSL #28
	MOV	R5,R5,LSR #4
	SUBS	R10,R10,#4
	BGT	d$l
end$l					; R4=pointer to the block R8=mode num
	FNLDR	R0,opt_modedata
	STR	R4,[R0,R8,LSL #2]	; save the block pointer
	FNRTS
mask$l  DCD	&F0F0F000
default$l				; default mode data words
	DCD	77+&12010000		; text default vals
	DCD	(1 << 25) + &F		; second mode word ! TT b25 = smart curs (1<<22=ASW)
	DCD	0			; bottom byte -> basemap; rest unused
	DCD	0			; <- unused (kludge to get round 12-byte old format)
defend$l				; length is current size of mode data's.

	LOCAL

;E R1=mode number R8/R9=file
;X mode data copied to make it default if the mode exists.
	FNAME	make_default_mode
make_default_mode
	FNJSR	"R1-R3"
	FNLDR	R3,opt_modedata
	LDR	R3,[R3,R1,LSL#2]
	CMP	R3,#0
	FNRTS	LE			; no mode there
	LDR	R3,[R3]
	MOV	R2,R3,LSR#24		; number of mode data words
a$l
	SUBS	R2,R2,#1		; mode data word number
	BMI	b$l
	MOV	R0,#-1
	BL	mode_data		; read
	FNRTS	VS
	PUSH	"R8"
	MOV	R8,#0
	BL	mode_data		; write
	PULL	"R8"
	BVC	a$l
	FNRTS
b$l
	MOV	R0,#-1
	BL	mode_colour_num
	FNRTS	VS
	MOV	R2,R0			; number of colour in window
	MOV	R0,#-1
	PUSH	"R8"
	MOV	R8,#0
	BL	mode_colour_num		; number of colours in options
	PULL	"R8"
	FNRTS	VS
	CMP	R0,R2
	MOVLT	R2,R0			; R2=min of the two
c$l
	SUBS	R2,R2,#1		; mode colour number
	FNRTS	MI
	MOV	R0,#-1
	BL	mode_colour		; read
	FNRTS	VS
	PUSH	"R8"
	MOV	R8,#0
	BL	mode_colour		; write
	PULL	"R8"
	BVC	c$l
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Text alteration on saving/loading				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R1 => 0=file just loaded 1=after a save R8/R9
;  First checks for DOS/SPOOL type file etc then calls mode's e_postload
	FNAME	post_load
post_load
	FNJSR	"R1-R2,R11"		; Beware - explicit pull of R1
	TEQ	R1,#0
	BNE	save$l			; after a save
	FNLDR	R0,opt_switches		; start testing on a new file/window
	TST	R0,#switch_TrapCRLF
	BEQ	a$l			; test for DOS flag not set
	LDRB	R0,[R8,#w_format]	; mode
	BL	read_mode
	LDR	R0,[R1,#2*e_mode]	; mode num + flags
	TST	R0,#1<<11
	BNE	a$l			; it's not a textual mode
	LDR	R0,[R9,#f_len]
	MOV	R1,#0
	BL	split_buffer		; split at end (is after a load anyway)
	FNRTS	VS
	LDR	R1,[R9,#f_ptr]		; file start (file can't move on testing)
	LDR	R11,[R9,#f_len]
	ADD	R11,R1,R11		; file end
	MOV	R2,#0			; flags b0=CRLF (Dos) b1=LFCR (Spool)

b$l	CMP	R1,R11			; file check loop
	BCS	c$l			; run out of file
	LDRB	R0,[R1],#1
	TEQ	R0,#&09
	TEQNE	R0,#&0C			; form-feed...?
	TEQNE	R0,#&1B			; seems to be in some DOS text files...
	BEQ	b$l			; allow tabs
	TEQ	R0,#&0A
	BEQ	lf$l
	TEQ	R0,#&0D			; line terminator?
	BEQ	d$l			; check it out
	CMP	R0,#&20
	BCC	u$l			; unacceptable control code
	TEQ	R0,#&7F
	BNE	b$l			; valid ASCII character (LE?)
	B	a$l			; no good

u$l	CMP	R1,R11			; control code
	BCC	a$l			; hadn't reached file end so no good
	TEQ	R0,#&1A			; early DOS terminating character?
	BEQ	c$l
	B	a$l
					; not a DOS file
d$l	TST	R2,#2			; found a CR
	BNE	a$l			; already thought it was a spool file
	CMP	R1,R11
	BCS	a$l			; not followed by a LF
	LDRB	R0,[R1],#1
	TEQ	R0,#&0A
	BNE	a$l
	ORR	R2,R2,#1		; found a valid DOS line ending
	B	b$l

lf$l	TST	R2,#1
	BNE	a$l			; already thought it was a DOS file
	CMP	R1,R11
	BCS	a$l			; not followed by a CR
	LDRB	R0,[R1],#1
	TEQ	R0,#&0D
	BNE	a$l			; Hmm...
	ORR	R2,R2,#2		; found a valid SPOOL line ending
	B	b$l
c$l					; file passed as a dos file
	ANDS	R14,R2,#3		; found a line ending?
	BLNE	dos_to_text		; if so then convert the file
	FNRTS	VS

a$l	LDMFD	R13,{R1}		; DOS status calculated and stored
	MOV	R11,#e_postload		; get back the status word
	BL	call_mode
	FNRTS

save$l					; after a save
	MOV	R2,#0
	LDR	R0,[R9,#f_flags]
	TST	R0,#1<<27
	ORRNE	R2,R2,#1		; DOS file
	TST	R0,#1<<29
	ORRNE	R2,R2,#2		; Spool file
	TEQ	R2,#0
	BEQ	a$l			; not a special file
	LDR	R0,[R9,#f_len]
	MOV	R1,#0
	BL	split_buffer
	BLVC	dos_to_text		; convert back again
	BVC	a$l
	FNRTS


;E R8/R9
;  First strips spaces or tabs if asked to do so
;  Then calls modes e_presave
;  Finally replaces LF by CRLF/LFCR if the file is marked as a DOS/Spool
	FNAME	pre_save
pre_save
	FNJSR	"R11"
	LDR	R0,[R8,#w_format]
	TST	R0,#1<<18		; space stripping
	MOVNE	R0,#3
	BLNE	strip_spaces
	MOVVC	R11,#e_presave
	BLVC	call_mode
	FNRTS	VS
	LDR	R11,[R9,#f_flags]
	TST	R11,#(1<<27)+(1<<29)
	BLNE	text_to_dos
	FNRTS

	FNAME	checkforautosoftwrap
checkforautosoftwrap
	CMP	R8,#0
	MOVEQ	PC,R14
	FNJSR	"R0-R12"
	LDR	R0,[R8,#w_format]	; format
	TST	R0,#format_AutoSoftWrap
	FNRTS	EQ
	LDRB	R0,[R8,#w_format]	; mode
	BL	read_mode
	LDR	R0,[R1,#2*e_mode]	; mode num + flags
	TST	R0,#emode_BinaryMode
	FNRTS	NE			; it's not a textual mode
	MOV	R0,#einterrogate_SoftWrap ; sw?
	MOV	R11,#e_interrogate
	BL	call_mode
	CMP	R0,#einterrogate_SoftWrap
	FNRTS	NE
	LDR	R0,[R8,#w_format]	; format
	BIC	R0,R0,#format_SoftWrap
	STR	R0,[R8,#w_format]	; find the bit
	LDR	R1,[R9,#f_ptr]		; file start (file can't move on testing)
	LDR	R3,[R9,#f_len]
	ADD	R3,R1,R3		; file end
	LDRB	R4,[R8,#w_cr]
a2$l
	MOV	R2,#0			; length of line ...
b2$l					; file check loop
	LDRB	R0,[R1],#1

	TEQ	R0,R4
	BEQ	lf2$l			; found a line end

	MOV	R14,R0,LSR #4
	TEQ	R14,#1			; test for control character (16-31)
	FNRTS	EQ			; if found then *no* softwrap

	ADD	R2,R2,#1
	CMP	R1,R3
	BCC	b2$l			; no good

	CMP	R2,#100
	BCS	d2$l			; check last line in file
	FNRTS

lf2$l
	CMP	R2,#100
	BCC	a2$l
d2$l
	LDR	R0,[R8,#w_format]	; find the bit
	ORR	R0,R0,#format_SoftWrap
	STR	R0,[R8,#w_format]	; find the bit
	LDR	R0,[R8,#w_flags]	; find the bit
	BIC	R0,R0,#flags_LineWrap	; clear line wrap
	STR	R0,[R8,#w_flags]	; find the bit
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DOS file convertion					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R2=file type b0=>Dos b1=>Spool
; R8/R9 R9=Coagulated valid file of above type
;X Dos/Spool flag set and & CR's removed #
	FNAME	dos_to_text
dos_to_text
	FNJSR	"R1-R6"
	LDR	R0,[R9,#f_flags]
	TST	R2,#1
	ORRNE	R0,R0,#1<<27		; mark as a dos file
	TST	R2,#2
	ORRNE	R0,R0,#1<<29		; mark as a spool file
	STR	R0,[R9,#f_flags]
	LDR	R4,[R9,#f_ptr]		; start (of current line)
	LDR	R5,[R9,#f_len]
	ADD	R5,R4,R5		; end (of file)
	MOV	R6,R4			; destination
newline$l
	MOV	R1,R4			; save start of line (source)
a$l
	CMP	R4,R5
	BCS	end$l
	LDRB	R0,[R4],#1
	TEQ	R0,#&0D
	BNE	a$l			; find next CR
	MOV	R2,R6			; dest
	SUB	R3,R4,R1
	SUB	R3,R3,#1		; length excluding CR
	ADD	R6,R6,R3		; new dest
	SWI	XZapRedraw_MoveBytes	; shift the line
	B	newline$l
end$l
	MOV	R2,R6			; dest
	SUBS	R3,R5,R1		; length to move
	ADDNE	R6,R6,R3		; new dest
	SWINE	XZapRedraw_MoveBytes	; shift the last bit of file
	LDR	R0,[R9,#f_ptr]
	SUB	R6,R6,R0
	STR	R6,[R9,#f_len]
	STR	R6,[R9,#f_splito]
	LDR	R0,[R9,#f_splite]	; same as buffer length
	SUB	R0,R0,R6
	STR	R0,[R9,#f_splits]
	FNRTS
	LOCAL

;E R8/R9 ordinary text file R11=file flags
;X CR inserted before every LF if a DOS file
; CR inserted after every LF if a spool file
	FNAME	text_to_dos
text_to_dos
	FNJSR	"R1-R7"
	MOV	R6,#0
	BL	read$l			; split at offset 0 in the file
	FNRTS	VS			; R4=start R5=end R6=dest R7=splits
newline$l
	MOV	R1,R4			; save start of line (source)
a$l
	CMP	R4,R5
	BCS	end$l
	LDRB	R0,[R4],#1
	TEQ	R0,#&0A
	BNE	a$l			; find next LF
	MOV	R2,R6			; dest
	SUB	R3,R4,R1
	SUB	R3,R3,#1		; length excluding LF
	ADD	R6,R6,R3		; new dest
	SWI	XZapRedraw_MoveBytes	; shift the line
	TST	R11,#1<<27		; DOS file?
	MOV	R0,#&0D
	MOV	R14,#&0A
	STRNEB  R0,[R6],#1
	STRB	R14,[R6],#1		; add DOS ending
	STREQB  R0,[R6],#1		; add spool ending
	SUBS	R7,R7,#1		; one less free byte
	BGT	newline$l		; still got bytes free
	BL	write$l
	BL	read$l			; ensure more split
	BVC	newline$l
	FNRTS
end$l
	MOV	R2,R6			; dest
	SUBS	R3,R5,R1		; length to move
	ADDNE	R6,R6,R3		; new dest
	SWINE	XZapRedraw_MoveBytes	; shift the last bit of file
	BL	write$l			; write new file extent etc
	FNRTS
read$l					; R6=split off -> R4-R7 space ensured
	FNJSR
	MOV	R0,R6
	MOV	R1,#file_size		; default free space
	BL	split_buffer		; split buffer at this offset
	LDRVC	R0,[R9,#f_ptr]		; start of the buffer
	ADDVC	R6,R0,R6		; destination
	LDRVC	R7,[R9,#f_splits]	; amount free in split
	ADDVC	R4,R6,R7		; start of the second half of file
	LDRVC	R5,[R9,#f_bufl]
	ADDVC	R5,R0,R5		; end (of file and buffer)
	FNRTS
write$l					; write R4-R6 as new values -> R6=split off
	SUB	R5,R5,R4		; amount left in second half of split
	LDR	R0,[R9,#f_ptr]
	SUB	R6,R6,R0
	STR	R6,[R9,#f_splito]
	SUB	R4,R4,R0
	STR	R4,[R9,#f_splite]
	SUB	R0,R4,R6
	STR	R0,[R9,#f_splits]
	ADD	R0,R5,R6
	STR	R0,[R9,#f_len]
	MOV	PC,R14

loaddisasmwithcare
	FNJSR	"R0,R1"
	FNLDR	R14,opt_switches
	TST	R14,#switch_Autoload_disassembler
	FNRTS	EQ
	BL	checkseeifdisasmloaded
	FNRTS	VC
	ADR	R0,disasmpath
	SWI	XWimp_StartTask
	SUBS	R14,R14,R14
	FNRTS

loaddisasm
	FNJSR	"R0,R1"
	FNLDR	R14,opt_switches
	TST	R14,#switch_Autoload_disassembler
	FNRTS	EQ
	BL	checkseeifdisasmloaded
	FNRTS	VC
	ADR	R0,disasmpath
	SWI	XWimp_StartTask
	BL	redrawallcodemodewindows
	SUBS	R14,R14,R14
	FNRTS

loadamodulefromname			; do nothing if V clear...
	SWIVS	XWimp_StartTask
	SUBS	R14,R14,R14
	FNRTS

loadlineeditor
	FNJSR	"R0,R1"
	FNLDR	R14,opt_switches
	TST	R14,#switch_Autoload_lineeditor
	FNRTS	EQ
	BL	checkseeiflineeditorloaded
	ADRVS	R0,lineeditorpath
	B	loadamodulefromname

loadiclear
	FNJSR	"R0,R1"
	FNLDR	R14,opt_switches
	TST	R14,#switch_Autoload_iclear
	FNRTS	EQ
	BL	checkseeificlearloaded
	ADRVS	R0,iclearpath
	B	loadamodulefromname

loadflashcar
	FNJSR	"R0,R1"
	FNLDR	R14,opt_switches
	TST	R14,#switch_Autoload_flashcar
	FNRTS	EQ
	BL	checkseeifflashcarloaded
	ADRVS	R0,flashcarpath
	B	loadamodulefromname

loadhidepointer
	FNJSR	"R0,R1"
	FNLDR	R14,opt_switches
	TST	R14,#switch_Autoload_hidepointer
	FNRTS	EQ
	BL	checkseeifhidepointerloaded
	ADRVS	R0,hidepointerpath
	B	loadamodulefromname

checkseeifdisasmloaded
	FNJSR	"R0-R5"
	ADR	R1,disasmnamed
	MOV	R0,#18
	SWI	XOS_Module
	FNRTS	VS
	BL	getmoduleversionnumber
	CMP	R0,#&200
	FNRTS	CS
	FNRTV

checkseeifflashcarloaded
	FNJSR	"R0-R5"
	ADR	R1,flashcarnamed
checkforamodulebyname
	MOV	R0,#18
	SWI	XOS_Module
	FNRTS

checkseeiflineeditorloaded
	FNJSR	"R0-R5"
	ADR	R1,lineeditornamed
	B	checkforamodulebyname

checkseeifFTEloaded
	FNJSR	"R0-R5"
	ADR	R1,FTEnamed
	B	checkforamodulebyname

checkseeificlearloaded
	FNJSR	"R0-R5"
	ADR	R1,iclearnamed
	B	checkforamodulebyname

checkseeifhidepointerloaded
	FNJSR	"R0-R5"
	ADR	R1,hidepointernamed
	B	checkforamodulebyname

getmoduleversionnumber			; e.g. 1.32 becomes &132 in R0.
	LDR	R0,[R3,#&14]
	ADD	R3,R3,R0
loop$l	LDRB	R0,[R3],#1
	CMP	R0,#'.'
	BNE	loop$l
	LDRB	R0,[R3,#-2]
	SUB	R2,R0,#'0'
	LDRB	R0,[R3],#1
	SUB	R1,R0,#'0'
	LDRB	R0,[R3],#1
	SUB	R0,R0,#'0'
	ADD	R0,R0,R1,LSL #4
	ADD	R0,R0,R2,LSL #8
	MOV	PC,R14


flashcarnamed	 FNS	("FlashCar")
disasmnamed	 FNS	("Debugger")
lineeditornamed	 FNS	("LineEditor")
hidepointernamed FNS	("HidePointer")
iclearnamed	 FNS	("IClear")
FTEnamed	 FNS	("FiletypeExtend")

disasmpath	 FNS	("Obey ZapExtensions:BootDisasm")
flashcarpath	 FNS	("Obey ZapExtensions:BootFlash")
lineeditorpath	 FNS	("Obey ZapExtensions:BootLineEd")
hidepointerpath  FNS	("Obey ZapExtensions:BootHide")
iclearpath	 FNS	("Obey ZapExtensions:BootIClear")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Filtering mode entry points				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL


; filter block
		^	0
ft_next		#	4		; next filter in chain
ft_code		#	4		; code to call
ft_private	#	4		; private word
ft_mode		#	4		; mode to filter
ft_length	*	@

; add a new filter
; E r0 = filter type:  0 = pre filter  1 = post filter
;   r1 -> code to call  r2 = private word  r3 = mode (-1 for all modes)  r4 = entry point
; X r0-r4 corrupt
; filter called before the mode with:
;   E  r0-r10 as on entry point  r11 = private word
;   X  r0-r10 updated  r11 == 0 => claim the entry
; filters are only called for Zap_CallMode, NOT CallGivenMode or BaseMode
	FNAME	add_filter
add_filter
	FNJSR	"R11"
	TEQ	R0,#0
	FNLDR	R11,pre_filters,EQ
	FNLDR	R11,post_filters,NE

	MOV	R0,#ft_length		; claim a new filter block
	BL	heap_claim
	STMVCIB	R0,{R1-R3}
	LDRVC	R2,[R11,R4]		; stick it at the head of the list
	STRVC	R2,[R0]
	STRVC	R0,[R11,R4]
	FNRTS


	LOCAL

; remove a filter
; E r0 = filter type:  0 = pre filter  1 = post filter
;   r1 -> code to call  r2 = private word  r3 = mode (-1 for all modes)  r4 = entry point
; X r0 corrupt
	FNAME	remove_filter
remove_filter
	FNJSR	"R7-R11"
	TEQ	R0,#0
	FNLDR	R11,pre_filters,EQ
	FNLDR	R11,post_filters,NE
	ADD	R7,R11,R4
	LDR	R11,[R11,R4]

loop$l	TEQ	R11,#0			; filter not found - maybe should be an error?
	FNRTS	EQ

	LDMIB	R11,{R8-R10}		; compare the spec
	TEQ	R8,R1
	TEQEQ	R9,R2
	TEQEQ	R10,R3
	MOVNE	R7,R11			; keep this filter
	LDRNE	R11,[R11]
	BNE	loop$l

	LDR	R0,[R11]		; remove it from the list
	STR	R0,[R7]
	MOV	R0,R11
	BL	heap_free
	FNRTS


	LOCAL

; call the pre-filters
; E as call_mode
; X EQ if entry point claimed, all registers preserved
	FNAME	call_pre_filters
call_pre_filters
	FNJSR	"R8-R11"		; save r9-r11 + 1 blank

	FNLDR	R10,pre_filters
	LDR	R10,[R10,R11]
	B	loop$l

; call the post-filters
; E as call_mode
; X all preserved
	FNAME	call_pre_filters
call_post_filters
	FNJSR	"R8-R11"		; save r9-r11 + 1 blank

	FNLDR	R10,post_filters
	LDR	R10,[R10,R11]

loop$l	LDRB	R9,[R8,#w_format]
loop2$l	TEQ	R10,#0			; no more?
	BEQ	nret$l

	LDR	R14,[R10,#ft_mode]	; check it's the right mode
	CMP	R14,#-1
	CMPNE	R14,R9
	LDRNE	R10,[R10]
	BNE	loop2$l

	LDR	R11,[R10,#ft_private]	; call it
	LDR	R14,[R10,#ft_code]
	STR	R10,[R13]		; keep filter block
	LDMIB	R13,{R9-R10}
	PUSH	"R14"
	MOV	R14,PC
	PULL	"PC"

	TEQ	R11,#0
	BEQ	ret$l

	LDR	R10,[R13]		; restore it
	LDR	R10,[R10]		; next
	B	loop$l

nret$l	CLRZ				; not claimed
ret$l	ADD	R13,R13,#4
	LDMFD	R13!,{R9-R11,PC}	; return




 END
