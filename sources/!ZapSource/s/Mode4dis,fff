; This file deals with 'clever' disassembly
; $Id: Mode4dis,fff,v 1.1.2.6 1999/03/18 09:36:20 james Exp $
;
; ******************* THIS IS A RE-WRITE (MOSTLY) *********************
; *** IT WAS WRITTEN BY GERPH - TOUCH IT AND HE'LL GET CONFUSED :-) ***
;     *** AND THAT INCLUDES 'TABBIFYING' IT - I'LL JUST UNDO IT ***

; some constants for later
CLEVER        * 1
THICK         * 0
DESCNAMES     * 0
SIMPLENAMES   * 1
FILE_NORMAL   * 0 ; when the file isn't AIF or a module
FILE_AIF      * 1 ; when the file is AIF code
FILE_MODULE   * 2 ; when the file is a module
FILE_CHUNK    * 3 ; when the file is a chunk file
SCL_ENTRIES   * 233 ; the number of entries in the SCL stub jump table


; OPTIONS >>>
; These would be better as runtime options, but for the time being...

; Use CLEVER to enable this file, or THICK to disable it
; - you might want to do this whilst debugging; it only cuts 6k from Zap
; You may have to link with the 'nounusedareas' option to prevent the SCL
; table being included.
DISASSEMBLY   * CLEVER

; Use DESCNAMES to get descriptive names, or SIMPLENAMES for simple names
; Tim likes the latter, Justin likes the former
NAMINGTYPE    * DESCNAMES

; <<< OPTIONS

 GET h.ZapHeader
 GET h.Messages
 GET h.AlterTxt

 EXPORT  mode4_clever_search
 EXPORT  mode4_clever_dis

 IMPORT  mode4_aif_headerstring
 IMPORT  mode4_mod_headerstring


; detokeniser for e_search
; => R0 = instruction
;    R1 = address it came from
;    R3 = file offset of current position
;    r8-> window
;    r9-> file
; <= r1-> string
;    r2 = length of string
mode4_clever_search
   STMFD   R13 !,{R0,R3,R5,R7,R14}       ; Stack registers
                           ; generate r7 (= the address in memory of code)
   LDR     R5,[R9,#f_splito]             ; find split offset in buffer
   CMP     R3,R5                         ; are we in the bottom or top half?
   LDR     R5,[R9,#f_splits]             ; if the top, read split size
   ADDCS   R14,R3,R5                     ; and skip the split
   MOVCC   R14,R3                        ; R14 = offset (to preserve R3)
   LDR     R5,[R9,#f_ptr]                ; start address of file
   ADD     R7,R14,R5                     ; add on start of file (R7=address)
                                         ; and R5 (=virtual start of file)
   SUB     R5,R7,R3                      ; 'virtual' start of buffer (=R5)
   ADD     R7,R7,#4                      ; add on 4 (why? because it
                                         ; doesn't work otherwise ;-()
   BL      mode4_clever_dis              ; do the 'new' disassembly
   LDRB    R0,[R8,#w_format]             ; mode number
   ADD     R3,R8,#w_mode0
   LDR     R0,[R3,R0,LSL #2]             ; load our mode word
   TST     R0,#mode4_CommentFree
   BEQ     finish$l                      ; else got to strip the trailing comment
   MOV     R3,R1
loop$l
   LDRB    R0,[R3],#1
   CMP     R0,#';'                       ; which can't exist except in the comment stage ...
   CMPNE   R0,#0
   BNE     loop$l                        ; fastest loop possible
   MOV     R0,#0
   STRB    R0,[R3,#-1]
   SUB     R2,R3,R1                      ; the real length of the string (including terminator)
finish$l
   ADDS    R14,R14,#0
   LDMFD   R13 !,{R0,R3,R5,R7,PC}        ; Return from call

   [ DISASSEMBLY=THICK
; this little section is for when we're in 'thick' mode
mode4_clever_dis
   STMFD   r13!,{r14}                    ; Stack registers
   SWI     XDebugger_Disassemble         ; do the disassembly and return
   LDMFD   r13!,{pc}                     ; Return from call
   |
; and everything else is the 'clever' stuff

; The 'special' disassembly options
; => r0 = instruction
;    r1 = address it came from
;    r5-> apparent start of file
;    r7-> address of code (R7-R5 = offset in file)
;    r8-> window
;    r9-> file
; <= r1-> string
;    r2 = length
; Note:
;    All routines called from within here have the following parameters :
;    => r0 = instruction
;       r1 = address it came from + 4
;       r3 = offset in file of code
;       r5-> apparent start of file
;       r7-> address of code
;       r8-> window
;       r9-> file
;       r14 = return address
;       localtypemarker = type of the file
;    <= r0 = 0 if processed, any other value if not
;       r1-> string
;       r2 = length
;       r3-r7 may be corrupt /iff/ the routine returns r0=0
;    The intermediate code held in here may return to part way through
;    these decoding routines, or to return$l to return safely. Routines
;    called should be named 'dec_<purpose>' to make things clearer, and
;    keep away from other naming conventions.
;
;    To append to the end of the debugger string they should call
;    copytoendofdebugger.
localtypemarker
   DCD     FILE_NORMAL
mode4_clever_dis
   STMFD   r13!,{r0,r1,r3-r7,r14}        ; Stack registers
; first any kinds of identification as to the files type
   MOV     r6,#FILE_NORMAL               ; mark as a normal file
   STR     r6,localtypemarker
   SUB     r3,r7,r5                      ; r3 = offset
;  identify AIFs
   LDR     R14,[R9,#f_load]
   MOV     R14,R14,ASR #8
   CMP     R14,#-6                       ; module?
   MOVEQ   r6,#FILE_MODULE
   STREQ   r6,localtypemarker            ; mark as a module
   BEQ     isntaif$l                     ; and it's not AIF
   CMP     r14,#-3                       ; data file ?
   BEQ     mightbechunk$l
   CMP     r14,#-8                       ; absolute?
   CMPNE   r14,#-45                      ; debuggable
   BNE     isntaif$l                     ; NO

   MOV     r4,r0                         ; hang on to instruction
   MOV     r0,#&10                       ; address &10
   BL      cln_readw                     ; read the word
   EOR     r0,r0,#&EF000000              ; clear top bits
   EORS    r0,r0,#&00000011              ; clear SWI number (EQ if OS_Exit)
   MOV     r0,r4                         ; restore instruction
   BNE     isntaif$l                     ; it's not AIF, so forget this
   MOV     r6,#FILE_AIF                  ; mark as AIF
   STR     r6,localtypemarker            ; store the type

   CMP     r3,#&80                       ; end of zero init
   CMPNE   r3,#&44                       ; debugger init
   CMPNE   r3,#&48                       ; start of zero init
   CMPNE   r3,#&14                       ; < header
   ADRLS   r14,return$l                  ; they should return as if BL'd
   BLS     dec_aifheader                 ; decode AIF header

isntaif$l
; now check functions
   EOR     r14,r0,#&FF000000             ; leave < 256 if SWI
   CMP     r14,#256                      ; is it SWI ?
   ADRLO   r14,return$l                  ; they should return as if BL'd
   BLO     dec_swinv                     ; it's a SWINV !
; branches
   AND     r14,r0,#&0F000000             ; read opcode
   TEQ     r14,#&0B000000                ; is it BL ?
   TEQNE   r14,#&0A000000                ; or is it B ?
   ADREQ   r14,return$l                  ; they should return as if BL'd
   BEQ     dec_branch                    ; if so, extended decoding needed
; addresses
   AND     r14,r0,#&0FE00000             ; checking for ADR's
   TEQ     r14,#&02400000                ; is it SUB ?
   TEQNE   r14,#&02800000                ; or ADD ?
   ANDEQ   r14,r0,#&000F0000             ; leave just source register
   TEQEQ   r14,#&000F0000                ; is it PC ?
   ADREQ   r14,return$l                  ; they should return as if BL'd
   BEQ     dec_adr                       ; yay, we've got it !

; jump here if you just want to use the normal debugger string
forceddecode$l
   MOV     r0,#1                         ; ensure it always decodes

; all the routines should return through here
return$l
   TEQ     r0,#0                         ; did we decode it ?
   LDMNEIA r13,{r0,r1}                   ; if not, re-read inst and addr
   SWINE   XDebugger_Disassemble         ; do the disassembly and return
   STR     r1,[r13,#4]                   ; stack r1 for retrieval
   LDMFD   r13!,{r0,r1,r3-r7,pc}         ; Return from call

; it might be a chunk file
mightbechunk$l
   MOV     r4,r0                         ; hang on to instruction
   MOV     r0,#0                         ; address 0
   BL      cln_readw                     ; read the word
   LDR     r14,chunk_area$l
   TEQ     r14,r0                        ; is it a chunk file ?
   MOV     r0,r4                         ; restore instruction
   BNE     isntaif$l                     ; it's not chunked, so forget this
   MOV     r6,#FILE_CHUNK                ; mark as Chunk
   STR     r6,localtypemarker            ; store the type

   CMP     r3,#0+4                       ; start of chunk file
   ADREQ   r14,return$l                  ; they should return as if BL'd
   BEQ     dec_chunkheader               ; decode chunk header
   B       isntaif$l                     ; if not, go back to standard code

chunk_area$l
   DCD     &c3cbc6c5                     ; looks like AREA

; decode addresses
; (params as described in 'newdisassemble')
   LOCAL
dec_adr
   STMFD   r13!,{r0,r1,r14}
; check it's not a long adr
   AND     r4,r0,#&0000F000              ; r4 = destination register
   AND     r14,r0,#&F0000000             ; r14 = condition code
   ORR     r4,r4,r4,LSL #4               ; duplicate the dest into src
   ORR     r4,r14,r4                     ; and add the condition code in
   ; r4 = &c00dd000 c=condition, d = dest from original
   MOV     r0,r3                         ; r0 = offset
   BL      cln_readw                     ; read a word
   MOV     r2,r0                         ; hang on to next word for later

   BIC     r0,r0,#&000000FF              ; clear low byte
   BIC     r0,r0,#&00000F00              ; clear the third nibble (number)
   AND     r14,r0,#&0FF00000             ; r14 = opcode
   TEQ     r14,#&02800000                ; is it ADD ?
   TEQNE   r14,#&02400000                ; or SUB ?
   BNE     notadrl$l
   BIC     r0,r0,#&0FF00000              ; remove the opcode
   EORS    r0,r0,r4                      ; should give us zero if same
   BNE     notadrl$l
; at this point, I'm 99.9% sure it's an ADRL

; for debugging I'll append a message to it
   LDMFD   R13 !,{R0,R1}                 ; restore old regs
   SWI     XDebugger_Disassemble         ; disassemble it (R1-> string)
   MOVVS   r0,#1                         ; if failed, mark as such
   LDRVS   pc,[r13],#4                   ;            and return safely
   MOV     r2,#3 ; should be -1          ; no data
   MOV     r6,#0                         ; it's got no indirection
   ADR     r4,longadr$l                  ; the string
   ADD     r3,r4,#13 ; MOV r3,#0
   LDR     r14,[r13],#4                  ; read link from stack
   B       copytoendofdebugger

longadr$l
   = "zap_d_longadr",0
   ALIGN

; usually I'd have :
;    MOV     r0,#1                         ; failed
;    STR     r0,[r13]                      ; mark it in r0
;    LDMFD   r13!,{r0,r1,pc}               ; return from call

notadrl$l
; => r2 = next instruction
;    r3 = offset of this code
   LDR     r0,[r13]                      ; re-read r0
; work out the address we are going to
   AND     r4,r0,#&00F00000              ; r4 = instruction type
   MOV     r0,r0,LSL #20                 ; shift up
   MOV     r0,r0,LSR #20                 ; now shift down (leaves address)
   MOV     r14,r0,LSR #8                 ; r3 = rotate
   MOV     r14,r14,LSL #1                ; r3 = rotate * 2
   AND     r0,r0,#&FF                    ; r0 = value to move
   MOV     r0,r0,ROR r14                 ; r0 = offset from here
   TEQ     r4,#&00400000                 ; is it SUB ?
   ADDNE   r3,r3,r0                      ; if not, add it
   SUBEQ   r3,r3,r0                      ; if so, take it off
   ADDS    r3,r3,#4                      ; add on 8 for pipeline
   BMI     notadr$l
; r3 = offset of the destination of this ADR

   TST     r3,#3                         ; is it aligned ?
   BNE     notaligned$l                  ; if not, skip error block check

; now we check that next instruction isn't an ORRS
   LDR     r1,orrsmask$l
   LDR     r4,orrsvalue$l
   AND     r14,r2,r1                     ; mask off next instruction
   TEQ     r14,r4                        ; is it an ORRS ?
   BEQ     iserror$l                     ; if so, it's an error block

; now we check that next instruction isn't an error SWI...
	LDR	r1,swimask$l
	LDR	r4,swivalue$l
	AND	r14,r2,r1		; mask it

	TEQ	r14,r4			; is it an ORRS ?
	BEQ	iserror$l		; if so, it's an error block

; now check LDMxx r#,{...link}
	LDR	r1,ldmmask$l
	LDR	r4,ldmvalue1$l
	AND	r14,r2,r1		; mask it
	TEQ	r14,r4			; is it an LDMxA ?
	LDRNE	r4,ldmvalue2$l		; if not, is it before ?
	TEQNE	r14,r4			; is it an LDMxB ?
	BNE	notaligned$l		; not an error

	SUB	r0,r7,r5		; R0 = file offset of inst
	ADD	r0,r0,#4
	LDR	r14,[r9,#f_len]
	CMP	r0,r14
	BCS	notaligned$l
	BL	cln_readw		; read word in Zap
	LDR	r1,orrsmask$l
	LDR	r4,orrsvalue$l
	AND	r14,r0,r1		; mask it

	TEQ	r14,r4			; is it an ORRS ?
	BEQ	iserror$l		; if so, it's an error block

; it's not got the look of an error return block so it's probably not
notaligned$l
   MOV     r6,#1                         ; 1 indirection so far
   MOV     r0,r3                         ; r0 = offset to look at
   BL      chk_destination               ; this will check the dest and
                                         ; return some valid params
; r2 = type (0-3), r3 = the parameter, r6 = indirection count, r4 = prefix
   MOV     r5,r2                         ; hang on to type
   LDMFD   R13 !,{R0,R1}                 ; restore old regs
   SWI     XDebugger_Disassemble         ; disassemble it (R1-> string)
   MOVVS   r0,#1                         ; if failed, mark as such
   LDRVS   pc,[r13],#4                   ;            and return safely
   MOV     r2,r5                         ; restore type
   LDR     r14,[r13],#4                  ; read link from stack
   B       copytoendofdebugger

notadr$l
   LDMFD   r13!,{r0,r1}                  ; restore old regs
   MOV     r0,#1                         ; mark us as having failed
   LDMFD   r13!,{pc}                     ; return from call

; we call here when we find an error block
iserror$l
   ADD     r0,r3,#4                      ; skip the error number
   MOV     r5,r3                         ; hang on to pointer
   MOV     r6,#1                         ; indirection =1
   BL      chk_destination               ; check that it's valid and stuff
; r2 = type (0-3), r3 = the parameter, r6 = indirection count, r4 = prefix
   TEQ     r6,#1                         ; is it still one level ?
   TEQEQ   r2,#0                         ; and is it a string ?
   MOVNE   r3,r5
   BNE     notaligned$l                  ; if not, it's not an error
; it's pretty definately an error block
   LDMFD   R13 !,{R0,R1}                 ; restore old regs
   SWI     XDebugger_Disassemble         ; disassemble it (R1-> string)
   MOVVS   r0,#1                         ; if failed, mark as such
   LDRVS   pc,[r13],#4                   ;            and return safely
   MOV     r2,#0                         ; it's a string
   ADR     r4,error$l                    ; if so, write 'error:'
   LDR     r14,[r13],#4                  ; read link from stack
   B       copytoendofdebugger

error$l
   = "zap_d_error ",0
   ALIGN

orrsmask$l
   DCD     &0ff0ffff                     ; mask for ORRS pc,r#,#&10000000
orrsvalue$l
   DCD     &0390F201                     ; value it should be
swimask$l
	DCD	&0FFFFFFF
swivalue$l
	DCD	&0F00002B
ldmmask$l
   DCD     &0f50C000                     ; mask for LDMxx r#,{...link}
ldmvalue1$l
   DCD     &08104000                     ; LDMxA r#,{...link}
ldmvalue2$l
   DCD     &09104000                     ; LDMxA r#,{...link}

; check a destination, following any indirection possible
; => r0 = destination offset
;    r6 = indirection count
; <= r2 = type of destination
;    r3 = parameter
;    r4 = the text to use for it
;    r6 = indirection count
   LOCAL
chk_destination
   STMFD   r13!,{r14}                    ; Stack registers

   CMP     r6,#4                         ; 4 levels of recursion ?
   BGE     toodeep$l                     ; if >, we'll just say it's too deep
; validate it
   MOVS    r3,r0                         ; set flags, and move it to r3
   BMI     notincode$l                   ; if -ve, it's invalid
   LDR     r14,[r9,#f_len]               ; read file length
   CMP     r14,r0                        ; is it outside ?
   BLE     notincode$l                   ; yep, so invalid

; it's valid
   CMP     r3,#&40                       ; is it in the header section
   BGE     notanaiffile$l                ; if not, it's not a 'header' blob
   TST     r3,#3                         ; is it aligned ?
   BNE     notanaiffile$l                ; if not, it's not a valid header

   LDR     r14,localtypemarker
   TEQ     r14,#FILE_AIF                 ; is it AIF ?
   BEQ     isaifheader$l                 ; yes, so parse it
   TEQ     r14,#FILE_MODULE              ; is it a Module ?
   BEQ     ismodheader$l                 ; yes, so parse it

notanaiffile$l
; this is where I need a cache of whether this file is AIF, etc...
; because the above code is actually a lie if it's not.

   BL      chk_code                      ; is it a piece of code ?
   CMN     r0,#1                         ; is it -1 (not code) ?
   BNE     iscode$l                      ; if not, deal with the code

   MOV     r0,r3                         ; r0 = offset
   TST     r0,#3                         ; is it aligned ?
   BNE     couldbestring$l               ; if it's not aligned, probably str

   BL      cln_readw                     ; read a word out
   MOV     r1,r0                         ; r1 = the word
   MOV     r0,r3                         ; r0 = the offset

   BMI     couldbestring$l               ; if it's -ve it's probably a string
   LDR     r14,[r8,#w_addr]              ; read file length
   SUBS    r1,r1,r14                     ; r1 = offset in file
   ADDMI   r1,r1,r14                     ; if too small, add it back!
   BMI     couldbenumber$l               ;               could be a number
   LDR     r14,[r9,#f_len]               ; read file length
   CMP     r14,r1                        ; is it outside ?
   BLE     couldbestring$l               ; > end, so could be a string

; we think it's a pointer, so let's dereference it
   ADD     r6,r6,#1                      ; one more level of recursion
   TEQ     r0,r1                         ; hang on, is it recursing ?
   BEQ     isrecursing$l
   LDR     r14,[r13],#4                  ; read r14 off stack
   MOV     r0,r1                         ; r0 = the new offset
   B       chk_destination               ; and recurse
; actually we don't recurse because we're a tail continuation function -
; coo, init neat?!

isrecursing$l
   MOV     r2,#2                         ; it's a pointer
   LDR     r14,[r8,#w_addr]              ; read file length
   ADD     r3,r0,r14                     ; r3 = physical address
   ADR     r4,roundandaround$l           ; prefix
   LDMFD   r13!,{pc}                     ; return

roundandaround$l
   = "zap_d_recur",0
   ALIGN

toodeep$l
   MOV     r2,#2                         ; string literal
   LDR     r14,[r8,#w_addr]              ; read file length
   ADD     r3,r0,r14                     ; r3 = physical address
   ADR     r4,toofarman$l                ; the prefix
   LDMFD   r13!,{pc}                     ; Return from call

toofarman$l
   = "zap_d_depth",0
   ALIGN

; it could be a number
; => r1 = number
; <= r2 = type of data
;    r3 = parameter
;    r4 = prefix, or 0 for none
couldbenumber$l
   MOV     r2,#1                         ; a number
   MOV     r3,r1                         ; the number
   ADR     r4,anumber$l                  ; the prefix
   LDMFD   r13!,{pc}                     ; Return from call

;    MOV     r2,#3                         ; string literal
;    ADR     r3,num$l
;    MOV     r4,#0                         ; no prefix
;    LDMFD   r13!,{pc}                     ; Return from call
; num$l
;    = "num?",0
;    ALIGN

; or it could be a string
; => r1 = rubbish
;    r0 = offset it comes from
; <= r2 = type of data
;    r3 = parameter
;    r4 = prefix, or 0 for none
couldbestring$l
   MOV     r3,r0                         ; r3 = offset
   MOV     r4,r0                         ; r4 = start offset
string_loop$l
   LDR     r14,[r9,#f_len]               ; read the file length
   CMP     R14,r3                        ; is it outside ?
   BLE     notastring$l                  ; yep, so invalid
   MOV     r0,r3                         ; r0 = offset of character
   BL      cln_readc                     ; read a character
   TEQ     r0,#10                        ; is it LF ?
   TEQNE   r0,#13                        ; or CR ?
   TEQNE   r0,#9                         ; or HT ?
   ADDEQ   r3,r3,#1                      ; if one of them, increment
   BEQ     string_loop$l                 ;                 and go for more
   TEQ     r0,#0                         ; is that it ?
   BEQ     string_done$l                 ; if so, we're done with !
   CMP     r0,#31                        ; if ctrl char, then it's not ours
   TEQGT   r0,#&FF                       ; or if it's &FF then it's invalid
   BLE     notastring$l                  ; so don't bother with it
   ADD     r3,r3,#1                      ; add one more
   B       string_loop$l                 ; and we know it's text

string_done$l
   SUBS    r14,r4,r3                     ; how long is the string?
   BEQ     notastring$l                  ; if =0 then it's not real

   MOV     r2,#0                         ; string literal
   MOV     r3,r4                         ; start offset
   ADR     r4,string$l                   ; the prefix
   LDMFD   r13!,{pc}                     ; Return from call

string$l
   = "zap_d_str",0
   ALIGN

; hey, we just give up and say it's a number!
notastring$l
   B       couldbenumber$l

;    MOV     r2,#3                         ; string literal
;    ADR     r3,str$l
;    MOV     r4,#0                         ; no prefix
;    LDMFD   r13!,{pc}                     ; Return from call
; str$l
;    = "string?",0
;    ALIGN


iscode$l
   CMN     r0,#2                         ; is it anonymous ?
   MOVEQ   r2,#2                         ; if so, it's a literal
                                         ; r3 already set up
   ADREQ   r4,anoncode$l                 ;        <code>
   LDMEQFD r13!,{pc}                     ; if so, return the value
   TST     r0,#1<<30                     ; is the code part of SCL ?
   MOVNE   r2,#3                         ; if set, literal string
   BICNE   r3,r0,#1<<30                  ;         and clear b30
   MOVEQ   r3,r0                         ; if not, it's in the file
   MOVEQ   r2,#4                         ;        explicit string in the file
   ADR     r4,codename$l                 ; they should both say 'code:'
   LDMFD   r13!,{pc}                     ; if so, return the value

; it's part of the AIF header
isaifheader$l
   BL      mode4_aif_headerstring
   MOV     r3,r0                         ; r3 = string literal to use
   MOV     r2,#3                         ; it's a string literal
   MOV     r4,#0                         ; no prefix
   LDMFD   r13!,{pc}                     ; return the value

; it's part of the module header (maybe)
ismodheader$l
   BL      mode4_mod_headerstring
   TEQ     r0,#0                         ; did it return 0 ?
   MOVEQ   r0,r3                         ; is so, restore offset
   BEQ     notanaiffile$l                ;        and do 'normal' things
   MOV     r3,r0                         ; r3 = string literal to use
   MOV     r2,#3                         ; it's a string literal
   MOV     r4,#0                         ; no prefix
   LDMFD   r13!,{pc}                     ; return the value


notincode$l
   MOV     r2,#1                         ; it's a number
   MOV     r3,r0                         ; parameter = offset
   ADR     r4,anumber$l                  ; the number we are using
   LDMFD   r13!,{pc}                     ; return the value

anumber$l
   = "zap_hash",0
anoncode$l
   = "zap_d_codeat",0
codename$l
   = "zap_d_code",0
   ALIGN

; decode branches
; (params as described in 'newdisassemble')
   LOCAL
dec_branch
   STMFD   r13!,{r0,r1,r14}
; work out the address we are going to
   MOV     r0,r0,LSL #8                  ; shift inst up to the top
   ADD     r0,r7,r0,ASR #6               ; add on to memory offset
                                         ; shift it down * 4 (signed)
   SUB     r0,r0,r5                      ; subtract apparent start of area
   ADD     r0,r0,#4                      ; move on to the actual instruction
   BL      chk_code                      ; check that it's valid
   CMN     r0,#1                         ; -1 means nothing found
                                         ; -2 means anonymous code (maybe)
   BLE     notbranch$l                   ; if nothing, skip

   MOV     r3,r0                         ; r3 = offset of string
   LDMFD   r13!,{r0,r1}                  ; restore old regs
   SWI     XDebugger_Disassemble         ; disassemble it (R1-> string)
   MOVVS   r0,#1                         ; if failed, mark as such
   LDRVS   pc,[r13],#4                   ;            and return safely
   TST     r3,#1<<30                     ; is the code part of SCL ?
   MOVNE   r2,#3                         ; if set, literal string
   BICNE   r3,r3,#1<<30                  ; and clear b30
   MOVEQ   r2,#4                         ; if not,explicit string in the file
   MOV     r6,#0                         ; it's got no indirection
   ADR     r4,call$l                     ; the call string
   LDR     r14,[r13],#4                  ; read link from stack
   B       copytoendofdebugger

notbranch$l
   LDMFD   R13 !,{R0-R1}                 ; restore old regs
   MOV     r0,#1                         ; mark us as having failed
   LDMFD   R13 !,{PC}                    ; return from call

call$l
   = "zap_d_call",0
   ALIGN

; check that an offset contains a piece of code
; => r0 = offset
; <= r0 = offset of string, or
;         -1 if not code
;         -2 if possibly anonymous code
;         b30 set if the offset is actually absolute (in module)
; NOTE: This should be safe as the module area cannot be in the top half of
;       memory on current Risc OS machines. If in future it is possible to
;       run Zap on a computer with the pc in 32 bit mode then it's quite
;       likely that this won't work.
   LOCAL
chk_code
   STMFD   r13!,{r2,r3,r4,r14}          ; Stack registers
; validate it
   TST     r0,#3                         ; is it aligned ?
   BNE     notcode$l                     ; nope, so not a code label
   SUBS    r2,r0,#4                      ; look at the word before it
   BMI     notcode$l                     ; if -ve, it's invalid
   LDR     r14,[r9,#f_len]               ; read file length
   CMP     r14,r2                        ; is it outside ?
   BLE     probablynotcode$l             ; yep, so invalid
; it's valid, check that it is a function
   MOV     r0,r2                         ; the address to read
   BL      cln_readw                     ; read a word
   EOR     r14,r0,#&FF000000             ; clear bottom bits (str len)
   CMP     r14,#256                      ; is it SWINV ?
   BHI     notswinv$l                    ; nope, so invalid
; it's a SWINV
   AND     r14,r0,#&FF                   ; leave just bottom bits (len)
   TST     r14,#3                        ; is it aligned ?
   BNE     notswinv$l                    ; nope, so not a code label
   SUB     r0,r2,r14                     ; decrement pointer by that
   LDMFD   r13!,{r2,r3,r4,pc}            ; Return from call

notswinv$l
   MOV     r4,#&E3000000                 ; xxxAL
   ORR     r4,r4,#&00A00000              ; MOVAL
   ORR     r4,r4,#&0000F000              ; MOVAL pc,#0
   EORS    r14,r0,r4                     ; invert the bits
   ADD     r0,r2,#4                      ; and the word itself
   BEQ     sharedc$l
notsharedc$l
   BL      cln_readw                     ; read a word
   AND     r14,r0,#&F0000000             ; leave just the top nibble
   TEQ     r14,#&E0000000                ; is it an 'AL' instruction ?
   MOVEQ   r0,#-2                        ; if so, it's probably anonymous
   MOVNE   r0,#-1                        ; else return -1 to say it's invalid
   LDMFD   r13!,{r2,r3,r4,pc}            ; Return from call

; it could be an SCL routine...
sharedc$l
   LDR     r14,localtypemarker           ; read the filetype
   TEQ     r14,#FILE_AIF                 ; is it AIF ?
   BNE     notsharedc$l                  ; if not, skip
   BL      cln_readw                     ; read this word
   TEQ     r0,r4                         ; invert it
   BNE     notsharedc$l                  ; if not, it's not SCL
   MOV     r3,r2                         ; hang on to the start address
loopforscl$l
   SUBS    r2,r2,#4                      ; decrement
   BMI     notcode$l                     ; if -ve, it's not a piece of code
   MOV     r0,r2                         ; offset to read
   BL      cln_readw                     ; read it
   TEQ     r0,r4                         ; is it the MOV pc,#0 thing ?
   BEQ     loopforscl$l                  ; if so, get it
scl_getstr$l
   ADR     r0,sharedclibrary             ; read the pointer
   SUB     r2,r3,r2                      ; gives us the offset from the base
   CMP     r2,#SCL_ENTRIES:SHL:2         ; is it too high ?
   BHS     notcode$l                     ; if so, it's not SCL
   LDR     r14,[r0,r2,LSR #1]  		 ; read the offset of the string
   MOV     r14,r14,LSL #16
   ADD     r0,r0,r14,LSR #16             ; and add on the string table base
   ORR     r0,r0,#1<<30                  ; set bit 30
   LDMFD   r13!,{r2,r3,r4,pc}            ; Return from call

gststubs_adr_scl_block
	&	&E28F0068 ; ADR R0,...

probablynotcode$l
; Extra bit of code to cope with gststubs
; (Darren Salt)
	LDR	r14,localtypemarker	; read the filetype
	TEQ	r14,#FILE_AIF		; is it AIF ?
	BNE	notcode$l		; if not, skip
	MOV	R3,R0			; preserve this address...
	MOV	R0,#12
	BL	cln_readw		; read main entry point branch
	MOV	R14,R0,LSR #24
	TEQ	R14,#&EB
	BNE	notcode$l		; not a BL
	MOV	R0,R0,LSL #8		; convert to file offset
	MOV	R0,R0,ASR #6		; giving address of init code
	ADD	R0,R0,#20
	MOV	R2,R0
	BL	cln_readw
	EOR	R0,R0,#&EF<<24
	TEQ	R0,#&10			; SWI OS_GetEnv ?
	BNE	notcode$l
	ADD	R0,R2,#8
	BL	cln_readw
	LDR	R14,gststubs_adr_scl_block
	TEQ	R0,R14
	BNE	notcode$l
	ADD	R0,R2,#&7C		; offset of ptr in gststubs SCL block
	BL	cln_readw
	LDR	R2,[R8,#w_addr]		; hmm...
	SUB	R2,R0,R2
	B	scl_getstr$l

notcode$l
   MOV     r0,#-1                        ; return -1 to say it's invalid
   LDMFD   r13!,{r2,r3,r4,pc}            ; Return from call

; The following bit of (tab-indented) code relies on another data file :-)
; (Darren Salt)

; For counting entries
	MACRO
	Count	$label
num	SETA	num+1
	MEND

; For building the offsets table
	MACRO
	Ptr	$label
	DCW	@
	#	1+:LEN:$label
	MEND

; For writing the strings themselves
	MACRO
	Str	$label
	=	$label,0
	MEND

	GBLS	op
	GBLA	num

; The file "data.clib_names" contains a list of entries of the form
;	op	"string"
; - it's really an assembler source file :-)

sharedclibrary

; First, count the number of entries.
	^	0
op	SETS	"Count"
num	SETA	0
	GET	data.clib_names

; Build the offsets table (halfwords)
	^	0
	#	num*2	; offsets are relative to |sharedclibrary|
op	SETS	"Ptr"
	GET	data.clib_names

; Build the strings table.
op	SETS	"Str"
	GET	data.clib_names

	ALIGN

; decode SWINV's - usually these are function headers
; (params as described in 'newdisassemble')
   LOCAL
dec_swinv
   STMFD   r13!,{r0,r1,r14}
   AND     R14,R0,#&FF                   ; leave just the back len
   TST     R14,#3                        ; is it aligned ?
   BNE     notfunc$l                     ; nope, so not a function
   SUBS    R3,R3,R14                     ; go back that far
   BMI     notfunc$l                     ; went -ve, so not ours
   LDMFD   R13 !,{R0,R1}                 ; restore old regs
   SWI     XDebugger_Disassemble         ; disassemble it (R1-> string)
   MOVVS   r0,#1                         ; if failed, mark as such
   LDRVS   pc,[r13],#4                   ;            and return safely
   MOV     r2,#4                         ; explicit string in the file
   SUB     r3,r3,#4                      ; right place !
   ADR     r4,funcdef$l                  ; the string to use
   MOV     r6,#0                         ; no indirection
   LDR     r14,[r13],#4                  ; restore link for tail continue
   B       copytoendofdebugger           ; and copy string

notfunc$l
   LDMFD   R13 !,{R0-R1}                 ; restore old regs
   MOV     r0,#1                         ; mark us as having failed
   LDMFD   R13 !,{PC}                    ; return from call

funcdef$l
   = "zap_d_func",0
   ALIGN


; decode chunk header
; (params as described in 'newdisassemble')
   LOCAL
dec_chunkheader
   STMFD   r13!,{r0,r1,r14}
   ADR     r3,null$l                     ; no name ;-)
   ADR     r4,chunkfile$l                ; r4-> the name
   MOV     r6,#0                         ; no indirection
copystring$l
   LDMFD   r13!,{r0,r1}                  ; unstack inst and addr
   SWI     XDebugger_Disassemble         ; disassemble it (R1-> string)
   MOVVS   r0,#1                         ; if failed, mark as such
   LDRVS   pc,[r13],#4                   ;            and return safely
   LDR     r14,[r13],#4                  ; restore link for tail continue
   MOV     r2,#3                         ; absolute string
   B       copytoendofdebugger

chunkfile$l
   = "zap_d_chunkf"
null$l = 0
   ALIGN

; decode AIF header
; (params as described in 'newdisassemble')
   LOCAL
dec_aifheader
   STMFD   r13!,{r0,r1,r14}
   SUB     r0,r3,#4                      ; r0 = offset
   MOV     r4,#0                         ; no prefix string
   MOV     r6,#0                         ; no indirection

   BL      mode4_aif_headerstring        ; read header string
   MOV     r3,r0                         ; r3-> the name
copystring$l
   LDMFD   r13!,{r0,r1}                  ; unstack inst and addr
   SWI     XDebugger_Disassemble         ; disassemble it (R1-> string)
   MOVVS   r0,#1                         ; if failed, mark as such
   LDRVS   pc,[r13],#4                   ;            and return safely
   LDR     r14,[r13],#4                  ; restore link for tail continue
   MOV     r2,#3                         ; absolute string
   B       copytoendofdebugger

; copy a set of strings onto the end of the debugger string
; it'll also cut off any other comments that are there for brevity
; => R1-> debugger string
;    R2 = type of data in r3 :
;          -1 = no data
;           0 = offset of 'quoted' string in file
;           1 = numeric data
;           2 = pointer (printed in hex alone)
;           3 = absolute string address
;           4 = offset of explicit string in file
;           x = <unknown>
;    R3 = dependant on r2
;    R4-> prefix string to place in between them, or 0 if none
;    R6 = indirection count (pre-pends '-> ' to string)
; <= R0 = 0
;    R1-> string
;    R2 = length
;
; Therefore, the output is :
; <debugger>        ; [-> ]*<prefix><r3 data>
; <prefix> must therefore contain a trailing space if it requires one
;
   LOCAL
copytoendofdebugger
   STMFD   R13 !,{R0,r1,r2,R3-R4,R14}    ; Stack registers
   CMN     r2,#1                         ; is the code -1 ?
   MOVEQ   r0,#1                         ; if so, ensure we mark as failed
   ADDEQ   r13,r13,#4                    ;        skip r0 on stack
   LDMEQFD r13!,{r1,r2,R3-R4,R14}        ;        and return
; first we copy their string to the end, or to the ';'
   MOV     R0,R1                         ; R0-> string
   FNLDR   R2,wimp_buffer                ; buffer - hope OK
   ADD     R2,R2,#128
copydebugger$l
   LDRB    R14,[R0],#1                   ; read and inc
   CMP     R14,#';'			 ; was it ';'
   CMPNE   R14,#31			 ; or a ctrl char?
   STRGTB  R14,[R2],#1			 ; if not, store and inc
   BGT     copydebugger$l		 ; and continue

; now move back over the spaces
skipspaces$l
   LDRB    r14,[r2,#-1]!                 ; read behind and update
   TEQ     R14,#' '                      ; was it ' ' ?
   LDREQB  r14,[r2,#-1]!                 ; read behind and update
   TEQEQ   R14,#' '                      ; was it ' ' ?
   BEQ     skipspaces$l                  ; if so, check for another
   ADD     r2,r2,#1                      ; jump back one character

; this works out whether we are in 'wide' mode and appends spaces
   LDR     R14,[R8,#w_mode4]             ; width of instructions
   TST     R14,#1<<22
   MOVEQ   R0,#26                        ; if not in wide mode
   MOVNE   R0,#46                        ; if in wide mode

   FNLDR   R14,wimp_buffer               ; buffer - hope OK
   ADD     R14,R14,#128
   SUB     r0,r0,r2                      ; take off the current position
   ADD     r0,r0,r14                     ; add on the start position (-line)

; now pad the comment
   BL      addsomeextraspaces            ; r2-> next char

; put our comment marker in
   MOV     r0,#';'
   STRB    r0,[r2],#1                    ; store and inc
   MOV     r0,#' '
   STRB    r0,[r2],#1                    ; store and inc

; now add any indirection arrows we need
indirection$l
; the normal route doesn't flush the pipeline with a jump - is this better ?
   SUBS    r6,r6,#1                      ; decrement counter
   MOVPL   r0,#'-'
   STRPLB  r0,[r2],#1                    ; store and inc
   MOVPL   r0,#'>'
   STRPLB  r0,[r2],#1                    ; store and inc
   MOVPL   r0,#' '
   STRPLB  r0,[r2],#1                    ; store and inc
   BPL     indirection$l

; copy the prefix string, if there is one
   MOVS    r0,r4			 ; was there a prefix ?
   BEQ     noprefix$l
   BL      lookup_token_R0
copyprefixstring
   LDRB    R1,[R0],#1                    ; read and inc
   CMP     R1,#32			 ; is that it ?
   STRHSB  R1,[R2],#1			 ; if not, store and inc
   BHS     copyprefixstring		 ; and get some more

noprefix$l
; and finally, copy the string indicated by r2 (which comes from stack)
   LDR     r0,[r13,#8]                   ; re-read r2 (type) from stack
   TEQ     r0,#0                         ; is it 0 ? (quoted string in file)
   TEQNE   r0,#4                         ; is it 4 ? (normal string in file)
   BEQ     stringinfile$l
   TEQ     r0,#1                         ; is it 1 ? (number)
   BEQ     anumber$l
   TEQ     r0,#2                         ; is it 2 ? (a pointer)
   BEQ     apointer$l
   TEQ     r0,#3                         ; is it 3 ? (a literal)
   ADRNE   r3,invalid$l                  ; if not, make it <unknown>
   MOV     r0,r3
   BLNE	   lookup_token_R0

; literal string
; => r3 = offset
;    r2-> destination to copy to
aliteral$l
   LDRB    r1,[r0],#1                    ; read a byte and inc
   STRB    r1,[r2],#1                    ; store back
   CMP     r1,#32			 ; done ?
   BHS     aliteral$l                    ; no, so go for more
   B       return$l                      ; return safely

invalid$l
   = "zap_d_unknown",0
   ALIGN

; a string in the file
; => r3 = offset
;    r2-> destination to copy to
stringinfile$l
   MOV     r4,r0                         ; hang on to type
   TEQ     r4,#0                         ; is it quoted ?
   MOVEQ   r0,#'"'                       ; if so, quote it
   STREQB  r0,[r2],#1                    ;        store and inc
   PUSH    "R6"
   MOV     R6,#176                       ; Tim's crude maximum value...
   ; 176 allows for wide display of -> -> -> -> -> string: (roughly...)
sif_loop$l
   SUBS    R6,R6,#1                      ; Tim's crude fix
   BMI     premature_end$l               ; Tim's crude fix
   MOV     R0,R3                         ; R0 = offset of funcname
   BL      cln_readc                     ; get a char
   TEQ     R0,#0                         ; was it 0 ?
   STRNEB  R0,[R2],#1                    ; if not, store in buffer and inc
   ADD     R3,R3,#1                      ; inc source
   BNE     sif_loop$l                    ; nope, go around again
premature_end$l
   TEQ     r4,#0                         ; is it quoted ?
   MOVEQ   r0,#'"'                       ; if so, quote it
   STREQB  r0,[r2],#1                    ;        store and inc
   PULL    "R6"
   B       return$l                      ; return

; a literal number in r0
; => r3 = number
;    r2-> destination to copy to
anumber$l
   MOV     r0,r3                         ; r0 = value
   MOV     r1,r2                         ; r1-> destination
   MOV     r2,#12                        ; r2 = number of characters
   SWI     XOS_ConvertInteger4           ; convert it
; and as a hex number
   MOV     r0,#' '
   STRB    r0,[r1],#1                    ; store and inc
   MOV     r0,#'('
   STRB    r0,[r1],#1                    ; store and inc
   MOV     r0,#'&'
   STRB    r0,[r1],#1                    ; store and inc
   MOV     r0,r3                         ; r0 = value
   MOV     r2,#12                        ; r2 = number of characters
   SWI     XOS_ConvertHex8               ; convert it

; maybe we should skip 0's ?
   MOV     r4,#8                         ; chars to process
   MOV     r14,r0                        ; dest=start
   MOV     r1,r0                         ; r1 = start of string
anumber_skip0s$l
   LDRB    r0,[r1],#1                    ; read and inc
   TEQ     r0,#'0'                       ; is it '0' ? (EQ if 0)
   BNE     anumber_0sgone$l
   SUBS    r4,r4,#1                      ; decrement count
   BNE     anumber_skip0s$l              ; go for more
anumber_0sgone$l
   SUB     r1,r1,#1                      ; if not, go back one
anumber_copy$l
   LDRB    r0,[r1],#1                    ; read and inc
   TEQ     r0,#0                         ; is that it ?
   STRNEB  r0,[r14],#1                   ; if not, store and inc
   BNE     anumber_copy$l
   MOV     r1,r14

; close hex
   MOV     r0,#')'
   STRB    r0,[r1],#1                    ; store and inc

   CMP     r3,#32                        ; is it >32 ?
   RSBGES  r14,r3,#126                   ; and < 127 ?
   MOVLT   r2,r1                         ; if not, that's the end
   BLT     return$l                      ; so exit
   MOV     r0,#' '
   STRB    r0,[r1],#1                    ; store and inc
   MOV     r0,#'='
   STRB    r0,[r1],#1                    ; store and inc
   MOV     r0,#'"'
   STRB    r0,[r1],#1                    ; store and inc
   STRB    r3,[r1],#1                    ; store and inc
   STRB    r0,[r1],#1                    ; store and inc
   MOV     r2,r1                         ; if not, that's the end
   B       return$l                      ; so exit

; a pointer (we place & and the number in the buffer)
; => r3 = address
;    r2-> destination to copy to
apointer$l
   MOV     r0,#'&'
   STRB    r0,[r2],#1                    ; store and inc
   MOV     r0,r3                         ; r0 = address
   MOV     r1,r2                         ; r1-> destination
   MOV     r2,#12                        ; r2 = number of characters
   SWI     XOS_ConvertHex8               ; convert it
   MOV     r2,r1                         ; r2-> end of string
   B       return$l

; all the type decoders return here
; => r2-> end of the string, which will be terminated anyway
return$l
   MOV     R0,#0                         ; 0 terminator
   STRB    R0,[R2],#1                    ; store and inc
   FNLDR   R1,wimp_buffer                ; buffer - hope OK
   ADD     R1,R1,#128
   SUB     R2,R2,R1                      ; length of string
   MOV     r0,#0                         ; ensure that we return a zero
   ADD     r13,r13,#4*3                  ; skip over r0-r2
   LDMFD   R13 !,{R3-R4,PC}     ; restore and return


; Pads spaces to r0
; => r0 = spaces
;    r2-> destination
; <= r0 corrupt
;    r2-> after spaces (no terminator)
   LOCAL
addsomeextraspaces
   STMFD   R13 !,{R14}                   ; Stack registers
   MOV     R14,#32
extraspace$l
   STRB    R14,[R2],#1
   SUBS    R0,R0,#1
   BPL     extraspace$l
   LDMFD   R13 !,{PC}                    ; Return from call

   ] ; end of the clever bits

; Notes on the re-written 'new' section (gerph)
; =====
;
; The previous note here described my intent to get a more generic system
; for decoding things. I've done most of the 'difficult' part of that now
; and all that remains is to add the instruction decoding.
;
; Hopefully anyone who fancies playing with this part of the code to add
; new dereferencing, etc, can do so a little easier with the new format of
; the calls.
;
; I'd like to say a big thank you to the zap-dev group who encouraged me
; in this madness :-)
;
; Implemented
; -----------
;   BL    gives a subset of the major messages - code: <name> only
;   ADR   gives the full messages as a pointer item. If followed
;         by ORRxxS pc,r#,#vbit or LDMxx r#,{...,r14} (BUG !) and the
;         item at +4 would be quoted string then 'error: "<string>"' is
;         used, otherwise the normal full messages are used.
;
; 'full' messages implemented :
;   string: "<string>"     if the item is a string
;   # <dec> <hex> ["<c>"]  if the item is probably a number
;   code: <name>           if the item is a named piece of code
;                          if the code is identified as AIF then SCL funcs
;                          will be decoded as below
;   code: at <addr>        if the item is an anonymous piece of code
;   -> <full message>      if the item is a number which is contained
;                          within the code
;   <header string>        if the item is in the header of the code.
;                          I need to check if the recursion is > 2
;                          and if so, use number items instead.
;   -> recursion: at <addr>       if the item refers to itself
;   -> ->... too deep: at <addr>  if the indirection goes too far
;
; SharedCLibrary functions
; ------------------------
; These will be decoded correctly by identifying a block of MOV pc,#0
; instructions and finding the offset in that block. If you 'grab' an
; application from memory, therefore, it will NOT work. Because of the
; technique used to decode the block it is not possible to identify
; _kernel_init (the first SCL routine). Since this is the only ever
; called once I'm not sure that I ever need fix this problem. If anyone
; feels differently then... well... tell me.
;
; SCL functions are currently only identified in AIF code, not Modules.
; If you wish to decode a module in C then you might as well switch to
; AIF mode (AIF mode is currently triggered by the filetype being
; 'Absolute' and the fifth word of the file being OS_Exit).
;
; Code compiled with some versions of stubs appear not to use MOV pc,#0
; as the dummy table instruction. Such programs will not have their SCL
; entries shown.
;
;
; Others
; ------
; Getting your parameter type numbers wrong on calling copytoendofdebugger
; will probably give you obscure data aborts. Since your code is the only
; thing that should pass these, obviously you should ensure you know what
; you are doing (I didn't, and that's why I've written this note!)
;
; I've split this 'clever' part of the disassembly into a new file. The
; reason behind this is simple - I have to keep merging with Tims (and
; others) changes to the main Code file. This way, only the changes that are
; directly related to the 'clever' disassembly are processed here.
;
; AIF and module header name decoding has been delegated to the mode4
; source, from which all the header names are decoded. This should now work
; correctly in both AIF and Module 'types' now.
;
; See chk_code for possible future problem with 32 bit mode RO machines.
;
;
; Bugs
; ----
; References to unaligned addresses can ONLY refer to strings; at present
; they are happily indirected as anything (but bug in ADR's which killed
; Zap is now fixed)
; The hourglass doesn't seem to pop up when doing F7 searches.
; ADRL doesn't appear correctly.
; See above for <header string> bugs
; It's possible to get nasty redraw effects if you change the files type
; Can we crash Zap if the string pointed to is massive ? Not tested.
; Old versions of the C compiler seemed to compile cack offsets for the
; function name addresses. !X (Gnome) is the only example I've found of
; this. Suggestions on handling these appreciated.
; Chunk files are identified in a comment - this should be as a
; destripution, rather than a comment. This implies that the bits to decode
; header descriptions should move into Mode4dis.
;
;
; To do
; -----
; LDR/LDRB
; ADRL identified as such (and the disassembly fixed)
; Identify SCL and cache table address at load time.
; post-fixed 'copytoendofdebugger' strings so that I can see what Tims
; idea for <functionname>() looks like (plus it'll be useful elsewhere.
; AOF files (Yeah, right!)
; C++ function names (now you're just being ridiculous!)
; Run-time debugger, triggered using the throwback system and attached
; to currently executing application. (And /no/ I'm not kidding).
; Change all references to adding 4 to the offset within the decoding
; routines so that we don't have to (/why/ am I entered with offset + 4?)

   END

; ***** THIS IS ALL OLD CODE ****

; decode the LDR name, producing strings if they are
; => R0 = instruction
;    R1 = address it came from
;    R5-> apparent start of file
;    R7-> address of code (R7-R5 = offset in file)
;    r8-> window
;    r9-> file
; <= R1-> string
;    R2 = length
ldrdecoder
   STMFD   R13 !,{R0,R1,R3-R5,R14}       ; just in case we need 'em
   AND     r4,r0,#&00F00000              ; r4 = instruction type
   MOV     r0,r0,LSL #20                 ; shift up
   MOV     r0,r0,LSR #20                 ; now shift down (leaves address)
   SUB     R3,R7,R5                      ; R3 = file offset of inst
   TEQ     r4,#&00800000                 ; is it SUB ?
   ADDNE   r3,r3,r0                      ; if not, add it
   SUBEQ   r3,r3,r0                      ; if so, take it off
   ADD     r3,r3,#4                      ; add on 4 for pipeline
; here we have the address it refers to
   CMP     r3,#0                         ; check it's valid
   BMI     notrealldr                    ; went -ve, so not ours
   LDR     r4,[r9,#f_len]                ; read the file length
   CMP     R4,r3                         ; is it outside ?
   BLE     notrealldr                    ; yep, so invalid
   TST     r3,#3                         ; is it aligned ?
   BNE     notrealldr                    ; if not, skip it
; now we read that address

;debug
;    MOV     r1,#0
;    STR     r3,[r1,#&40]
;    STR     r4,[r1,#&3C]

   MOV     r0,r3                         ; r0 = file offset
   BL      cln_readw                     ; read the word
   LDR     R1,[R8,#w_addr]               ; address of offset 0
   SUB     r0,r0,r1                      ; take the base address from it

;debug
;    MOV     r1,#0
;    STR     r0,[r1,#&44]
;    STR     r4,[r1,#&38]

   CMP     r0,#0                         ; check it's valid
   BMI     notrealldr                    ; went -ve, so not ours
   CMP     R4,r0                         ; is it outside ?
   BLE     notrealldr                    ; yep, so invalid
; and if it's valid, see if it's a string
   ADR     r4,ldr_string
   MOV     r3,r0                         ; r3 = offset of string
   MOV     r5,r0                         ; r5 = offset of string
   B       adr_cantbeinstruction         ; tell them it's a string pointer

notrealldr
   LDMFD   R13 !,{R0-R1}                 ; restore old regs
   SWI     XDebugger_Disassemble         ; disassemble it (R1-> string)
exitldr
   LDMFD   R13 !,{R3-R5,PC}              ; return from call

ldr_string
   = "zap_d_pstr",0
   ALIGN

; NOTE:
;   If you are reading this you are looking at the WRONG BIT OF CODE!!
;   The section above this (to 'END') is not included in the compilation.
