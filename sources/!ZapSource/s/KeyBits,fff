; Contains code for processing keyboard input
; $Id: KeyBits,fff,v 1.1.2.15 1999/08/19 23:56:39 ds Exp $

 GET h.ZapHeader
 GET h.Strings
 GET h.CreateFile
 GET h.Heap
 GET h.Menus
 GET h.Commands
 GET h.Execute
 GET h.ModeBits
 GET h.MiniBuff
 GET h.Cursors
 GET h.Template
 GET h.TMTVars
 GET h.Messages
 GET h.TMFs

 IMPORT err41
 IMPORT get_MacroBox
 IMPORT err3
 IMPORT Save
 IMPORT call_back

 EXPORT convert_key
 EXPORT show_key
 EXPORT get_key_string
 EXPORT find_key
 EXPORT do_ntimes
 EXPORT do_allfiles
 EXPORT do_eachleaf
 EXPORT do_linked_files
 EXPORT do_in_svc
 EXPORT init_settings
 EXPORT init_keys
 EXPORT add_key_table
 EXPORT add_key_entry
 EXPORT get_key_entry
 EXPORT find_key_entry
 EXPORT find_key_table_number
 EXPORT find_key_table
 EXPORT find_key_table_by_name
 EXPORT init_basemap
 EXPORT get_basemap
 EXPORT process_key
 EXPORT test_shiftctrl
 EXPORT process_a_key
 EXPORT process_converted_key
 EXPORT test_forkey
 EXPORT tmt_offsets
 EXPORT bad_keymap
 EXPORT Passthrough

; some constants
LONG	* 0
SHORT	* 1

MENUSHORTS	* LONG




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Key conversion				      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=wimp key number
;X R0=my key number | (or -1 = key is ambiguous) :-/

convert_key
 TEQ R0,#&7F
 BEQ ck_delete			; delete key
 CMP R0,#(ck_end-ck_start)/4
 MOVCS PC,R14			; standard character or fn key
 STMFD R13!,{R1,R14}
 BL special_test_shiftctrl	; read sc status in R1
 ADD PC,PC,R0,LSL#2		; branch
 DCD 0
ck_start
 B ck_code0
 B ck_num
 B ck_num
 B ck_num			; 00-03
 B ck_num
 B ck_num
 B ck_num
 B ck_num			; 04-07
 B ck_back
 B ck_tab
 B ck_ctrl
 B ck_ctrl			; 08-0B
 B ck_ctrl
 B ck_ret
 B ck_ctrl
 B ck_ctrl			; 0C-0F
 B ck_ctrl
 B ck_ctrl
 B ck_ctrl
 B ck_ctrl			; 10-13
 B ck_ctrl
 B ck_ctrl
 B ck_ctrl
 B ck_ctrl			; 14-17
 B ck_ctrl
 B ck_ctrl
 B ck_ctrl
 B ck_escape			; 18-1B
 B ck_slash
 B ck_slash
 B ck_home
 B ck_slash			; 1C-1F
 B ck_space
 B ck_null
 B ck_null
 B ck_hash			; 20-23
 B ck_null
 B ck_null
 B ck_null
 B ck_null			; 24-27
 B ck_null
 B ck_null
 B ck_star
 B ck_plus			; 28-2B
 B ck_null
 B ck_minus
 B ck_dot
 B ck_kslash			; 2C-2F
 B ck_digit
 B ck_digit
 B ck_digit
 B ck_digit			; 30-33
 B ck_digit
 B ck_digit
 B ck_digit
 B ck_digit			; 34-37
 B ck_digit
 B ck_digit			; 38-39
ck_end

ck_null
 LDMFD R13!,{R1,PC}

ck_delete
 STMFD R13!,{R1,R14}
 BL special_test_shiftctrl	; read sc status
 TST R1,#2
 MOVNE R0,#&1F			; ctrl delete
; B ck_ctrl			; fall through...

ck_ctrl
 TST R1,#1			; and return
 ADDNE R0,R0,#&100
 LDMFD R13!,{R1,PC}

ck_space
 TST R1,#2			; ctrl key?
 MOVNE R0,#0			; ctrl space
 B ck_ctrl

ck_code0
 MOV R0,#49			; inkey "2"
 ORR R0,R0,#&1200		; key code
 BL special_test_forkey
 MOVCC R0,#&30			; zero
 MOVCS R0,#&32			; two
; B ck_shift			; fall through...

ck_shift
 ADD R0,R0,#&100		; and return
 TST R1,#1
 ADDNE R0,R0,#&20
 LDMFD R13!,{R1,PC}

ck_num
 STMFD R13!,{R0}		; save ctrl letter
 ADR R14,ck_num_table		; inkey numbers
 LDR R0,[R14,R0,LSL #1]
 MOV R0,R0,LSL #16
 MOV R0,R0,LSR #16
 BL special_test_forkey		; is digit 0-9 pressed?
 LDMFD R13!,{R0}
 ADDCS R0,R0,#&30		; yes
 BCS ck_shift
 B ck_ctrl

ck_num_table
 = 39,&1A
 = 48,&11
 = 49,&12
 = 17,&13
 = 18,&14			; digit inkey numbers
 = 19,&15
 = 52,&16
 = 36,&17
 = 21,&18
 = 38,&19
 ALIGN

ck_back
 MOV R0,#21			; inkey "8"
 ORR R0,R0,#&1800
 BL special_test_forkey
 MOVCS R0,#&38
 BCS ck_shift			; ctrl 8

 MOV R0,#84			; inkey "H"
 ORR R0,R0,#&4100
 BL special_test_forkey
 MOVCS R0,#8
 BCS ck_ctrl			; ctrl H

 MOV R0,#47			; inkey "<-"
 ORR R0,R0,#&1E00
 BL special_test_forkey
 MOV R0,#&1C ; CS
 BCS ck_shctrl			; backspace

; MOV R0,#1			; inkey "H"
; BL test_forkey
; MOVCC R0,#0
; BLCC test_forkey
; MOVCC R0,#&1C
; BCC ck_shctrl			; backspace
; MOV R0,#-1
 LDMFD R13!,{R1,PC}

ck_tab
	MOV	R0,#38		; inkey "9"
	ORR	R0,R0,#&1900
	BL	special_test_forkey
	MOVCS	R0,#&39
	BCS	ck_shift	; ctrl 9

	MOV	R0,#37		; inkey "I"
	ORR	R0,R0,#&2E00
	BL	special_test_forkey
	MOVCS	R0,#9
	BCS	ck_ctrl		; ctrl I

	MOV	R0,#96		; inkey "TAB"
	ORR	R0,R0,#&2600
	BL	special_test_forkey
	MOVCS	R0,#&8A
	BCS	ck_shctrll	; ctrl I

	LDMFD	R13!,{R1,PC}

ck_ret
 MOV R0,#60			; inkey "kEnter"
 ORR R0,R0,#&6700
 BL special_test_forkey
 MOVCS R0,#&66
 BCS ck_shctrlk
 MOV R0,#101			; inkey "M"
 ORR R0,R0,#&5400
 BL special_test_forkey		; is M pressed
 MOVCS R0,#&0D			; ctrl M
 BCS ck_ctrl
 MOV R0,#&1D			; Return
; B ck_shctrl ; fall through

ck_shctrl
 AND R1,R1,#255
 TEQ R1,#1
 ADDEQ R0,R0,#&100
 TEQ R1,#2
 ADDEQ R0,R0,#&120
 TEQ R1,#3
 ADDEQ R0,R0,#&140
 LDMFD R13!,{R1,PC}

ck_shctrlk
 ADD R0,R0,#&100		; for s/c/sc
 AND R1,R1,#255
 TEQ R1,#1
 ADDEQ R0,R0,#&10
 TEQ R1,#2
 SUBEQ R0,R0,#&40
 TEQ R1,#3
 SUBEQ R0,R0,#&20
 LDMFD R13!,{R1,PC}

ck_shctrll
 ADD R0,R0,#&100		; for s/c/sc
 AND R1,R1,#255
 TEQ R1,#1
 ADDEQ R0,R0,#&10
 TEQ R1,#2
 ADDEQ R0,R0,#&20
 TEQ R1,#3
 ADDEQ R0,R0,#&30
 LDMFD R13!,{R1,PC}

ck_escape
 MOV R0,#56			; inkey "["
 ORR R0,R0,#&3100
 BL special_test_forkey
 MOVCC R0,#&1B
 MOVCS R0,#&2B
 BCC ck_shctrl			; escape key
 B ck_shift			; ctrl [

ck_slash
 ADD R0,R0,#&10
 B ck_shift

ck_home
 MOV R0,#52			; inkey "6"
 ORR R0,R0,#&1600
 BL special_test_forkey
 MOVCC R0,#&1E
 MOVCS R0,#&36
 BCC ck_shctrl			; home key
 B ck_shift			; ctrl 6

ck_hash
 MOV R0,#90			; keypad #
 ORR R0,R0,#&2500
 BL special_test_forkey
 MOVCC R0,#&23
 MOVCS R0,#&63
 BCC ck_null
 B ck_shctrlk

ck_star
 MOV R0,#91			; keypad *
 ORR R0,R0,#&2400
 BL special_test_forkey
 MOVCC R0,#&2A
 MOVCS R0,#&62
 BCC ck_null
 B ck_shctrlk

ck_plus
 MOV R0,#58			; keypad +
 ORR R0,R0,#&4B00
 BL special_test_forkey
 MOVCC R0,#&2B
 MOVCS R0,#&65
 BCC ck_null
 B ck_shctrlk

ck_minus
 MOV R0,#59			; keypad -
 ORR R0,R0,#&3A00
 BL special_test_forkey
 MOVCC R0,#&2D
 MOVCS R0,#&64
 BCC ck_null
 B ck_shctrlk

ck_dot
 MOV R0,#76			; keypad .
 ORR R0,R0,#&6600
 BL special_test_forkey
 MOVCC R0,#&2E
 MOVCS R0,#&67
 BCC ck_null
 B ck_shctrlk

ck_kslash
 MOV R0,#74			; keypad /
 ORR R0,R0,#&2300
 BL special_test_forkey
 MOVCC R0,#&2F
 MOVCS R0,#&61
 BCC ck_null
 B ck_shctrlk

ck_digit
 SUB R0,R0,#&30			; reduce to 0-9
 STMFD R13!,{R0}
 ADR R14,ck_knum_table
 LDR R0,[R14,R0,LSL #1]		; keypad inkey number
 MOV R0,R0,LSL #16
 MOV R0,R0,LSR #16
 BL special_test_forkey
 LDMFD R13!,{R0}
 ADDCC R0,R0,#&30
 ADDCS R0,R0,#&C0
 BCS ck_shctrll			; do keypad keys
 TST R1,#2
 BNE ck_shift			; control number
 B ck_null

ck_knum_table
 = 106,&65
 = 107,&5A
 = 124,&5B
 = 108,&5C
 = 122,&48
 = 123,&49
 =  26,&4A
 =  27,&37
 =  42,&38
 =  43,&39
 ALIGN

;X R0 saved R1=flags (b0=shift pressed b1=ctrl pressed)

special_test_shiftctrl
	STMFD	R13!,{R0,R2-R3,R9,R14}
	MOV	R0,#-1
	MOV	R1,#-1
	MOV	R9,#&15 ; RemV
	SWI     XOS_IntOff
	SWI	XOS_CallAVector
	MOVVS	R0,#-1
	SWI	XOS_IntOn
	CMN	R0,#1
	ANDNE	R1,R0,#7<<3
	ORRNE	R1,R0,R1,LSR #3
	BICNE	R1,R1,#7<<3
	BLEQ	test_shiftctrl
	LDMFD	R13!,{R0,R2-R3,R9,PC}^

;X R0 saved R1=flags (b0=shift pressed b1=ctrl pressed)

test_shiftctrl
	STMFD	R13!,{R0,R2-R3,R14}
	MOV	R3,#0			; flags
	MOV	R0,#&81			; shift either inkey = 0
	MOV	R1,#&FF
	MOV	R2,#&FF
	SWI	XOS_Byte
	CMP	R1,#&FF			; cmp and clv
	ORREQ	R3,R3,#1
	MOV	R0,#&81
	MOV	R1,#&FE			; ctrl either inkey = 1
	MOV	R2,#&FF
	SWI	XOS_Byte
	CMP	R1,#&FF
	ORREQ	R3,R3,#2
	ORR	R1,R3,#1<<31
	LDMFD	R13!,{R0,R2-R3,PC}

;E R0=inkey number (not eored) + (internal key code)<<8
;  R1=mod state + (key code)<<8, else -1
;X CS if key pressed |
;  R0 corrupt

special_test_forkey
	TEQ	R1,#0
	BMI	test_forkey
	MOV	R0,R0,LSR #8
	TEQ	R0,R1,LSR #8
	BICNES	PC,R14,#1<<29
	ORRS	PC,R14,#1<<29

;E R0=inkey number (not eored)
;X CS if key pressed |

test_forkey
	STMFD	R13!,{R1-R2,R14}
	EOR	R1,R0,#&FF
	MOV	R2,#&FF
	MOV	R0,#&81
	SWI	XOS_Byte
	CMP	R1,#&FF
	LDMFD	R13!,{R1-R2,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Menu show key subs					       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

 MACRO
$l L $x,$y
 [ MENUSHORTS=SHORT
$l = :LEN:"$x","$x"
 |
$l = :LEN:"$y","$y"
 ]
 MEND

;E R0=(my) key code R1=string R2=max len (inc. term)
;X Key name appended, with at least two spaces preceding it
;  String will be padded out to R2 bytes, inc. term.
;Internal flags in R2
; b0=shift b1=ctrl b2=F b3=1 b4=keypad

show_key
 FNJSR "R1-R3"
a$l
 LDRB R14,[R1],#1
 CMP R14,#&1F
 SUBCS R2,R2,#1
 BCS a$l
 SUB R1,R1,#1			; point at string terminator
 MOV R14,#32
s$l
 SUBS R2,R2,#1			; pad out to length R2
 STRGTB R14,[R1],#1
 BGT s$l
 MOV R2,#0			; flags
 STRB R2,[R1]			; string terminator
 CMP R0,#&1C0
 BCS fkeys$l			; &1C0-&1FF (k0-k9,F10-F12 and Ins)
 CMP R0,#&180
 BCS sh3			; &180-&1BF (F0-F9,TAB,CPY,ARROWS)
 CMP R0,#&20
 RSBHSS R14,R0,#&FF
 BCS char$l			  ; &20-&FF
mine$l				; &100-&17F (sc0 etc)
 ANDS R14,R0,#&1F
 TEQNE R14,#&1F
 BEQ spcdel$l			; space/delete
 CMP R0,#&160
 BCS sh15			; keypad
 CMP R14,#&0A
 BCS sh16			; not keypad
 CMP R0,#&120
 BCS sh15			; keypad
sh16
 CMP R14,#&1B
 BCS sh11			; ESC/BAK/RET/HOM
 ORR R2,R2,#2			; set CTRL
 CMP R0,#&120
 BCS sh14			; ctrl 0-9 etc
 CMP R0,#&100
 ORRCS R2,R2,#1			; shift
 ADD R0,R14,#&40		; letters
 B sh4
sh15
 AND R3,R0,#&0F0		; get middle digit
 TEQ R3,#&20
 ORREQ R2,R2,#2
 TEQ R3,#&40
 ORREQ R2,R2,#3
 TEQ R3,#&70
 ORREQ R2,R2,#1			; set sc type
 AND R0,R0,#&0F
 TEQ R0,#6
 ADREQ R3,ent$l
 BEQ letters$l			; Enter key on keypad
 ORR R2,R2,#1<<4		; set k type
 CMP R0,#0
 CMPNE R0,#8
 LDRLOB R0,[PC,R0]
 B sh4
 = " /*#-+ ."
sh14
 CMP R0,#&140
 ORRCS R2,R2,#1			; shift
 TEQ R14,#&B
 TEQNE R14,#&C
 TEQNE R14,#&D
 ADDEQ R0,R14,#'['-&B
 CMP R14,#&F
 MOVEQ R0,#'-'
 ADDHI R0,R14,#&20
 B sh4
spcdel$l
 CMP R0,#&120
 ORRCC R2,R2,#2			; ctrl
 CMP R0,#&100
 ORRCS R2,R2,#1			; shift
 ANDS R14,R0,#&1F
 MOVEQ R0,#&20
 MOVNE R0,#&7F
 B char$l			; this traps and replaces by string

bak$l L "<-|","<-|"
esc$l L "Esc","Esc"
del$l L "Del","Delete"
tab$l L "Tab","Tab"
cpy$l L "Cpy","Copy"
ins$l L "Ins","Insert"
pnt$l L "Pnt","Print"
ret$l L "Ret","Return"
hom$l L "Hom","Home"
ent$l L "Ent","Enter"
spc$l L "Spc","Spc"
 ALIGN

sh11
 TEQ R14,#&1B
 ADREQ R3,esc$l
 TEQ R14,#&1C
 ADREQ R3,bak$l
 TEQ R14,#&1D
 ADREQ R3,ret$l
 TEQ R14,#&1E
 ADREQ R3,hom$l
 CMP R0,#&120
 ORRCS R2,R2,#2			; ctrl
 CMP R0,#&20
 BCC letters$l
 CMP R0,#&120
 ORRCC R2,R2,#1
 CMP R0,#&140
 ORRCS R2,R2,#1
 B letters$l
char$l				; R0=character &20-&FF (20/7F trapped)
 TEQ R0,#&20
 ADREQ R3,spc$l
 BEQ letters$l
 TEQ R0,#&7F
 BNE sh4			; normal character
 ADR R3,del$l			; delete key
letters$l
 LDRB R14,[R3],#1
 ADD R3,R3,R14
letter$l
 LDRB R0,[R3,#-1]!
 STRB R0,[R1,#-1]!
 SUBS R14,R14,#1
 BNE letter$l
 B sh6
sh3
 AND R14,R0,#&30		; get shift/ctrl bits
 ORR R2,R2,R14,LSR#4
 ANDS R0,R0,#&0F		; key number
 ADREQ R3,pnt$l
 BEQ letters$l
 TEQ R0,#&0A
 ADREQ R3,tab$l
 BEQ letters$l
 TEQ R0,#&0B
 ADREQ R3,cpy$l
 BEQ letters$l
 CMP R0,#&0C			; arrow?
 ADDCS R0,R0,#&88-&0C
 ADDCC R0,R0,#'0'		; character
 ORRCC R2,R2,#4			; function key
 B sh4
fkeys$l
 AND R14,R0,#&30		; get shift/ctrl bits
 ORR R2,R2,R14,LSR#4
 AND R0,R0,#&0F			; key number
 TEQ R0,#&0D
 ADREQ R3,ins$l
 BEQ letters$l			; Insert key
 CMP R0,#10
 ORRCS R2,R2,#&C		; "F1-"
 ORRCC R2,R2,#&10		; "k-"
 SUBCS R0,R0,#10		; bring 0-9
 ADD R0,R0,#'0'
sh4
 STRB R0,[R1,#-1]!
 TST R2,#1<<3
 MOVNE R0,#'1'
 STRNEB R0,[R1,#-1]!
 TST R2,#1<<2
 MOVNE R0,#'F'
 STRNEB R0,[R1,#-1]!
 TST R2,#1<<4
 MOVNE R0,#'k'
 STRNEB R0,[R1,#-1]!		; keypad
sh6
 TST R2,#2
 MOVNE R0,#'^'
 STRNEB R0,[R1,#-1]!		; ctrl
 TST R2,#1
 MOVNE R0,#&8B
 STRNEB R0,[R1,#-1]!		; shift
 FNRTS

;E R0=my keycode
;X R0=pointer to a 0 term string in WB of string for this key #

get_key_string
 STMFD R13!,{R1-R3,R14}
 ADR R1,ge_s0
 MOV R2,#12
 BL show_key
 LDMVSFD R13!,{R1-R3,PC}
 FNLDR R0,wimp_block
ge17
 LDRB R14,[R0]
 TEQ R14,#&20
 ADDEQ R0,R0,#1
 BEQ ge17
 LDMFD R13!,{R1-R3,PC}
ge_s0 % 12

 LOCAL

;E R0=data for key command (types byte/word) R7=address of key command
;  R11=parameter type
;X R0=key code of lowest key with this command in default map / -1 if none |

find_key
 FNJSR "R1-R5"
 MOV R3,R0			; save key command data
 FNLDR R0,key_default		; default key map (for menus)
 BL find_key_table_maybe_name
 FNRTS MI			; not found
 LDR R1,[R0,#8]			; first char
 LDR R2,[R0,#12]		; last char
 LDR R4,[R0,#4]			; table address
a$l
 LDMIA R4!,{R0,R5,R14}		; read the words back
 TEQ R7,R0
 BEQ b$l			; possible match
d$l				; failed match
 ADD R1,R1,#1
 CMP R1,R2
 BCC a$l
 MOV R0,#-1
 FNRTS
b$l				; commands match
 LDR R0,[R7,#-4]
 TST R0,#7<<3			; parameter type (0=none)
 BEQ c$l
 TEQ R3,R5			; check data matches
 TEQEQ R11,R14			; ...and actual parameter types too
; MOV R0,R0,LSR#3
; ANDS R0,R0,#7			; paramter type
; BEQ c$l			; none
; TEQ R3,R14			; check data matches
 BNE d$l
c$l				; got a match
 MOV R0,R1
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; process key subs					     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;E R0-R8=args R10=address of sub of # format  R11=number of times
;X Sub at R10 executed R11 times as if it were a # sub. #

do_ntimes
 TEQ R11,#0
 MOVEQ PC,R14
 STMFD R13!,{R9,R11,R14}
 MOV R9,R0			; save arg R0
do1
 MOV R0,R9
 MOVS R14,PC			; return addr
 MOV PC,R10			; branch to sub
 LDMVSFD R13!,{R9,R11,PC}
 SUBS R11,R11,#1
 BGT do1
 LDMFD R13!,{R9,R11,PC}

;E R0-R8=args R10=address of sub with # format
;X Sub at R10 executed with R9 set up for each (valid) file #

do_allfiles
 STMFD R13!,{R9,R11,R14}
 MOV R11,R0			; save arg R0
 FNLDR R9,file_list
do15
 BL get_file_off
 FNLDR R14,file_num
 CMP R0,R14
 LDMCSFD R13!,{R9,R11,PC}	; no more files left
 LDR R14,[R9,#f_ptr]
 CMN R14,#1
 BEQ do16			; file deleted
 MOV R0,R11			; arg R0
 MOVS R14,PC			; return addr
 MOV PC,R10			; branch to the sub
 LDMVSFD R13!,{R9,R11,PC}
do16
 ADD R9,R9,#file_blk ; ? wind_blk ; next file
 B do15

;E R0-R6,R8-R9=args R10=address of a # sub
;X sub at R10 executed for each leaf window with R7 set up #

do_eachleaf
 STMFD R13!,{R7,R11,R14}
 MOV R11,R0			; save arg R0
 FNLDR R7,tem_list
do4
 LDR R0,[R7]
 TEQ R0,#0
 LDMEQFD R13!,{R7,R11,PC}
 MOV R0,R11
 MOVS R14,PC
 MOV PC,R10			; call the sub
 LDMVSFD R13!,{R7,R11,PC}
 ADD R7,R7,#32
 B do4				; next window

;E R0-R5=args R9=file R10=address of # sub
;X sub at R10 executed with R9 set up for each linked file to R9
;  R7 is set up to the link entry giving the original file #

do_linked_files
 STMFD R13!,{R6-R11,R14}
 MOV R11,R0			; save arg R0
 FNLDR R0,file_list
 SUB R6,R9,R0
 MOV R6,R6,LSR#f_shift		; offset of this file
 SUB R9,R0,#file_blk		; first file-1 block
 FNLDR R8,file_num
do13
 ADD R9,R9,#file_blk
 SUBS R8,R8,#1
 LDMMIFD R13!,{R6-R11,PC}
 LDR R0,[R9,#f_ptr]
 CMP R0,#0
 BMI do13			; not a valid file
 LDR R7,[R9,#f_links]		; links list
do14
 LDR R0,[R7]
 CMP R0,#0
 BMI do13			; no links left from this file
 LDR R0,[R7,#8]			; file linked to
 TEQ R0,R6
 ADDNE R7,R7,#16
 BNE do14
 MOV R0,R11			; arg 0
 MOVS R14,PC			; return addr
 MOV PC,R10			; call the sub
 ADD R7,R7,#16			; next block
 B do14

;E R0-R9=args R10=address of # sub
;X sub at R10 called in svc mode. R0-R9=output #

do_in_svc
 FNJSR
 SWI XOS_EnterOS		; Enter SVC mode
 MOVS R14,PC			; return address
 MOV PC,R10			; call the sub
 MOVS R14,PC			; get PC with flags
 BIC R14,R14,#3			; user mode
 TEQP R14,#0			; update flags
 MOV R0,R0			; Nop instruction
 FNRTS

 LOCAL


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Reading keys file info                                     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;X settings file read in and variables set from it #

init_settings
 FNJSR "R1"
 BL pre_read_keys
 ADR R0,read_keys
 ADR R1,str3$l
 BL str_readfile
 FNRTS

;X file keys read in and variables set from it #

init_keys
 FNJSR "R1"
 MOV R0,#-1
 FNSTR R0,key_basemapdef
 FNSTR R0,key_currentdef
 FNLDR R1,key_maplist
 LDR R0,[R1]
 TEQ R0,#0
 MOVPL R0,#-1
 STRPL R0,[R1,#20] ; memory leak :-(
 ADR R0,read_keys
 ADR R1,str4$l ; ...
 BL str_readfile ; ...
 ADRVC R0,read_keys
 ADRVC R1,str2$l
 BLVC str_readfile
 ADRVC R0,read_keys
 ADRVC R1,str1$l
 BLVC str_readfile
 ADRVC R0,read_keys
 ADRVC R1,str1a$l
 BLVC str_readfile
 FNRTS

str1$l = "<",|zap$|,"$Keys>",0
str1a$l = "ZapGenerated:Keys",0
str2$l = "<",|zap$|,"$Types>",0
str3$l = "<",|zap$|,"$Settings>",0
str4$l = "<",|zap$|,"$ClickSend>",0 ; ...
 ALIGN

 LOCAL

pre_read_keys
 STMFD R13!,{R1-R11,R14}
 BL null_macros			; clear macro defns & link (out of date)
 MOV R1,#0
 FNLDR R0,wimp_modelist
 STR R1,[R0]			; clear the modelist entries
 FNLDR R0,wimp_clicksend
 STR R1,[R0]			; clear the clicksend entries
 LDMFD R13!,{R1-R11,PC}

;E R10=pointer to keys file terminated by a 0
;X variables stored in keys file read #

read_keys
 STMFD R13!,{R1-R11,R14}
 ; BL null_macros			; clear macro defns & link (out of date)
 ; MOV R1,#0
 ; FNLDR R0,wimp_modelist
 ; STR R1,[R0]			; clear the modelist entries
 ; MOV R3,#0
cr10
 LDMVSFD R13!,{R1-R11,PC}	; error returned by a keys sub
 LDRB R0,[R10],#1
 TEQ R0,#0
 BEQ cr12			; reached file end
 TEQ R0,#'&' ; 10
 BNE cr10			; find a hex number
;crampersand
; LDMVSFD R13!,{R1-R11,PC}	; error returned by a keys sub
; LDRB R0,[R10],#1
; TEQ R0,#0
; BEQ cr12			; reached file end
; TEQ R0,#'&'
; BNE crampersand		; find a hex number
 MOV R1,R10
 BL hex_read			; find the value in R0
 TEQ R1,R10
 BEQ cr10			; if no hex digits, try again
 MOV R3,R0			; save (start of) range
 MOV R4,R0			; and set as end for the moment
 LDRB R14,[R1]
 TEQ R14,#'-'			; range given?
 BNE cr11
 LDRB R14,[R1,#1]!
 TEQ R14,#'&'
 ADDEQ R1,R1,#1			; maybe skip an "&"
 BL hex_read			; get end of range
 CMP R0,R3
 MOVCS R4,R0			; end of range if >= start
cr11
 LDRB R0,[R1],#1
 TEQ R0,#&20
 TEQNE R0,#9
 BEQ cr11			; skip white space
 SUB R10,R1,#1			; start of first argument
 ADR R14,ret$l			; return address
 MOV R0,R3			; command number
 CMP R0,#&200
 BCC rk_key
 CMP R0,#&210
 BCC rk_macro
 SUB R0,R3,#&300
 CMP R0,#&100
 BCC rk_othervar
 SUB R0,R3,#&400
 CMP R0,#&100
 BCC rk_keymap
 SUB R0,R3,#&500
 CMP R0,#&100
 BCC rk_mode
 SUB R0,R3,#&600
 CMP R0,#&100
 BCC rk_clicksend
 SUB R0,R3,#&800
 CMP R0,#&100
 BCC rk_keymapdef
 SUB R0,R3,#&1000		; file type
 CMP R0,#&1000
 BLS rk_mode			; &2000 is for untyped files
 CMP R3,#&1000000
 BGE rk_mode			; &2000 is for untyped files
 CMP R3,#&10000
 BGE rk_key
 ;B cr10				; not a valid code???
ret$l
 LDMVSFD R13!,{R1-R11,PC}	; return in case of error
 BL str_next			; start of next line
 BCC cr10			; start of a new line
cr12
 LDMFD R13!,{R1-R11,PC}

 LOCAL

rk_othervar
 SUB R3,R3,#&300		; variable number
 CMP R3,#(varend$l-varstart$l)/8; total number
 MOVHS PC,R14
 LDR R7,[PC,R3,LSL #3]
 ADD PC,PC,R3,LSL #3	; jump into table...
varstart$l
 & wimp_dateformat	; 0
 B rk_string
 & wimp_timeformat	; 1
 B rk_string
 & font_name		; 2
 B rk_string
 & wimp_bottomgap	; 3
 B rk_buffernum
 & font_size		; 4
 B rk_buffernum
 & font_topred		; 5
 B rk_buffernum
 & font_botred		; 6
 B rk_buffernum
 & wimp_eolstring	; 7
 B rk_string
 & car_left		; 8
 B rk_buffernum
 & car_right		; 9
 B rk_buffernum
 & car_top		; &0A
 B rk_buffernum
 & car_bottom		; &0B
 B rk_buffernum
 & wimp_leftgap		; &0C
 B rk_buffernum
 & wimp_rightgap	; &0D
 B rk_buffernum
 & wimp_selecttype	; &0E
 B rk_string		; new SJA
 & wimp_adjusttype	; &0F
 B rk_string		; new SJA
 & font_leftred		; &10
 B rk_buffernum
 & font_rightred	; &11
 B rk_buffernum
 & 0			; &12
 MOV PC,R14
 & 0			; &13
 MOV PC,R14
 & mini_bufl		; &14
 B rk_buffernum
 & wimp_indentstring	; &15
 B rk_string
 & car_flashon		; &16
 B rk_buffernum
 & car_flashoff		; &17
 B rk_buffernum
 & wimp_minaw		; &18
 B rk_buffernum
 & wimp_maxaw		; &19
 B rk_buffernum
 & font_namelow		; &1A
 B rk_string
 & font_namehigh	; &1B
 B rk_string
 & wimp_attr		; &1C
 B rk_buffernum
 & tem_offsets		; &1D
 B rk_string_tmt
 & font_offsets		; &1E
 B rk_string_tmt
 & wimp_sofstring	; &1F
 B rk_string
 & wimp_eofstring	; &20
 B rk_string
 & wimp_backupdelay	; &21
 B rk_buffernum
 & startup_command	; &22
 B rk_string
 & default_mode		; &23
 B rk_string
varend$l

	LOCAL

rk_keymap
	FNJSR	"R4,R5"
	SUB	R3,R3,#&400	; variable number
	TEQ	R3,#0
	BNE	declare$l
	PUSH	"R10"
	BL	str_readnum
	FNSTR	R0,key_default,VC
	PULL	"R14",VC
	FNRTS	VC
	PULL	"R10"		; not a number? must be a name
	BL	rk_keymap_getname
	FNSTR	R14,key_default,VC
	FNRTS
declare$l
	BL	str_readnum
	MOVVC	R1,R0		; min num
	BLVC	str_readnum
	FNRTS	VS
	ADD	R2,R0,#1	; max num+1
	BL	rk_keymap_getname
	FNRTS	VS
	MOV	R0,R3		; table number
	MOV	R3,R14		; ptr to name
	BL	add_key_table
	FNRTS

	LOCAL

rk_keymapdef
	FNJSR	"R4,R5"
	BL	str_readnum
	MOVVC	R1,R0		; min num
	BLVC	str_readnum
	FNRTS	VS
	ADD	R2,R0,#1	; max num+1
	FNLDR	R4,key_maplist	; find first free keymap number
	MOV	R5,#1
find$l	MOV	R0,R5
	BL	find_key_table
	ADDPL	R5,R5,#1
	BPL	find$l
	CMP	R5,#256
	BLHS	toomany$l
	BLVC	rk_keymap_getname
	FNRTS	VS
	MOV	R0,R5		; table number
	FNSTR	R0,key_currentdef
	MOVS	R3,R14		; ptr to name
	BLEQ	noname$l
	FNRTS	VS
	BL	add_key_table
	MOV	R4,R10
	BL	str_skip
	CMP	R0,#32		; is there a basemap name?
	MOVLO	R0,#0
	BLO	gotbase$l	; ...no
	FNLDR	R1,wimp_kbdbuf
	MOV	R2,R10
	MOV	R3,#256
	MOV	R4,#32
	BL	strmove		; copy its name & terminate with NUL
	FNLDR	R0,wimp_kbdbuf
	BL	find_key_table_number
	BMI	nobase$l
	FNRTS	VS
gotbase$l
	FNSTR	R0,key_basemapdef
	FNRTS
noname$l ERR	"zap_e_nokeyname"
toomany$l ERR	"zap_e_toomanymaps"
nobase$l
	ADR	R0,nobasemsg$l
	MOV	R4,R5
	FNLDR	R5,wimp_kbdbuf
	BL	lookup_error
	FNRTS
nobasemsg$l &	0
	=	"zap_e_nokeybasename",0
	ALIGN

	LOCAL

;E R10=string containing keymap (term <=32)
;X Leading spaces skipped; R10 updated
;  R14=heap block containing name
rk_keymap_getname
	FNJSR	"R4,R5"
	BL	str_skip
	CMP	R0,#32
	MOVLO	R14,#0		; no name for keymap?
	FNRTS	LO
	MOV	R4,R10
len$l	LDRB	R0,[R10],#1	; keymap name len (stop at ctrl)
	CMP	R0,#32
	BHS	len$l
	SUB	R0,R10,R4
	SUB	R10,R10,#1
	BL	heap_claim	; heap block for name...
	FNRTS	VS
	MOV	R14,R0
copy$l	LDRB	R5,[R4],#1	; ...put name in heap block
	TEQ	R4,R10
	STRB	R5,[R0],#1
	BNE	copy$l
	MOV	R5,#0
	STRB	R5,[R0]
	FNRTS

 LOCAL

;E The rk_keys subs have on entry (range of codes)
;  R3=lowest code R4=highest code (inc) R10=pointer in file
;X may corrupt R0-R9 and (idealy) update R10 #

;internal R1=current keynum R2=command addr R3=parameter
;	  R4=end keynum R5=keymap number
;	  R6=paramter type 0=none 1=num 2=keynum

rk_key
 FNJSR
 FNLDR R5,key_currentdef
 TEQ R5,#0
 MOVMI R5,R3,LSR#16		; get keymap number
 MOV R3,R3,LSL #16		; range start
 MOV R3,R3,LSR #16
 MOV R4,R4,LSL #16		; range end
 MOV R4,R4,LSR #16
 CMP R4,R3
 FNRTS LT			; wrong way around
 CMP R4,#&200
 FNRTS CS			; too large
 LDRB R0,[R10]
 TEQ R0,#'*'
 FNLDR R6,key_basemapdef,EQ
 BEQ copy$l			; duplicate (base map)
 TEQ R0,#'#'
 MOVEQ R6,R5
 BEQ copy$l			; duplicate (current map)
 BL read_command		; get command to R7,R1,R6
 MOVVS R1,#0		; the bug...? nope...
 MOVVS R7,#0
 MOVVS R6,#0
 BVS read$l			; command not found
 CMP R0,#0
 BLMI err41			; bad args
 FNRTS VS
read$l				; read the command
 ADDS R2,R7,#0			; command address and CLV
 MOV R0,R1			; parameter
 MOV R1,R3			; current keynum
 MOV R3,R0			; parameter
nextkey$l
 TEQ R6,#2
 MOVEQ R3,R1			; paramter is keynum
 MOV R0,R5			; keymap
 BL add_key_entry
 FNRTS VS
 ADD R1,R1,#1			; next key
 CMP R1,R4
 BLS nextkey$l			; loop through range
 FNRTS
copy$l
 ADD R10,R10,#1			; character after the "*"
 BL str_readnum
 MOVVS R0,R3			; replace with range start if none
 TEQ R6,#0
 MOVMI R6,R0,LSR#16		; source keymap number
 MOV R7,R0,LSL #16
 MOV R7,R7,LSR #16		; source range start
 MOV R8,R3			; current keynum
loop$l
 MOV R0,R6
 MOV R1,R7
 BL find_key_entry		; find source key (don't validate!!)
 FNRTS VS
 CMP R0,#0
 FNRTS LE			; not found
 STMFD R13!,{R6}
 LDMIA R0,{R2,R3,R6}		; cmd, param, param type
 MOV R0,R5			; keymap
 MOV R1,R8			; key number
 BL add_key_entry
 LDMFD R13!,{R6}
 FNRTS VS
 ADD R8,R8,#1
 ADD R7,R7,#1
 CMP R8,R4			; R4=range end
 BLS loop$l
 FNRTS

rk_macro
 FNJSR
 SUBS R3,R3,#&200		; macro number
 FNLDR R5,fnd_macros		; address of search macros table
 ADD R9,R5,R3,LSL #search_macro_log
; ADD R9,R9,R3,LSL#4		; +R3*16 to give +R3*20 in total
 MOV R1,R9
 MOV R2,R10
 MOV R3,#8			; experiment...
 MOV R4,#&20			; no spaces...!
 BL strmove			; copy first string
 BL str_jump			; skip this string
 ADD R1,R9,#8			; (was 4)...
 MOV R2,R10
 MOV R3,#(search_macro_size - 8)
 MOV R4,#&1F	; terminated by < 32 (was 32)
 BL strmove			; copy second string
 BL str_jump			; skip this string
 FNRTS

; R7=offset in vars of buffer in which to place the string

rk_string
 FNJSR
 MOV R0,R10
 BL str_len
 ADD R1,R0,#4
 LDR R0,[R12,R7]
 BL heap_ensure
; FNRTS VS
 STRVC R0,[R12,R7]
 MOVVC R1,R0
 MOVVC R2,R10
 BLVC strcopy
 SUBVC R10,R2,#1			; terminator
 FNRTS

rk_string_tmt
 FNJSR
 MOV R0,R10
 BL str_len
 ADD R1,R0,#4
 ADR R2,tmt_offsets
 LDR R0,[R2,R7]
 CMP R0,#0
 BEQ claimsome_tmt

 BL heap_ensure
 FNRTS VS
nearendof_rk_string_tmt
 ADR R2,tmt_offsets		; OTT.
 STR R0,[R2,R7]
 MOV R1,R0
 MOV R2,R10
 BL strcopy
 SUB R10,R2,#1			; terminator
 FNRTS

claimsome_tmt
 MOV R0,R1
 BL heap_claim
 BVC nearendof_rk_string_tmt
 FNRTS

tmt_offsets
 & 0 ; tem_offsets...
 & 0 ; font_offsets...
 & 0 ; defeat anti-aliasing...?

; DCD &2001F
;Fontoffsets
; CMP R2,#17
; BEQ fontoffs_proviindftval
; MOV R10,R0
; MOV R7,#font_offsets
; B rk_string_tmt
;
;fontoffs_proviindftval
; CMP R0,#0
; ADREQ R0,font_off_titlestr
; MOVEQ PC,R14
;
; CMP R0,#2
; MOVEQ R0,#12 ; buffer length...
; MOVEQ PC,R14
;
; CMP R0,#1
; MOVNE PC,R14
; FNJSR "R1-R11"
; LDR R0,tmt_offsets + font_offsets
; CMP R0,#0
; ADREQ R0,adrofnullbyte
; FNRTS EQ
; ;
; FNRTS
;
;font_off_titlestr
; = "Offsets",0
;
;adrofnullbyte
; = "0,0,0,0",0
; ALIGN

;adrofthisbyte
; DCD 0
; DCD 0
; DCD 0

; clear macro buffer |

null_macros
 STMFD R13!,{R1-R7,R14}
 BL get_MacroBox
 LDR R6,[R7]
 MOV R2,#3
 FNLDR R1,fnd_macros
nu1
 MOV R0,#0
 STRB R0,[R1]
 STRB R0,[R1,#4]
 MOV R0,R2
 BL cw_indtxt
 ADD R0,R2,#1
 ADD R1,R1,#8
 BL cw_indtxt
 ADD R1,R1,#(search_macro_size - 8)
 ADD R2,R2,#2
 CMP R2,#35
 BCC nu1
 LDMFD R13!,{R1-R7,PC}

 LOCAL

; wimp_modelist conatains a 0 terminated list of blocks of the form:
;
;	#0  Block length (inclusive of this word)
;	#4  b0-b23 Filetype to match (0-fff=filetype &1000=untyped &2000=any)
;	    b31=load even if shift not pressed
;	#8  Command address to execute after file loaded / 0 if none / b0 set
;	#12 Command data of command to execute
;	#16 Wilcarded filename to match (null if any) 0 term
;	    Name of mode 0 terminated
;	    Align to start of next block

;E For the keys subs, R3=code/5xx for path R10=pointer in file
;X may corrupt R0-R9 and (idealy) update R10 #

rk_mode
 FNJSR
 FNLDR R5,wimp_modelist		; start of list
 MOV R1,R5			; current pointer
a$l
 LDR R0,[R1]			; length of this block
 CMP R0,#0
 ADDGT R1,R1,R0
 BGT a$l			; next block
 SUB R6,R1,R5			; offset of the last entry
 MOV R0,R10
 BL str_len			; find the length of this line INC TABS!
 ADD R1,R6,R0			; string length
 ADD R1,R1,#&20			; + bits at end &10 blk +12 terminators
 MOV R0,R5
 BL heap_ensure
 FNRTS VS
 FNSTR R0,wimp_modelist
 ADD R5,R0,R6			; start of new entry
 ADD R6,R5,#&10			; start of string etc.
 MOV R0,#0
 STR R0,[R5,#8]			; no command to execute
 SUBS R3,R3,#&1000		; file type (1000=untyped)
 BLT path$l			; was a path name
 MOV R0,#0
 STRB R0,[R6],#1		; no filename to match
getmode$l			; R3=filetype Read the path
 LDRB R0,[R10]
 TEQ R0,#'+'
 ORREQ R3,R3,#1<<31		; mark as auto load
 ADDEQ R10,R10,#1		; skip the plus
 STR R3,[R5,#4]			; save the filetype
c$l				; save mode name (not loaded yet usually!)
 LDRB R0,[R10],#1
 CMP R0,#&09			; what about tabs...? TT?
 CMPNE R0,#&20			; what about tabs...? TT?
 SUBLT R10,R10,#1		; don't skip the EOL!
 BLT end$l			; reached the end of the mode name
 TEQ R0,#':'
 STRNEB R0,[R6],#1
 BNE c$l
command$l			; get command string following
 PUSH "R5-R6"
 BL read_command		; R7=command/b0 set
 ORR R7,R7,R6,LSL #28
 PULL "R5-R6"
 MOVVS R7,#0
 ADDVSS R14,R14,#0		; CLV
 ;FNRTS VS
 CMP R0,#0
 BLMI err41
; FNRTS VS
 STR R7,[R5,#8]			; command address
 STR R1,[R5,#12]		; command parameter

; the above lines after command$l were if wrong...
; STRB R0,[R6],#1
; B c$l

end$l				; got the mode name
 MOV R0,#0
 STRB R0,[R6],#4		; add mode name terminator
; STRB R0,[R6],#1		; add mode name terminator
; ADD R6,R6,#3
 BIC R6,R6,#3			; align
 SUB R0,R6,R5
 STR R0,[R5]			; write block length
 MOV R0,#0
 STR R0,[R6],#4			; block list terminator
 FNRTS
path$l
 BL str_readnum
 FNRTS VS
 ADDS R3,R0,#0			; the filetype to match
 MOVMI R3,#&2000		; match any type
b$l
 LDRB R0,[R10],#1
 CMP R0,#&20
 STRGTB R0,[R6],#1
 BGT b$l
 MOV R0,#0
 STRB R0,[R6],#1		; copy accross the pathname to match
 BL str_skip			; skip spaces in keys file
 B getmode$l
;command$l			; get command string following
; PUSH "R5-R6"
; BL read_command		; R7=command/b0 set
; PULL "R5-R6"
; FNRTS VS
; CMP R0,#0
; BLMI err41
; FNRTS VS
; STR R7,[R5,#8]			; command address
; STR R1,[R5,#12]		; command parameter
; B end$l

; R7=offset in vars buffer to put word

rk_buffernum
 FNJSR
 MOV R0,R10
 FNLDR R1,wimp_block
 MOV R2,#0
 SWI XOS_EvaluateExpression
 FNRTS VS
 TEQ R1,#0
 BLNE err3
; FNRTS VS
 STRVC R2,[R12,R7]
 FNRTS

rk_buffernum_tmt
 FNJSR
 MOV R0,R10
 FNLDR R1,wimp_block
 MOV R2,#0
 SWI XOS_EvaluateExpression
 FNRTS VS
 TEQ R1,#0
 BLNE err3
; FNRTS VS
 ADRVC R1,tmt_offsets
 STRVC R2,[R1,R7]
 FNRTS


	LOCAL

; wimp_clicksend conatains a 0 terminated list of blocks of the form:
;
;	#0   Block length (inclusive of this word)
;	#4   Command address / b0 set (takes string)
;	#8   Flags word - mode types (see e_interrogate 14)
;	#12  Offset to mode names (0 if none)
;	#16  Function address / b0 set (early call)
;	#20  Function address / b0 set (late call)
;            (Takes int; returns string)
;	#24  String to search for (null = call e_returnword)
;	     String to match against
;	     Mode names (comma separated)
;
; The command is assumed to take a string parameter

;E For the keys subs, R3=code/5xx for path R10=pointer in file
;X may corrupt R0-R9 and (ideally) update R10 #

rk_clicksend
	FNJSR
	FNLDR	R5,wimp_clicksend	; start of list
	MOV	R1,R5			; current pointer
a$l	LDR	R0,[R1]			; length of this block
	CMP	R0,#0
	ADDGT	R1,R1,R0
	BGT	a$l			; next block
	SUB	R6,R1,R5		; offset of the last entry
	MOV	R0,R10
	BL	str_len			; find length of this line INC TABS!
	ADD	R1,R6,R0		; string length
	ADD	R1,R1,#&20		; + bits at end +12 terminators
	MOV	R0,R5
	BL	heap_ensure
	FNRTS	VS
	FNSTR	R0,wimp_clicksend
	ADD	R5,R0,R6		; start of new entry
	ADD	R6,R5,#24		; start of string etc.
	MOV	R0,#0			; allow in text-based mode
	MOV	R1,#1<<14		; no command to execute
	MOV	R2,#0			; no mode info
	MOV	R3,#0			; no function to call
	MOV	R4,#0			; no function to call
	STMIB	R5,{R0-R4}
	BL	str_skip		; skip spaces in keys file
	LDRB	R0,[R10]
	TEQ	R0,#'.'			; if '.', we want to use e_returnword
	BNE	b$l
	LDRB	R0,[R10,#1]!		; ...or maybe a function?
	TEQ	R0,#'.'
	BEQ	b$l
	TEQ	R0,#9
	TEQNE	R0,#32
	BEQ	c$l
	MOV	R0,#1<<31
	BL	read_cmd$l		; if so, get it and skip the string
	STRVC	R7,[R5,#16]		;  matching section
	MOVVC	R0,#0
	STRVCB	R0,[R6],#1
	BVC	e$l
	FNRTS
b$l	LDRB	R0,[R10],#1		; string preceding word
	CMP	R0,#&20
	STRGTB	R0,[R6],#1
	BGT	b$l
c$l	MOV	R0,#0
	STRB	R0,[R6],#1
	BL	str_skip
	LDRB	R0,[R10]
	TEQ	R0,#'.'			; if '.', we want to use e_returnword
	BNE	d$l
	LDRB	R0,[R10,#1]!		; ...or maybe a function?
	TEQ	R0,#'.'
	BEQ	d$l
	TEQ	R0,#9
	TEQNE	R0,#32
	BEQ	e$l
	MOV	R0,#1<<31
	BL	read_cmd$l
	STRVC	R7,[R5,#20]
	BVC	e$l
	FNRTS
d$l	LDRB	R0,[R10],#1		; string to match word against
	CMP	R0,#&20
	STRGTB	R0,[R6],#1
	BGT	d$l
e$l	MOV	R0,#0
	STRB	R0,[R6],#1
	BL	str_skip		; skip spaces in keys file
	MOV	R0,#0
	BL	read_cmd$l
	FNRTS	VS
	STR	R7,[R5,#4]		; command address
	LDRB	R0,[R10]
	TEQ	R0,#10
	TEQNE	R0,#0
	BEQ	z$l
	MOV	R1,#0
	BL	str_skip
	LDRB	R0,[R10]
	TEQ	R0,#'='			; mode names?
	BEQ	h$l
	TEQ	R0,#'~'
	ADDEQ	R10,R10,#1
f$l	BL	str_skip		; get mode types
f1$l	LDRB	R0,[R10]
	TEQ	R0,#0
	TEQNE	R0,#10
	BEQ	g$l
	ADR	R0,text$l
	MOV	R2,#1<<14
	BL	strleft$l
	ADR	R0,bin$l
	MOV	R2,#1<<0
	BL	strleft$l
	ADR	R0,code$l
	MOV	R2,#1<<1
	BL	strleft$l
	ADR	R0,token$l
	MOV	R2,#1<<2
	BL	strleft$l
	ADR	R0,tokn1$l
	BL	strleft$l
	ADR	R0,tokn2$l
	BL	strleft$l
	ADR	R0,tw$l
	MOV	R2,#1<<3
	BL	strleft$l
	ADR	R0,tb$l
	MOV	R2,#1<<4
	BL	strleft$l
	BL	str_skip
	TEQ	R0,#','			; comma separator?
	BNE	f1$l
	ADD	R10,R10,#1
	B	f$l
g$l	TEQ	R1,#0
	STRNE	R1,[R5,#8]		; only store if some types specified
	B	z$l
strleft$l
	STMFD	R13!,{R14}		; partial match code
	MOV	R14,#0
sa$l	LDRB	R3,[R0],#1
	TEQ	R3,#0			; end of match?
	BEQ	sb$l
	LDRB	R7,[R10,R14]
	ADD	R14,R14,#1
	TEQ	R7,#','
	TEQ	R7,#32			; end of match
	TEQNE	R7,#10			; (OK since spaces already skipped)
	TEQNE	R7,#9
	TEQNE	R7,#0
	BEQ	sb$l
	BIC	R7,R7,#32		; upper case
	TEQ	R7,R3
	BEQ	sa$l
	LDMFD	R13!,{PC}		; match failed
sb$l	ADD	R10,R10,R14
	ORR	R1,R1,R2		; got match, so set flag
	ADD	R13,R13,#4		; dump return address
	B	f$l			; and loop :-)
text$l	=	"TEXT",0
bin$l	=	"BINARY",0
code$l	=	"CODE",0
token$l	=	"TOKENISED",0
tokn1$l	=	"TOKENIZED",0	; alt TOKENISED
tokn2$l	=	"BASIC",0	; alt TOKENISED
tw$l	=	"TASKWINDOW",0
tb$l	=	"THROWBACK",0
	ALIGN
h$l	ADD	R10,R10,#1
	BL	str_skip
	SUB	R0,R6,R5
	STR	R0,[R5,#12]		; mode names offset
i$l	LDRB	R0,[R10],#1		; mode names
	CMP	R0,#&20
	STRGTB	R0,[R6],#1
	BGT	i$l
	MOV	R0,#0
	STRB	R0,[R6],#1
	STR	R0,[R5,#8]		; no mode type info

z$l	ADD	R6,R6,#3		; Tidy up
	BIC	R6,R6,#3		; align
	SUB	R0,R6,R5
	STR	R0,[R5]			; write block length
	MOV	R0,#0
	STR	R0,[R6],#4		; block list terminator
	FNRTS

read_cmd$l
	FNJSR	"R5";"R5,R6"
	MOV	R5,R0
	BL	str_skip
	ORR	R0,R5,R10		; R0=0 or 1<<31
	BL	look_key_command	; parameter type NOT checked
	FNRTS	VS
	MOV	R7,R0
	TEQ	R5,#0
	BLMI	str_fnseparator
	BLPL	str_separator
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Key table handling					     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; key_maplist is a -1 terminated list of blocks of the form:
; #0 Keymap number
; #4 Address of keymap table (of form command addr,parameter)
; #8 First character code cached
; #12 Last character cached (+1)
; #16 Keymap name ptr (heap block)
; NB the command addresses can be 0 or the bit zero set form.

; Accessed directly by some routines below; addressed directly by BASEMAPLIST

;E R0=table number R1=min key number R2=max key number (+1) R3=keymap name
;X key table added to list (or ensured if already there)

add_key_table
 STMFD R13!,{R1-R4,R14}
 MOV R3,R1			; min key num
 MOV R4,R0			; table num
 FNLDR R1,key_maplist
ad10
 LDR R0,[R1],#20		; get next entry
 CMP R0,#0
 BMI ad11			; gone off end of table
 TEQ R0,R4
 BNE ad10
 SUB R1,R1,#20
 LDR R0,[R1,#4]
 BL heap_free			; free old keymap table
 LDMVSFD R13!,{R1-R4,PC}
 B ad12				; add this map
ad11
 STR R4,[R1,#-20]!		; save table number
 FNLDR R0,key_maplist
 SUB R4,R1,R0			; current length of table
 ADD R1,R4,#32			; add entry + terminator
 BL heap_ensure
 LDMVSFD R13!,{R1-R4,PC}
 FNSTR R0,key_maplist
 ADD R1,R0,R4			; entry to complete
 MVN R0,#0
 STR R0,[R1,#20]		; terminator
ad12
 STR R3,[R1,#8]			; min key num
 STR R2,[R1,#12]		; max key num
 LDR R0,[R13,#8]
 STR R0,[R1,#16]		; keymap name
 SUB R0,R2,R3
 ADD R0,R0,R0,LSL #1
 MOV R0,R0,LSL #2		; 12 bytes each entry
 MOV R3,R0			; save num of bytes
 BL heap_claim
; LDMVSFD R13!,{R1-R4,PC}
 STRVC R0,[R1,#4]
 MOVVC R2,R0			; buffer
 MOVVC R1,#0
 BLVC fill_words			; clear keytable to zeros
 LDMFD R13!,{R1-R4,PC}

;E R0=table number R1=key number R2=command R3=parameter R6=param type

add_key_entry
 FNJSR
 BL find_key_entry		; don't validate!
 CMP R0,#0
 STMNEIA R0,{R2,R3,R6}
 FNRTS

;E R0=table number R1=key number
;X R0=address of key entry / 0 if not found
;  Key entry has been validated - ie if the command is not loaded then
;  it is and the key entry updated with its address #

get_key_entry
 FNJSR
 BL find_key_entry
 TEQ R0,#0
 FNRTS EQ			; not found
 LDR R14,[R0]
 TST R14,#1
 FNRTS EQ			; key entry ok
 PUSH "R6-R7"
 MOV R6,R0			; address of key entry
 MOV R7,R14			; command with b0 set
 BL validate_command
 STRVC R7,[R6]			; new command address
 MOVVC R0,R6			; key entry pointer
 PULL "R6-R7"
 FNRTS

 LOCAL

;E R0=table number R1=key number
;X R0=address of key entry / 0 if not found |
;  Key entry points to: command/0/b0 set, parameter, type

find_key_entry
 FNJSR "R2"
 FNLDR R2,key_maplist
loop$l
 LDR R14,[R2],#20
 TEQ R14,R0
 BMI notfound$l			; no more keymaps
 BNE loop$l			; doesn't match so onto next map
 SUB R0,R2,#20			; this key map address
 LDR R14,[R0,#12]
 CMP R1,R14
 BCS notfound$l			; off the top
 LDR R14,[R0,#8]
 SUBS R14,R1,R14
 BCC notfound$l			; off the bottom
 LDR R0,[R0,#4]
 ADD R0,R0,R14,LSL #2
 ADD R0,R0,R14,LSL #3		; 12 bytes each
 FNRTS
notfound$l
 MOV R0,#0
 FNRTS

;E R0->table name or =table number
;X R0=table number / -ve if none
;  (also PL if found, MI if not)
find_key_table_number
	FNJSR
	BL	find_key_table_maybe_name
	LDRPL	R0,[R0]
	FNRTS

;E R0->table name or =table number
;X R0=table info block pointer / 0 if none
;  (also PL if found, MI if not)

find_key_table_maybe_name
	CMP	R0,#256
	BHS	find_key_table_by_name
;	B	find_key_table

 LOCAL

;E R0=table number
;X R0=table info block pointer (20 bytes) /0 if none |
;  (also PL if found, MI if not)
find_key_table
 FNJSR "R1"
 FNLDR R1,key_maplist
loop$l
 LDR R14,[R1],#20
 TEQ R0,R14
 MOVMI R0,#0			; not found
 FNRTS MI
 BNE loop$l
 SUB R0,R1,#20
 FNRTS

;E R0->table name
;X R0=table info block pointer / 0 if none
;  (also PL if found, MI if not)

	LOCAL

find_key_table_by_name
	FNJSR	"R1-R4"
	MOV	R3,R0
	FNLDR	R4,key_maplist
loop$l	LDR	R0,[R4],#20
	TEQ	R0,#0
	MOVMI	R0,#0
	FNRTS	MI
	LDR	R2,[R4,#-4]
	MOV	R1,R3
	TEQ	R2,#0
	BEQ	loop$l
	BL	strCMP
	BNE	loop$l
	SUBS	R0,R4,#20
	FNRTS


 LOCAL

;E R8
;X Base map, current map, help map, default map set up for current mode

init_basemap
	FNJSR	"R0-R2"
	BL	get_basemap
	TEQ	R1,#0
	BEQ	setmap$l
	MVN	R1,#0
	ADR	R2,warn$l
	MOV	R3,R8
	BL	call_back
	MOV	R0,#0
setmap$l
	STRB	R0,[R8,#w_basemap]
	STRB	R0,[R8,#w_currentmap]
	STRB	R0,[R8,#w_helpmap]
	STRB	R0,[R8,#w_defaultmap]
	FNRTSS
warn$l	FNJSR	"R8-R10"
	MOV	R8,R11
	BL	bad_keymap
	FNRTS

;X R0,R1 corrupt; warning displayed

bad_keymap
	FNJSR	"R1"
	ADR	R0,b$l
	MOV	R1,#1<<29
	BL	warn_user
	FNRTS
b$l	=	"zap_UnkKeymap",0
	ALIGN

;E R8
;X R0=basemap R1=0 / R0=0 R1=1

get_basemap
	FNJSR
	ADR	R0,basemap$l
	BL 	get_mode_variable
	BEQ	nomap$l			; no basemap variable - use default
	BL 	find_key_table_number
	MOVVC	R1,#0
	FNRTS	VC
nomap$l	MOVVC	R1,#0			; 0 if no map name
	MOVVS	R1,#1			; 1 if error
	FNLDR	R0,key_default
	BL 	find_key_table_number
	MOVMI	R1,#1
	TEQ	R1,#0
	MOVNE	R0,#0
	FNRTS
basemap$l =	"Basemap",0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; P R O C E S S	  K E Y	  S U B S			       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=wimp key number / -1 if failed to fetch any more
;  R6=number of key presses buffered so far
;  R7=address of buffered command if R6<>0
;  R8-R10=input caret (in correct window)
;X If R0>=0 then R6,R7 updated and try and get another key
;  If R0<0 then carry on with main loop. #

process_key
 FNJSR "R5,R11" ; ,R11" ; "R5" R11!!!
 MOVS R5,R0			; wimp key number
 BLPL convert_key		; convert R0 to zap key number
 BL process_converted_key	; do the key action
 FNRTS

 LOCAL

;E R0=zap key number
;  R5=wimp key number/-1 if failed to get more/&200 if not valid
;  R6=num buffered R7=buf command if R6<>0 R8-R10
;X R0>=0 to get another key, R0<0 to carry on sending keys #

process_converted_key
 FNJSR "R1-R5"
 CMP R5,#0			; any more keys?
 BMI cantadd$l			; run out of buffered input
 MOV R1,R0			; key number
 MOV R3,R0			; and in R3 for buffering
 LDRB R0,[R8,#w_currentmap]	; current key map
 BL get_key_entry		; R0=key entry address/0 if none
 BLVC test_exec$l
 FNRTS VS			; may have loaded a module
 MOVS R4,R0			; save key entry
 ADREQ R4,null$l		; no entry!
 LDRB R0,[R8,#w_basemap]	; restore basemap
 STRB R0,[R8,#w_currentmap]	; KEYMAP will change it!
 LDRB R0,[R8,#w_format]		; mode number
 ADD R14,R12,#(mode_store+4):AND:&FF00
 ADD R14,R14,#(mode_store+4):AND:&00FF
 LDR R0,[R14,R0,LSL#3]		; table pointer for this mode
 LDR R2,[R0,#2*e_mode]		; flags word
 FNLDR R0,key_flags
 TST R0,#1<<3			; character quoted?
 MOVNE R2,#1<<8			; get raw input
 TST R2,#3<<8
 BLNE raw_key			; send raw keyboard input
 FNRTS VS
 CMP R6,#0
 BLE cantadd$l			; not yet buffered anything
 LDR R0,[R4]			; command address
 LDR R14,[R4,#8]
 ORR R0,R0,R14,LSL #28
 TEQ R0,R7
 BNE cantadd$l			; no longer same Command
 CMP R6,#kbdbuf_size
 BCS cantadd$l			; buffered maximum allocation
 B gobuffer$l
; BL buffer_key
; MOV R0,#0			; wait for next key
; FNRTS
cantadd$l			; can't add the key to the buffer
 CMP R6,#0
 BLE donebuf$l			; nothing buffered
 BL exec$l
 FNRTS VS
 CMP R0,#0			; don't wait for more if minibuf
 FNRTS MI			; open
 BL minibuffer_show		; update the minbuffer on screen (help info)
 FNRTS VS
donebuf$l			; executed the buffered command
 MOVS R0,R5			; carry on with main loop if no more
 FNRTS MI
 LDR R7,[R4]			; new command address
 CMP R7,#0
 BLE hotkey$l			; pass on hotkey don't buffer
 LDR R14,[R4,#8]
 ORR R7,R7,R14,LSL #28
 MOV R6,#0			; buffer now empty
gobuffer$l
 BL buffer_key
 MOVVC R0,#0			; wait for more
 FNSTR R0,if_count,VC
 FNSTR R0,if_skip,VC
 FNSTR R0,if_stop,VC
 BLVC test_exec$l
 FNRTS
hotkey$l
 BL minibuffer_wipe		; clear buffer (eg ESC prompt)
 FNRTS VS
 CMP R5,#&200
 BCS notwimp$l			; not a valid wimp key!
 MOV R0,R5			; original wimp key
 SWI XWimp_ProcessKey		; pass on (eg F12)
; FNRTS VS
notwimp$l
	MOVVC R0,#-1			; don't wait any more
	FNRTS				; (or wimp gets confused)
test_exec$l
	STMFD	R13!,{R14}
	BICS	R14,R7,#15<<28
	LDRNE	R14,[R14,#-4]	; get flags for current command
	TSTNE	R14,#1<<28	; immediate exec?
	BNE	go_exec$l
	AND	R14,R14,#7<<3	; type of data - string?
	TEQ	R14,#3<<3
	FNLDR	R14,wimp_kbdbuf,EQ; command data (if needed)
	LDREQ	R14,[R14]	; command data word
	TEQEQ	R14,#0		; no parameter?
	LDMNEFD	R13!,{PC}	; no - return
go_exec$l
	STMFD	R13!,{R1-R5}
	BL	exec$l
	LDMFD	R13!,{R1-R5,PC}
exec$l
	STMFD	R13!,{R0,R14}
	MOVS	R1,R6		; number of times pressed
	LDMEQFD	R13!,{R0,PC}
	BL	minibuffer_clear; wipe minibuffer before new command
	BLVC	minibuffer_close; close minibuffer if it was open
	LDMVSFD	R13!,{R14,PC}
	MOV	R2,R7,LSR #4	; call normal reason code
	AND	R2,R2,#15<<24
	BIC	R7,R7,#15<<28
	LDR	R0,[R7,#-4]	; command flags
	MOV	R0,R0,LSR#3
	AND	R0,R0,#7	; type of data
	CMP	R0,#3
	FNLDR	R0,wimp_kbdbuf	; command data (if needed)
	LDRCS	R0,[R0]		; command data word
	BL	process_command	; perform the action
	MOV	R6,#0
	MOV	R7,#0
	LDMVCFD	R13!,{R0,PC}
	LDMFD	R13!,{R14,PC}
null$l				; default null entry
	DCD	0,0			; command,arg

;E R0=zap key number R5=wimp key number R8-R10=input caret
;X Key processed as if typed and sent to process key KB #

process_a_key
	STMFD	R13!,{R1-R7,R14}
	MOV	R6,#0			; none buffered
	MOV	R7,#0			; no command buffered
	BL	process_converted_key
	MVNVC	R5,#0			; R5=-1 => no more keys
	BLVC	process_converted_key
	LDMFD	R13!,{R1-R7,PC}

	LOCAL

;E R2=mode flags word R3=Zap internal key number of the key
;  R4=current key entry pointer R5=wimp key number R8-R10=input
;X R4=new command pointer if key should be raw. #
;  R8-R10=updated input caret if copy mode cancelled for example.

raw_key
 FNLDR R0,key_flags
 BIC R0,R0,#1<<3
 FNSTR R0,key_flags		; clear the 'quote' flag.
 TST R2,#1<<8
 BNE send_raw_key		; just send the key on
 FNJSR "R1-R3"			; start of taskwindow key handling
 CMP R5,#&1C0			; Must base on Wimp key Numbers (eg keypad)
 FNRTS CS			; don't pass on F10-F12
 MOV R14,#&100
 ORR R14,R14,#&52
 TEQ R3,R14
 BEQ ctrlat$l			; return + reset the cursor mode
 CMP R5,#&180
 BCS cursor$l			; it's a cursor/function key
 CMP R5,#&20
 BCS passon$l			; pass on ordinary characters and delete
 TEQ R3,#&1B
 BEQ escape$l
 TEQ R3,#&1D
 BEQ reset$l			; return + reset the cursor mode

; SUB R14,R3,#&100
; TEQ R14,#&1B			; don't pass on  s-Escape
; TEQ R14,#&3B			; don't pass on  c-Escape
; TEQ R14,#&5B			; don't pass on sc-Escape
; FNRTS EQ

 CMP R3,#&20
 RSBHI R14,R3,#&100
 FNRTS HI

; BHI okafterall$l
 ;FNRTS EQ
; CMP R3,#&20
; FNRTS CS			; don't pass on sc-letters c-Escape etc
 LDR R2,[R4]			; current key command
 FNLDR R0,env_modstart
 SUB R2,R2,R0			; offset from module start
 ADR R1,trap$l			; list of commands not to pass on
a$l
 LDR R0,[R1],#4
 TEQ R0,R2
 FNRTS EQ			; match so execute the command as normal
 TEQ R0,#0
 BNE a$l			; not at end of list yet
passon$l			; pass on wimp key number as raw
 MOV R3,R5			; wimp key number
 BL send_raw_key
 FNRTS
cursor$l			; function and cursor key range 180-1C0
 AND R0,R5,#&0F
 CMP R0,#&C
 BCS escape$l			; a cursor key
 CMP R5,#&1A0
 FNRTS CS			; don't pass on ctrl-tabs etc
 TEQ R0,#&A
 BEQ passon$l			; pass on Tab/shift tab (fname completion)
 FNRTS

ctrlat$l
 MOV R3,R5
 BL pre_send_raw_key
 FNRTS

escape$l			; cursors and escape
 FNLDR R0,car_mode
 TEQ R0,#2
 FNRTS EQ			; in copy mode so don't pass cursors/escape
 B passon$l

reset$l				; pass on key and reset cursor state
 MOV R3,R5
 BL send_raw_key
 BLVC default_caret		; cancel copy mode
 BLVC get_input_caret		; may have changed due to cancel
 FNRTS

trap$l
 DCD Copy,Copysel,Movesel	; always trap & do these commands
 DCD PasteGC,Save,Mode,Clearsel
 DCD Quote,Command,0		; Command ?????!?

 LOCAL

;E R3=keynumber 0-&1FF
;X R4=in line buffer with command to send it raw. |

send_raw_key
 FNJSR
 ADR R4,raw_key_buf
 CMP R3,#&100
 BCS rk21
 FNADR R0,ext1$l
 STR R0,[R4]			; sub
 STRB R3,[R4,#4]		; data
 FNRTS
rk21
 CMP R3,#&180			; There's not much point doing this
 BCC rk_scnum_specialcases	; if A not a TW or B not a F-Key...
 FNADR R0,ext2$l
 STR R0,[R4]
 ADD R0,R4,#8
 STR R0,[R4,#4]
 MOV R0,#0
 STR R0,[R4,#8]
 STR R0,[R4,#12]
 MOV R0,#'|'
 STRB R0,[R4,#8]
 MOV R0,#'@'
 STRB R0,[R4,#9]
 CMP R3,#&120
 STRCSB R3,[R4,#10]
 FNRTS CS
 MOV R0,#'|'
 STRB R0,[R4,#10]
 ADD R0,R3,#&40
 STRB R0,[R4,#11]
 FNRTS
raw_key_buf
 DCD 0
 DCD 0
 DCD 0
 DCD 0				; raw keyboard entry buffer
ext1$l DCD Char
ext2$l DCD Insertgs
ext3$l DCD Null

rk_scnum_specialcases		; (TT)
 SUB R3,R3,#&100
 CMP R3,#&2B
 CMPNE R3,#&2C
 CMPNE R3,#&2D
 SUBEQ R3,R3,#&10		; crafty subtraction :-| (TT)
 BEQ rk_nottonull
 CMP R3,#&56
 MOVEQ R3,#&1E			; '0' (TT)
 BEQ rk_nottonull
 CMP R3,#&4F
 MOVEQ R3,#&1F			; '0' (TT)
 BEQ rk_nottonull
 CMP R3,#&52
 BEQ tw_sendactrlat
 FNADR R0,ext3$l
 STR R0,[R4]
 FNRTS

pre_send_raw_key
 FNJSR
 ADR R4,raw_key_buf

tw_sendactrlat
 ;MOV R0,#0
 ;SWI XWimp_ProcessKey		; oops - *bad* idea TT
 ;MOV R0,#0
 ;SWI XWimp_ProcessKey		; oops - *bad* idea TT
 ;
 ;MOV R0,#138
 ;MOV R1,#0
 ;MOV R2,#0
 ;SWI XOS_Byte

 ADR R0,sendacharzerototw
 BL command_string
; FNcall Zap_CommandString,R3

 ;MOV R0,#&100
 ;ORR R0,R0,#&52
 ;MOV R5,#0
 ;FNcall Zap_ProcessAKey
 ;SWI &107
 MOV R3,#0
rk_nottonull			; (TT)
 FNADR R0,ext1$l		;
 STR R0,[R4]			; sub (TT)
 STRB R3,[R4,#4]		; data (TT)
 FNRTS

sendacharzerototw
 = "CHAR 0",0,0

;E R3=keynum R4=table entry R6=num currently buffered R7=function
;X If not a string then parameter buffered R6 incremented
;  If a string with then address (or 0) stored in kbdbuf
;  If a data block then address stored in kbdbuf
;  R0=0/1 if minibuffer will be needed |

buffer_key
 STMFD R13!,{R1-R4,R7,R14}
 FNSTR R3,key_last		; save last buffered keynumber
 BIC R7,R7,#15<<28
 LDR R1,[R7,#-4]		; get command flags
 LDR R2,[R4,#4]			; get parameter
 MOV R3,R1,LSR#3
 AND R3,R3,#7			; data type
 FNLDR R14,wimp_kbdbuf		; buffer start
 TEQ R3,#3
 BEQ bu10			; string input
 TEQ R3,#1
 STREQB R2,[R14,R6]		; buffered bytes
 TEQ R3,#2
 STREQ R2,[R14,R6,LSL#2]	; buffered words
 TEQ R3,#4
 STREQ R2,[R14]			; data block
 ADD R6,R6,#1			; inc R6
 MOV R0,#0			; no minibuffer needed
 LDMFD R13!,{R1-R4,R7,PC}
bu10
 STR R2,[R14]			; save string parameter
 ADD R6,R6,#1
 TEQ R2,#0
 MOVEQ R0,#1			; minibuffer
 MOVNE R0,#0			; none
 LDMFD R13!,{R1-R4,R7,PC}

	LOCAL

	&	2<<3
Passthrough
	STMFD	R13!,{R0,R14}
	MOV	R2,R0
	MOV	R3,R1
	MOV	R0,#14
	MOV	R11,#e_interrogate
	BL	call_mode
	TEQ	R0,#3
	LDMNEFD	R13!,{R14,PC}
loop$l	LDR	R0,[R2],#4
	CMP	R0,#0
	CMPNE	R0,#&100
	MOVHS	R1,#0
	STRHSB	R1,[R13]
	STRHSB	R0,[R13,#1]
	MOVHS	R5,#2
	STRLOB	R0,[R13]
	MOVLO	R5,#1
	LDR	R4,[R8,#w_flags]
	LDR	R6,[R8,#w_format]
	MOV	R7,R13
	MOV	R11,#e_char
	STMFD	R13!,{R2,R3}
	BL	call_mode
	LDMVSFD	R13!,{R2,R3,R14,PC}
	LDMFD	R13!,{R2,R3}
	SUBS	R3,R3,#1
	BGT	loop$l
	LDMFD	R13!,{R14,PC}

 END
