; Contains menu related code.
; $Id: Menus,fff,v 1.1.2.9 1999/02/12 00:48:44 ds Exp $

 GET h.ZapHeader
 GET h.Messages
 GET h.Cursors
 GET h.ModeBits
 GET h.Strings
 GET h.Heap
 GET h.CreateFile
 GET h.Template
 GET h.Commands
 GET h.Execute
 GET h.Redraw
 GET h.MiniBuff
 GET h.CreateWind
 GET h.StartUp
 GET h.KeyBits
 GET h.ModuleBits
 GET h.StartCode
 GET h.TMTVars
 GET h.Messages

 IMPORT create_ColourBox
 IMPORT conv_font_off
 IMPORT get_font_off
 IMPORT find_zap_font
 IMPORT minimise_font_memory
 IMPORT add_font_suffix
 IMPORT Bitmapfont
 IMPORT get_MiniBuf
 IMPORT strcopy

 EXPORT init_menus
 EXPORT create_menu
 EXPORT menu_click
 EXPORT menu_warning
 EXPORT menu_decode
 EXPORT build_menu
 EXPORT load_menus
 EXPORT read_menu_handle
 EXPORT update_menu_path
 EXPORT read_menu
 EXPORT load_menu
 EXPORT open_menu
 EXPORT create_menu_structure
 EXPORT set_mode_menu_title

 EXPORT Bitmaplist
 EXPORT Basemaplist
 EXPORT Colourlist
 EXPORT Tofrontlist
 EXPORT Fontlist
 EXPORT Newviewlist
 EXPORT Removelist
 EXPORT Modelist
 EXPORT Typelist
 EXPORT Getmodule
 EXPORT Getworkspace
 EXPORT Getdynamicarea
 EXPORT Savelist
 EXPORT Closelist

; tick menu option if EQ with $a=menu start $b=menu offset corrupts R0

	MACRO
$la	FNtickeq $a,$b
$la	LDR R0,[$a,#(28+24*$b)]
	ORREQ R0,R0,#1
	BICNE R0,R0,#1
	STR R0,[$a,#(28+24*$b)]
	MEND

; create a new menu $t=title $w=width $c=creation sub

	GBLA menu_num_off
	MACRO
$la	FNnew_menu $t,$w,$c
menu_num_off SETA 0		; reset the menu entry count
$la	= "$t",0		; title
	ALIGN
	DCD ($w<<4)			; width in os coords
	DCD $c
	MEND

; create a new menu entry $t=title $f=flags $s=submenu $k=key/argument
; $i=interprate $ll=label to be assigned (optional)

	MACRO
$la	FNnme $t,$f,$s,$k,$i,$ll
$la	DCD $f				; flags
	DCD $s				; submenu pointer
	DCD $k				; index word
	DCD $i				; interpret code
	= "$t",0			; text string
	ALIGN
	[ "$ll"<>""
$ll	* menu_num_off			; define the label
	]
menu_num_off SETA menu_num_off+1
	MEND

; end a menu returning its length in $ll (optional)

	MACRO
$la	FNend_menu $ll
$la	ASSERT menu_num_off<>0
	[ "$ll"<>""
$ll	* menu_num_off
	]
	DCD -1
	MEND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CREATE THE MENU (TICK CORRECT BOXES ETC)		    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=number R10=menu
;X buffer of first menu entry filled with number and R0-R2 corrupted |

cm_buffernum
 FNJSR
 ADD R1,R10,#28			; first item
 LDR R2,[R1,#20]		; buffer length
 LDR R1,[R1,#12]		; buffer address
 SWI XOS_ConvertInteger4
 ADDS R0,R0,#0			; clv
 FNRTS

;E R0=number R10=menu
;X buffer of first menu entry filled with number and R0-R2 corrupted |

cm_bufferhex
 FNJSR
 ADD R1,R10,#28			; first item
 LDR R2,[R1,#20]		; buffer length
 LDR R1,[R1,#12]		; buffer address
 MOV R14,#'&'
 STRB R14,[R1],#1
 SUB R2,R2,#1			; add & at start
 SWI XOS_ConvertHex8
 ADDS R0,R0,#0			; clv
 FNRTS

;E R0=string R10=menu
;X string copied into menu entry #

cm_bufferstring
 STMFD R13!,{R1-R4,R14}
 ADD R1,R10,#28			; first item
 MOV R2,R0			; source string
 LDR R3,[R1,#20]		; buffer length
 MOV R4,#&1F			; max term char
 LDR R1,[R1,#12]		; buffer address
 BL strmove
 LDMFD R13!,{R1-R4,PC}

;E R0=number R5=icon menu number R10=menu
;X buffered #

cm_bufferhex_icon
 STMFD R13!,{R1-R2,R14}
 ADD R1,R10,#28
 ADD R2,R5,R5,LSL#1		; R5*3
 ADD R1,R1,R2,LSL#3		; R5*24
 LDR R2,[R1,#20]		; buffer len
 LDR R1,[R1,#12]
 MOV R14,#'&'
 STRB R14,[R1],#1
 SUB R2,R2,#1
 SWI XOS_ConvertHex8
 LDMFD R13!,{R1-R2,PC}

cm_curlist
 FNJSR
 FNLDR R1,opt_cursor
 MOV R0,R0,LSL#3		; cursor number (0-3) times 8
 MOV R1,R1,LSR R0		; get the byte
 AND R7,R1,#&FF			; cursor type
 ADD R1,R10,#28			; first menu item
 MOV R2,#0
cm19
 LDR R0,[R1]
 TEQ R2,R7
 ORREQ R0,R0,#1
 BICNE R0,R0,#1
 STR R0,[R1],#24		; tick items
 ADD R2,R2,#1
 CMP R2,#5
 BCC cm19
 FNRTS

cm_minibuffer
 FNJSR
 MOV R7,R7,LSR#23
 ANDS R7,R7,#3
 FNtickeq R10,s_minipopup
 TEQ R7,#1
 FNtickeq R10,s_miniperm
 FNLDR R14,opt_switches
; EOR R14,R14,#switch_MinibufferAntialiased
 TST R14,#switch_MinibufferAntialiased
 FNtickeq R10,s_minifont
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SUBMENU INTERPRET					     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sub_curlist
 FNJSR				; R0=new cursor type
 LDR R4,[R11,#-8]		; get cursor number
 FNLDR R1,opt_cursor
 MOV R2,R4,LSL#3		; cursor number * 8
 MOV R1,R1,ROR R2
 BIC R1,R1,#&FF
 ORR R1,R1,R0
 RSB R2,R2,#32
 MOV R1,R1,ROR R2
 FNSTR R1,opt_cursor
 MOV R0,R4
 LDR R1,[R3,#4]
 BL update_menu
 FNRTS

sub_minibuffer
 FNJSR
 MOV R3,#0
 TEQ R0,#s_miniperm
 MOVEQ R3,#1
 BIC R7,R7,#1<<23
 ORR R7,R7,R3,LSL#23
 FNSTR R7,opt_flags
 BL minibuffer_ensure
 FNRTS

sub_minifont
 FNJSR
 MOV R1,#1<<27
 BL new_switches_set
; TEQ R2,#0
; FNRTS NE
 BL get_MiniBuf
 LDR R0,[R7,#8]
 CMP R0,#0
 BLPL minibuffer_update
; MOV R3,#0
; TEQ R0,#s_miniperm
; MOVEQ R3,#1
; BIC R7,R7,#1<<23
; ORR R7,R7,R3,LSL#23
; FNSTR R7,opt_flags
; BL minibuffer_ensure
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MENU WARN CREATION SUBS				 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; anti-aliased font listings

 LOCAL

 DCD 7+(1<<16)
Fontlist
 TEQ R2,#16
 MOVNE PC,R14
 ADR R0,name$l
 ADR R1,build$l+1
 ADR R2,create$l
 FNLDR R3,wimp_version
 CMP R3,#300 ; good enough test ;-)
 ADRLO R3,exec$l
 ADRHS R3,exec3$l
 MOV R4,#48			; max - was 40...
 MOV R8,#0			; count
 B build_menu
name$l FNS ("zap_m_font")
build$l
 FNJSR "R1-R6"
; FNJSR "R1-R3"
 LDR R14,[R6,#8]
; BIC R14,R14,#(1<<3)+(1<<6)+(1<<7)	; possibly a flags problem...?
 TEQ R9,#0
 ORREQ R14,R14,#1<<22
 STR R14,[R6,#8]
loop$l
 FNLDR R1,wimp_version
 CMP R1,#300 ; good enough test ;-)
 MOVLO R1,R0			; buffer pointer
 MOVLO R2,R8			; count
 MVNLO R3,#0			; use Font$Path
 FNLDR R1,wimp_block,HS
 ORRHS R2,R8,#3<<16
 MOVHS R3,#40
 MOVHS R4,R0
 MOVHS R5,#40
 MOVHS R6,#0
 SWI XFont_ListFonts		; can give buffer_overflow error...?

 MOVVC R8,R2			; new count
 MOVVC R0,R2			; return as index
;  FNRTS VC
; ; a problem...
;  ADDS R2,R2,#1			; CLV...
;  MOV R14,#'?'
;  STRB R14,[R0],#1
;  MOV R14,#0
;  STRB R14,[R0],#1
;  MOV R8,#-1			; last one...
;  MOV R0,#-1			; new count
 FNRTS				; ridiclous if gets here...

create$l
 FNJSR
 FNLDR R6,font_name
 LDRB R0,[R6]
 CMP R0,#&20
 FNRTS CC			; none
  LDRB R0,[R6]
  TEQ R0,#'\'
  BNE gotname$l			; no initial '\'; no extra processingqd
  MOV R7,R6
find_bs$l
  LDRB R0,[R7,#1]!
  TEQ R0,#'\'
  TEQNE R0,#0
  BNE find_bs$l
  TEQ R0,#0
  ADDEQ R6,R6,#2
  BEQ gotname$l
find_spc$l
  LDRB R0,[R7,#1]!
  TEQ R0,#32
  BNE find_spc$l
  ADD R6,R7,#1
gotname$l
 ADD R5,R10,#28			; first menu item
a$l
 LDR R1,[R5,#12]		; buffer
 MOV R2,R6			; font name
 BL strCMP
 LDR R0,[R5]
 ORREQ R0,R0,#1
 BICNE R0,R0,#1
 STR R0,[R5],#24
 TST R0,#1<<7			; at end yet
 BEQ a$l
 FNRTS
exec$l
 FNJSR "R1,R2"			; preserve for no good reason...?
exec_gotname$l
 MOV R0,R10			; font name string
 BL str_len
 ADD R1,R0,#8
 FNLDR R0,font_name
 BL heap_ensure
 FNSTR R0,font_name,VC
 MOVVC R1,R0
 MOVVC R2,R10
 BLVC strcopy			; copy in new font name
 BLVC new_font
 FNRTS
exec3$l
 FNJSR "R1,R2"			; must be same as in exec$l (above)
 SUB R1,R2,R0,LSL #4
 SUB R1,R1,R0,LSL #3
 SUB R1,R1,#28			; point at start of menu
 MOV R0,#0
 SUB R2,R11,#4
 FNLDR R3,wimp_block
 MOV R4,#256
 SWI XFont_DecodeMenu
 MOV R10,R3
 B exec_gotname$l

; colour list background1,background2,foreground etc

 LOCAL

 DCD 7+(1<<16)
Colourlist
 FNJSR
 TEQ R2,#16			; 16 to use command as a submenu
 FNRTS NE
 TEQ R8,#0
 FNLDRB R10,opt_format,EQ
 LDRNEB R10,[R8,#w_format]	; mode number
 MOV R11,#e_init		; entry point
 MOV R1,#6			; get colours menu
 BL call_given_mode		; R1=address of cols/6
 FNRTS VS
 MOV R9,R1			; pointer to extra colours/6
 TEQ R8,#0
 FNLDRB R0,opt_format,EQ
 LDRNEB R0,[R8,#w_format]
 BL read_mode
 LDR R11,[R1,#2*e_mode]
 MVN R8,#0			; current colour number (-1)
 ADR R0,data$l			; colours 0-8 current data
 BL lookup_token_R0
 MOV R10,R0
 ADR R0,name$l
 ADR R1,build$l+1		; build menu sub
 ADR R2,create$l		; put tick by all modes
 ADR R3,sub$l			; toggle all modes button
 MOV R4,#12
 BL build_menu			; create the menu
 FNRTS
name$l = "zap_m_col",0
data$l = "zap_m_cols",0
 ALIGN

build$l				; R0=buffer R8=entry number R9=mode entries
 FNJSR "R1-R2,R11"		; R10=current pos R7=start of menu entry
 ;LDR R14,[R6,#8]		; possibly a flags problem...?
 ;BIC R14,R14,#&EE
 ;BIC R14,R14,#&E00
 ;STR R14,[R6,#8]		; possibly a flags problem...?
 CMP R8,#9
 MVNLT R11,#0			; if doing the std entries, assume tokens...
 BNE nothit9$l			; when we hit the 9th entry...
 CMP R9,#&100
 MOVCC R0,#-1			; finish if invalid
 FNRTS CC
 TST R11,#1<<12			; if using token for mode colours,
 MOVEQ R10,R9
 MOVNE R0,R9
 BLNE lookup_token_R0		; expand it
 MOVNE R10,R0
nothit9$l
 TST R11,#1<<12			; are we using a token?
 LDRB R0,[R10]
 ADDNE R10,R10,#1		; point past separator if so
 MOVNE R11,R0			; and keep the separator for later
 MOVEQ R11,#256
 CMP R0,#32
 MOVLO R0,#-1			; go home if reached end of list
 FNRTS LO
 ADD R7,R7,#4			; add extra word for warning bit
 MOV R1,R7			; dest string
c$l
 LDRB R0,[R10],#1		; copy until separator or ctrl
 CMP R0,R11
 CMPNE R0,#31
 MOVLS R0,#0			; ensure that we finish with a null
 STRB R0,[R1],#1
 BHI c$l
 TEQ R11,#256			; if using tokens,
 SUBNE R10,R10,#1		; point at separator/ctrl for next call
 CMP R8,#0
 BMI b$l			; on first entry (the all modes option)
 ADR R0,mw_collist		; sub to create colour menu
 STR R0,[R7,#-12]		; save as submenu create
 ;MOV R0,#0
 ;STR R0,[R7,#-4]		; save as execute sub

 LDR R0,[R6]			; menu flags word
 ORR R0,R0,#1<<3		; set warning bit
 TEQ R8,#8
 BNE a$l			; not just done 8th entry
 CMP R9,#&100
 ORRGE R0,R0,#2			; dotted line before mode entries
a$l
 STR R0,[R6]
 MOV R0,#1
 STR R0,[R6,#4]			; submenu pointer
 MOV R0,#0			; index for this entry 0
 STR R0,[R7,#-4]		; save as execute sub
b$l
 MOV R0,#0
 ADD R8,R8,#1			; next entry
 FNRTS
create$l			; add ticks
 FNJSR
 TEQ R8,#0
 FNLDR R1,opt_format,EQ
 LDRNE R1,[R8,#w_format]
 TST R1,#1<<30
 FNtickeq R10,0
 FNRTS
sub$l				; interpret sub (all modes button)
 FNJSR
 TEQ R0,#0			; first menu entry toggles 'all' flag
 FNRTS NE
 TEQ R8,#0
 FNLDR R1,opt_format,EQ
 LDRNE R1,[R8,#w_format]
 EOR R1,R1,#1<<30
 FNSTR R1,opt_format,EQ
 STRNE R1,[R8,#w_format]
 FNRTS

; Colour selector list (off the main colour list)

mw_collist
 FNJSR
 SUB R0,R5,#1			; offset of colour number
 BL create_ColourBox
 MOVVC R1,R0
 FNRTS

mw_collist_mini
 FNJSR
 TEQ R5,#s_minifor
 MOVEQ R0,#-1			; foreground
 MOVNE R0,#-2
 BL create_ColourBox
 MOVVC R1,R0
 FNRTS

 DCD 7+(1<<16)+(1<<15)
Tofrontlist
 B Removelist

 DCD 7+(1<<16)+(1<<15)
Savelist			; ensure it's a different address
 B Removelist

 DCD 7+(1<<16)+(1<<15)
Closelist			; ensure it's a different address
 B Removelist

 DCD 7+(1<<16)+(1<<15)
Newviewlist			; ensure it's a different address
 B Removelist

 LOCAL

 DCD 7+(1<<16)+(1<<15)
Removelist
 FNJSR "R1-R11"			; save registers as called by sub_filelist
 ADR R0,name$l
 ADR R1,mwf_sub+1
 ADR R3,sub_filelist
 MOV R4,#13 ; was 12
 FNLDR R8,file_num
 FNLDR R9,file_list
 MOV R10,#0			; next file offset
 TEQ R2,#15			; to tickable...
 BEQ tick_filelist
 TEQ R2,#16			; especially save R3!
 FNRTS NE
 MOV R2,#0
 BL build_menu
 MOVVC R1,R0			; menu pointer
 BLVC sort_menu
 MOVVC R0,R1			; restore menu pointer
 FNRTS
name$l FNS ("zap_m_file")

tick_filelist
 MOV R11,#0			; cntr
mw9
 CMP R10,R8
 BCS nomorefilestocount
 LDR R0,[R9,#f_ptr]
 CMP R0,#0
 ADDGT R11,R11,#1
 ADD R10,R10,#1
 ADD R9,R9,#file_blk
 B mw9

nomorefilestocount
 CMP R11,#0
 MOVEQ R0,#2
 MOVNE R0,#0
 FNRTS

mwf_sub				; create the menu of buffers
 STMFD R13!,{R1-R4,R14}
 MOV R11,R0			; save buffer pointer
mw1
 CMP R10,R8
 MVNCS R0,#0			; no more
 LDMCSFD R13!,{R1-R4,PC}
 LDR R0,[R9,#f_ptr]
 CMP R0,#0
 BGT mw2			; found next file
 ADD R10,R10,#1
 ADD R9,R9,#file_blk
 B mw1
mw2
 LDR R0,[R9,#f_name]
 BL find_leaf_name
 MOV R2,R0
 MOV R1,R11
 MOV R3,#48
 MOV R4,#&1F
 BL strmove			; copy in leafname
 LDR R0,[R9,#f_flags]
 TST R0,#1<<3			; is the file marked changed
 MOVNE R0,#' '
 STRNEB R0,[R1],#1
 MOVNE R0,#'*'
 STRNEB R0,[R1],#1
 MOVNE R0,#0
 STRNEB R0,[R1],#1
 MOV R0,R10			; index
 ADD R10,R10,#1
 ADD R9,R9,#file_blk		; next entry
 LDMFD R13!,{R1-R4,PC}

 LOCAL

sub_filelist			; file chosen
 FNJSR
 CMP R1,#0
 FNRTS MI			; empty menu item selected
 LDR R4,[R3,#12]		; previous menu item text
 LDR R4,[R4,#-12]		; menu command for previous item
 BIC R4,R4,#1<<31		; actual address
 FNLDR R9,file_list
 ADD R9,R9,R1,LSL#f_shift	; file address

 ADR R0,Removelist
 TEQ R0,R4
 BEQ remove$l

 ADR R0,Savelist
 TEQ R0,R4
 BEQ save$l

 ADR R0,Tofrontlist
 TEQ R0,R4
 BEQ tofront$l

 ADR R0,Closelist
 TEQ R0,R4
 BEQ closewindows$l

 BL new_view			; new view on this file (R8=0)
 FNRTS
remove$l
 BL get_a_view$l		; new view on this file (R8=0)
; LDR R0,[R9,#f_flags]
; TST R0,#1<<3			; is the file marked changed
; BNE filechangedprob$l
 BL delete_file
 FNRTS VS
 FNRTS CS			; warning given don't recreate
 MOV R2,#16
 BL Removelist			; create new menu (must be shorter)
				; beware of saving R3
 STRVC R0,[R3,#4]		; new submenu pointer
 FNRTS
closewindows$l
 ADR R10,closewindowsub$l
 BL do_eachwindow
 FNRTS
;filechangedprob$l
; BL get_a_view$l		; new view on this file (R8=0)
; BL delete_file
; FNRTS
save$l
 BL get_a_view$l		; new view on this file (R8=0)
 BL save_text			; Quicksave (which mode???)
 FNRTS
tofront$l
 BL bringtofront$l
 FNRTS

tofrontit$l
 FNJSR "R1"
 MOV R0,#3
 MOV R1,R8
 BL open_a_window
 STR R8,local_wcount$l
 FNRTS

closewindowsub$l
 B discard_window

bringtofront$l
 FNJSR "R8,R10"
 MOV R14,#0
 STR R14,local_wcount$l
 ADR R10,tofrontit$l
 BL do_eachwindow
 LDR R8,local_wcount$l
 CMP R8,#0
 BLEQ new_view			; new view on this file (R8=0)
 FNRTS

get_a_view$l
 FNJSR "R10"
 MOV R14,#0
 STR R14,local_wcount$l
 ADR R10,wcnttoseeifanyopen
 BL do_eachwindow
 LDR R8,local_wcount$l
 CMP R8,#0
 BLEQ new_view			; new view on this file (R8=0)
 FNRTS

wcnttoseeifanyopen
 STR R8,local_wcount$l
 MOV PC,R14

local_wcount$l
 DCD 0

 LOCAL

 ; VS
 ;FNRTS CS			; warning given don't recreate
 ;MOV R2,#16
 ;BL Removelist			; create new menu (must be shorter)
 ;FNRTS VS			; beware of saving R3
 ;STR R0,[R3,#4]			; new submenu pointer
 ;FNRTS

; Cursor list

mw_curlist
 FNLDR R1,menu_memory
 LDR R1,[R1,#8]
 MOV PC,R14

; create list of modules for grabbing

 DCD 7+(1<<16)
Getworkspace			; grab workspace list
 B Getmodule

 LOCAL

 DCD 7+(1<<16)
Getmodule
 FNJSR
 TEQ R2,#16
 FNRTS NE
 ADR R0,name$l
 ADR R1,buildsub$l+1
 MOV R2,#0
 ADR R3,execsub$l
 MOV R4,#22
 MOV R8,#0			; module number
 MOV R9,#0			; instantiation number
 BL build_menu
 MOVVC R1,R0
 BLVC sort_menu
 MOVVC R0,R1			; menu pointer
 FNRTS
name$l FNS ("zap_m_module")
buildsub$l
 FNJSR "R1-R5"
 MOV R11,R0			; save buffer pointer
 MOV R0,#12
 MOV R1,R8
 MOV R2,R9
 SWI XOS_Module
 MVNVS R10,#0			; index
 BVS end$l
 ADD R10,R9,R8,LSL#16		; save index incase needed
 MOV R8,R1
 MOV R9,R2			; next module
 MOV R1,R11			; buffer
 LDR R0,[R3,#&10]		; title string offset
 ADD R2,R3,R0			; title string
 MOV R3,#46
 MOV R4,#&1F
 BL strmove			; copy in module title
 LDR R0,[R5]			; postfix
 LDR R14,base$l
 TEQ R0,R14
 BEQ end$l			; none
 MOV R0,#'%'
 STRB R0,[R1],#1
 MOV R2,R5
 BL strmove			; copy in postfix
end$l
 ADDS R0,R10,#0
 FNRTS
base$l = "Base"
execsub$l
 FNJSR
 LDR R7,[R3,#12]		; text
 LDR R7,[R7,#-12]		; sub to open the menu
 BIC R7,R7,#1<<31		; save address of command that was called
 MOV R0,R1,LSR#16		; module number
 EOR R2,R1,R0,LSL#16
 MOV R1,R0
 MOV R0,#12
 SWI XOS_Module			; get info
 FNRTS VS
 ADR R14,Getworkspace
 TEQ R14,R7			; get workspace?
 MOVEQ R3,R4			; R3=block to import
 MOVNE R4,#0			; start address to use for display
 MOV R7,R3			; save pointer
 CMP R7,#&8000
 FNRTS LE			; not valid
 LDR R6,[R7,#-4]
 SUB R0,R6,#4			; block length
 MOV R1,R10			; filename
 MOV R2, #&FF000000
 ORR R2,R2,#&FF0000		; load
 ORR R2,R2,#&00FA00
 MOV R3,#0			; exec
 BL create_file_block
 FNRTS VS
 MOV R1,R7			; source
 LDR R2,[R9,#f_ptr]
 SUB R3,R6,#4
 SWI XZapRedraw_MoveBytes ; BL move_bytes			; copy the data
 FNLDR R5,opt_addr
 FNSTR R4,opt_addr		; force start address of first byte
 BL create_window_block		; create the window
 BLVC init_basemap
 FNSTR R5,opt_addr		; restore addr pointer
 BLVC create_window_caret
 FNRTS

	LOCAL

; List of modes which are already loaded

	&	7+(1<<16)
Modelist
	TEQ	R2,#16
	MOVNE	PC,R14
	FNJSR
	ADR	R0,name$l
	ADR	R1,buildsub$l+1
	MOV	R2,#0
	MOV	R3,#0
	MOV	R4,#16
	MOV	R8,#-2			; mode number
	BL	build_menu
	FNRTS
name$l	FNS	("zap_m_mode")
buildsub$l
	FNJSR	"R1-R2,R5"
	ADD	R7,R7,#4		; modify R7 :-)
	TEQ	R8,#0
	BMI	loadmode$l
	ADRL	R3,Mode
	ORR	R3,R3,#2<<27:OR:1<<31	; command, int parameter
find$l	MOV	R0,R8
	BL	read_mode
	TEQ	R0,#0
	BNE	got$l
	ADD	R8,R8,#1
	TEQ	R8,#max_mode
	BNE	find$l
	MOV	R0,#-1
	FNRTS
got$l	LDRB	R0,[R1,#e_basemode*2+4]	; get the clone base mode
	TEQ	R0,R8
	BEQ	notclone$l
	LDR	R2,[R6,#8]
	EOR	R2,R2,#15<<24		; if is a clone, set text to blue
	STR	R2,[R6,#8]
	LDR	R2,[R6]
	ORR	R2,R2,#16		; allow submenu even if grey
	STR	R2,[R6]
notclone$l
	LDR	R0,[R1,#e_menu*2]	; mode menu
	CMP	R0,#0
	STRGT	R0,[R6,#4]		; if we have a submenu...
	LDRGT	R0,[R6]
	ORRGT	R0,R0,#8		; submenu warn
	STRGT	R0,[R6]
	ADR	R0,opensub$l
	STR	R0,[R7,#-12]		; submenu handler
	LDR	R2,[R1,#e_title*2]	; mode name
	MOV	R1,R7			; buffer for string
	BL	strcopy			; copy it in
	MOV	R0,R8
	ADD	R8,R8,#1
	FNRTS
loadmode$l
	ADDS	R8,R8,#1
	ADRNE	R0,Loadlist
	ADREQ	R0,Clonelist
	ORR	R0,R0,#1<<31
	STR	R0,[R7,#-12]
	ADRNE	R0,lmode
	ADREQ	R0,cmode
	BL	lookup_token_R0
	MOV	R2,R0
	MOV	R1,R7
	BL	strcopy
	LDR	R0,[R6]
	TEQ	R8,#0
	ORREQ	R0,R0,#2		; dotted line (if after clone list)
	ORR	R0,R0,#8		; submenu warn
	MOV	R1,#1
	STMIA	R6,{R0,R1}
	MOV	R0,#0
	FNRTS
opensub$l
	FNJSR	"R0"
	FNLDR	R14,menu_struct
	ADD	R14,R14,R5,LSL #4
	ADD	R14,R14,R5,LSL #3
	LDR	R1,[R14,#40]		; read submenu pointer
	LDR	R0,[R14,#48]		; ptr to text
	LDR	R0,[R0,#-8]		; command data
	FNSTR	R0,menu_mode
	BL	set_mode_menu_title
	FNRTS

lmode	=	"zap_m_lmode",0
cmode	=	"zap_m_cmode",0
	ALIGN

	LOCAL

;E R0=mode R1=menu structure
;X Menu title updated (pointer/string)
set_mode_menu_title
	FNJSR	"R0-R4"
	BL	read_mode
	FNLDR	R0,wimp_version
	LDR	R2,[R1,#e_title*2]	; mode name
	LDR	R1,[R13,#4]
	CMP	R0,#300
	BLO	ro2$l
	ADR	R3,null$l
null$l	MOV	R4,#0			; low byte = 0
	STMIA	R1,{R2-R4}
	LDR	R2,[R1,#28]
	ORR	R2,R2,#256		; mark title as indirected
	STR	R2,[R1,#28]
	FNRTS
ro2$l	MOV	R3,#12
	MOV	R4,#32
	BL	strmove
	FNRTS


 LOCAL

; List of modes that can be loaded

 DCD 7+(1<<16)
Loadlist
 FNJSR
 TEQ R2,#16
 FNRTS NE
 ADR R0,lmode
 ADR R1,buildsub$l+1
 MOV R2,#0
 ADRL R3,Moden
 ORR R3,R3,#3<<27:OR:1<<31	; command, string parameter
 MOV R4,#14
 FNLDR R8,ext_modes		; list of external modes
 BL swapmenu
 BL build_menu
 MOVVC R1,R0
 BLVC sort_menu
 MOVVC R0,R1			; menu pointer
 BL swapmenu
 FNRTS
buildsub$l
 FNJSR "R1-R2,R5" ; "R1-R7" ;
 ;LDR R14,[R6,#8]		; possibly a flags problem...?
 ;BIC R14,R14,#&EE
 ;BIC R14,R14,#&E00
 ;STR R14,[R6,#8]		; possibly a flags problem...? NOPE :-(
nearstartofbuildsub
 LDR R14,[R8]
 TEQ R14,#0
 MOVEQ R0,#-1
 FNRTS EQ			; reached the end of the list
 MOV R5,R0
 MOV R0,R8
 BL test_mode_name
 CMP R0,#0
 BPL getthenextmodeformenu$l
 MOV R1,R5			; buffer for string
 MOV R2,R8			; source
 BL strcopy			; copy it in
 MOV R0,R8
 BL str_len
 ADD R14,R8,R0
 MOV R0,R8			; index = pointer to mode name (may not fit)
 ADD R8,R14,#8			; skip terminator + offset
 BIC R8,R8,#3			; align
 ;ADD R8,R2,#7			; skip terminator + offset
 ;BIC R8,R8,#3			; align
 ;MOVS R0,#0			; no index...
 FNRTS

getthenextmodeformenu$l
 MOV R0,R8
 BL str_len
 ADD R8,R8,R0
 ADD R8,R8,#8			; skip terminator + offset
 BIC R8,R8,#3			; align
 MOV R0,R5
 B nearstartofbuildsub

	LOCAL

; List of uninitialised clone modes

	DCD	7+(1<<16)
Clonelist
	TEQ	R2,#16
	FNRTS	NE
	FNJSR
	ADR	R0,cmode
	ADR	R1,buildsub$l+1
	MOV	R2,#0
	ADRL	R3,Moden
	ORR	R3,R3,#3<<27:OR:1<<31	; command, string parameter
	MOV	R4,#14
	FNLDR	R8,ext_clones		; list of clone modes
	BL	swapmenu
	BL	build_menu
	MOVVC	R1,R0
	BLVC	sort_menu
	MOVVC	R0,R1			; menu pointer
	BL	swapmenu
	FNRTS
buildsub$l
	FNJSR	"R1-R2,R5"
	MOV	R5,R0
find$l	LDR	R2,[R8],#4
	TEQ	R2,#0
	MOVEQ	R0,#-1
	FNRTS	EQ			; reached the end of the list
	MOV	R0,R2
	BL	test_mode_name
	TEQ	R0,#0
	BPL	find$l
	MOV	R1,R5			; buffer for string
	BL	strcopy			; copy it in
	LDR	R0,[R8,#-4]		; index -> mode name
	FNRTS

 LOCAL

; create list of dynamic areas for grabbing

 DCD 7+(1<<15)+(1<<16)
Getdynamicarea
 FNJSR
 TEQ R2,#15
 BEQ shade$l			; shall we shade it?
 TEQ R2,#16			; create submenu?
 FNRTS NE
 ADR R0,name$l
 ADR R1,buildsub$l+1
 MOV R2,#0
 ADR R3,execsub$l
 MOV R4,#22
 MOV R9,#-1			; current area number
 BL build_menu
 MOVVC R1,R0
 BLVC sort_menu
 MOVVC R0,R1			; menu pointer
 FNRTS
shade$l				; shade item if pre RO 3.5
 FNLDR R0,wimp_version
 CMP R0,#320
 MOVLE R0,#2			; yes
 MOVGT R0,#0
 FNRTS
name$l FNS ("zap_m_aname")
buildsub$l
 FNJSR "R1-R8"
 MOV R11,R0			; save buffer pointer
next$l				; get next dynamic area
 MOV R0,#3
 MOV R1,R9			; current area
 SWI XOS_DynamicArea		; read next dynamic area in the list
 FNRTS VS
 CMP R1,#-1
 MOVEQ R0,#-1
 FNRTS EQ			; reached the end of the list
 MOV R9,R1			; new current area
 MOV R0,#2
 SWI XOS_DynamicArea		; read information
 FNRTS VS
 ADR R1,pool$l
 MOV R2,R8			; dynamic area name
 BL strCMP
 BEQ next$l			; skip free pool (reading it causes havoc!)
 MOV R1,R11			; buffer
 MOV R2,R8
 MOV R3,#46
 MOV R4,#&1F
 BL strmove			; copy in area name
 MOV R0,R9			; index = area number
 FNRTS
pool$l = "Free pool",0
 ALIGN
execsub$l
 FNJSR				; R1=index
 MOV R0,#2
 SWI XOS_DynamicArea		; read information on the area
 FNRTS VS			; R2=len R3=start R8=name
 ADD R4,R3,R2			; end address
 MOV R2,R3			; start address (load address) + exec addr
 MOV R1,R8			; area name
 SUB R0,R4,R2			; length
 BL create_file_block
 LDRVC R0,[R9,#f_ptr]		; buffer
 MOVVC R1,R2			; start address
 MOVVC R2,R4			; end address
 BLVC read_memory
 BLVC create_window_block
 BLVC init_basemap
 BLVC create_window_caret
 FNRTS

 LOCAL

; create list of bitmap fonts

 DCD 7+(1<<16)+(1<<15)
Bitmaplist
 FNJSR
 TEQ R2,#15
 ;TEQNE R8,#0
 BEQ shade$l
 TEQ R2,#16			; create submenu?
 FNRTS NE
 ADR R0,name$l
 ADR R1,buildsub$l+1
 ADR R2,create$l
 ADR R3,execsub$l
; MOV R3,#0
 MOV R4,#11
 MOV R8,#0			; offset in the directory
 BL build_font_menu
 ;FNRTS VS
 ;MOV R1,R0
 ;BL sort_menu
 ;MOVVC R0,R1			; menu pointer returned in R0
 ;;SWI &107			; gets here
 MOV R1,R0			; menu pointer returned in R0
 FNRTS
shade$l
 TEQ R8,#0			; doesn't work...
 MOVEQ R0,#2			; shade if on the options menu
 MOVNE R0,#0
 FNRTS
name$l FNS ("zap_m_bitmap")
buildsub$l			; uses WB
 FNJSR "R1-R6"			; NB Updating R7!!
 LDR R0,[R6]
 ORR R0,R0,#1<<3
 MOV R14,#1
 STMIA R6,{R0,R14}		; set warning bit; submenu off this entry
 LDR R14,[R6,#8]		; possibly a flags problem...?
 BIC R14,R14,#(1<<3)+(1<<6)+(1<<7)
 TEQ R9,#0
 ORREQ R14,R14,#1<<22
 STR R14,[R6,#8]		; possibly a flags problem...?
 ADD R7,R7,#4			; add in room for open code
 ADR R0,mw_bitmaplist
 STR R0,[R7,#-12]		; open code
 MOV R0,#0;execsub$l
 STR R0,[R7,#-4]		; no exec sub
next$l				; get next file name
 MOV R0,#10
 ADR R1,dir$l
 FNLDR R2,wimp_block
 ;ADD R2,R2,#&40 ; new ;(
 MOV R3,#1
 MOV R4,R8			; current offset in the directory
 MOV R5,#&100
 ADR R6,wild$l
 SWI XOS_GBPB
 FNRTS VS
 MOVCC R0,#-1
 FNRTS CC			; nothing read - reached the end
 MOV R8,R4			; save next thing to look at
 LDR R0,[R2,#16]		; object type
 TST R0,#2
 BEQ next$l			; not a directory
 MOV R1,R7
 ADD R2,R2,#20			; dir name
 BL strcopy			; copy in the name
 MOV R0,#0			; no index
 FNRTS
dir$l = |zap$|,"Fonts:",0
wild$l = "*",0
 ALIGN
create$l
 FNJSR
 ADD R5,R10,#28			; first menu item
 CMP R8,#0
 ADREQ R6,dir$l			; anywhere...
 BEQ a$l
 LDRNE R0,[R8,#w_font]
 LDRNE R0,[R0,#font_data0]
 BLNE conv_font_off		; R7=font block
 LDR R6,[R7,#4]			; font name
a$l
 LDR R1,[R5,#12]		; buffer
 MOV R2,R6			; font name
 BL strCMPstr			; R0=next point in text
 LDREQB R0,[R0]
 TEQEQ R0,#'.'
 LDR R0,[R5]
 ORREQ R0,R0,#1			; ticking the font in use...
 BICNE R0,R0,#1			; and clearing any other ticks...
 STR R0,[R5],#24
 TST R0,#1<<7			; at end yet
 BEQ a$l
 FNRTS
execsub$l			; R3=address of prev item start R10=text
 CMP R8,#0			; IB friendly...
 MOVEQ PC,R14			; IB friendly...
 FNJSR "R0-R12"
; SWI &107
 FNLDR R1,wimp_data		; buffer
 ;LDR R2,[R3,#12]		; text
 ;BL strcopy
 ;MOV R0,#'.'
 ;STRB R0,[R1],#1
 MOV R2,R10
 BL strcopy
 FNLDR R0,wimp_data		; text for this item = font name
 BL Bitmapfont
 FNRTS

 LOCAL

;E Called by warning code
;  R5=off in mother menu R10=address of text
;X Created bitmaplist submenu R1=submenu
;  Other registers preserved!

mw_bitmaplist
 FNJSR "R2-R10"
 ADR R9,font_path_name
 MOV R1,R9			; must match above... :-(
 ;FNLDR R9,wimp_data ; block
 ;ADD R9,R9,#&80			; address for directory name
 MOV R1,R9
 ADR R2,dir$l			; R9="Fonts:"
 BL strcpy
 MOV R2,R10
 BL strcopy			; R9=Fonts:<name>
 MOV R0,R10
 ADR R1,buildsub$l
 ADR R2,create$l
 ADR R3,mwbml_execsub
 MOV R4,#11
 MOV R8,#0			; R8=offset in the directory
 BL build_menu
 MOV R1,R0			; in R1
 ;FNRTS VS
 ;MOV R1,R0
 ;BL sort_menu
 ;MOVVC R0,R1
 FNRTS				; menu pointer in R0...
buildsub$l			; uses WB
 FNJSR "R1-R6,R10,R11"		; NB Updating R7!!
 MOV R11,R0			; save buffer pointer?
 LDR R14,[R6,#8]		; possibly a flags problem...?
 BIC R14,R14,#(1<<3)+(1<<6)+(1<<7)	; doesn't work...!???!?
 STR R14,[R6,#8]		; possibly a flags problem...?
 MOV R10,R6
next$l				; get next file name
 MOV R0,#10
 ;FNLDR R1,wimp_data ; block
 ;ADD R1,R1,#&80		; address for directory name
 MOV R1,R9			; from CALLING ROUTINE : *where*...?
 FNLDR R2,wimp_block		; space...
 ;ADD R2,R2,#&40 ; new ;(
 MOV R3,#1
 MOV R4,R8			; current offset in the directory
 MOV R5,#&100
 ADR R6,wild$l
 SWI XOS_GBPB
 FNRTS VS
 MOVCC R0,#-1
 FNRTS CC			; nothing read - reached the end
 MOV R8,R4			; save next thing to look at
 LDR R0,[R2,#16]		; object type
 TEQ R0,#2
 BEQ doadir$l
 TST R0,#1
 BEQ next$l			; not a file
 LDRB R14,[R2,#21]
 CMP R14,#31
 LDRLEB R14,[R2,#20]
 CMPLE R14,#'0'
 BEQ next$l
 LDR R0,[R2,#0]			; load address
 BL calc_ftype
 BCC next$l			; untyped
 SUB R0,R0,#&F00
 TEQ R0,#&FD
 TEQNE R0,#&FF
 BNE next$l			; not data or text type / any will do.

 ;ADD R1,R11,#4
 MOV R1,R11
 ADD R2,R2,#20			; filename
 BL strcopy
 MOV R0,#0			; no index
 FNRTS
doadir$l
 MOV R0,#1
 STR R0,[R10,#4]			; submenu off this entry - yes...
 LDR R0,[R10]
 ORR R0,R0,#1<<3
 STR R0,[R10]			; set warning bit
 ;LDR R0,[R6]			; submenu creation...
 ;ORR R0,R0,#1<<3
 ;STR R0,[R6]			; set warning bit
 ;MOV R0,#1
 ;STR R0,[R6,#4]			; submenu off this entry - yes...
 ADD R7,R7,#4			; add in room for open code...
 ADR R0,mw_substylelist		; warn code...
 STR R0,[R7,#-12]		; open code
;; MOV R0,#0			; commented as has no effect...?
;; STR R0,[R7,#-4]		; no exec sub?????????????????

 ADD R1,R11,#4
 ADD R2,R2,#20			; filename of directory...
 BL strcopy
 MOV R0,#0			; no index
 FNRTS
dir$l = |zap$|,"Fonts:",0
wild$l = "*",0
 ALIGN
create$l			; R10=address of menu = menu name
 FNJSR
 CMP R8,#0			; IB friendly...
 FNRTS EQ
 LDR R0,[R8,#w_font]
 LDR R0,[R0,#font_data0]
 BL conv_font_off		; R7=font block
 MOV R1,R10			; Font name first part (title bar?)
 LDR R2,[R7,#4]			; font name
 BL strCMPstr			; R0=char after match
 FNRTS NE			; doesn't match family
 MOV R6,R0
 ADD R5,R10,#28			; first menu item
 LDRB R0,[R6],#1		; R6=start of second half
 TEQ R0,#'.'
 FNRTS NE
a$l
 LDR R1,[R5,#12]		; from menu buffer
 MOV R2,R6			; rest of font name
 BL strCMPstr			; new str
 BLEQ weedoutcases
 LDR R0,[R5]
 ORREQ R0,R0,#1			; ticking the font in use...
 BICNE R0,R0,#1			; and clearing any other ticks...
 STR R0,[R5],#24
 TST R0,#1<<7			; at end yet
 BEQ a$l
 FNRTS
weedoutcases
 LDRB R0,[R0]
 CMP R0,#'.'
 MOVEQ PC,R14
 CMP R0,#31
 MOVLES R0,#0
 MOV PC,R14
mwbml_execsub			; R3=address of prev item start R10=text
 CMP R8,#0			; IB friendly...
 MOVEQ PC,R14			; IB friendly...
 FNJSR "R0-R12"
 FNLDR R1,wimp_data		; buffer
 LDR R2,[R3,#12]		; text
 BL strcpy
 MOV R0,#'.'
 STRB R0,[R1],#1
 MOV R2,R10
 BL strcopy

 FNLDR R0,wimp_data		; text for this item = font name
; PUSH "R0-R12"
 BL Bitmapfont
; PULL "R0-R12"
 FNRTS

 LOCAL

;E Called by warning code
;  R5=off in mother menu R10=address of text
;X Created bitmaplist submenu R1=submenu
;  Other registers preserved!

font_path_name
 = "ZapFonts:"
font_path_leaf
 FNS ("00x00zzzzz.NameOfFont.Style+ForGoodMeasure")

mw_substylelist
 FNJSR "R2-R10"

 ADR R9,font_path_name
 MOV R1,R9			; must match above... :-(
 BL asfarasastops$l
 MOV R14,#'.'			; at the right spot?
 STRB R14,[R1],#1

 MOV R2,R10			; new name
 BL strcopy			; R9=Fonts:<size>.<name>.<sub-style>

 MOV R0,R10			; menu title...
 ADR R1,buildsub$l
 ADR R2,create$l		; not needed...? for ticks...
 ADR R3,execsub$l
 MOV R4,#43			; width...(very wide :-< use new WM...)
 MOV R8,#0			; R8=counter...
 BL build_second_font_menu	; don't bother to preserve r9...
 MOV R1,R0			; in R1
 ;possibly try to adjust width retrospectively...
 ;FNRTS VS
 ;MOV R1,R0
 ;BL sort_menu
 ;MOVVC R0,R1			; menu pointer R0?
 FNRTS				; return menu pointer in R0
buildsub$l			; uses WB
 FNJSR "R1-R7,R11"		; r7 not changed so OK.
 MOV R11,R0			; save buffer pointer
 LDR R14,[R6,#8]		; possibly a flags problem...?
 BIC R14,R14,#(1<<3)+(1<<6)+(1<<7)
 STR R14,[R6,#8]		; possibly a flags problem...?
next$l				; get next file name
 MOV R0,#10
 MOV R1,R9			; from CALLING ROUTINE : *where*...?
 FNLDR R2,wimp_data ; block	; space...
 ADD R2,R2,#&90 ; new ;(
 MOV R3,#1
 MOV R4,R8			; current offset in the directory
 MOV R5,#&100
 ADR R6,wild$l
 SWI XOS_GBPB
 FNRTS VS
 MOVCC R0,#-1
 FNRTS CC			; nothing read - reached the end
 MOV R8,R4			; save next thing to look at
 LDR R0,[R2,#16]		; object type
 TST R0,#1
 BEQ next$l			; not a file
 LDRB R14,[R2,#21]
 CMP R14,#31
 LDRLEB R14,[R2,#20]
 CMPLE R14,#'0'
 BEQ next$l
 LDR R0,[R2,#0]			; load address
 BL calc_ftype
 BCC next$l			; untyped
 SUB R0,R0,#&F00
 TEQ R0,#&FD
 TEQNE R0,#&FF
 BNE next$l			; not data or text type / any will do.
 MOV R1,R11			; normal
 ADD R2,R2,#20			; filename
 BL lengthenssname
 BL strcopy
 MOV R0,#0			; no index
 FNRTS
dir$l = |zap$|,"Fonts:",0
wild$l = "*",0
 ALIGN
create$l			; R10=address of menu = menu name
 CMP R8,#0			; IB friendly...
 MOVEQ PC,R14
 FNJSR
 LDR R0,[R8,#w_font]
 LDR R0,[R0,#font_data0]
 BL conv_font_off		; R7=font block
 ;MOV R1,R10			; Font name first part (title bar?)
 ADRL R1,font_path_leaf
 LDR R2,[R7,#4]			; font name
 BL strCMPstr			; R0=char after match
 FNRTS NE			; doesn't match family
 MOV R6,R0
 ADD R5,R10,#28			; first menu item
 LDRB R0,[R6],#1		; R6=start of second half
 TEQ R0,#'.'
 FNRTS NE
a$l
 FNLDR R1,wimp_data ; block		; space...
 LDR R2,[R5,#12]		; from menu buffer
 BL strcopy
 FNLDR R2,wimp_data ; block		; space...
 BL shortenname

 MOV R1,R2
 MOV R2,R6			; rest of font name
 BL strCMPstr			; new str
 BLEQ weedoutcases
 LDR R0,[R5]
 ORREQ R0,R0,#1			; ticking the font in use...
 BICNE R0,R0,#1			; and clearing any other ticks...
 STR R0,[R5],#24
 TST R0,#1<<7			; at end yet
 BEQ a$l
 FNRTS
execsub$l			; R3=address of prev item start R10=text
 CMP R8,#0			; IB friendly...
 MOVEQ PC,R14			; IB friendly...
 FNJSR "R0-R12"
 FNLDR R1,wimp_data		; buffer
 ADRL R2,font_path_leaf
 ;LDR R2,[R3,#12]		; text
 BL strcpy
 MOV R0,#'.'
 STRB R0,[R1],#1
 MOV R5,R1			; temp...
 MOV R2,R10
 ADD R1,R5,#&30
 BL strcopy
 ADD R2,R5,#&30
 BL shortenname
 MOV R1,R5			; temp...
 BL strcopy

 FNLDR R0,wimp_data		; text for this item = font name
 PUSH "R0-R12"
 BL Bitmapfont
 PULL "R0-R12"
 FNRTS

asfarasastops$l
 FNJSR ; "R0"
loop$l
 LDRB R14,[R1]
 CMP R14,#'.'
 CMPNE R14,#31
 ADDGT R1,R1,#1
 BGT loop$l
 FNRTS				; R1 = PTR TO FINAL 0 or '.'

;E R2 = pointer to substyle name E.G. 'U'
;X R2 = pointer to long substyle name E.g. 'Underlined'

lengthenssname
 FNJSR "R1,R3-R7"
 MOV R7,R2
 MOV R6,#0
 FNLDR R3,wimp_data
;
 MOV R4,R3
bloop$l
 LDRB R0,[R2],#1
 BIC R0,R0,#32
 CMP R0,#32
 BCC prealoop$l
 TEQ R0,#'B'
 TEQNE R0,#'I'
 TEQNE R0,#'S'
 TEQNE R0,#'U'
 BNE theend$l
 B bloop$l
prealoop$l
 MOV R2,R7
;
aloop$l
 LDRB R0,[R2],#1
 BIC R0,R0,#32
 TEQ R0,#'B'
 ADREQ R5,boldlong$l
 TEQNE R0,#'I'
 TEQNE R0,#'S'
 TEQNE R0,#'U'
 BNE theend$l
 TEQ R0,#'I'
 ADREQ R5,italiclong$l
 TEQ R0,#'S'
 ADREQ R5,strikethroughlong$l
 TEQ R0,#'U'
 ADREQ R5,underlinedlong$l
 BL copyitin$l
 B aloop$l
theend$l
 CMP R3,R4
; CMP R3,R14
 MOVNE R2,R4
 MOVNE R14,#0
 STRNEB R14,[R3]
 MOVEQ R2,R7
 FNRTS

copyitin$l
 FNJSR "R1,R2"
 MOV R1,R3
 CMP R6,#0
 ADRNE R2,plus$l
 BLNE strcpy
 MOV R0,R5
 BL lookup_token_R0
 MOV R2,R0
 BL strcpy
 MOV R6,#1
 MOV R3,R1
 FNRTS

plus$l
 = " + ",0

 ALIGN

;  LDRB R0,[R2,#1]
;  CMP R0,#31
;  MOVGE PC,R14
;  LDRB R0,[R2,#1]
;  CMP R0,#0
;  BEQ single$l
;  LDRB R0,[R2,#2]
;  CMP R0,#0
;  ADRNE R2,bolditalicunderlinedlong$l
;  MOVNE PC,R14
;
;  LDRB R0,[R2,#1]
;  TEQ R0,#'B'
;  ADREQ R2,boldunderlinedlong$l
;  TEQ R0,#'I'
;  ADREQ R2,italicunderlinedlong$l
;  MOV PC,R14
;
; single$l
;  LDRB R0,[R2]
;  TEQ R0,#'B'
;  ADREQ R2,boldlong$l
;  TEQ R0,#'I'
;  ADREQ R2,italiclong$l
;  TEQ R0,#'U'
;  ADREQ R2,underlinedlong$l
;  MOV PC,R14

;E R2 = pointer to long substyle name e.g. 'Underlined'
;X R2 = pointer to substyle name e.g. 'U'

shortenname
 FNJSR "R0-R1,R3-R6"
 ;FNLDR R4,wimp_data
 MOV R1,R0
 ADR R4,local_verytemp
 MOV R6,R4
 MOV R3,R2
 MOV R5,#'U'
 ADR R0,underlinedlong$l
 BL matched$l
 BL skipon$l
 BEQ enditnow$l

 MOV R5,#'S'
 ADR R0,strikethroughlong$l
 BL matched$l
 BL skipon$l
 BEQ enditnow$l

 MOV R5,#'I'
 ADR R0,italiclong$l
 BL matched$l
 BL skipon$l
 BEQ enditnow$l

 MOV R5,#'B'
 ADR R0,boldlong$l
 BL matched$l
 BL skipon$l
 ;BEQ enditnow$l

enditnow$l
 CMP R4,R6
 MOVNE R14,#0
 STRNEB R14,[R4]
 MOVNE R2,R6
 MOVEQ R2,R3
 FNRTS

local_verytemp
 DCD 0
 DCD 0

matched$l
 FNJSR
 BL lookup_token_R0
 MOV R2,R3
 BL strcmpstr
 STREQB R5,[R4],#1
 MOVEQ R3,R1
 FNRTS

; EQ if end found.
;X R3 updated to nexr non ' '/'+'
skipon$l
 FNJSR
threeloop$l
 LDRB R14,[R3],#1
 TEQ R14,#0
 FNRTS EQ
 TEQ R14,#'+'
 TEQNE R14,#' '
 BEQ threeloop$l
 SUB R3,R3,#1
 FNRTS

boldlong$l
 FNS ("zap_m_bold")
italiclong$l
 FNS ("zap_m_italic")
strikethroughlong$l
 FNS ("zap_m_strkthru")
underlinedlong$l
 FNS ("zap_m_uline")

; List of possible file types to use

 LOCAL

 DCD 7+(1<<16)
Typelist
 FNJSR
 TEQ R2,#16
 FNRTS NE
 ADR R0,name$l
 ADR R1,build$l+1
 MOV R2,#0			; no creating sub (use Newtype command)
 FNADR R3,ext1$l		; new type command
 ORR R3,R3,#1<<31:OR:2<<27	; it's a command execute type
 MOV R4,#14
 MOV R8,#0			; count
 BL build_menu
 MOVVC R1,R0			; save menu pointer
 BLVC sort_menu
 MOVVC R0,R1
 FNRTS
name$l FNS ("zap_m_ftype")
ext1$l DCD Newtype
build$l
 FNJSR "R1-R4"
 LDR R14,[R6,#8]		; possibly a flags problem...?
 BIC R14,R14,#(1<<3)+(1<<6)+(1<<7)
 STR R14,[R6,#8]		; possibly a flags problem...?
 MOV R1,R0                      ; pointer to buffer
 MOV R2,#32                     ; buffer len
 MOV R3,R8                      ; name pointer
 MOV R4,#3
 ADR R0,type$l
 SWI XOS_ReadVarVal
 MOVVS R0,#-1			; no more
 BVS end$l
 MOV R0,#0
 STRB R0,[R1,R2]                ; terminate string
 ADD R1,R3,#10                  ; start of hex digits
 BL hex_read                    ; convert to filetype in R0
 MOV R8,R3                      ; save new name pointer
end$l
 ADDS R0,R0,#0                  ; clv
 FNRTS
type$l FNS ("File$Type_*")

; List of keymaps (for basemap selection)

	LOCAL

	DCD	7+(1<<16)
Basemaplist
	FNJSR
	TEQ	R2,#16
	FNRTS	NE
	ADR	R0,name$l
	ADR	R1,build$l+1
	MOV	R2,#0		; no creating sub (use Basemap command)
	FNADR	R3,cmd$l	; new type command
	ORR	R3,R3,#1<<31:OR:2<<27 ; it's a command execute type
	MOV	R4,#14
	FNLDR	R11,key_maplist	; count
	BL	build_menu
	MOVVC	R1,R0		; save menu pointer
	BLVC	sort_menu
	MOVVC	R0,R1
	FNRTS
name$l	FNS	("zap_m_basemap")
cmd$l	DCD	Basemap
build$l
	FNJSR	"R1-R4"
	LDR	R3,[R11],#20	; keymap number
	LDR	R14,[R6,#8]	; possibly a flags problem...?
	BIC	R14,R14,#(1<<3)+(1<<6)+(1<<7)
	STR	R14,[R6,#8]	; possibly a flags problem...?
	TEQ	R3,#0
	MOVMI	R0,#-1
	FNRTS	MI

	LDR	R2,[R11,#-4]	; ptr to name
	TEQ	R2,#0		; if 0 then build default
	BEQ	mapn$l
	MOV	R1,R0		; buffer ptr
	MOV	R0,#48		; buffer len
	BL	strbuf		; copy name
	MOV	R0,R3
	FNRTS
mapn$l	MOV	R1,#'M'
	STRB	R1,[R0],#1
	MOV	R1,#'a'
	STRB	R1,[R0],#1
	MOV	R1,#'p'
	STRB	R1,[R0],#1
	MOV	R1,#' '
	STRB	R1,[R0],#1
	MOV	R1,R0
	MOV	R0,R3
	MOV	R2,#4
	SWI	XOS_ConvertCardinal1
	MOVVC	R0,R3
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; S U B M E N U	  B U F F E R S (Old style)		;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mf_warn * 8

sm_curlist
 FNnew_menu "zap_m_ct",11,cm_curlist
 FNnme "zap_m_ct0",0,0,0,sub_curlist
 FNnme "zap_m_ct1",0,0,0,sub_curlist
 FNnme "zap_m_ct2",0,0,0,sub_curlist
 FNnme "zap_m_ct3",0,0,0,sub_curlist
 FNnme "zap_m_ct4",0,0,0,sub_curlist
 FNend_menu

sm_minibuffer
 FNnew_menu "zap_m_mb",12,cm_minibuffer
 FNnme "zap_m_mb0",0,0,0,sub_minibuffer,s_minipopup
 FNnme "zap_m_mb1",0,0,0,sub_minibuffer,s_miniperm
 FNnme "zap_m_mb2",0,0,0,sub_minifont,s_minifont
 FNnme "zap_m_mb3",mf_warn,mw_collist_mini,0,0,s_minifor
 FNnme "zap_m_mb4",mf_warn,mw_collist_mini,0,0,s_minibac
 FNend_menu

sm_cursor
 FNnew_menu "zap_m_cu",9,0
 FNnme "zap_m_cu0",mf_warn,mw_curlist,0,0
 FNnme "zap_m_cu1",mf_warn,mw_curlist,0,0
 FNnme "zap_m_cu2",mf_warn,mw_curlist,0,0
 FNnme "zap_m_cu3",mf_warn,mw_curlist,0,0
 FNend_menu

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialise old style relocatable menus	;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;X mode menus, main menu and Zap menu structures created  #
;  (Now creates them in heap blocks)
;  memory 0=reserved 1=reserved 2=curlist 3=minibuffer 4=cursor

init_menus
 FNJSR "R1-R2"
 FNLDR R2,menu_memory		; address of 16 word memory
 ADR R0,sm_curlist
 BL expand$l
 STRVC R0,[R2,#8]
 ADRVC R0,sm_minibuffer
 BLVC expand$l
 STRVC R0,[R2,#12]
 ADRVC R0,sm_cursor
 BLVC expand$l
 STRVC R0,[R2,#16]
 FNRTS
expand$l
 FNJSR "R2-R3"
 MOV R1,#0
 ADRL R2,Module_header
 BL expand_menu
 MOVVC R1,R2
 MOVVC R2,R0
 BLVC create_menu_structure
 MOVVC R3,R0
 MOVVC R0,R2
 BLVC heap_free
 MOVVC R0,R3
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Load menus file				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R10=start of menu structure title string
;X R0=created menu (+4)/0 if it wasn't valid #

read_one_menu
 FNJSR "R1-R4,R10-R11"
 BL read_count_menu		; find number of entries
 FNRTS VS			; bad entry found
 CMP R0,#0
 FNRTS EQ			; menu is null!
 MOV R0,R0,LSL#3		; times 8
 ADD R0,R0,R0,LSL#1		; times 3 (24 bytes per entry)
 ADD R4,R0,#28			; + 28 bytes header = header amount
 ADD R0,R4,R1			; total amount (with string buffers)
 ADD R0,R0,#8			; add space for count and cm
 BL heap_claim			; get the memory memory
 ADDVC R11,R0,#8		; menu pointer
 MOVVC R1,R11			; menu title
 BLVC str_strcopy		; copy in the title
 ADR R1,header$l
 ADD R2,R11,#12
 MOV R3,#16
 SWI XZapRedraw_MoveBytes ; BL move_bytes			; copy in default header
 BL str_skip
 BL str_readnum			; get menu width in chars
 FNRTS VS
 MOV R0,R0,LSL#4		; width in os coords
 STR R0,[R11,#16]		; and insert the width
 ADD R3,R11,#28			; start of first menu entry
 ADD R4,R11,R4			; start of scratch space for buffers
a$l
 BL next_menu_entry		; move to the start of the next entry
 BCS end$l
 LDRB R0,[R10]			; get first character
 TEQ R0,#'-'
 BEQ b$l			; add dashed line
 TEQ R0,#'"'
 BNE a$l			; not a valid entry
 BL read_one_entry		; read this one menu entry
 ADDVC R3,R3,#24		; move onto next item
 BVC a$l			; next
 FNRTS
b$l
 LDR R0,[R3,#-24]
 ORR R0,R0,#2			; dotted line follows
 STR R0,[R3,#-24]
 B a$l
end$l
 LDR R0,[R3,#-24]
 ORR R0,R0,#&80			; mark as last item
 STR R0,[R3,#-24]
 MOV R0,#0
 STR R0,[R11,#-4]		; no update routine
 STR R0,[R11,#-8]		; zero the count
 MOV R0,R11			; address of the menu structure
 FNRTS
header$l
 DCD &00070207,256,44,0

 LOCAL

;E R10=start of menu title string
;X R0=number of menu entries found
;  R1=total amount of storage space needed for the menu entry strings #

read_count_menu
 FNJSR "R10-R11"
 MOV R11,#0			; number found so far
 MOV R1,#0			; storage space
a$l
 BL next_menu_entry
 MOVCS R0,R11			; can't find any more
 FNRTS CS
 LDRB R0,[R10]
 TEQ R0,#'"'
 BNE a$l			; was a '-' or not a proper entry
 BL str_strlen			; count the length of the entry string
 CMP R0,#0
 BLMI err$l			; mismatched quotes
 FNRTS VS
 ADD R11,R11,#1			; found another
 ADD R0,R0,#4			; terminator + align
 BIC R0,R0,#3
 ADD R1,R1,R0			; add room for the text of the entry
 ADD R1,R1,#12			; add room for the addresses
 B a$l
err$l ERR "zap_e_menustrprob"

 LOCAL

;E R10=somewhere on a menu entry line
;X R10=start of next line after the indenting spaces CS if there are no
;  more entries

next_menu_entry
 FNJSR
 BL str_next			; start of next line
 FNRTS CS			; reached the file end
 LDRB R0,[R10]			; first character of line
 TEQ R0,#9
 TEQNE R0,#&20
 BNE a$l
 BL str_skip			; skip the spaces
 ADDS R0,R0,#0			; clc
 FNRTS
a$l
 SUBS R0,R0,#0			; sec
 FNRTS

;E R0=menu handle
;X R1=pointer to wimp menu structure (+8) /0

read_menu_handle
 FNJSR
 FNLDR R1,menu_handles
 LDR R14,[R1],#4
 CMP R0,R14
 LDRCC R1,[R1,R0,LSL#2]		; R0=the new Zap menu start
 MOVCS R1,#0			; R0=the Zap menu start
 FNRTS

 LOCAL

;E R3=menu entry to create R4=start of scratch space R10=input file text
;X R0-R2 corrupted R4 updated R3 decremented to delete the entry #

read_one_entry
 FNJSR "R6-R7,R10"
 MOV R0,#0
 STR R0,[R4],#4
 STR R0,[R4],#4
 STR R0,[R4],#4			; clear the 3 address entry points
 STR R0,[R3,#16]		; validation string
 MOV R0,#1<<3			; all menus warned
 STR R0,[R3]			; default menu flags
 LDR R0,iconf$l
 STR R0,[R3,#8]			; icon flags
 MOV R2,R4
 MOV R1,R4
 BL str_strcopy			; copy in the text for this entry
 ADD R1,R1,#3
 BIC R4,R1,#3			; word align for next entry
 STR R2,[R3,#12]		; text address
 SUB R0,R4,R2
 STR R0,[R3,#20]		; buffer length
 BL str_skip			; skip any spaces
 LDRB R0,[R10]
 TEQ R0,#'>'			; submenu pointer ?
 BEQ sub$l
 BL read_command		; read the command name (updates R10)
 BLVS readnull$l		; bad command name
; FNRTS VS			; bad command name (may get b0 set form)
 ORR R0,R7,#1<<31
 ORR R0,R0,R6,LSL #27
 STR R0,[R2,#-4]		; command address
 STR R1,[R2,#-8]		; command data
sub$l				; start on the submenu pointer
 MOV R0,#-1
 STR R0,[R3,#4]			; no submenu as default
 LDRB R0,[R10],#1
 TEQ R0,#'>'
 FNRTS NE			; no submenu
 BL str_skip			; skip spaces
 BL str_readnum			; submenu number
 STRVC R0,[R3,#4]
 FNRTS VC
command$l			; check for command giving submenu
 ADDS R0,R0,#0			; clv
 MOV R0,R10
 BL look_key_command		; R0=address / 0 if not found WB
;;;;;; FNRTS VS			; no good (never called?)
 MOVS R7,R0
; BLEQ nocommandsousenull$l	; a problem...
 FNRTS EQ			; uh oh - a problem...
 BL get_command_flags		; may not be known!
 TST R0,#1<<16
 BEQ box$l			; open leaf box
 MOV R0,#1
 STR R0,[R3,#4]			; there is a submenu
 BL validate_command
 ORRVC R7,R7,#1<<31		; safe to assume CS if VC
 STRVC R7,[R2,#-12]		; command to call to open submenu
 FNRTS
box$l				; create a leaf box R7=the command R0=flags
 BL create_leaf_box		; R0=address of leaf box
 STRVC R0,[R3,#4]		; address of the submenu
 FNRTS
iconf$l DCD &07009131		; icon flags

; nocommandsousenull$l		; and hope that's good enough...
; ; B box$l
;  MOV R0,#1
;  STR R0,[R3,#4]			; there is a submenu
;  ORR R7,R7,#1<<31		; safe to assume CS if VC
;  STR R7,[R2,#-12]		; command to call to open submenu
;  FNRTS

readnull$l
 FNJSR "R0"
 ADR R0,getanull$l
 BL look_key_command
 ADDS R7,R0,#0			; clv
 FNRTS

getanull$l
 FNS ("BEEP")		; to signal command not loaded...

 LOCAL

;E R7=the command to create the box for R10=command name string
;X R0=address of the leaf box menu

create_leaf_box
 FNJSR "R1-R6"
 LDR R4,[R7,#-4]		; get the command flags
 MOV R5,R4,LSR#3
 AND R5,R5,#7			; command type
 TEQ R5,#1
 TEQNE R5,#2
 MOVEQ R0,#8
 MOVNE R0,#16			; default bufffer size
 TST R4,#1<<17
 BEQ a$l
 MOV R2,#17
 MOV R0,#2
 BL process_command		; find the buffer size
 FNRTS VS
 CMP R0,#2
 MOVLE R0,#4			; minimum buffer size
a$l				; R0=buffer size to use
 MOV R6,R0			; save requested buffer size
 ADD R0,R0,#3+8+28+24+12	; cm+header+one entry+pre buffer
 BIC R0,R0,#3			; and round up
 BL heap_claim
 FNRTS VS
 MOV R5,R0			; start of the menu
 MOV R0,#0
 STR R0,[R5],#4			; clear the count
 ADR R0,cm_leaf_box
 STR R0,[R5],#4			; set create menu routine
 TST R4,#1<<17
 MOVEQ R0,R10			; pointer to command name
 BEQ b$l
 MOV R2,#17
 MOV R0,#0
 BL process_command
 FNRTS VS
b$l				; R0=command name
 MOV R1,R5
 MOV R2,R0
 MOV R3,#12
 MOV R4,#&0A
 BL strmove			; copy in the menu name
 ADR R1,header$l
 ADD R2,R5,#12
 MOV R3,#28
 SWI XZapRedraw_MoveBytes ; BL move_bytes ; copy in rest of menu header + icon flags
 ADD R4,R5,#28			; start of the menu entry
 ADD R3,R4,#24+12		; string buffer
 STR R3,[R4,#12]		; icon address
; SWI &107			; !!!never!
 MOV R0,#0
 STR R0,[R4,#16]		; no validation string
 STR R0,[R3,#-12]		; no submenu code
 STR R0,[R3]			; initially clear buffer
 STR R6,[R4,#20]		; buffer size
 MOV R6,R6,LSL#4		; 16 os per character
 CMP R6,#&100			; upper bound
 MOVGT R6,#&100
 STR R6,[R5,#16]		; menu width in OS
 ADR R0,sub_leaf_box
 STR R0,[R3,#-4]		; command to do the executing
 STR R7,[R3,#-8]		; command address is the index
 MOV R0,R5
 FNRTS
header$l
 DCD &00070207,256,44,0,&84,-1,&07009131

 LOCAL

; creation sub for a leaf menu box (index=the command address)

cm_leaf_box
 FNJSR
 ADD R6,R10,#28			; first menu entry
 LDR R5,[R6,#12]		; address of the text buffer
 LDR R7,[R5,#-8]		; address of the command (the index entry)
 CMP R7,#0
 FNRTS LE
 LDR R4,[R7,#-4]		; flags
 TST R4,#1<<17
 FNRTS EQ			; doesn't support update
 MOV R0,#1
 MOV R2,#17
 MOV R10,#0
 BL process_command		; R0=address of the string or number
 FNRTS VS
 CMN R0,#1
 FNRTS EQ			; don't change the buffer
 TEQ R0,#0
 BEQ a$l			; clear the buffer
 MOV R4,R4,LSR#3
 AND R4,R4,#7			; command type
 TEQ R4,#1
 TEQNE R4,#2
 BEQ b$l			; numerical argument
 TST R0,#1<<31
 BICNE R0,R0,#1<<31		; it's a number
 MOVNE R10,#0
 BNE d$l
 MOV R1,R5			; dest
 MOV R2,R0			; source
 LDR R3,[R6,#20]		; buffer length
 MOV R4,#&0D			; return code
 BL strmove
 FNRTS
a$l				; clear the buffer
 MOV R0,#0
 STRB R0,[R5]
 FNRTS
b$l				; numerical arg
 MOV R10,R0,LSR#31		; save the top bit
 BIC R0,R0,#1<<31		; address of the word/byte
 TEQ R4,#1
 LDREQB R0,[R0]
 LDRNE R0,[R0]			; word argument
d$l				; R0=number to insert R10=insert type
 MOV R1,R5			; dest
 LDR R2,[R6,#20]		; buffer length
 TEQ R10,#0
 BNE c$l			; hex
 SWI XOS_ConvertInteger4
 FNRTS
c$l
 MOV R14,#'&'
 STRB R14,[R1],#1
 SUB R2,R2,#1
 SWI XOS_ConvertHex8
 FNRTS

 LOCAL

; interpret sub for a leaf menu box (index=the command address)

sub_leaf_box
 FNJSR
 ADDS R7,R1,#0			; index = the command address
 FNRTS LE
 MOV R0,R10			; address of text for this entry
 LDR R14,[R7,#-4]		; command flags
 MOV R14,R14,LSR#3
 AND R14,R14,#7			; comand type
 TEQ R14,#1
 TEQNE R14,#2
 BNE a$l			; takes a string/no parameter
 BL minibuffer_eval		; get the number in R0
 FNRTS CS			; none
 STR R0,temp$l
 ADR R0,temp$l			; pointer to the number
a$l
 MOV R1,#1
 MOV R2,#0
 MOV R10,#0			; no cursor
 BL process_command
 FNRTS
temp$l DCD 0

;E R0=source menu (in old Zap relocatable format)
;  R1=base for offsets (start of module)
;X R0=wimp created menu structure (zap+8) (in heap block) |

create_menu_structure
 FNJSR "R10"
 MOV R10,R1
 BL cms_sub
 FNRTS

 LOCAL

;E R0=source structure (in old Zap relocatable format)
;  R10=module start (start of module used for offsets)
;X R0=menu(+4) (now stored in a heap block) |
;  Internal  R1=current source  R2=current destination R3=start dest

cms_sub
 FNJSR "R1-R11"
 MOV R1,R0			; source structure
 MOV R5,R1			; R5=save source
 ADD R1,R1,#&14			; first items
 MOV R4,#8+28			; R4=size need by menu (cm+header)
 MOV R6,#0			; R6=size needed by menu data
count$l				; count num of entries and menu size
 BL cms_next
 ADD R4,R4,#24			; add another entry
 ADD R6,R6,#12			; submenu and interpret area
 ADD R6,R6,R0			; text buffer size
 BNE count$l			; count entries to R4
 ADD R0,R4,R6			; total size needed by menu
 BL heap_claim
 FNRTS VS
 MOV R2,R0			; start of menu
 ADD R3,R2,#8			; save start of wimp structure (to return)
 ADD R6,R2,R4			; start of indirected data buffer
 MOV R0,#0
 STR R0,[R2],#4			; zero the count
 LDR R0,[R5,#&10]		; create sub offset
 TEQ R0,#0
 ADDNE R0,R0,R10		; create sub address
 STR R0,[R2],#4			; fill in create menu sub
 LDMIA R5,{R7-R8,R14}
 STMIA R2!,{R7-R8,R14}		; copy menu name
 LDR R1,cols$l
 LDR R7,[R5,#&0C]
 MOV R8,#44
 MOV R14,#0
 STMIA R2!,{R1,R7,R8,R14}	; colours, width, height, spacing
 ADD R1,R5,#&14			; first item
iconloop$l
 BL cms_icon			; fill in item icon and create its buffer
 LDRB R4,[R1]			; get the flags
 ORR R0,R4,#1<<3		; warn all menus now
 STR R0,[R2]			; save actual menu flags
 LDR R0,[R1,#4]			; get submenu pointer to source
 CMP R0,#0
 MOVEQ R0,#-1
 BEQ next$l			; no submenu
 TST R4,#1<<3			; warned ?
 MOVNE R0,#1
 BNE next$l			; yes - invalid submenu pointer
 ADD R0,R0,R10			; convert submenu to source address
 BL cms_sub			; create structure (iterate)
next$l				; R0=submenu pointer
 STR R0,[R2,#4]			; submenu pointer to finish item
 BL cms_next			; next source entry
 ADDNE R2,R2,#24		; next dest entry
 BNE iconloop$l
 LDR R0,[R2]
 ORR R0,R0,#1<<7		; no more so mark menu as finished
 STR R0,[R2]
 MOV R0,R3			; start of structre
 FNRTS				; return
cols$l DCD &00070207		; work area colours

 LOCAL

;E R1=current source menu item pointer (relocatable)
;X R0=size of buffer needed for this entry (inc term and aligned)
;  R1=next item pointer
;  EQ if at menu end (this was the last menu item) |

cms_next
 FNJSR "R2"
 LDRB R0,[R1,#1]		; minimum buffer size
 ADD R1,R1,#&10			; start of entry text
 MOV R2,R1			; save the start of the text entry
a$l
 LDRB R14,[R1],#1
 CMP R14,#&20
 BCS a$l			; skip the string
 SUB R2,R1,R2			; length of the string (inc term)
 CMP R0,R2
 MOVLT R0,R2			; new min buffer size
 ADD R1,R1,#3
 BIC R1,R1,#3			; word align to next menu entry
 ADD R0,R0,#3
 BIC R0,R0,#3			; word align buffer size
 LDR R14,[R1]
 CMP R14,#-1			; are we at menu end
 FNRTS

 LOCAL

;E R1=source entry (relocatable format)
;  R2=destination entry
;  R6=buffer for indirected data
;  R10=base of offsets (start of module)
;X Text for this entry set up and pointer written, len, validation string
;  Icon flags for this entry set up
;  R6 updated to next free location |

cms_icon
 FNJSR "R1-R5"
 MOV R4,R1			; R4=source
 LDR R1,[R4]			; R1=flags of source entry
 ANDS  R0,R1,#&FF000000		; icon colours
 ORREQ R0,R0,#&07000000		; default
 LDR R14,icon$l			; icon flags
 ORR R0,R0,R14
 STR R0,[R2,#8]			; write the icon flags
 ADD R5,R2,#12			; R5=dest icon data
 TST R1,#1<<3			; warned?
 LDRNE R0,[R4,#4]		; submenu pointer
 ADDNE R0,R0,R10		; submenu call address
 MOVEQ R0,#0			; no submenu code
 STR R0,[R6],#4			; save in buffer (text,#-12)
 LDR R0,[R4,#&08]		; index word
 TEQ R0,#0
 ADDNE R0,R0,R10		; it's an offset !?!
 STR R0,[R6],#4			; save index word (text,#-8)
 LDR R0,[R4,#&0C]		; sub to call
 TEQ R0,#0
 ADDNE R0,R0,R10		; address of interpret code.
 STR R0,[R6],#4			; exec sub (text,#-4)
 STR R6,[R5]			; pointer to indirected string
 MOV R1,R6
 ADD R2,R4,#&10
 BL strcopy			; copy menu text
 SUB R0,R1,R6			; length of buffer
 LDRB R14,[R4,#1]		; min buffer length
 CMP R0,R14
 MOVLT R0,R14			; buffer length
 STR R0,[R5,#8]			; write buffer length
 ADD R6,R6,R0			; end of string
 ADD R6,R6,#3
 BIC R6,R6,#3			; word align
 MOV R0,#0
 STR R0,[R5,#4]			; no validation string
 FNRTS
icon$l DCD &00009131		; icon flags (indirect text)

 LOCAL

;E R1=pointer to menu (zap+8)
;X key short cuts shown on this one menu (not recursive) #

show_menu
 FNJSR "R1,R7,R11"
 ADD R1,R1,#28			; first item in menu
loop$l
 LDR R14,[R1,#12]		; address of indirected data
 LDR R0,[R14,#-4]		; interpret code of the menu entry
 TST R0,#1<<31
 BEQ next$l			; not a command
 MOV R11,R7,LSR #27
 AND R11,R11,#15
 BIC R7,R0,#&FC<<24		; address of the command
 LDR R0,[R14,#-8]		; data for the command
 BL find_key			; get associated key in R0
 CMP R0,#0
 BL hide_key$l
 BMI next$l			; no key
 PUSH "R1"
 LDR R1,[R1,#12]		; get menu string
 BL show_key			; add key macro
 PULL "R1"
next$l
 LDR R0,[R1],#24		; get flags
 TST R0,#&80			; are we at end?
 BEQ loop$l			; next item
 FNRTS

hide_key$l			; menu width fiddling for outline font WMs
	FNJSR	"R0-R3"
	FNLDR	R3,wimp_realver
	MOVPL	R2,#32
	MOVMI	R2,#31
	CMP	R3,#320
	FNRTSS	LS
	LDR	R1,[R1,#12]	; get menu string
	MOV	R3,#0
a$l	LDRB	R0,[R1],#1
	CMP	R0,#32
	ADDHI	R3,R1,#1
	CMP	R0,#31
	BGE	a$l
	TEQ	R3,#0
	TEQNE	R3,R1
	STRNEB	R2,[R3,#-1]
	FNRTSS

 LOCAL

;E R1=menu address R2=mouse x R3=mouse y R4=mode (if R3b31 set) R8/R9
;X menu updated and opened & wimp_menuptr/wimp_menu updated #

create_menu
 FNJSR "R1-R3"
 TST R3,#1<<31
 BIC R3,R3,#1<<31
 MOVEQ R14,#-1
 MOVNE R14,R4
 FNSTR R14,menu_mode
 SUB R2,R2,#64
 TEQ R8,#0
; SUBNE R2,R2,#64		; adjust the x for window menus
 BNE a$l
; SUB R2,R2,#96			; adjust the x for main menu
 MOV R0,R1
 BL count_menu_size		; R0=menu height
 ADD R3,R0,#96			; y opening offset
a$l
 BL open_menu
 FNRTS

;E R1=menu address R2=mouse x R3=mouse y R8/R9
;X menu updated and opened etc.

open_menu
 FNJSR
 FNLDR R0,menu_count
 ADD R0,R0,#1
 FNSTR R0,menu_count		; everything needs updating
 MOV R0,#0
 BL update_menu			; update the given menu
 BLVC get_wind_off
 FNSTR R0,wimp_menu,VC		; window offset
 FNSTR R1,wimp_menuptr,VC	; save pointer to current menu
 SWIVC XWimp_CreateMenu
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Update menu ticks					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;(this is OK - i.e. fairly bug free)
;
;E R0=offset in previous menu/0 R1=menu to update  R8/R9=source window
;X menu updated (not recursive) #

update_menu
 CMP R1,#&100
 MOVCC PC,R14			; serious problems...
 FNJSR "R1-R11"
; FNRTS
 FNLDR R3,menu_count		; time needs to be updated for
 LDR R4,[R1,#-8]		; last time menu updated
 CMP R4,R3
 FNRTS GE			; already updated
 STR R3,[R1,#-8]		; new update time
 LDR R11,[R1,#-4]		; creation address ; problem with longfiles!?
 CMP R11,#0
 BLE com$l			; do the commands (0 or bit set)
 MOV R10,R1			; menu address
 TEQ R8,#0
 FNLDR R7,opt_flags,EQ
 FNLDR R6,opt_format,EQ
 LDRNE R7,[R8,#w_flags]
 LDRNE R6,[R8,#w_format]	; flags and format
 MOVS R14,PC			; return (R0=offset in previous)
 MOV PC,R11			; call the sub
 FNRTS				; finished
com$l				; creation address le 0
 BICS R11,R11,#1<<31		; address of the source menu
 BEQ gotmenu$l			; already got the menu
 PUSH "R1"
 LDR R3,[R11],#4		; length of the menu
 ADD R2,R1,#28			; destination (first entry)
 MOV R1,R11			; source
 SWI XZapRedraw_MoveBytes	; BL move_bytes	; copy in the menu
 PULL "R1"
gotmenu$l			; menu has been copied if need be
 MOV R11,R1			; save the menu start
 ADD R6,R11,#28			; first item
 MOV R10,#0			; no cursor
a$l
 LDR R5,[R6,#12]		; address of the item text
 LDR R7,[R5,#-4]		; interpret code
 TST R7,#1<<31
 BEQ next$l			; no command here
 BIC R7,R7,#&FC<<24		; command address (maybe b0 set)
 BL get_command_flags
 MOV R4,R0			; command flags
; TST R7,#1
; TSTNE R0,#1<<15:OR:1<<18:OR:1<<19:OR:1<<20
; BEQ comok$l
; LDR R0,[R5,#-4]
; AND R0,R0,#&FC<<24
; ORR R0,R0,R7
; STR R0,[R5,#-4]		; new interpret code address
;comok$l				; validated the command address
 TST R4,#1<<20			; possibly delete this entry?
 BEQ nodel$l

 MOV R2,#20			; command reason code
 BL menu_process_key_command
 FNRTS VS
 TST R0,#1
 BEQ nodel$l			; don't delete the entry
 LDR R0,[R11,#-4]
 TST R0,#1<<31
 BLEQ update_menu_backup	; make a backup copy before we delete
 FNRTS VS
 MOV R0,R6
 BL count_menu_entries		; R0=number of entries left
 SUBS R0,R0,#1			; number to shift
 BLE lastitem$l
 ADD R1,R6,#24			; source
 MOV R2,R6
 ADD R3,R0,R0,LSL#1
 MOV R3,R3,LSL#3
 SWI XZapRedraw_MoveBytes	; BL move_bytes	; shift next entry down
 B a$l				; try doing this entry again
lastitem$l			; tried to remove the last item
 LDR R0,[R6,#-24]
 ORR R0,R0,#1<<7		; make previous item the last
 STR R0,[R6,#-24]
 FNRTS
nodel$l				; don't delete the entry R4=flags etc
 TST R4,#1<<18
 BEQ gottxt$l

 MOV R2,#18			; command reason code
 BL menu_process_key_command
 FNRTS VS
 MOV R1,R5			; dest buffer
 ADDS R2,R0,#0			; source string
 BLGT callstrov$l		; copy in the new string
gottxt$l			; copied in the new text if needed
 TST R4,#1<<19			; does it want to supply a submenu?
 BEQ gotsubmenu$l
 LDR R0,[R5,#-12]		; submenu handler
 TEQ R0,#0
 BNE gotsubmenu$l		; handler already installed
 MOV R2,#19			; command reason code
 BL menu_process_key_command		; R0=menu pointer / 0 for none
 FNRTS VS
 CMP R0,#0
 MOVLE R0,#-1			; no submenu
 STR R0,[R6,#4]			; submenu pointer
gotsubmenu$l			; submenu pointer added
 TST R4,#1<<15
 BEQ next$l			; not tickable
 MOV R2,#15			; command reason code
 BL menu_process_key_command
 FNRTS VS
 LDR R1,[R6]			; get the menu flags
 TST R0,#1			; ticked?
 ORRNE R1,R1,#1
 BICEQ R1,R1,#1
 STR R1,[R6]
 LDR R1,[R6,#8]			; icon flags
 TST R0,#2			; shaded?
 ORRNE R1,R1,#1<<22
 BICEQ R1,R1,#1<<22
 STR R1,[R6,#8]
next$l				; finished
 LDR R0,[R6],#24
 TST R0,#&80
 BEQ a$l			; next item
 FNRTS

callstrov$l			; copy in the new string
 FNJSR
 BL strover			; copy in the new string
 MOV R14,#&20			; blank with spaces...
loop$l
 LDRB R0,[R1]
 CMP R0,#&20
 STRCSB R14,[R1],#1
 BCS loop$l
 FNRTS

	LOCAL

;E As for process_key_command, except:
;  R5->menu entry string buffer
;  R2=reason code
;  R0,R7 not set up
;X R0,R2,R7 changed

menu_process_key_command
	FNJSR
	LDR	R7,[R5,#-4]
	BIC	R7,R7,#&FC<<24
	BL	validate_command
	FNRTS	VS
	LDRCS	R0,[R5,#-4]
	ANDCS	R0,R0,#&FC<<24
	ORRCS	R0,R7,R0
	STRCS	R0,[R5,#-4]
	LDMDB	R5,{R0,R14}		; command argument & parameter type
	MOV	R14,R14,LSR #3
	AND	R14,R14,#&F<<24
	ADD	R2,R14,R2
	FNPULL
	B	process_key_command

	LOCAL

;E R11=address of the menu
;X menu backed up and R11,#-4 has the address of the backup copy +b31
;  Backup copy is of the form length,backup #

update_menu_backup
 FNJSR "R1-R3"
 ADD R0,R11,#28			; first item
 BL count_menu_entries		; R0=number of entries
 ADD R3,R0,R0,LSL#1
 MOV R3,R3,LSL#3		; size of backup
 ADD R0,R3,#4
 BL heap_claim
 ORRVC R14,R0,#1<<31
 STRVC R14,[R11,#-4]
 STRVC R3,[R0],#4
 ADDVC R1,R11,#28
 MOVVC R2,R0
 SWIVC XZapRedraw_MoveBytes ; BL move_bytes
 FNRTS

 LOCAL

;E R1=root node of the menu
;  R8/R9=window
;  R11=block with -1 terminated list of the selected path
;X All menus on selected path are updated. Menu warn code called as it
;  follows the path. menu_count incremented first #

update_menu_path
 FNJSR "R1-R2,R5,R11"
 FNLDR R0,menu_count
 ADD R0,R0,#1
 FNSTR R0,menu_count		; update menu count
 MOV R5,#0			; offset in previous menu
a$l
 MOV R0,R5
 BL update_menu			; recreate this menu
 FNRTS VS
 LDR R5,[R11],#4		; get the next submenu offset
 CMP R5,#0			; finished if -ve
 LDRPL R14,[R11]
 CMPPL R14,#0
 FNRTS MI			; this is the last entry so no submenu
 ADD R1,R1,#28
 ADD R1,R1,R5,LSL#4		; +16*
 ADD R2,R1,R5,LSL#3		; +8* so R2 now points to this entry
 BL call_warn_code		; R1=the submenu
 FNRTS VS
 CMP R1,#0
 FNRTS LE			; no submenu
 STR R1,[R2,#4]			; save menu pointer
 CMP R1,#&8000
 FNRTS LT
 TST R1,#3
 FNRTS NE			; was a window
 B a$l				; recurse onto this submenu

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MENU WARNING CODE				       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

menu_warning
 FNJSR
 MOV R11,R1			; start of data block
 FNLDR R0,wimp_menu
 BL conv_wind_off		; get R8/R9 of current window with menu
 FNLDR R1,wimp_menuptr		; menu address
 PUSH "R11"
 ADD R11,R11,#32		; sequence of choices
 BL menu_decode			; find item in R2
 LDR R5,[R11,#-4]		; offset in previous menu
 PULL "R11"
 BL call_warn_code		; get the submenu in R1
 FNRTS VS
 CMP R1,#0
 FNRTS LE			; no submenu
 STR R1,[R2,#4]			; save the submenu pointer
 CMP R1,#&8000
 BCC a$l			; it's a window
 TST R1,#3
 BNE a$l			; it's a RISC OS 3 window
 MOV R0,R5			; offset in previous menu
 BL update_menu			; update the submenu entries
 FNRTS VS
a$l
 LDR R2,[R11,#24]		; x pos
 LDR R3,[R11,#28]		; y pos
 SWI XWimp_CreateSubMenu	; XWimp_CreateSubMenu
; SWI &107
 FNRTS

 LOCAL

;E R2=address of menu entry
;  R5=offset in previous menu
;  R8/R9=window /0
;X R1=handle of window to open or pointer to submenu or 0 if none.

call_warn_code
 FNJSR "R2,R7,R10"
 LDR R10,[R2,#12]		; text of the entry
 LDR R7,[R10,#-12]		; address to create the submenu
 TEQ R7,#0
 BEQ a$l			; none
 TST R7,#1<<31
 BNE com$l			; new command style
 MOVS R14,PC			; old style
 MOV PC,R7			; get the menu address
 CMP R1,#&8000
 FNRTS CC
 TST R1,#3
 ; um - shit!?
 MOVEQ R0,#0			; if a menu...
 STREQ R0,[R1,#-8]		; needs to be updated (eg collist)
 FNRTS
com$l				; new style - call the command
 MOV R2,#16
 BIC R7,R7,#1<<31
 MOV R10,#0			; no cursor(! :-< )
 BL process_command		; returns in R0...!
 MOVVC R1,R0
 FNRTS
a$l
 LDR R1,[R2,#4]			; menu should already be there
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CREATE A VARIABLE LENGTH MENU				  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=menu name (max 12 chars)
;  R1=address of sub to create the menu (b0 set if menu name is a token)
;  R2=address of cm_sub to update the menu /0
;  R3=address of interpret sub for each menu entry /0
;  R4=menu width in characters
;  R8-R11=values to call creation sub with
;X R0=pointer to menu start (menu_struct+8) # (Does NOT use WB)
;    The sub pointed to by R1 has entry/exit
; ;E R0=buffer for string (48)
;    R5=address of start of menu structure
;    R6=address of menu entry being built
;    R7=address of current buffer entry (top of data+8)
;    R8-R11=as returned from last call
; ;X R0=index for this entry/-1 (you may use WB)
;    R1-R7 saved (unless you alter R7 deliberately - beware)
;    R8-R11 updated (for your use, and passed back to you) #

build_menu
 FNJSR "R1-R11"
 MOV R5,R0			; save name
 FNLDR R6,menu_struct		; menu structure pointer
 FNLDR R7,menu_entries		; menu entries pointer
 BL build_menu_ensure
 FNRTS VS
 MOV R0,#0
 STR R0,[R6],#4			; save count
 STR R2,[R6],#4			; save creation address
 TST R1,#1			; menu name is a token?
 MOV R0,R5
 BLNE lookup_token_R0
 MOV R2,R0
 MOV R0,#12
 MOV R1,R6
 BL strbuf			; copy title
 LDR R1,[R13]
 LDR R3,[R13,#8]
 ADD R6,R6,#12			; point past copied title
 LDR R0,cols$l
 MOV R2,R4,LSL #4
 MOV R14,#44
 STMIA R6!,{R0,R2,R14}		; colours, width, entry height
 MOV R0,#0
 STR R0,[R6],#4			; gap
entry$l				; entry loop
 BL build_menu_ensure		; make sure enough room
 FNRTS VS
 MOV R0,#0
 MVN R5,#0
 LDR R14,icon$l
 STMIA R6,{R0,R5,R14}		; flags, submenu, icon flags
 FNLDR R5,menu_entries
 MOV R0,#0
 STR R0,[R6,#16]		; no validation by default.
 STR R0,[R7,#8]!		; null string in case at end
 MOV R0,R7			; buffer
 MOVS R14,PC
 MOV PC,R1			; call the sub to create menu text
				; OK, what if R7 gets updated by this...?
 FNRTS VS

; MOV R14,#65
; STRB R14,[R7];bug!
; MOV R14,#0
; STRB R14,[R7,#1];bug! ; buffer OK at this point.

 SUB R14,R7,R5			; buffer offset
 STR R14,[R6,#12]		; (link offsets AFTER buffers stop moving)
 STMDB R7,{R0,R3}		; index, addr of interpret sub
 MOV R5,R0			; save index
 MOV R0,R7			; menu entry text
 BL str_len
 ADD R0,R0,#1			; buffer length
 STR R0,[R6,#20]		; poke in length of indirected text :-/
 ADD R7,R7,R0
 ADD R7,R7,#16; 3
 BIC R7,R7,#3			; word align to finish entry
 CMN R5,#1			; finished?
 ADDNE R6,R6,#24
 BNE entry$l			; do next entry

 FNLDR R1,menu_struct		; menu finished
 ADD R1,R1,#8			; start of structure
 SUB R0,R6,R1			; offset in structure
 CMP R0,#28
 SUBGT R6,R6,#24		; goto previous entry unless at start
 LDR R0,[R6]
 ORR R0,R0,#1<<7
 STR R0,[R6]			; mark this as the last entry
 LDRLE R0,[R6,#8]
 ORRLE R0,R0,#1<<22		; and grey it if no entries were built
 STRLE R0,[R6,#8]

 FNLDR R2,menu_entries
 ADD R3,R1,#28			; skip over menu header...
link$l				; link the entries loop
; MOV R0,#-1
; STR R0,[R3,#4]		; submenu; !!!!!!!!!!!!!!!!

; LDR R0,icon$l
; STR R0,[R3,#8]		; icon flags

 LDR R0,[R3,#12]		; offset of buffer
 ADD R0,R2,R0
 STR R0,[R3,#12]

 LDR R0,[R3,#16]		; validation string if present
 CMP R0,#0
 ADDGT R0,R2,R0
 ADRLE R0,null$l		; !!!
 STR R0,[R3,#16]

; MOV R0,#2
; STR R0,[R3,#20]		; len !!!!!!!!!!!!!!!!

 ADD R3,R3,#24
 CMP R3,R6
 BLE link$l			; next entry

 MOV R0,R1			; menu address returned in R0.
 FNRTS
cols$l DCD &00070207		; colours
icon$l DCD &07009131		; icon flags (ind txt)

null$l
 DCD 0

; ensure menu_struct has 36 bytes free and menu_entries 64 bytes free
; R6 and R7 are corresponding pointers to update. #

build_menu_ensure
 FNJSR "R1"

 FNLDR R0,menu_struct
 SUB R6,R6,R0
 ADD R1,R6,#1024 ; 8+28 ; +128		; cm+header (was 8+28/64!)
 BL heap_ensure
 FNSTR R0,menu_struct,VC
 ADDVC R6,R6,R0

 FNLDR R0,menu_entries,VC
 SUBVC R7,R7,R0
 ADDVC R1,R7,#1024 ; 64+128		; should be plenty...? (was 64)
 BLVC heap_ensure
 FNSTR R0,menu_entries,VC
 ADDVC R7,R7,R0
 BICVC R7,R7,#3			; word align for test purposes.

 FNRTS

;E R0=pointer to a menu structure
;X entries on this menu reversed #

reverse_menu
 STMFD R13!,{R1-R5,R14}
 BL count_menu_clear
 MOV R4,R0			; number of entries
 ADD R5,R1,#28			; first item
 ADD R0,R0,R0,LSL#1
 ADD R2,R5,R0,LSL#3		; last item end
 SUB R2,R2,#24			; last item
re34
 CMP R5,R2			; finished?
 BCS re33
 MOV R3,#0			; count
re35
 LDR R0,[R5,R3]
 LDR R14,[R2,R3]
 STR R0,[R2,R3]
 STR R14,[R5,R3]
 ADD R3,R3,#4
 CMP R3,#24
 BCC re35			; swap loop
 ADD R5,R5,#24
 SUB R2,R2,#24
 B re34
re33
 MOV R0,R4
 BL add_menu_stop
 LDMFD R13!,{R1-R5,PC}

 LOCAL

;E R0=pointer to a list of 24 byte menu entries
;X R0=number of entries in the list |

count_menu_entries
 FNJSR "R1"
 MOV R1,#0			; zero the count
a$l
 LDR R14,[R0],#24
 ADD R1,R1,#1			; read another entry
 TST R14,#1<<7
 BEQ a$l			; not the end
 MOV R0,R1
 FNRTS

 LOCAL

;E R0=pointer to a wimp menu structure
;X R0=height of the entries in OS coords including dashes |
;  (Excludes title as so do open coords)

count_menu_size
 FNJSR "R1-R2"
 LDR R2,[R0,#20]		; height of entries
 LDR R1,[R0,#24]		; gap between entries
 ADD R2,R2,R1			; total height
 RSB R1,R1,#0			; start at -gap
 ADD R0,R0,#28
a$l
 LDR R14,[R0],#24
 ADD R1,R1,R2			; read another entry
 TST R14,#2
 ADDNE R1,R1,#24		; dotted line
 TST R14,#1<<7
 BEQ a$l			; not the end
 MOV R0,R1
 FNRTS

;E R1=pointer to menu structure
;X R0=num of menu entries & bit 7 of last item cleared |

count_menu_clear
 FNJSR "R1"
 ADD R1,R1,#28			; first item
 MOV R0,R1
 BL count_menu_entries		; R0=num of entries
 ADD R1,R1,R0,LSL#4
 ADD R1,R1,R0,LSL#3		; +24*R0
 LDR R14,[R1,#-24]
 BIC R14,R14,#1<<7
 STR R14,[R1,#-24]		; remove stoppage bit
 FNRTS

;E R0=number of entries R1=menu structure
;X stop bit added |

add_menu_stop
 FNJSR
 ADD R0,R0,R0,LSL#1		; *3
 ADD R14,R1,#28			; start of entries
 ADD R0,R14,R0,LSL#3		; +num*24
 LDR R14,[R0,#-24]		; last entry
 ORR R14,R14,#1<<7
 STR R14,[R0,#-24]		; add stop
 FNRTS

;E R0=menu structure
;X sorted to alphabetical order #

sort_menu
 STMFD R13!,{R1-R11,R14}
 MOV R1,R0			; menu structure
 BL count_menu_clear
 MOV R10,R0			; number of items
 MOV R11,R1			; menu structure
 MOV R0,R0,LSL#2		; 4 bytes each entry
 BL heap_claim
 LDMVSFD R13!,{R1-R11,PC}
 MOV R7,R0			; pointer list
 ADD R1,R11,#28			; first item
 MOV R2,R10			; count
so1
 STR R1,[R0],#4			; pointer
 ADD R1,R1,#24			; next item
 SUBS R2,R2,#1
 BGT so1
 MOV R0,R10			; number to sort
 MOV R1,R7			; pointer list
 ADR R2,sort_menu_sub		; comparion sub
 MOV R3,R12			; workspace pointer
 ADD R4,R11,#28			; array of objects
 MOV R5,#24			; size of objects
 MOV R6,#0			; no temp workspace
 SWI XOS_HeapSort		; sort pointers
 MOVVC R0,R10			; number
 BLVC sort_objects
 MOVVC R0,R7
 BLVC heap_free			; free block
 MOVVC R0,R10
 MOVVC R1,R11
 BLVC add_menu_stop
 LDMFD R13!,{R1-R11,PC}

;E R0=item0 R1=item1
;X GE if R0>=R1. R4+ saved.

sort_menu_sub
 LDR R0,[R0,#12]		; icon data string
 LDR R1,[R1,#12]
so2
 LDRB R2,[R0],#1
 CMP R2,#'a'
 RSBHSS R3,R2,#'z'
 LDRB R3,[R1],#1
 SUBHS R2,R2,#32		; upper case
 SUB R3,R3,#'a'
 CMP R3,#26
 ADDCS R3,R3,#'a'
 ADDCC R3,R3,#'A'
 CMP R2,R3
 MOVNE PC,R14			; return LT or GT
 CMP R2,#&20
 BGE so2			; haven't reached end yet
 MOV PC,R14			; R0<R1 as shorter

;E R0=num objects R1=pointers list R4=objs start R5=objs size
;X actual objects sorted #

sort_objects
 FNJSR "R1-R4,R10"
 MOV R10,R0			; num objects left
so3
 MOV R2,R1
so4
 LDR R0,[R2],#4
 TEQ R0,R4
 BNE so4
 SUB R2,R2,#4			; pointer for next element
 TEQ R2,R1			; is this object already there?
 ADDEQ R4,R4,R5
 BEQ so6
 LDR R3,[R1]			; object to swap with
 STR R3,[R2]			; new pointer to object after swap
 MOV R2,R5			; size count
so5
 LDR R0,[R3]
 LDR R14,[R4]
 STR R14,[R3],#4
 STR R0,[R4],#4
 SUBS R2,R2,#4
 BGT so5
so6
 ADD R1,R1,#4			; done next pointer
 SUBS R10,R10,#1		; number of pointers left
 BGT so3
 FNRTS

;E As for build_menu but uses the font menu buffer
;X As for build_menu

build_font_menu
 FNJSR "R6-R7"
 BL swap$l
 BL build_menu
 BL swap$l
 FNRTS
swap$l				; swap over without changing flags
 FNLDR R6,font_entries
 FNLDR R7,menu_entries
 FNSTR R6,menu_entries
 FNSTR R7,font_entries
 FNLDR R6,font_struct
 FNLDR R7,menu_struct
 FNSTR R6,menu_struct
 FNSTR R7,font_struct
 MOV PC,R14

 LOCAL

local_f_ss_vals
 DCD 0
 DCD 0

build_second_font_menu
 FNJSR "R6-R7"
 BL swapmenu
 BL build_menu
 BL swapmenu
 FNRTS
swapmenu			; swap over without changing flags
 ;ADR R6,local_f_ss_vals
 FNLDR R6,font_ssentries
 FNLDR R7,menu_entries
 FNSTR R6,menu_entries
 ;STR R7,local_f_ss_vals
 FNSTR R7,font_ssentries
 ;LDR R6,local_f_ss_vals + 4
 FNLDR R6,font_ssstruct
 FNLDR R7,menu_struct
 FNSTR R6,menu_struct
 ;STR R7,local_f_ss_vals + 4
 FNSTR R7,font_ssstruct
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MENU INTERPRET					     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R1=start of menu R8/R9=window/0 R11=menu selection block
;X menu action performed # Menu subs called with
;  ;E R0=offset in last menu of click=!(R11-4) R1=index entry=!(R10-8)
;     R2=address of item R3=address of menu containing chosen item
;     R6=format R7=flags R8/R9=window/0 R10=item text entry
;     R11=menu sequence end (end of block returned by wimp)
;  ;X may corrupt R0-R11 #

menu_click
 FNJSR "R1-R11"
 BL menu_decode			; R2=item R3=last item R11=sequence end
 LDR R10,[R2,#12]		; address of item text
 LDR R5,[R10,#-4]		; sub to call
 TST R5,#1<<31
 BNE a$l
 BIC R5,R5,#&FC<<24
 CMP R5,#&8000
 FNRTS LT			; nothing to call
 LDR R0,[R11,#-4]		; previous offset
 LDR R1,[R10,#-8]		; index entry
 TEQ R8,#0
 FNLDR R7,opt_flags,EQ
 FNLDR R6,opt_format,EQ
 LDRNE R7,[R8,#w_flags]
 LDRNE R6,[R8,#w_format]	; set up flags
 MOVS R14,PC
 MOV PC,R5			; call the sub
 FNRTS
a$l				; it is a command
 LDMDB R10,{R0,R7}		; parameter, address/type
 MOV R2,R7,LSR #3
 AND R2,R2,#15<<24		; execute command
 BIC R7,R7,#&FC<<24
 TST R7,#1
 BNE b$l			; hmm, we still have a name pointer...
c$l
 MOV R10,#0			; no cursor
 BL process_key_command
 FNRTS
b$l
	STMFD	R13!,{R0}
	BL	validate_command
	ADDVS	R13,R13,#4
	FNRTS	VS
	LDR	R0,[R10,#-4]	; safe to assume that command has been found?
	AND	R0,R0,#&FC<<24
	ORR	R0,R7,R0
	STR	R0,[R10,#-4]	; update for next time
	LDMFD	R13!,{R0}
	B	c$l

;E R1=address of menu R11=sequence of menu off,off,...-1 as given by wimp
;X R2=clicked item R3=previous clicked item R11=end of seq (-1) |

menu_decode
 STMFD R13!,{R1,R14}
 ADD R2,R1,#28			; current chosen item
 MOV R3,R2			; previous chosen item
 LDR R0,[R11]
 CMP R0,#0
 LDMMIFD R13!,{R1,PC}		; nothing selected
me1
 LDR R0,[R11],#4		; get next selection
 ADD R1,R1,#28			; first entry
 ADD R0,R0,R0,LSL#1		; off*3
 ADD R1,R1,R0,LSL#3		; add off*24 to get menu entry
 MOV R3,R2			; save last item
 MOV R2,R1			; currently chosen item
 LDR R0,[R11]
 CMP R0,#0
 LDMMIFD R13!,{R1,PC}		; reached end
 LDR R1,[R1,#4]			; submenu pointer
 CMP R1,#&8000			; is it valid
 BGT me1			; yes
 LDMFD R13!,{R1,PC}

;E Heap set up
;X Menu file read into heap blocks and then linked #

load_menus
 FNJSR "R1,R10-R11"
; FNLDR R0,menu_handles
; CMP R0,#0
; BLNE heap_free
 ADR R0,str$l
 BL load_menu				; read all the menus in
 FNRTS VS
 CMP R0,#0
 FNSTR R0,menu_handles,GT
 FNRTS
str$l = "<",|zap$|,"$Menus>",0
 ALIGN

 LOCAL

;E R0=pointer to filename of Zap_menu file
;X R0=list of menu handles or <=0 #

load_menu
 FNJSR "R1"
 MOV R1,R0
 ADR R0,read$l
 BL str_readfile
 FNRTS
read$l
 MOV R0,R10
; B read_menu
; fall through...

;E R0=start of zero terminated text file of form of Zap menu file
;X R0=pointer to heap block containing number of handle, handle0, etc
;  or 0 if file invalid

read_menu
 FNJSR "R10"
 MOV R10,R0
 BL read_menus				; read menu file to R4
 FNRTS VS
 CMP R4,#0
 BLGT link_menus			; link & show keys
 SUBVC R0,R4,#4				; address of heap block
 FNRTS

 LOCAL

;E R4=menu handles (+4)
;X Menus linked to each other #

link_menus
 FNJSR "R1-R6"
 LDR R3,[R4,#-4]			; number of valid handles
 MOV R5,R4				; current handle pointer
 MOV R6,R3				; number of menus left
menu$l
 SUBS R6,R6,#1
 FNRTS LT				; all done
 LDR R1,[R5],#4				; next menu
 CMP R1,#0
 BLE menu$l				; not a valid menu
 BL show_menu				; show key short cuts
 FNRTS VS
 ADD R2,R1,#28				; first entry
entry$l
 LDR R0,[R2,#12]			; the text of this entry
 LDR R0,[R0,#-12]			; the submenu creation
 TEQ R0,#0
 BNE end$l				; there is code to open the menu
 LDR R0,[R2,#4]				; submenu offset
 CMP R0,#0
 BLT end$l				; no submenu
 CMP R0,R3
 BCS end$l				; not a handle (eg an address)
 LDR R1,[R4,R0,LSL#2]			; address of the menu
 CMP R1,#0
 MOVLE R1,#-1				; no menu
 STR R1,[R2,#4]
end$l					; done this entry
 LDRB R0,[R2],#24
 TST R0,#&80
 BEQ entry$l				; next item
 B menu$l

 LOCAL

;E R10=start of zero termianted menu file
;X R4=pointer to menu handles block (+4) #

read_menus
 FNJSR "R1-R3,R10"
 MOV R4,#0			; address of menu handles (+4)
a$l				; start of a line
 LDRB R0,[R10]
 TEQ R0,#0
 BEQ b$l			; reached file end
 TEQ R0,#10
 TEQNE R0,#9
 TEQNE R0,#&20
 TEQNE R0,#'|'
 BEQ c$l
 BL str_readnum			; get number of menu handles/handle
 BVS c$l			; ignore error and try next line
 MOV R2,R0			; save handle number
 CMP R4,#0
 BLE d$l
 BL read_one_menu		; R0=address of menu (+4)
 FNRTS VS
 LDR R14,[R4,#-4]		; number of handles
 CMP R2,R14
 STRCC R0,[R4,R2,LSL#2]		; save the address of the menu
 B c$l
d$l				; read in the number of valid handles
 MOV R1,R2,LSL#2		; 4 bytes each entry
 ADD R1,R1,#8
 MOV R0,R1
 BL heap_claim			; ensure block big enough
 FNRTS VS
 STR R2,[R0]			; save number of handles
 ADD R4,R0,#4			; handles (+4)
 SUB R3,R1,#4
 MOV R2,R4
 MOV R1,#0
 BL fill_words			; null the handles
c$l				; go to next line
 ADDS R0,R0,#0			; clv
 BL str_next
 BCC a$l
b$l				; reached end of file
 FNRTS

 LOCAL

 END
