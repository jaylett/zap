; Contains processing command code and Zap command table.
; $Id: Commands,fff,v 1.1.2.26 1999/04/14 00:26:42 ds Exp $

	GET	h.ZapHeader
	GET	h.Messages
	GET	h.Template
	GET	h.CreateWind
	GET	h.KeyBits
	GET	h.MiniBuff
	GET	h.Heap
	GET	h.ModeBits
	GET	h.Cursors
	GET	h.AlterTxt
	GET	h.Search
	GET	h.CreateFile
	GET	h.Undo
	GET	h.Redraw
	GET	h.Strings
	GET	h.Menus
	GET	h.StartUp
	GET	h.StartCode
	GET	h.ModuleBits
	GET	h.Fonts
	GET	h.Mode1
	GET	h.Mode2
	GET	h.Mode4
	GET	h.Mode11
	GET	h.Update
	GET	h.TMTVars
	GET	h.Execute
	GET	h.Boxes
	GET	h.TMFs
	GET	h.ModeBits

	IMPORT	Countmatches
	IMPORT	TotalSel
	IMPORT	WC
	IMPORT	WCSel
	IMPORT	Dzapbox
	IMPORT	Movebox
	IMPORT	Goto
	IMPORT	Infobox
	IMPORT	Mzapbox
	IMPORT	Printfile
	IMPORT	Quickprint
	IMPORT	Quit
	IMPORT	Replace
	IMPORT	Save
	IMPORT	Savelist
	IMPORT	Savesel
	IMPORT	Searchbuf
	IMPORT	Searchcur
	IMPORT	Tofrontlist
	IMPORT	Closelist

	IMPORT	get_DyingBox
	IMPORT	get_SaveBox
	IMPORT	get_SaveSelBox
	IMPORT	open_UndoBox
	IMPORT	message_send
	IMPORT	update_all_save_boxes
	IMPORT	char_del_dispatch

	EXPORT	add_command_table
	EXPORT	bad_zap_variable
	EXPORT	execute_strokes
	EXPORT	key_command_table
	EXPORT	reallysetwidth
	EXPORT	insertsomespaces
	EXPORT	shade_no_sel
	EXPORT	tellzapspell
	EXPORT	blat_cache_of_this_window
	EXPORT	shade_no_sel_at_all
	EXPORT	checktrue
	EXPORT	checklearn

	EXPORT	Autosoftwrap
	EXPORT	Basemap
	EXPORT	Beep
	EXPORT	Break
	EXPORT	Cancel
	EXPORT	Cdown
	EXPORT	Char
	EXPORT	ClearGC
	EXPORT	CloneCreate
	EXPORT	Continue
	EXPORT	Copy
	EXPORT	Copysel
	EXPORT	Clearsel
	EXPORT	Command
	EXPORT	Cup
	EXPORT	Delete
	EXPORT	Endwhile
	EXPORT	Execute
	EXPORT	Insertgs
	EXPORT	Return
	EXPORT	Lastcylinder
	EXPORT	Lasttrack
	EXPORT	Lastsector
	EXPORT	Learn
	EXPORT	Local
	EXPORT	Moden
	EXPORT	Movesel
	EXPORT	Multicommand
	EXPORT	Nextcylinder
	EXPORT	Nexttrack
	EXPORT	Nextsector
	EXPORT	Null
	EXPORT	PasteGC
	EXPORT	Quote
	EXPORT	Repeat
	EXPORT	Mode
	EXPORT	Newfile
	EXPORT	Newtype
	EXPORT	Right
	EXPORT	Selregion
	EXPORT	Searchforward
	EXPORT	Searchback
	EXPORT	Tofront
	EXPORT	Until
	EXPORT	While

; define a new command $a=command name $b=label for the command

	MACRO
$la	FNcom $a,$b
$la	= "$a",0
	ALIGN
	DCD $b
	MEND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; KEY COMMAND TABLE					      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; command table in ALPHABETICAL order (so can do binary search)
; and so we have no duplications

key_command_table
	DCD	key_command_table		; offset from module start
	DCD	0				; flags (don't kill module)
;;;;;;;;;;;; FNcom "ADDLF",Addlf
;;;;;;;;;;;; FNcom "ADDLFSEL",Addlfsel
	FNcom	"ALLFILES",Allfiles
	FNcom	"ALLMODES",Allmodes	; ALLOPTIONS?
	FNcom	"ALLWINDOWS",Allwindows
	FNcom	"ALTERSEL",Altersel
	FNcom	"ASYOUTYPE",Spellasyoutype
	FNcom	"AUTOINDENT",Autoindent
	FNcom	"AUTOSOFTWRAP",Autosoftwrap
	FNcom	"BASEMAP",Basemap
	FNcom	"BASEMAPLIST",Basemaplist
	FNcom	"BASEMAPN",Basemapn
	FNcom	"BASIC",Basic
	FNcom	"BEEP",Beep
	FNcom	"BINDTOKEY",Bindtokey
	FNcom	"BITMAPLIST",Bitmaplist
	FNcom	"BITMAPFONT",Bitmapfont
	FNcom	"BYTE_CONTROLREPLACE",CmdBYTEctrlreplace
	FNcom	"BYTE_FLAGSTOGGLE",CmdBYTEflagstoggle
	FNcom	"BYTE_GROUPSIZE",CmdBYTEgroupsize
	FNcom	"CANCEL",Cancel
	FNcom	"CDOWN",Cdown
	FNcom	"CHAR",Char
	FNcom	"CLEARSEL",Clearsel
	FNcom	"CLEARGC",ClearGC
	FNcom	"CLEFT",Cleft
	FNcom	"CLI",Cli
	FNcom	"CLONEBASE",CloneBase
	FNcom	"CLONEBOX",Clonebox
	FNcom	"CLONECREATE",CloneCreate
	FNcom	"CLONEDELETE",CloneDelete
	FNcom	"CLONEHIDE",CloneHide
	FNcom	"CLOSEFILE",Deletefile
	FNcom	"CLOSELIST",Closelist
	FNcom	"CLOSEOTHER",Closeother
	FNcom	"CLOSEPRINTER",Closeprinter
	FNcom	"CLOSEWINDOW",Closewindow
	FNcom	"CODE_FLAGSTOGGLE",CmdCODEflagstoggle
	FNcom	"CODE_DISASMTOGGLE",Code_disasmtoggle
	FNcom	"COLONSEPARATOR",Colonseparator
	FNcom	"COLOURLIST",Colourlist
	FNcom	"COLUMNTAB",Columntab
	FNcom	"COMMAND",Command
	FNcom	"COMPILE",Compile
	FNcom	"CONFINEHORIZONTALLY",Confinehorizontally
	FNcom	"CONFINEVERTICALLY",Confinevertically
	FNcom	"COPY",Copy
	FNcom	"COPYSEL",Copysel
	FNcom	"COREDUMP",Coredump
	FNcom	"COUNTMATCHES",Countmatches
	FNcom	"CREATEFILE",Createfile
; FNcom "CRASH",Crash ; !!!!!!!!!!
; FNcom "CRUNCH",Crunch ; !!!!!!!!!!
; FNcom "CRUMPLE",Crumple ; !!!!!!!!!!
	FNcom	"CRIGHT",Cright
	FNcom	"CUP",Cup
	FNcom	"CURSORMENU",Cursormenu
	FNcom	"CUT",Cut
	FNcom	"DATE",Date
	FNcom	"DEFAULTMAP",Defaultmap
	FNcom	"DELETE",Delete
	FNcom	"DELETENEXT",Deletenext
	FNcom	"DELETENEXTNOCOPY",Deletenextnocopy
	FNcom	"DELLINE",Delline
	FNcom	"DELTOEND",Deltoend
	FNcom	"DELTOSTART",Deltostart
	FNcom	"DELWORDEND",Deletewordnext
	FNcom	"DELWORDSTART",Deletewordprev
	FNcom	"DISCARDFILE",discard_file
	FNcom	"DISCARDWINDOW",discard_window
	FNcom	"DOWN",Down
	FNcom	"DUMPFILE",Dumpfile
	FNcom	"DZAPBOX",Dzapbox
	FNcom	"EMACS",Emacs
	FNcom	"ESCAPE",Escape
	FNcom	"EXECUTE",Execute
	FNcom	"FASTUNDO",Fastundo
	FNcom	"FFLAGS_TOGGLE",Fflags_toggle
	FNcom	"FINDFILE",Findfile
	FNcom	"FINDFILEREADONLY",Findfilereadonly
	FNcom	"FINDFUNCTION",Findfunction
	FNcom	"FONTASPECT",Fontaspect
	FNcom	"FONTLIST",Fontlist
; FNcom "FONTOFFSETS",Fontoffsets
	FNcom	"FONTSIZE",Fontsize
	FNcom	"FONTTYPE",Fonttype
	FNcom	"FORMATTEXT",Formattext
	FNcom	"FREECLICK",Freeclick
	FNcom	"FULLUNDO",Fullundo
	FNcom	"GETMODULE",Getmodule
	FNcom	"GETVAR",Getvar
	FNcom	"GETWORKSPACE",Getworkspace
	FNcom	"GETDYNAMICAREA",Getdynamicarea
	FNcom	"GOTO",Goto
; FNcom "GOTOADDR",Gotoaddr
	FNcom	"HELP",Help
	FNcom	"HELPCOM",Helpcom
	FNcom	"HELPFN",Helpfn
	FNcom	"HELPKEY",Helpkey
	FNcom	"HELPVAR",Helpvar
	FNcom	"HEXASCII",Hexascii
	FNcom	"ICONISE",Iconise
	FNcom	"INDENT",Indent
	FNcom	"INDENTBY",Indentby
	FNcom	"INDIRECT",Indirect
	FNcom	"INFINITEWRAP",Infinitewrap
	FNcom	"INFOBOX",Infobox
	FNcom	"INSERT",Insert
	FNcom	"INSERTBLOCK",Insertblock
	FNcom	"INSERTBLOCKGS",Insertblockgs
	FNcom	"INSERTDATE",Insertdate
	FNcom	"INSERTGS",Insertgs
	FNcom	"INSERTTIME",Inserttime
	FNcom	"INSTALLICON",Installicon
	FNcom	"JOINLINE",Joinline
	FNcom	"KEEPREGION",Keepregion
	FNcom	"KEYMAP",Keymap
	FNcom	"KEYMAPN",Keymapn
	FNcom	"KILLFILES",Killfiles
	FNcom	"LASTCYLINDER",Lastcylinder
	FNcom	"LASTMARK",Lastmark
	FNcom	"LASTMATCH",Lastmatch
	FNcom	"LASTSECTOR",Lastsector
	FNcom	"LASTTRACK",Lasttrack
	FNcom	"LEARN",Learn
	FNcom	"LEFT",Left
	FNcom	"LINEEDIT",Lineedit
	FNcom	"LINENOS",Linenos
	FNcom	"LINESELECT",Lineselect
	FNcom	"LINESPACING",Linespacing
	FNcom	"LINEWRAP",Linewrap
 ;FNcom "LISTFILES",Listfiles
	FNcom	"LISTFNS",Listfns
	FNcom	"LOADMODULE",Loadmodule
	FNcom	"LOCALPASTE",Paste
	FNcom	"MAKEDEFAULT",Makedefault
	FNcom	"MARGIN",Margin
	FNcom	"MENUOPEN",Menuopen
; FNcom "MCV",Mcv
; FNcom "MENUCOMMAND",Menucommand
; FNcom "MINIFONT",Minifont
	FNcom	"MINIMENU",Minimenu
	FNcom	"MINIMISEMEMORY",minimise_memory
	FNcom	"MISCOPS",Miscops
	FNcom	"MODE",Mode
	FNcom	"MODELIST",Modelist
	FNcom	"MODEN",Moden
	FNcom	"MOVEBOX",Movebox
	FNcom	"MOVESEL",Movesel
	FNcom	"MULTICOMMAND",Multicommand
	FNcom	"MZAPBOX",Mzapbox
	FNcom	"NEWFILE",Newfile
	FNcom	"NEWTYPE",Newtype
	FNcom	"NEWVIEW",Newview
	FNcom	"NEWVIEWLIST",Newviewlist
	FNcom	"NEXTCYLINDER",Nextcylinder
	FNcom	"NEXTMARK",Nextmark
	FNcom	"NEXTMATCH",Nextmatch
	FNcom	"NEXTSECTOR",Nextsector
	FNcom	"NEXTTRACK",Nexttrack
	FNcom	"NONSTANDARD",Nonstandard
; FNcom "NOSUBSTYLES",Nosubstyles
	FNcom	"NULL",Null
	FNcom	"OPENPARENT",Openparent
	FNcom	"OPENPRINTER",Openprinter
	FNcom	"OSCLI",Oscli
	FNcom	"OUTDENT",Outdent
	FNcom	"OUTLINEFONT",Outlinefont
	FNcom	"PASTE",PasteGC
	FNcom	"PASSTHROUGH",Passthrough
; FNcom "PASTEGC",PasteGC
	FNcom	"PRINTFILE",Printfile
	FNcom	"QUICKPRINT",Quickprint
	FNcom	"QUICKSAVE",Quicksave
	FNcom	"QUIT",Quit
	FNcom	"QUOTE",Quote
	FNcom	"READONLY",Readonly
	FNcom	"REDO",Redo
	FNcom	"RELOADKEYS",Reloadkeys
;;;;;;;;;;;;;;;;;;; FNcom "REMOVELF",Removelf
;;;;;;;;;;;;;;;;;;; FNcom "REMOVELFSEL",Removelfsel
	FNcom	"REMOVELIST",Removelist
	FNcom	"RENUMBER",Renumber
	FNcom	"REPLACE",Replace
	FNcom	"RETURN",Return
	FNcom	"RETURNCHAR",Returnchar
	FNcom	"RETURNNOINDENT",Returnnoindent
	FNcom	"RIGHT",Right
	FNcom	"RUN",Run
	FNcom	"RUNANDQUIT",Runandquit
	FNcom	"SAVE",Save
	FNcom	"SAVEANDRUN",Saveandrun
	FNcom	"SAVEFILE",Savefile
	FNcom	"SAVELIST",Savelist
	FNcom	"SAVEOPTIONS",Saveoptions
	FNcom	"SAVESEL",Savesel
	FNcom	"SCDOWN",Scdown
	FNcom	"SCLEFT",Scleft
	FNcom	"SCRIGHT",Scright
	FNcom	"SCUP",Scup
	FNcom	"SDOWN",Sdown
	FNcom	"SEARCHBACK",Searchback
	FNcom	"SEARCHBUF",Searchbuf
	FNcom	"SEARCHCUR",Searchcur
	FNcom	"SEARCHFORWARD",Searchforward
	FNcom	"SELECTBUFFER",Selectbuffer
	FNcom	"SELECTLINE",Selectline
	FNcom	"SELREGION",Selregion
	FNcom	"DROPMARK",Dropmark
	FNcom	"SENDSEL",Sendsel
	FNcom	"SETMARGINWIDTH",Setmarginwidth
	FNcom	"SETWIDTH",Setwidth
	FNcom	"SLEFT",Sleft
	FNcom	"SOFTWRAP",Softwrap
	FNcom	"SPLITLINE",Splitline
	FNcom	"SRIGHT",Sright
	FNcom	"STARTADDR",Startaddr
	FNcom	"STARTLINE",Startline
	FNcom	"STARTOP",Startop
	FNcom	"STILLDOWN",Stilldown
	FNcom	"STILLUP",Stillup
	FNcom	"STOPOP",Stopop
	FNcom	"STRIPSPACES",Stripspaces
; FNcom "STRONGSOFTWRAP",Strongsoftwrap
	FNcom	"SUP",Sup
	FNcom	"SUSPEND",Suspend
; FNcom "SWAPCASE",Swapcase
	FNcom	"SWAPCHARS",Swapchars
	FNcom	"SWAPWINDOW",Swapwindow
	FNcom	"SWITCHTAB",Switchtab
	FNcom	"TAB",Tab
	FNcom	"TABCHAR",Tabchar
	FNcom	"TABDISPLAY",Tabdisplay
	FNcom	"TABMODE",Tabmode
	FNcom	"TABSASSPACES",Tabsasspaces
	FNcom	"TOBACK",Toback
	FNcom	"TOFRONT",Tofront
	FNcom	"TOFRONTLIST",Tofrontlist
	FNcom	"TOGGLEHEX",Togglehex
	FNcom	"TOGGLEINSERT",Toggleinsert
	FNcom	"TOGGLEMARK",Togglemark
	FNcom	"TOGGLEUNDO",Toggleundo
	FNcom	"TOGGLEWIND",Togglewind
	FNcom	"TOTALSEL",TotalSel
	FNcom	"TYPELIST",Typelist
	FNcom	"UNIVERSALARG",Universalarg
;;;;;;;;;;;;; FNcom "UNSPACE",Unspace
	FNcom	"UP",Up
	FNcom	"UPDATEWINDOW",Updatewindow
	FNcom	"WC",WC
	FNcom	"WCSEL",WCSel
	FNcom	"WFLAGS_ALTER",Wflags_alter
	FNcom	"WFLAGS_TOGGLE",Wflags_toggle
	FNcom	"WFORMAT_ALTER",Wformat_alter
	FNcom	"WFORMAT_TOGGLE",Wformat_toggle
	FNcom	"WINFO_ALTER",Winfo_alter
	FNcom	"WINFO_TOGGLE",Winfo_toggle
	FNcom	"WIMPTASK",Wimptask
	FNcom	"WINDOWWRAP",Windowwrap
	FNcom	"WORDWRAP",Wordwrap
	FNcom	"EDITBYTE",Editbyte
	FNcom	"EDITWORD",Editword
	FNcom	"WORD_CONTROLREPLACE",CmdWORDctrlreplace
	FNcom	"WORD_FLAGSTOGGLE",CmdWORDflagstoggle
	FNcom	"WORD_GROUPSIZE",CmdWORDgroupsize
	FNcom	"WRAPWIDTH",Wrapwidth
	FNcom	"WRITEBUFFER",Writebuffer
	FNcom	"WRITEFILE",Writefile
	FNcom	"YANK",Yank

; Temp home for Darren's functions and related comands...
	FNcom	"BREAK",Break
	FNcom	"CASE",Case
	FNcom	"CONTINUE",Continue
	FNcom	"CWHEN",CWhen
	FNcom	"DEFAULT",Default
	FNcom	"ELSE",Else
	FNcom	"ENDCASE",Endcase
	FNcom	"ENDIF",Endif
	FNcom	"ENDWHILE",Endwhile
	FNcom	"IF",If
	FNcom	"LOCAL",Local
	FNcom	"REPEAT",Repeat
	FNcom	"SET",Set
	FNcom	"UNSET",Unset
	FNcom	"UNTIL",Until
	FNcom	"WHILE",While
	FNcom	"WHEN",When
;  The following are functions, for testing IF
	FNcom	"ADJUST",Adjust
	FNcom	"ALT",Alt
	FNcom	"BUTTONS",Buttons
	FNcom	"CHAROFF",Charoff
	FNcom	"CHAROFFSTR",Charoffstr
	FNcom	"CHARSTR",Charstr
	FNcom	"CTRL",Ctrl
	FNcom	"EOF",Eof
	FNcom	"FALSE",False
	FNcom	"FILENAME",Filename
	FNcom	"GREYED",Greyed
	FNcom	"IN",In
	FNcom	"MENU",Menu
	FNcom	"MODET",ModeT
	FNcom	"MODIFIED",Modified
	FNcom	"MODIFIERS",Modifiers
	FNcom	"SELANYWHERE",Selanywhere
	FNcom	"SELECT",Select
	FNcom	"SELHERE",Selhere
	FNcom	"SELSIZE",Selsize
	FNcom	"SHIFT",Shift
	FNcom	"SOF",Sof
	FNcom	"TICKED",Ticked
	FNcom	"TRUE",True

	DCD	0				; end of table

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; KEY COMMAND SUBS					      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	ALIGN

	LOCAL

; DCD 0
;Addlf
; FNJSR
; MOV R1,#0
; LDR R2,[R9,#f_len]
; B addlfsbetweenoffsets
;
; LOCAL

; DCD 0
;Addlfsel
; FNJSR
; LDR R0,[R9,#f_len]
; TEQ R0,#0
; FNRTS EQ
; MOV R4,R9
; BL get_selection
; ;FNcall Zap_GetSel
; FNRTS CS
; CMP R4,R9
; FNRTS NE
;addlfsbetweenoffsets
; CMP R9,#0
; FNRTS EQ
; CMP R2,#0
; FNRTS EQ
; MOV R6,R1
; ADD R7,R1,R2
; MOV R0,#2			; sw possible...?
; MOV R11,#e_interrogate
; BL call_mode
; CMP R0,#2
; FNRTS NE
; MOV R0,R7
; MOV R1,#&100
; BL split_buffer
; MOV R10,R7
; ;FNcall Zap_SplitBuffer         ; get the split out of the way
; BL Startop
; BL long_op_on
; BL swon_for_addlf
; LDRB R5,[R8,#w_cr]
; STRB R5,insertdata$l
;loop$l
; SWI XOS_ReadEscapeState	; doesn't corrupt R14 as in user mode
; BCS exit_Addlfsel
; SUB R1,R10,R6
; SUB R0,R7,R6
; SUB R0,R1,R0			; as going in reverse...
; BL long_op_display
; MOV R0,R7
; BL cln_off
; SUBS R7,R1,#1
; BMI exit_Addlfsel
; MOV R0,R7
; BL cln_readc
; CMP R0,R5
; BLNE toReturn$l
; CMP R7,R6
; BCS loop$l
;exit_Addlfsel
; BL swoff_for_addlf
; BL long_op_off
; BL Stopop
; FNRTS
;
;toReturn$l
; FNJSR
; CMP R0,#32
; BEQ replacewithaCR$l
; MOV R0,#1
; ADD R1,R7,#1
; MOV R2,#1
; ADR R3,insertdata$l
; BL execute_command
; FNRTS
;
;replacewithaCR$l
; MOV R0,#3
; MOV R1,R7
; MOV R2,#1
; ADR R3,insertdata$l
; BL execute_command
; FNRTS
;
;insertdata$l
; DCD 0
;
;swon_for_addlf
; FNJSR "R0-R7"
; ;TEQ R8,#0
; BL blat_cache_of_this_window
; MOV R0,#1<<26		; clear linewrap
; MOV R1,#0 ; 		; toggle nothing
; BL new_wind_flags
; MOV R0,#1<<27		; clear nothing
; MOV R1,#1<<27		; toggle softwrap
; BL new_wind_format_set
; FNRTS
;
;swoff_for_addlf
; FNJSR "R0-R7"
; BL blat_cache_of_this_window
; MOV R0,#1<<27		; clear softwrap
; MOV R1,#0		; toggle zilch
; BL new_wind_format_set
; FNRTS

	LOCAL

	DCD	7+(3<<3)+(1<<6)+(1<<28)
Allfiles
	FNJSR
	CMP	R2,#6
	BEQ	p$l
	ADR	R10,callallroutine$l
	BL	do_allfiles
 ; SUBS R14,R14,R14
	FNRTS
p$l
	ADR	R0,s$l
	BL	minibuffer_prompt_token
	FNRTS
s$l
	FNS	("zap_p_allfiles")
callallroutine$l
	FNJSR	"R0-R12"
	MOV	R8,#0
	BL	command_string
	STRVS	R0,[R13]			; report errors...
	FNRTS

	LOCAL

	DCD	7+(3<<3)+(1<<6)+(1<<28)
Allmodes
	FNJSR
	CMP	R2,#6
	BEQ	p$l
	MOV	R7,R0
 ; suspicious code to deal with *other modes.*..!?
	FNLDR	R11,opt_format
	MOV	R0,#0			; start mode
a$l
	BL	tochangeibmode		; change mode from IB first!!!
	FNRTS	VS
	BL	callallroutine2$l
	ADD	R0,R0,#1
	CMP	R0,#max_mode
	BCC	a$l
	AND	R0,R11,#&FF
	BL	tochangeibmode		; back to how it was before...
	FNRTS
p$l
	ADR	R0,s$l
	BL	minibuffer_prompt_token
	FNRTS
s$l
	FNS	("zap_p_allmodes")

callallroutine2$l
	FNJSR	"R0-R12"
	ORR	R0,R7,#1<<31
	MOV	R8,#0
	MOV	R9,#0
	MOV	R10,#0
	BL	command_string		; execute the string
	STRVS	R0,[R13]
	FNRTS

	LOCAL

	DCD	7+(3<<3)+(1<<6)+(1<<28)
Allwindows
	FNJSR
	CMP	R2,#6
	BEQ	p$l
	ADR	R10,callallroutine$l
	MOV	R7,R0
	BL	do_allwindow
	CMP	R8,#0
	BLNE	enter_window
	CMP	R8,#0
	MOVEQ	R0,#0
	BLEQ	set_caret_mode		; no caret
	FNRTS
p$l
	ADR	R0,s$l
	BL	minibuffer_prompt_token
	FNRTS
callallroutine$l
	FNJSR	"R0-R12"
	BL	enter_window
	MOV	R0,R7
	BL	command_string		; execute the string
	STRVS	R0,[R13]
	FNRTS
s$l	FNS	("zap_p_allwindows")

	LOCAL

	DCD	0
Altersel
	FNJSR
	MOV	R6,R8
	MOV	R7,R9
	BL	get_selection
	TEQ	R6,R8
	SUBNES	R8,R6,#0
	MOV	R9,R7
	ADD	R4,R1,R2,LSR	#1
	ADD	R3,R1,R2
	MOV	R2,R1
	LDR	R0,[R10,#c_off]
	ADDCS	R3,R0,#1
	CMPCC	R4,R0
	MOVHS	R2,R0
	MOVLO	R3,R0
	BL	select_region		; alter_selection
	FNRTS

	LOCAL

	DCD	7+(1<<15)
Autoindent
	FNJSR
	MOV	R0,#0
	MOV	R1,#1<<16
	BL new_wind_format_set
;  CMP R2,#15
;  BEQ grey$l
	FNRTS

; grey$l
;  MOV R10,R0
;  MOV R0,#24			; sw possible...?
;  MOV R11,#e_interrogate
;  BL call_mode
;  CMP R0,#24
;  MOVEQ R0,R10
;  ORRNE R0,R10,#2
;  FNRTS

	DCD	7+(1<<15)
Autosoftwrap
	FNJSR
	MOV	R0,#0		; clear nothing
	MOV	R1,#1<<22		; toggle windowwrap
	BL	new_wind_format_set
	BLVC	test_for_sw
	FNRTS

	LOCAL
;	now produces tickable menu entries...
	DCD	7 :OR: 2<<3 :OR: 1<<15 :OR: 1<<23 :OR: 1<<28
Basemap
	TEQ	R2,#15
	BEQ	tick$l
	TEQ	R2,#23
	BEQ	function$l
	SUB	R1,R1,#1
	LDR	R0,[R0,R1,LSL#2]		; last word in list
basemap_entry
	STMFD	R13!,{R0,R14}
	BL	find_key_table
	LDMFD	R13!,{R0,R14}
	BPL	put_basemap$l
	B	bad_keymap
;
;	STRPLB	R0,[R8,#w_basemap]	; this is a convenience copy...
;	STRPLB	R0,[R8,#w_currentmap]
;	STRPLB	R0,[R8,#w_helpmap]
;	; !?!?!
;	LDRB	R1,[R8,#w_format]
;	MOV	R2,#2			; *NOT* currently forward-compatible!
;	B	mode_data
function$l
	FNJSR
	BL	get_basemap$l
	MOV	R1,#1
	FNRTS
tick$l	SUB	R1,R1,#1
	LDR	R0,[R0,R1,LSL#2]		; last word in list
tick_keymap
	CMP	R8,#0
	BEQ	ibtick$l
	LDRB	R2,[R8,#w_basemap]
	CMP	R2,R0
	MOVNE	R0,#0
	MOVEQ	R0,#1
	MOV	PC,R14
ibtick$l
	FNJSR	"R2"
	MOV	R2,R0
	BL	get_basemap$l
	CMP	R2,R0
	MOVNE	R0,#0
	MOVEQ	R0,#1
	FNRTS

get_basemap$l
	CMP	R8,#0
	LDRNEB	R0,[R8,#w_basemap]
	MOVNE	PC,R14
	MOV	R0,#-1
	FNJSR	"R1,R2"
	FNLDRB	R1,opt_format
	MOV	R2,#2
	BL	mode_data			; mode's base map
	AND	R0,R0,#&FF			; mask out rest...
	FNRTS
put_basemap$l
	CMP	R8,#0
	BEQ	putoptbasemap$l
	STRB	R0,[R8,#w_basemap]	; this is a convenience copy...
	STRB	R0,[R8,#w_currentmap]
	STRB	R0,[R8,#w_helpmap]
	MOV	PC,R14
putoptbasemap$l
	FNJSR	"R0-R2"
	MOV	R0,#-1
	FNLDRB	R1,opt_format
	MOV	R2,#2
	BL	mode_data			; mode's base map in low byte
	LDR	R14,[R13]
	BIC	R0,R0,#255
	ORR	R0,R0,R14
	FNLDRB	R1,opt_format
	MOV	R2,#2
	BL	mode_data
	FNRTS

	LOCAL

	&	3<<3 :OR: 1<<6 :OR: 1<<23 :OR: 1<<28
Basemapn
	TEQ	R2,#23
	LDREQB	R0,[R8,#w_basemap]
	STMFD	R13!,{R14}
	BEQ	keymap_name
	TEQ	R2,#6
	BEQ	prompt$l
	BL	find_key_table_by_name
	TEQ	R2,#15
	BEQ	tick_keymap
	TEQ	R0,#0
	LDMFD	R13!,{R14}
	BPL	basemap_entry
	B	bad_keymap
prompt$l
	ADR	R0,s$l
	LDMFD	R13!,{R14}
	B	minibuffer_prompt_token
s$l	FNS	("zap_p_basemap")
keymap_name ; R14 on stack
	BL	find_key_table
	TEQ	R0,#0
	LDRNE	R1,[R0,#16]
	TEQNE	R1,#0
	MOVEQ	R0,#0
	BLNE	strdup
	MOV	R1,#3
	LDMFD	R13!,{PC}

	DCD	7
Beep
	FNJSR
	FNLDR	R14,opt_switches
	TST	R14,#switch_InhibitBeeping
	SWIEQ	&20107			; BEEP command
	FNRTS

	LOCAL

	DCD	(3<<3)+(1<<6)+(1<<8)+(1<<28)
Bindtokey
	FNJSR
	FNLDR	R14,key_flags		; turn off learn mode
	BIC	R14,R14,#4		; turn off learn mode
	FNSTR	R14,key_flags		; turn off learn mode
	TEQ	R2,#6
	BEQ	p$l
	SUB	R1,R2,#&8000
	CMP	R1,#&200
	BCC	prekey$l		; user has pressed a key
	BL	minibuffer_eval		; read num in R0
	FNRTS	VS
	FNRTS	CS
	MOV	R1,R0
	LDRB	R0,[R8,#w_basemap]
	BL	find_key_entry		; R0=entry address (don't validate th
	FNRTS	VS			; command as we're overwriting it!)
	CMP	R0,#0
	FNRTS	LE
	MOV	R4,R0			; save address of key entry
	FNLDR	R3,key_llen		; current length of learnt string
	ADD	R0,R3,#4		; add room for -1 at end
	BL	heap_claim
	FNRTS	VS			; claim a block for it
	MOV	R2,R0			; dest
	ADD	R3,R3,#4		; len (inc -1)
	FNLDR	R1,key_learn		; source
	ADRL	R0,Multicommand
	STR	R0,[R4]			; command address
	STR	R2,[R4,#4]		; data parameter
	SWI	XZapRedraw_MoveBytes	; copy the data into the block
	FNRTS
prekey$l
	MOV	R0,R1			; number
	TEQ	R0,#&1B			; escape?
	FNRTS	EQ			; pass on if so
	FNLDR	R1,wimp_kbdbuf
	MOV	R2,#16
	SWI	XOS_ConvertHex4
	MOVVC	R14,#'&'
	STRVCB	R14,[R0]		; put & at start
	BLVC	minibuffer_write
	MOVVC	R0,#&1D			; return operation finished
	FNRTS
p$l
	ADR	R0,s$l
	BL	minibuffer_prompt_token
	FNRTS
s$l
	FNS	("zap_p_bindtokey")

	DCD	7+(1<<15)
Basic
	CMP	R2,#15
	BEQ	returnifonibmenu
	FNJSR
	MOV	R11,#e_basic
	BL	call_mode
	FNRTS

	DCD	7+(3<<3)+(1<<6)+(1<<14)+(1<<9)	; tabs for filenames
Cli
	MOV	R3,#0
	B	os_cli

	DCD	0
Cancel
	FNJSR
	BL	yank_cancel
	FNRTS				; cancel any yank operation

	DCD	7+(1<<15)
Clearsel
	FNJSR
	BL	shade_no_sel_at_all
	FNRTS	CS

	MOV	R14,#1
	FNSTR	R14,clk_depth		; current click depth

	BL	caret_writable		; make caret 1,2
	BLVC	clear_selection
	FNRTS

	DCD	7+(1<<14)+(1<<15)
Compile
	CMP	R2,#15
	BEQ	returnifonibmenu
	MOV	R11,#e_compile
	B	call_mode

	DCD	0
Cleft
	MVN	R2,#2
	MOV	R3,#0
	B	move_cursor

	DCD	0
Cright
	MOV	R2,#3
	MOV	R3,#0
	B	move_cursor

	DCD	0
Cdown
	FNJSR
	BL	get_cursor_caret
	LDR	R0,[R9,#f_len]
	BL	goto_offset
	FNRTS

	DCD	8+(1<<12)+(1<<23)	; byte input
Char
	TEQ	R2,#23
	BEQ	Char_fn
	FNJSR
	MOV	R7,R0			; save address of data
	PUSH	"R0"
	MOV	R5,R1			; save number of bytes
	LDR	R6,[R8,#w_format]
	LDR	R4,[R8,#w_flags]
	MOV	R11,#e_char
	BL	call_mode		; insert the chars
	BVS	problemexit
	PULL	"R0"
	BL	tellzapspell
	FNRTS
problemexit
	PULL	"R14"
	FNRTS
tellzapspell				; expects R0, pointer to char, R5 = 1
	FNJSR				;  "R10"
; MOV R10,R0
	LDR	R14,[R8,#w_info]
	TST	R14,#1<<7
	FNRTS	EQ
	CMP	R5,#1			; /how/ many characters...?
	FNRTS	GT
	STR	R0,local_key_number
	LDR	R0,spellasyoutypenum
	BLEQ	getsaytnom
	CMP	R0,#0
	FNRTS	EQ
	PUSH	"R1-R12"
	MOV	R7,R0
	LDR	R0,local_key_number
; MOV R0,R10
	MOV	R1,#4
	MOV	R2,#1<<31		; don't learn
	BL	process_command
	PULL	"R1-R12"
	ADDS	R14,R14,#0		; no error - already reported...
	FNRTS

getsaytnom
	FNJSR
	ADR	R0,spellasyoutypenamed
	BL	find_key_command
	STR	R0,spellasyoutypenum
	FNRTS

local_key_number
	DCD	0

spellasyoutypenum
	DCD	0

spellasyoutypenamed
	FNS ("SPELL_ASYOUTYPE")

	DCD	7+(1<<15)
ClearGC
	FNLDR	R0,opt_switches
	CMP	R2,#15
	BEQ	tick$l
	BIC	R0,R0,#bit_got_gclip
	FNSTR	R0,opt_switches
	MOV	PC,R14
tick$l
	ANDS	R0,R0,#bit_got_gclip
	MOVEQ	R0,#2
	MOVNE	R0,#0
	MOV	PC,R14

	LOCAL

	DCD	7+(3<<3)+(1<<15)
CloneBase
	TEQ	R2,#15
	MOVNE	PC,R14
	FNJSR
	BL	test_mode_name
	CMP	R0,#0
	MOVMI	R0,#2
	FNRTS	MI
	BL	isthisaclonebase	; we just want the mode numbers
	CMP	R14,#-1
	CMPNE	R0,R14
	MOVEQ	R0,#0
	MOVNE	R0,#2
	FNRTS

	LOCAL

	DCD	7+(3<<3)+(1<<6)+(1<<14)
CloneCreate
	FNJSR
	TEQ	R2,#6
	BEQ	prompt$l
	SUB	R6,R0,#1
	BL	str$l			; get clone name
	SUBS	R3,R7,R6
	ADREQ	R0,noclone$l
	BEQ	error$l
	CMP	R3,#15
	ADRHI	R0,badclone$l
	BHI	error$l
	FNLDR	R1,wimp_kbdbuf		; copy clone name
	MOV	R2,R6
	ADD	R3,R3,#1
	MOV	R4,#32
	BL	strmove
	FNLDR	R0,wimp_kbdbuf
	BL	test_mode_name		; does a mode of this name exist?
	CMP	R0,#0
	ADRGE	R0,cloneexists$l	; if so, error
	FNLDR	R4,wimp_kbdbuf
	BGE	error$l
	MOV	R0,R4
	BL	find_ext_mode
	ADRNE	R0,cloneexists$l
	BNE	error$l
	FNLDR	R1,wimp_kbdbuf
	BL	find_clone_mode_entry
	TEQ	R0,#0
	ADRNE	R0,cloneexists$l
	BNE	error$l
	MOV	R6,R7			; get clone base name
	BL	str$l
	SUBS	R3,R7,R6
	ADREQ	R0,noclonebase$l
	BEQ	error$l
	MOV	R0,R6
	BL	find_mode_number
	TEQ	R0,#0
	ADRMI	R0,clonefail$l
	BMI	error$l
	BL	read_mode
	LDR	R0,[R1,#e_mode*2]
	TST	R0,#emode_MayBeCloned
	ADREQ	R0,cantclone$l
	MOVEQ	R4,R6
	BEQ	error$l
	FNLDR	R1,wimp_kbdbuf		; copy clone base name
s$l	LDRB	R0,[R1],#1
	TEQ	R0,#0
	BNE	s$l
	MOV	R2,R6
	MOV	R3,#48
	MOV	R4,#32
	BL	strmove
	FNLDR	R1,wimp_kbdbuf
	BL	add_clone_mode_entry
	FNLDR	R0,wimp_kbdbuf,VC
	BLVC	find_mode_number	; create the clone mode
	FNRTS	VS
	TEQ	R0,#0
	FNRTS	PL
	ADR	R0,clonefail$l
error$l	FNPULL
	B	lookup_error

prompt$l
	ADR	R0,p$l
	BL	minibuffer_prompt_token
	FNRTS

str$l	LDRB	R0,[R6,#1]!
	TEQ	R0,#32
	BEQ	str$l
	SUB	R7,R6,#1
find$l	LDRB	R0,[R7,#1]!
	CMP	R0,#32
	BHI	find$l
	MOVS	PC,R14

p$l	FNS	("zap_p_mkclone")
noclone$l &	0
	FNS	("zap_e_noclone")
badclone$l &	0
	FNS	("zap_e_badclone")
noclonebase$l &	0
	FNS	("zap_e_noclonebase")
cloneexists$l &	0
	FNS	("zap_e_cloneexists")
clonefail$l &	0
	FNS	("zap_e_clonefail")
cantclone$l &	0
	FNS	("zap_e_badclonebase")

	LOCAL

	DCD	7+(3<<3)+(1<<6)+(1<<14)
CloneDelete
	MOV	R3,#0
	B	clone_dh$l

	DCD	7+(3<<3)+(1<<6)+(1<<14)
CloneHide
	MOV	R3,#1
clone_dh$l
	FNJSR
	TEQ	R2,#6
	BEQ	prompt$l
	SUB	R1,R0,#1
s$l	LDRB	R0,[R1,#1]!
	TEQ	R0,#32
	BEQ	s$l
	MOV	R2,R3
	BL	remove_clone_mode_entry
	FNRTS
prompt$l
	ADR	R0,p$l
	BL	minibuffer_prompt_token
	FNRTS
p$l	=	"zap_p_delclone",0
	ALIGN

	DCD	0
Closeother
	FNJSR
	BL	find_next_window
	FNRTS	VS
	CMP	R0,#0
	BLPL	delete_window		; window to swap to? close it (with prompt)
	FNRTS

	DCD	7
Closeprinter
	FNJSR
	ADR	R0,op_s2
	SWI	XOS_CLI
	FNRTS
op_s2
	FNS	("Filer_CloseDir Printer:$")

	DCD	0+(1<<28)
Closewindow
	FNJSR
	BL	test_delete_window	; what will happen when we delete?
	FNRTS	VS
	TEQ	R0,#0
	BEQ	cl18			; promt will come up...?
	BL	swap_window		; move to another winodow
; FNRTS VS
	BLVC	delete_window		; and original window
	MOVVC	R1,#-1
	SWIVC	XWimp_CreateMenu	; close all menus to prevent adjust-click bug
	FNRTS
cl18
	BL	delete_window
; FNRTS VS
	BLVC	get_DyingBox
	MOVVC	R7,R1
	LDRVC	R0,[R7,#4]
	ORRVC	R0,R0,#1<<4		; swap window on dying
	STRVC	R0,[R7,#4]
	FNRTS

	LOCAL

	DCD	7+(3<<3)+(1<<6)+(1<<11)+(1<<12)+(1<<17)+(1<<28)
Command					; R1=number of times (inc uni arg)
	FNJSR
	TEQ	r2,#17
	BEQ	m$l
	TEQ	R2,#6
	BEQ	p$l			; minibuffer
	LDRB	R14,[R0]		; get first character
	TEQ	R14,#0
	MOVEQ	R0,#0			; close minibuffer
	FNRTS	EQ			; quit if empty
	MOV	R6,R0			; save argument
	MOV	R0,R1
	BL	universal_arg		; repeat time for next command
	FNRTS	VS
	ORR	R0,R6,#1<<31		; don't learn
	BL	command_string		; execute the string
	FNRTS	VS
	CMP	R0,#0
	MOVPL	R0,#0			; close minibuffer
	MOVMI	R0,#1			; leave it open as command uses it
	FNRTS
m$l
	CMP	r0,#0
	ADREQ	r0,s$l			; menu title
	BLEQ	lookup_token_R0		; lookup_token_R0 preserves flags across call
	FNRTS	EQ
	CMP	r0,#1
	MOVEQ	r0,#0			; clear entry
	CMP	r0,#2
	FNLDR	r0,mini_bufl,EQ		; get minibuffer size into r0
	FNRTS
p$l
	ADR	R0,s$l
	BL	minibuffer_prompt_token
	FNRTS
s$l	FNS	("zap_p_command")

; This command seems to suffer from severe theoretical problems.
; Zap doesn't seem to be able to load modules under these circumstances :(

; DCD 7+(3<<3)+(1<<16) ; +(1<<6)+(1<<11)+(1<<12)
;Menucommand				;R1=total number (inc uni arg)
; FNJSR
; TEQ R2,#6
; BEQ p$l				; minibuffer
; TEQ R2,#16
; BEQ menucmdsetup
; ;LDRB R14,[R0]			; get first character
; ;TEQ R14,#0
; ;MOVEQ R0,#0				; close minibuffer
; ;FNRTS EQ				; quit if empty
; ;MOV R6,R0				; save argument
; ;MOV R0,R1
; ;BL universal_arg			; repeat time for next command
; ;FNRTS VS
; ;ORR R0,R6,#1<<31			; don't learn
; ;BL command_string			; execute the string
; ;FNRTS VS
; ;CMP R0,#0
; ;MOVPL R0,#0				; close minibuffer
; ;MOVMI R0,#1				; leave it open as command uses it
; FNRTS
;
;menucmdsetup
; PUSH "R1-R12"
; BL find_key_command ; Zap_FindCommand
;loop$l
; B loop$l
; MOV R7,R0
; ADR R0,cmdexectmp
;
; ;MOV R14,PC
; ;MOV PC,R7
;
; ;BL Infobox
; PULL "R1-R12"
;
;; CMP R0,#0
;;FNRTS
;
; ;CMP R0,#0
; ;PUSH "R10"			; save input caret
; ;MOV R10,R0			; string start
; ;BL read_command		; R7=command address / b0 set form
; ;BLVC validate_command	; R7=command address (command now loa;ded)
; ;PULL "R10"			; restore caret pointer
; ;FNRTS VS
; ;LDR R14,[R7,#-4]
; ;TST R14,#(1<<16)
; ;FNRTS EQ
; ;CMP R0,#0
; ;BMI reportusraproblem	; check command params ok???
; ;MOV R0,R1			; parameter
; MOV R7,R0
; MOV R1,#1
; MOV R2,#16
; ;ORR R2,R2,#(1<<31)
; ADR R0,cmdexectmp
; ;ADRL R7,Save
; ;MOV R14,PC
; ;MOV PC,R7
; BL get_SaveSelBox
; MOV R0,R1
; PULL "R1-R12"
; ;BL process_command
; FNRTS
;cmdexectmp
; DCD 0

;reportusraproblem
; SWI &20107
; FNRTS

	DCD	1<<23
Copy
	FNJSR
	FNLDR	R0,car_mode
	TEQ	R2,#23
	BEQ	Copy_fn
	TEQ	R0,#2
	BEQ	co11			; copy already initiated
	TEQ	R0,#1
	FNRTS	NE			; not in a state to initiate copy
	MOV	R0,#2
	BL	set_caret_mode		; initialise copy
	MOV	R14,#-1
	FNSTR	R14,car_column		; column preferred by cursor
	FNRTS
co11
	MOV	R0,R1			; number of bytes to copy
	BL	copy_text
	FNRTS
Copy_fn
	TEQ	R0,#2
	MVNEQ	R0,#0
	MOVNE	R0,#0
	MOV	R1,#2
	FNRTS

	LOCAL

	DCD	7+(2<<3)+(1<<17)
Columntab
	TEQ	R2,#0
	BNE	a$l
	LDR	R5,[R0]
	CMP	R5,#1
	MOVLT R5,#1
a$l
	TEQ	R8,#0
	MOVEQ	R3,#opt_tab
	MOVNE	R3,#w_tab
	ADR	R4,s$l
	B	new_w_num_checked
s$l	FNS	("zap_m_tabw")

	DCD	7+(1<<15)
Confinehorizontally
	MOV	R0,#0			; 1<<21	; clear freeclick?
	MOV	R1,#1<<24		; toggle Confinehorizontally
	B	new_wind_format_set

	DCD	7+(1<<15)
Colonseparator
	MOV	R0,#0			; clear zilch
	MOV	R1,#info_LineNumberColons
	B	new_info_set

	LOCAL

	DCD	7+(1<<15)
Confinevertically
	MOV	R0,#0			; clear nothing
	MOV	R1,#1<<23		; toggle Confinevertically
	B	new_wind_format_set

;\E R2 = Length
;   R3 = 0/ptr to data to be inserted... R8/R9/R10
;\X R1 number of spaces (also flags, EQ or NE)

getnoofspaces
	FNJSR	"R11"
	CMP	R3,#0
	BEQ	zerospaces		; no data = no need...
	MOV	R0,#10
	MOV	R11,#e_interrogate	; R3=ptr to data?
	BL	call_mode
	CMP	R0,#0
	BEQ	zerospaces
	LDR	R0,[R10,#c_loff]
	LDR	R1,[R10,#c_off]
	BL	cln_lineoff		; \X R0 = column on screen...
	BVS	zerospaces
	MOV	R11,R0
	LDR	R0,[R10,#c_off]
	LDR	R14,[R9,#f_len]
	CMP	R0,R14
	BLCC	cln_readc
	CMP	R0,#32
	BCS	zerospaces
	LDR	R1,[R8,#w_margin]
	ADD	R0,R11,R1		; add margin
	LDR	R1,[R10,#c_col]
	SUBS	R1,R1,R0		; number of spaces to insert before entry
	MOVMIS	R1,#0			; number of spaces to insert before entry
	FNRTS

zerospaces
	MOVS	R1,#0			; problems solved
	FNRTS

; R1 = noofspaces... R8/R9/R10...
; X R0 = spaces inserted.
actuallyinsertthemspaces
 FNJSR "R1-R4"
 LDR R4,[R8,#w_format]
 BIC R14,R4,#(1 << 15)			; clear non-standard editing
 STR R14,[R8,#w_format]
 ADD R0,R1,#8				; r1 = length
 BL ensure_redblk			; ensure enough spaces in spaces buffer
 MOVVC R2,R1				; number of spaces
 LDRVC R1,[R10,#c_off]
 FNLDR R3,red_blkbuf,VC
 MOVVC R0,#&11
 BLVC execute_command			; insert the spaces
 STRVC R4,[R8,#w_format]		; restore the flags
 MOVVC R0,R2
 FNRTS

;E R8/R9/R10
;X R0 = length of nofspaces done...
insertsomespaces
 FNJSR "R1-R7"
 BL getnoofspaces			; returns it in R1.
 CMP R1,#0
 BLE nonespacesatall
 BL actuallyinsertthemspaces
 FNRTS
nonespacesatall
 MOV R0,#0				; R0=column offset on screen - margin
 FNRTS

; Sigh. to avoid what appear to be  bugs in start_operation/stop_operation,
; this command has turned into a right mess...

copyseltmp
 DCD 0
 DCD 0

 DCD (1<<15)
Copysel
 FNJSR
 BL shade_no_sel
 FNRTS CS				; R1=file off R2=len R8/R9=window
 ;BL save_txt_status            ; BL start_operation
 MOV R6,R1				; start off of selection
 ADD R7,R1,R2				; end off of selection
 BL read_selection			; into heap block in R2...
 BVS copyselexit			; copyselerrorexit2
 STR R2,copyseltmp + 4			; length...
 MOV R4,R8
 MOV R5,R9				; save window containing selection
 BL get_input_caret			; find input caret window R8,R9,R10
 LDR R1,[R10,#c_off]			; input caret offset
 STR R1,copyseltmp
 BL getnoofspaces			; returns it in R1.
 CMP R1,#0				; needed?
 MOVLE R11,#0
 BLE endoffudge$l
; BL insertsomespaces			; was/is commented out...
 MOV R11,R1
 MOV R0,R3
 BL heap_extend				; extend selected block (yuck code)
 BVS copyselerrorexit
 MOV R3,R2
 ADD R2,R11,R0
 MOV R1,R0
 ;LDR R3,copyseltmp + 4
 MOV R10,R0
 SWI XZapRedraw_MoveBytes ; BL move_bytes
 MOV R3,R10
 MOV R2,#0
 ADD R2,R10,R11
 MOV R14,#32
loop1$l
 STRB R14,[R10],#1
 CMP R10,R2
 BCC loop1$l

 LDR R2,copyseltmp + 4		; length...
 ADD R2,R2,R11			; new length...
endoffudge$l			; ...?
 BL get_input_caret		; find input caret window (set up R10)
 LDR R1,[R10,#c_off]		; input caret offset
 MOV R0,#&11			; insert block
 BL execute_command
 BVS copyselerrorexit		; copyselexit
 MOV R0,R3
 BL heap_free			; free selected block
 BVS copyselexit		; copyselerrorexit
 TEQ R9,R5
 BNE co2			; block was inserted in another file
 LDR R1,copyseltmp
 CMP R6,R1	 		; a problem
 ADDCS R6,R6,R2			; a problem
 ;ADDCS R6,R6,R11		; a problem
 CMP R7,R1			; a problem
 ADDGT R7,R7,R2			; find new start end of region
 ;ADDGT R7,R7,R11		; find new start end of region
co2
 MOV R8,R4
 MOV R9,R5			; window with selection
 MOV R2,R6
 MOV R3,R7
 BL select_region		; select the region
copyselexit
 ;BL new_txt_status
 ;BL stop_operation
 FNRTS

copyselerrorexit
 PUSH "R0"
 MOV R0,R3
 BL heap_free			; free selected block
 PULL "R0"
 FNRTV

;copyselerrorexit2
; PUSH "R0"
; LDR R0,copyseltmp + 4
; BL heap_free			; free selected block
; PULL "R0"
; FNRTV

;  DCD (1<<15)
; Copysel
;  FNJSR
;  BL shade_no_sel
;  FNRTS CS			; R1=file off R2=len R8/R9=wind with sel
;  MOV R6,R1			; start off of selection
;  ADD R7,R1,R2			; end off of selection
;  BL read_selection
;  FNRTS VS			; read the selection to heap block R3
;  MOV R4,R8
;  MOV R5,R9			; save window containing selection
;  BL get_input_caret		; find input caret window
;  LDR R1,[R10,#c_off]		; input caret offset
;  MOV R0,#&11			; insert block
;  BL execute_command
;  FNRTS VS			; insert the data
;  MOV R0,R3
;  BL heap_free
;  FNRTS VS			; free selected block
;  TEQ R9,R5
;  BNE co2			; block was inserted in another file
;  CMP R6,R1
;  ADDCS R6,R6,R2
;  CMP R7,R1
;  ADDGT R7,R7,R2			; find new start end of region
; co2
;  MOV R8,R4
;  MOV R9,R5			; window with selection
;  MOV R2,R6
;  MOV R3,R7
;  BL select_region		; select the region
;  FNRTS

 DCD 7
Coredump
 B core_dump

; DCD (3<<3) + (1<<6) + (1<<10)		; !later!
;Crash
; FNJSR
; CMP R2,#6
; ADREQ R0,chara$l
; FNRTS EQ
; BL Char
; FNRTS
;chara$l
; DCD 65

;  DCD 7
; Crash
;  FNJSR				; !!!!!!!!!!!!! BUG !!!!!!!!!!!!!
;  SWI XOS_ReadMemMapInfo
;  FNRTS VS
;  MOV R2,R0
;  MOV R1,#&04000000
; findinvalidaddress
;  MOV R0,R1
;  ADD R1,R1,R2
;  SWI XOS_ValidateAddress	; CS if any addrs in range invalid
;  FNRTS VS
;  BCC findinvalidaddress
;  MOV R1,#1
;  MOV R2,#2
;  MOV R3,#3
;  MOV R4,#4
;  MOV R5,#5
;  MOV R6,#6
;  MOV R7,#7
;  MOV R8,#8
;  MOV R9,#9
;  MOV R10,#10
;  MOV R11,#11
;  MOV R12,#12
;  MOV R13,#13
;  MOV R14,#14
;  LDR R0,[R0]			; abort
;  FNRTS
;
;  DCD 7
; Crunch
;  FNJSR				; !!!!!!!!!!!!! BUG !!!!!!!!!!!!!
;  SWI XOS_GetEnv
;  LDR R1,[R1]
;  FNRTS
;
;  DCD 7
; Crumple
;  FNJSR				; !!!!!!!!!!!!! BUG !!!!!!!!!!!!!
;  MOV R0,#&EA000000
;  LDR R0,[R0]
;  FNRTS

 DCD 7+(2<<3)+(1<<28)
Createfile
 FNJSR
 LDR R0,[R0]			; file type
 BL create_empty
; BLVC stop_operation		; to avoid bugs...
 BLVC create_window_caret
 FNRTS

 DCD 0
Cup
 FNJSR
 BL get_cursor_caret
 MOV R0,#0
 BL goto_offset
 FNRTS

 DCD 7+(1<<16)
Cursormenu
 FNLDR R0,menu_memory
 LDR R0,[R0,#16]
 MOV PC,R14

 DCD (1<<15)
Cut
 FNJSR
 MOV R7,R8
 BL shade_no_sel		; get R8/R9 containg the selection
 FNRTS CS
 BL caret_writable
 BL shade_no_sel		; get R8/R9 containg the selection
 CMP R7,R8
 LDRNE R0,[R8,#w_poff]
 LDREQ R0,[R10,#c_off]
 BL goto_file_offset
 ;BLVC clear_point		; scrub out point if marked
 ;BLVC gain_input
 ;BLVC plot_caret ; set_old_caret_pos ; call_set_caret
 ;BLVC make_cursor_visible
; BLVC gain_input
; BLVC clear_selection		; remove selected area
 FNRTS VS
 LDR R0,[R9,#f_flags]
 TST R0,#1
 BEQ noundo$l
 ;MOV R4,R2			; save length of delete
 ;MOV R5,R3
 BL read_selection
 FNRTS VS
 LDR R14,[R9,#f_flags]
 TST R14,#&110			; read only?
 BLEQ clear_selection		; remove selected area if not
 CMP R3,#0
 FNRTS EQ
 MOV R0,#&52			; delete no concat
 LDR R14,[R10,#c_off]
 CMP R14,R1
 MOVEQ R0,#&55			; cursor at start...!
 FNLDR R14,opt_switches		; ask for no returned heap block...
 ORR R14,R14,#bit_return_deletions
 FNSTR R14,opt_switches
 BL execute_command
 FNLDR R14,opt_switches		; ask for no returned heap block...
 BIC R14,R14,#bit_return_deletions
 FNSTR R14,opt_switches
; FNRTS VS
 MOVVC R0,#0
 BLVC add_yank_region		; add it to the yank list
 MOVVC R0,R3
 BLVC heap_free
 FNRTS

noundo$l
 LDR R14,[R9,#f_flags]
 TST R14,#&110			; read only?
 BLEQ clear_selection		; remove selected area if not
 FNRTS VS
 MOV R0,#&52			; delete no concat
 LDR R14,[R10,#c_off]
 CMP R14,R1
 MOVEQ R0,#&55			; cursor at start...!
 FNLDR R14,opt_switches		; ask for no returned heap block...
 ORR R14,R14,#bit_return_deletions
 FNSTR R14,opt_switches
 BL execute_command
 FNLDR R14,opt_switches		; ask for no returned heap block...
 BIC R14,R14,#bit_return_deletions
 FNSTR R14,opt_switches
 FNRTS

 DCD (3<<3)+(1<<6)
Date
 FNJSR
 TEQ R2,#6
 BEQ da13
 BL insert_date
 FNRTS
da13
 ADR R0,da_s0
 BL minibuffer_prompt_token
 FNRTS
da_s0
 FNS ("zap_p_date")

 DCD 0+(1<<28)
Defaultmap
 TEQ R8,#0
 FNLDR R0,key_default,EQ
 LDRNEB R0,[R8,#w_defaultmap]
 B basemap_entry

delprev$l
 FNS ("PREV")
delnext$l
 FNS ("NEXT")
delprevword$l
 FNS ("WORDSTART")
delnextword$l
 FNS ("WORDEND")
delword$l
 FNS ("WORD")
dellinestart$l
 FNS ("LINESTART")
dellineend$l
 FNS ("LINEEND")
delline$l
 FNS ("LINE")
delparagraphstart$l
 FNS ("PARASTART")
delparagraphend$l
 FNS ("PARAEND")
delparagraph$l
 FNS ("PARA")
delfilestart$l
 FNS ("FILESTART")
delfileend$l
 FNS ("FILEEND")
delfile$l
 FNS ("FILE")
delselection$l
 FNS ("SEL")
delnonselection$l
 FNS ("NONSEL")

goifmatched$l
 FNJSR
 MOV R2,R7
 BL strcmp
 FNRTS NE
 PULL "R14"
 MOV R1,R5
 MOV R2,#0
 MOV PC,R4

delnorm$l
 MOV R7,#0			; normal delete type
de10
 MOV R5,R1			; save number of bytes
 LDR R6,[R8,#w_format]		; window format
 MOV R11,#e_delete
 BL call_mode
 ADRVC R0,ptrtotfs$l
 BLVC tellzapspell
 FNRTS				; !!! /should/ match a simple one...

update_caret_call_mode
 LDR R0,[R10,#c_loff]
 LDR R1,[R10,#c_off]
 LDR R2,[R10,#c_col]
 LDR R3,[R8,#w_margin]
 SUBS R2,R2,R3
 MOVMI R2,#0
 B call_mode			; find start of next line

 DCD (3<<3) + (1<<6) + (1<<10) + (1<<27) ; !later!
Delete
 FNJSR
 CMP R2,#6
 ADREQ R0,delprev$l
 FNRTS EQ
 MOV R5,R1			; save number of bytes
 CMP R0,#0
 BEQ delnorm$l
 LDRB R14,[R0]
 CMP R14,#0
 BEQ delnorm$l
; B delnorm$l
 MOV R7,R0
 ADR R4,delnorm$l
 ADR R1,delprev$l
 BL goifmatched$l
 ADR R4,Deletenextnocopy + 4
 ADR R1,delnext$l
 BL goifmatched$l
 ADR R4,Deletewordprev + 4
 ADR R1,delprevword$l
 BL goifmatched$l
 ADR R4,Deletewordnext + 4
 ADR R1,delnextword$l
 BL goifmatched$l
 ADR R4,Deleteword + 4
 ADR R1,delword$l
 BL goifmatched$l
 ADR R4,to_Deltostart			; Deltostart + 4
 ADR R1,dellinestart$l
 BL goifmatched$l
 ADR R4,to_Deltoend			; Deltoend + 4
 ADR R1,dellineend$l
 BL goifmatched$l
 ADR R4,Delline + 4
 ADR R1,delline$l
 BL goifmatched$l
; ADR R4,Deletenextnocopy + 4
; ADR R1,delparagraphstart$l
; BL goifmatched$l
; ADR R4,Deletenextnocopy + 4
; ADR R1,delparagraphend$l
; BL goifmatched$l
; ADR R4,Deletenextnocopy + 4
; ADR R1,delparagraph$l
; BL goifmatched$l
 ADR R4,Deltosof + 4
 ADR R1,delfilestart$l
 BL goifmatched$l
 ADR R4,Deltoeof + 4
 ADR R1,delfileend$l
 BL goifmatched$l
 ADR R4,Delfile + 4
 ADR R1,delfile$l
 BL goifmatched$l
 ADR R4,Cut + 4
 ADR R1,delselection$l
 BL goifmatched$l
 ADR R4,Delnonsel + 4
 ADR R1,delnonselection$l
 BL goifmatched$l

 MOV R1,R5
 MOV R2,#0
 B delnorm$l

ptrtotfs$l
 DCD 65 ; lie...

 & 1+(1<<28)
Deletefile
 B delete_file

 DCD 0
Deletenext
 FNLDR R0,car_mode
 TEQ R0,#2
 BEQ Copy			; perform copy action
 ; fall through (safe because DCD 0 == ANDEQ R0,R0,R0)

 DCD 0
Deletenextnocopy
 FNJSR
 MOV R7,#1
 B de10

 DCD 0
Delline
 FNJSR
 LDR R0,[R10,#c_off]
 MOV R11,#e_linenext
 BL call_mode			; find start of next line
 MOVVC R2,R0			; save
 LDRVC R0,[R10,#c_off]
 MOVVC R11,#e_lineprev
 BLVC call_mode			; find start of this line
 FNRTS VS
 LDR R14,[R9,#f_len]
 CMP R0,R14
 FNRTS EQ
 MOV R1,R0			; first char to delete
 SUB R2,R2,R1			; number to delete
 MOV R0,#&12			; del block
 BL execute_command
 ANDVC R0,R3,#1
 MOVVC R0,R0,LSL#30		; is this a repeat block
 ;MOV R0,#0
 BLVC add_yank_region
 FNRTS

 DCD 0
Deletewordnext
 FNJSR
 LDRB	R7,[R8,#w_format]
 CMP	R7,#5 ; BASIC
 BEQ	BASICfudge1$l
 LDR R7,[R10,#c_off]
 MOV R11,#e_splus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 LDR R14,[R9,#f_len]
 CMP R1,R14
 MOVCS R1,R14
 SUB R14,R1,#1
 CMP R14,R7
 BGT carryon$l
 STR R1,[R10,#c_off]
 BL update_caret
 MOV R11,#e_splus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 LDR R14,[R9,#f_len]
 CMP R1,R14
 MOVCS R1,R14
carryon$l
 MOV R6,R1
 STR R1,[R10,#c_off]
 BL update_caret
 MOV R11,#e_sminus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 SUB R14,R1,#1
 CMP R14,R7
 MOVGT R6,R1
 MOV R1,R7
 SUB R2,R6,R1			; number to delete
 MOV R0,#&15			; del block
 BL execute_command
 ANDVC R0,R3,#1
 MOVVC R0,R0,LSL#30		; is this a repeat block
 BLVC add_yank_region
 FNRTS
DELWORDLEFTcmd$l
 = "DELWORDLEFT",0
DELWORDRIGHTcmd$l
 FNS ("DELWORDRIGHT")

BASICfudge1$l
	ADR	R0,DELWORDRIGHTcmd$l
	BL	command_string
	FNRTS

 DCD 0
Deletewordprev
 FNJSR
 LDRB	R7,[R8,#w_format]
 CMP	R7,#5 ; BASIC
 BEQ	BASICfudge2$l
 LDR R7,[R10,#c_off]
 MOV R11,#e_sminus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 CMP R1,#0
 MOVMI R1,#0
 ADD R14,R1,#1
 CMP R14,R7
 BLT carryon2$l
 STR R1,[R10,#c_off]
 BL update_caret
 MOV R11,#e_sminus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 CMP R1,#0
 MOVMI R1,#0
carryon2$l
 MOV R6,R1
 STR R1,[R10,#c_off]
 BL update_caret
 MOV R11,#e_splus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 ADD R14,R1,#1
 CMP R14,R7
 MOVGE R1,R6
 SUB R2,R7,R1			; number to delete
 MOV R0,#&12			; del block
 BL execute_command
 ANDVC R0,R3,#1
 MOVVC R0,R0,LSL#30		; is this a repeat block
 BLVC add_yank_region
 FNRTS

BASICfudge2$l
	ADR	R0,DELWORDLEFTcmd$l
	BL	command_string
	FNRTS

 DCD 0
Delfile
 FNJSR
 MOV R1,#0
 LDR R2,[R9,#f_len]
 MOV R0,#&12			; del block
 BL execute_command
 AND R0,R3,#1
 MOV R0,R0,LSL#30		; is this a repeat block
 BL add_yank_region
 FNRTS

 DCD 0
Delnonsel
 FNJSR
 BL shade_no_sel
 FNRTS CS
 MOV R7,R1
 BL start_operation
 ADD R1,R1,R2
 LDR R2,[R9,#f_len]
 SUB R2,R2,R1
 MOV R0,#&12			; del block
 BL execute_command
 MOVVC R1,#0
 MOVVC R2,R7
 MOVVC R0,#&12			; del block
 BLVC execute_command
 BLVC stop_operation
 FNRTS

 DCD 0
Deleteword
 FNJSR
 MOV R11,#e_sminus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE

 CMP R1,#0
 MOVMI R1,#0
 MOV R7,R1
 MOV R11,#e_splus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE

 LDR R14,[R9,#f_len]
 CMP R1,R14
 MOVCS R1,R14
 SUB R2,R1,R7
 MOV R1,R7
 MOV R0,#&12			; del block
 BL execute_command
 ANDVC R0,R3,#1
 MOVVC R0,R0,LSL#30		; is this a repeat block
 BLVC add_yank_region
 FNRTS

 DCD 0
Deltosof
 FNJSR
 MOV R1,#0
 LDR R2,[R10,#c_off]
 MOV R0,#&12			; del block
 BL execute_command
 MOVVC R0,#0
 BLVC add_yank_region
 FNRTS

 DCD 0
Deltoeof
 FNJSR
 LDR R1,[R10,#c_off]
 LDR R2,[R9,#f_len]
 SUB R2,R2,R1
 MOV R0,#&12			; del block
 BL execute_command
 MOVVC R0,#0
 BLVC add_yank_region
 FNRTS

to_Deltostart
 LDMFD R13!,{R14}
 B Deltostart

 DCD 0
Deltostart
	ADR	R3,Deltostart_main
	B	Delto_common
Deltostart_main
 FNJSR
 LDR R0,[R10,#c_off]
 MOV R11,#e_linestart
 BL call_mode			; start of line
 MOVVC R1,R0
 LDRVC R2,[R10,#c_off]
 SUBVC R2,R2,R1			; num chars to delete
 MOVVC R0,#&12			; del block
 BLVC execute_command
 MOVVC R0,#0
 BLVC add_yank_region
 FNRTS

to_Deltoend
 LDMFD R13!,{R14}
 B Deltoend

 DCD 0
Deltoend
	ADR	R3,Deltoend_main
Delto_common
	ORR	R3,R3,#1<<31
	LDR	R4,[R8,#w_flags]
	MVN	R5,#1<<31
	LDR	R6,[R8,#w_format]
	B	char_del_dispatch
Deltoend_main
 FNJSR
 MOV R5,R0
 LDR R0,[R10,#c_off]
 LDR R14,[R9,#f_len]
 CMP R0,R14
 FNRTS CS
 MOV R11,#e_lineend
 BL call_mode			; find end of line
 FNRTS VS
 MOV R2,R0			; end of del area
 LDR R0,[R10,#c_off]
 TEQ R0,R2			; is this line empty
 TEQEQ R5,#0
 BEQ de11			; join the next line if so
 LDR R1,[R10,#c_off]
 SUB R2,R2,R1			; num chars to delete
 MOV R0,#&15			; del block
 BL execute_command
 B de17				; finished
de11
; LDR R14,[R9,#f_len]
; SUB R14,R14,#1
; CMP R0,R14
; FNRTS CS
 STMFD R13!,{R3}
 BL Joinline
 LDMFD R13!,{R3}
 FNRTS VS			; return on error
de17
 AND R0,R3,#1
 MOV R0,R0,LSL#30
 ;MOV R0,#0
 BL add_yank_region		; add it
 FNRTS

 DCD (1<<12)
Down
 MOV R2,#0
 MOV R3,#1
 B move_cursor

 DCD 7
Dumpfile
 FNJSR
 BL get_wind_off
 ADR R10,sub$l
 BL do_longop
 FNRTS
sub$l B dump_file

 DCD 0+(1<<28)
Emacs
 ADR R0,emacs$l
 B Basemapn
emacs$l FNS ("Emacs")

 DCD 0
Escape
 B default_caret

 DCD 0+(1<<28)
Execute
 FNJSR
 FNLDR R3,key_flags
 BIC R3,R3,#4
 FNSTR R3,key_flags		; turn off learn first!
 FNLDR R0,key_learn		; learn buffer
 BL execute_strokes
 FNRTS

 DCD 0
Fastundo
 MOV R0,R1			; undo R1 chars
 MOV R1,#0			; fast undo
 B undo_command

 DCD 7+(2<<3)+(1<<15)
Fflags_toggle
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 BL new_file_flags_set
 FNRTS

 LOCAL

 DCD 7+(3<<3)+(1<<6)+(1<<9)+(1<<28)
Findfile
 FNJSR
 TEQ R2,#6
 ADREQ R0,fi_s0
 BEQ fi11
 ; need to fix this to cope with DDEUtils...
 BL find_file ; FNcall Zap_FindFile
 MOVVC R0,#3			; bring to front
 MOVVC R1,R8
 BLVC open_a_window
; BLVC open_window
; FNcallc Zap_OpenWindow,VC,R11
 LDRVC R0,[R8,#w_poff]		; cursor position ; ? poff
 BLVC put_caret
; FNcallc Zap_PutCaret,VC,R11
 FNRTS
fi11
 BL minibuffer_prompt_token		; insert prompt
 FNRTS VS
 BL find_current_directory_dde
 TEQVC R0,#0
 TEQVS R0,R0
 BNE fi13
 CMP R9,#0
 BEQ fi12
 LDR R0,[R9,#f_name]
 BL check_file_name		; does name contain path
 FNRTS VS
 TEQ R0,#0
 BNE fi12			; no path
 LDR R0,[R9,#f_name]		; assosiated file name
 MOV R2,R0
 BL find_leaf_name		; find leaf name part
 FNRTS VS
 MOV R3,R0			; save start of leaf name
 LDRB R4,[R3]			; first char of leaf name
 MOV R0,#0
 STRB R0,[R3]			; chop it off
 MOV R0,R2
 BL minibuffer_write ; FNcall Zap_MiniWrite ; write name into buffer (default)
 STRB R4,[R3]			; restore name
 FNRTS
fi12
 BL find_current_directory
 FNRTVC VS			; cope with things like "disk not present"
fi13
 BL minibuffer_write 		; write name into buffer (default)
 MOVVC R0,#'.'
 BLVC minibuffer_writec		; insert current dir as prompt
 FNRTS
fi_s0 FNS ("zap_p_findfile")
fi_s1 FNS ("zap_p_findfilero")

 DCD 7+(3<<3)+(1<<6)+(1<<9)+(1<<28)
Findfilereadonly
 FNJSR
 TEQ R2,#6
 ADREQ R0,fi_s1
 BEQ fi11
; FNcall Zap_FindFile,R11
 BL find_file
 LDRVC R0,[R9,#f_flags]
 ORRVC R0,R0,#1<<8
 STRVC R0,[R9,#f_flags]
 BLVC new_file_title
; FNcall Zap_NewFileTitle,R11
 FNRTS

 LOCAL

 DCD 0 ; +(3<<3)+(1<<6)+(1<<10)
Findfunction
 FNJSR
 LDR R0,[R10,#c_off]
 MOV R1,#12
 MOV R11,#e_init
 BL call_mode
 CMP R1,#12
 CMPNE R1,#0
 CMPNE R1,#2
 FNRTS EQ ; OK.
 ADR R0,err_notfunfound
 MOV R1,#0
 BL warn_user
 FNRTS
err_notfunfound
 FNS ("zap_FnNotFound")

 DCD 7+(2<<3)+(1<<17)
Fontaspect
 FNJSR
 TEQ R2,#17
 BEQ a$l
 LDR R0,[R0]
 CMP R0,#1
 MOVLE R0,#1 ; default?
 FNLDR R14,font_size
 MOV R14,R14,LSL #16
 MOV R14,R14,LSR #16
 ORR R0,R14,R0,LSL #16
 FNSTR R0,font_size
 BL new_font
 FNRTS
a$l
 TEQ R0,#0
 ADREQ R0,s$l
 BLEQ lookup_token_R0
 TEQ R0,#1
 BEQ returnaspect$l
 TEQ R0,#2
 MOVEQ R0,#9 ; length...
 FNRTS
returnaspect$l
 LDR R0,[R12,#font_size]
 MOVS R0,R0,LSR #16
 MOVEQ R0,#100
 STR R0,local_fontaspect
 ADR R0,local_fontaspect
 FNRTS

s$l FNS ("zap_m_faspect")
local_fontaspect
 DCD 0

 LOCAL

 DCD 7+(2<<3)+(1<<17)
Fontsize
 FNJSR
 TEQ R2,#17
 BEQ a$l
 LDR R0,[R0]
 CMP R0,#1
 MOVLE R0,#1 ; default?
 FNLDR R14,font_size
 MOV R14,R14,LSR #16
 MOV R14,R14,LSL #16
 ORR R0,R14,R0
 FNSTR R0,font_size
 BL new_font
 FNRTS
a$l
 TEQ R0,#0
 ADREQ R0,s$l
 BLEQ lookup_token_R0
 TEQ R0,#1
 LDREQ R0,[R12,#font_size]
 MOVEQ R0,R0,LSL #16
 MOVEQ R0,R0,LSR #16
 STREQ R0,local_fontaspect
 ADREQ R0,local_fontaspect
 TEQ R0,#2
 MOVEQ R0,#9
 FNRTS
s$l FNS ("zap_m_fsize")

 LOCAL

 DCD 7+(2<<3)+(1<<15)
Fonttype
 LDR R3,[R0]
 MOV R0,#&320000		; mask
 CMP R3,#5
 MOVHI R3,#1			; scaled font as default
 ADR R1,type$l
 LDR R1,[R1,R3,LSL #2]
 B new_flags_select
type$l
 & 0, &100000, &020000, &200000, &120000, &220000

 DCD 0
Formattext
 MOV R11,#e_formattext
 B call_mode

 DCD 7+(1<<15)
Freeclick
 MOV R0,#0 ; 1<<24	; clear CONFINE HORIZ... nothing
 MOV R1,#1<<21		; toggle freeclick
 B new_wind_format_set

 DCD 0
Fullundo
 MOV R0,R1			; undo R1 chars
 MOV R1,#1			; full undo
 B undo_command

 DCD 7+(1<<15)
Hexascii
 MOV R0,#0
 MOV R1,#1<<5
 B new_wind_flags_set

 LOCAL

; DCD &0258
;Gotoaddr
; ; \E\X AS FOR STARCOM
; TEQ R2,#6
; BEQ ga_openmb
; TEQ R2,#0
; TEQNE R2,#1
; MOVNES PC,R14
; STMFD R13!,{R14}
; ; GOING TO EXECUTE IT!
; BL skipspc
; MOV R1,R0
; MOV R0,#10
; SWI XOS_ReadUnsigned
; LDMVSFD R13!,{PC}
; ; R2 = ADDRESS; MUST GO THERE
; LDR R0,[R8,#w_addr]
; SUB R0,R2,R0
; ; R0 = OFFSET FOR THE ADDRESS (WHAT IF THIS IS -VE?)
; BL goto_offset
; ;FNcall Zap_GotoOffset
; LDMVCFD R13!,{PC}^
; LDMFD R13!,{PC}

;ga_openmb
; STMFD R13!,{R14}
; ADR R0,ga_prompt
; BL minibuffer_prompt ; FNcall Zap_MiniPrompt
; MOV R0,#'&'
; BL minibuffer_writec ; FNcall Zap_MiniWriteC
; LDMFD R13!,{PC}
;ga_prompt
; = "Goto address: ",0
; ALIGN

;E R0
;X R0 updated past any spaces...

;skipspc
; STMFD R13!,{R14}
;sks_l
; LDRB R14,[R0],#1
; TEQ R14,#32
; BEQ sks_l
; SUB R0,R0,#1
; LDMFD R13!,{PC}^

 LOCAL

 DCD 7+(3<<3)+(1<<6)+(1<<8)+(1<<11)
Help
 FNJSR
 TEQ R2,#6
 BEQ p$l
 SUB R14,R2,#&8000
 CMP R14,#&200
 BCC key$l
 LDRB R0,[R0]			; first byte of string
 CMP R0,#'a'
 SUBGE R0,R0,#'a'-'A'		; make upper case
 TEQ R0,#'K'
 ADREQ R7,Helpkey
 BEQ helpon$l
 TEQ R0,#'F'
 ADREQ R7,Helpfn
 BEQ helpon$l
 TEQ R0,#'C'
 ADREQ R7,Helpcom
 BEQ helpon$l
 TEQ R0,#'V'
 ADREQ R7,Helpvar
 BEQ helpon$l
 TEQ R0,#'M'
 BEQ mode$l
 TEQ R0,#'D'
 TEQNE R0,#'Z'
 BNE end$l			; not recognised
 MOV R11,R0
 MOV R0,#21
 BL minibuffer_writec		; avoid problems if help file not found
 FNLDR R1,opt_flags		; save old flags
 ORR R0,R1,#(1<<4)+(1<<8)	; file fixed as read only
 FNSTR R0,opt_flags
 TEQ R11,#'Z'
 ADREQ R0,help$l
 ADRNE R0,docs$l
 SWI XWimp_StartTask
 FNSTR R1,opt_flags
end$l				; exit closing the minibuffer
 MOVVC R0,#0			; close minibuffer
 FNRTS
mode$l				; help on mode
 FNLDR R1,wimp_block
 ADR R2,m$l
 BL strcpy
 TEQ R8,#0
 FNLDRB R0,opt_format,EQ
 LDRNEB R0,[R8,#w_format]
 BL mode_name
 BLVC strcopy
 MOVVC R2,#-1			; not a command
 FNLDR R0,wimp_block,VC
 MOVVC R3,#0
 BLVC find_command_help
 BLVC display_help
 B end$l
helpon$l
 MOV R0,#0
 MOV R1,#1
 MOV R2,#0
 BL process_command		; do the help command
 MOVVC R0,#1			; leave minibuffer open
 FNRTS
key$l
 MOV R0,R14
 BL minibuffer_writec		; write that value
 MOVVC R0,#&1D			; finish
 FNRTS
p$l
 ADR R0,s$l
 BL minibuffer_prompt_token
 FNRTS
s$l	= "zap_p_help",0
m$l	= "mode_",0
help$l	= "/",|zapdir$|,".!Help",0
docs$l	= "Filer_OpenDir ZapResources:Docs",0
	ALIGN

 LOCAL

 DCD 7+(3<<3)+(1<<6)
Helpcom
 FNJSR
 TEQ R2,#6
 BEQ p$l
 MOV R2,#0
 BL find_command_help
 BLVC display_help
 FNRTS
p$l
 ADR R0,s$l
 BL minibuffer_prompt_token
 FNRTS
s$l FNS ("zap_p_helpcom")

	LOCAL

	DCD 7+(3<<3)+(1<<6)
Helpfn
	FNJSR
	TEQ	R2,#6
	BEQ	p$l
	MOV	R2,#0
	ORR	R0,R0,#1<<31
	BL	find_command_help
	BLVC	display_help
	FNRTS
p$l	ADR	R0,s$l
	BL	minibuffer_prompt_token
	FNRTS
s$l	FNS	("zap_p_helpfn")

 LOCAL

 DCD 7+(3:SHL:3)+(1:SHL:6)
Helpvar
 FNJSR
 TEQ R2,#6
 BEQ p$l
 MOV R2,#0
 ORR R0,R0,#1:SHL:30
 BL find_command_help
 BLVC display_help
 FNRTS
p$l
 ADR R0,s$l
 BL minibuffer_prompt_token
 FNRTS
s$l
 FNS ("zap_p_helpvar")

 LOCAL

 DCD 7+(3<<3)+(1<<6)+(1<<8)
Helpkey
 FNJSR
 TEQ R2,#6
 BEQ p$l
 SUB R1,R2,#&8000
 CMP R1,#&200
 BCC prekey$l			; user has pressed a key
 BL minibuffer_eval		; read num in R0
 FNRTS VS
 FNRTS CS
 MOV R1,R0
 LDRB R2,[R8,#w_basemap]
 LDRB R0,[R8,#w_helpmap]	; use 'current' keymap
 STRB R2,[R8,#w_helpmap]
 BL find_key_entry		; R0=entry address (don't validate)
 FNRTS VS			; only want the command name
 CMP R0,#0
 FNRTS LE
 MOV R4,R0			; save address of key entry
 LDR R0,[R4]			; key command
 CMP R0,#0
 FNRTS LE			; no command given
 TST R0,#1
 BICNE R0,R0,#3			; command name
 MOVNE R2,#0			; command flags (assume none)
 BNE do$l
 LDR R1,[R4,#4]			; command data
 LDR R2,[R0,#-4]		; command flags
 BL find_command_fromkey	; R0=command string
 FNRTS VS
 CMP R0,#0
 FNRTS LE
do$l
 BL find_command_help
 LDR R3,[R4,#8]
 BLVC display_help
 FNRTS
prekey$l
 MOV R0,R1			; number
 FNLDR R1,wimp_kbdbuf
 MOV R2,#16
 SWI XOS_ConvertHex4
 MOVVC R14,#'&'
 STRVCB R14,[R0]		; put & at start
 BLVC minibuffer_write
 MOVVC R0,#&1D			; return operation finished
 FNRTS
p$l
 ADR R0,s$l
 BL minibuffer_prompt_token
 FNRTS
s$l FNS ("zap_p_helpkey")

 LOCAL

 DCD 1+(1<<28)
Iconise
 FNJSR
 FNLDR R1,wimp_block
 LDR R0,[R8,#w_handle]		; window handle
 STR R0,[R1,#20]
 FNLDR R0,wimp_task		; Zap's task handle
 STR R0,[R1,#24]
 LDR R0,[R9,#f_name]
 BL find_leaf_name
 MOV R2,R0
 ADD R1,R1,#28
 BL strcopy
 LDR R0,iconise$l
 FNLDR R1,wimp_block
 MOV R2,#0			; broadcast
 MOV R3,#48			; length
 BL message_send
 FNRTS
iconise$l DCD &400CA

 DCD 0
Indirect
 FNJSR
 LDR R0,[R8,#w_format]
 ANDS R0,R0,#&FF
 TEQ R0,#2			; word
 TEQNE R0,#4			; code
 FNRTS NE
 LDR R0,[R10,#c_off]
 BIC R0,R0,#3			; word align
 BL cln_readw			; get address in r0
 LDR R1,[R8,#w_addr]
 SUB R0,R0,R1
 BL goto_offset
 FNRTS

 DCD 7+(1<<15)
Infinitewrap
 FNJSR ; why - "R3"
 MOV R0,#0			; clear zilch
 MOV R1,#bit_infiniteww		; toggle separating colons
 BL new_info_set
 CMP R2,#15
 BEQ ww_new_wind_format_set
 CMP R8,#0			; ib menu...?
 FNRTS EQ
 LDR R0,[R8,#w_format]
 TST R0,#bit_windowwrap
 FNRTS EQ

 LDR R0,[R8,#w_width]
 BL setwidth_as_a_service
 BLVC reflect_window_height
 BLVC Updatewindow		; redraw screen
 FNRTS

reflect_window_height
 FNJSR
 BL update_wind_state
 BLVC find_work_height		; find new height
 STRVC R0,[R8,#w_height]	; save work height
 BLVC new_extent		; call Wimp_SetExtent & modify open coords
 BLVC reflect_carets		; reposition caret if in this window
 BLVC change_extent		; do first or constrict will move them
 MOVVC R1,R8
 BLVC reopen_window		; open window in new position
 FNRTS

 LOCAL

 DCD (3<<3)+(1<<6)		; string input
Insertblock
 TEQ R2,#6
 BEQ is2
 FNJSR
 PUSH "R0-R12"
 BL Startop
 PULL "R0-R12"
 BL Insert
 BL Stopop
 FNRTS

 DCD (3<<3)+(1<<6)		; string input
Insert
 FNJSR
 TEQ R2,#6
 BEQ is2
 MOV R1,R0
is1
 LDRB R14,[R1],#1
 TEQ R14,#0
 BNE is1
 SUB R1,R1,#1
 SUB R1,R1,R0
 BL Char			; insert the chars
 FNRTS
is2
 ADR R0,is_s0
 BL minibuffer_prompt_token
 FNRTS
is_s0
 FNS ("zap_p_insert")

 DCD (3<<3)+(1<<6)		; string input
Insertblockgs
 TEQ R2,#6
 BEQ is3
 FNJSR
 PUSH "R0-R12"
 BL Startop
 PULL "R0-R12"
 BL Insertgs
 BL Stopop
 FNRTS

 LOCAL

 DCD (3<<3)+(1<<6)
Insertgs
 FNJSR
 TEQ R2,#6
 BEQ is3
 FNLDR R1,wimp_kbdbuf
 MOV R2,#kbdbuf_size*4
 SWI XOS_GSTrans
 FNLDR R0,wimp_kbdbuf,VC	; address of text
 MOVVC R1,R2			; length
 BLVC Char
 FNRTS
is3
 ADR R0,is_s1
 BL minibuffer_prompt_token
 FNRTS
is_s1
 FNS ("zap_p_insertgs")

 LOCAL

 DCD 0+(3<<3)+(1<<6)+(1<<10)
Insertdate
 CMP R2,#6
 BEQ prompt$l
 ;FNJSR
 ;FNLDR R0,wimp_dateformat
 B insert_date
 ;FNRTS
prompt$l
 FNLDR R0,wimp_dateformat
 MOV PC,R14

 LOCAL

 DCD 0+(3<<3)+(1<<6)+(1<<10)
Inserttime
 CMP R2,#6
 BEQ prompt$l
 ;FNJSR
 ; FNLDR R0,wimp_timeformat
 B insert_date
 ;FNRTS
prompt$l
 FNLDR R0,wimp_timeformat
 MOV PC,R14

 LOCAL

 DCD (3<<3)+(1<<6)+(1<<10)+(1<<15)
Indent
 CMP R2,#6
 BEQ prompt$l
 FNJSR
 MOV R6,R0
 BL shade_no_sel
 FNRTS CS
 MOV R0,R6
 BL indent_selection
 FNRTS
prompt$l
 FNLDR R0,wimp_indentstring
 MOV PC,R14

 LOCAL

 DCD (3<<3)+(1<<6)+(1<<8)+(1<<17)
Indentby
 FNJSR
 TEQ R2,#6
 BEQ p$l
 CMP R2,#&8000
 BCS q$l
 TEQ R2,#17
 BEQ m$l
 MOV R5,R0			; save string
 BL str_len
 ADD R1,R0,#1
 FNLDR R0,wimp_indentstring
 BL heap_ensure
; FNRTS VS
 FNSTR R0,wimp_indentstring,VC
 MOVVC R1,R0
 MOVVC R2,R5
 BLVC strcopy			; copy to current indent string
 FNLDR R0,wimp_indentstring,VC
 BLVC indent_selection
 FNRTS
p$l
 ADR R0,s$l
 BL minibuffer_prompt_token
 FNRTS
q$l
 SUB R14,R2,#&8100
 TEQ R14,#&8A
 TEQNE R14,#&9A
 TEQNE R14,#&AA
 SUBNE R0,R2,#&8000
 FNRTS NE
 ADR R0,clearstr$l
 BL minibuffer_write
; FNcall Zap_MiniWrite,R11
 FNLDR R0,wimp_indentstring
 BL minibuffer_write
; FNcall Zap_MiniWrite,R11
 MOV R0,#-1
 FNRTS
m$l
 TEQ R0,#0
 ADREQ R0,s$l			; menu title
 BLEQ lookup_token_R0
 TEQ R0,#1
 FNLDR R0,wimp_indentstring,EQ
 TEQ R0,#2
 MOVEQ R0,#32
 FNRTS

s$l = "zap_m_indentby",0
clearstr$l = 21,0

 ALIGN

 LOCAL

 DCD 0
Joinline
 MOV R11,#e_joinline
 B call_mode

 DCD 2<<3 :OR: 1<<23 :OR: 1<<28
Keymap
 TEQ R2,#23
 LDREQB R0,[R8,#w_currentmap]
 MOVEQ R1,#1
 MOVEQ PC,R14
 STMFD R13!,{R14}
 SUB R1,R1,#1
 LDR R0,[R0,R1,LSL#2]		; last word in list
 MOV R1,R0
 BL find_key_table
 BMI bad_keymap_jump
 STRPLB R1,[R8,#w_currentmap]
 STRPLB R1,[R8,#w_helpmap]
 FNLDR R0,key_last
 BL get_key_string
 BLVC minibuffer_write
 ADRVC R0,ke_s0
 BLVC minibuffer_write
 LDMFD R13!,{PC}
ke_s0
 FNS (" - ")

	&	3<<3 :OR: 1<<6 :OR: 1<<23 :OR: 1<<28
Keymapn
	TEQ	R2,#23
	LDREQB	R0,[R8,#w_currentmap]
	STMFD	R13!,{R14}
	BEQ	keymap_name
	TEQ	R2,#6
	BEQ	prompt$l
	BL	find_key_table_by_name
	TEQ	R0,#0
	STRPLB	R0,[R8,#w_currentmap]
	STRPLB	R0,[R8,#w_helpmap]
	LDMPLFD	R13!,{PC}
bad_keymap_jump
	LDMFD	R13!,{R14}
	B	bad_keymap
prompt$l
	ADR	R0,s$l
	LDMFD	R13!,{R14}
	B	minibuffer_prompt_token
s$l	FNS	("zap_p_keymap")

 DCD (1<<15)
Keepregion
 FNJSR
 BL shade_no_sel		; R1=off R2=len
 FNRTS CS
 BL read_selection		; R3=heap block
 BLVC clear_selection
 ORRVC R0,R3,#1<<31		; block pointer
 MOVVC R1,R2			; length
 BLVC add_yank_region
 BLVC default_caret
 BLVC plot_caret
 FNRTS

 DCD 1<<12
Lastcylinder
 FNJSR
 MOV R0,R1
 MOV R1,#0
 MOV R2,#0
 MVN R3,#0
 BL new_read_disc
 FNRTS

 DCD 1<<12
Lastsector
 MOV R0,R1
 MVN R1,#0
 MOV R2,#0
 MOV R3,#0
 B new_read_disc

 DCD 1<<12
Lasttrack
 MOV R0,R1
 MOV R1,#0
 MVN R2,#0
 MOV R3,#0
 B new_read_disc

 DCD 0
Learn
 FNJSR
 FNLDR R0,key_flags
 TST R0,#4
 EOR R0,R0,#4			; toggle mode
 FNSTR R0,key_flags
 BNE le1			; switch off learn mode
 MOV R0,#0
 FNSTR R0,key_llen		; reset buffer
 FNRTS
le1
 FNRTS

 DCD 7 + (1<<15)
Listfns
 CMP R2,#15
 BEQ returnifonibmenu
 MOV R11,#e_listfns
 B call_mode

 LOCAL

;  DCD 7 + (1<<15)
; Listfiles
;  FNJSR
;  MOV R0,#0
;  BL create_throwback
;  ;FNLDR R1,wimp_data
;  ;ADD R2,R0,#1
;  ;MOV R0,#0
;  MOV R6,R8
;  MOV R7,R9
;  ADR R10,allwindlistfile
;  BL do_allwindow
;  FNRTS
;
; allwindlistfile
;  CMP R7,R9
;  MOVEQ PC,R14
;  FNJSR "R1-R9"
;
;  BL get_file_off
;  MOV R4,R0 ; file offset
;  ;FNLDR R1,wimp_data
;  ;LDR R0,[R1]
;  ;ADD R2,R0,#1
;  ;STR R2,[R1]
;  MOV R0,#0 ; (1 << 31)
;  LDR R1,[R9,#f_name]
;  MOV R8,R6
;  MOV R9,R7
;  ADR R2,loadedfiles_str
;  ;MOV R2,#0
;  ADR R3,loadedfiles_str
;  MOV R5,#(1 + 2)
;  ORR R5,R5,#0 ; (1 << 16) ; flags...
;  ADR R6,loadedfiles_str1
;  ADR R7,loadedfiles_str2
;  BL add_throwback_entry
;  FNRTS
;
; nullstrs
;  = 0
; loadedfiles_str
;  = "File: ",0
; loadedfiles_str1
;  = "Triple-click to bring to front...",0
; loadedfiles_str2
;  = 10,"When modified...",0
;
;  ALIGN

 DCD (1<<12)
Left
 MVN R2,#0
 MOV R3,#0
 B move_cursor

 DCD 7+(1<<15)
Linewrap
 FNJSR "R2"
 TEQ R2,#15
 BEQ linewrap_justtest
 FNRTS EQ

 ; ;MOV R0,#1 << 27		; clear softwrap
 ; ;MOV R1,#0			; toggle nothing
 ; ;TEQ R8,#0
 ; ;BEQ new_opt_format
 ; ;FNJSR
 ; LDR R14,[R8,#w_format]
 ; BIC R14,R14,R0
 ; ;EOR R14,R14,R1
 ; STR R14,[R8,#w_format]
 ; ;BL new_title
 ; ;LDR R0,[R8,#w_format]
 ; ;BIC R0,R0,#1 << 27
 ; ;STR R0,[R8,#w_format]
 MOV R0,#1 << 27		; clear softwrap
 MOV R1,#0			; toggle nothing
 BL new_wind_format
 TEQ R8,#0
 BLNE blat_cache_of_this_window
 TEQ R8,#0
 BLNE Updatewindow		; redraw screen
linewrap_justtest
 MOV R0,#1 << 13		; clear wordwrap
 MOV R1,#1 << 26		; toggle linewrap
 BL new_wind_flags_set		; was flags?????
 FNRTS

 DCD 0+(1<<28)
Lastmark
 FNJSR
 BL get_cursor_caret
 BL previous_mark
 FNRTS

 DCD 0
Lastmatch
 FNJSR
 BL default_search_flags	; set up R5
 BL get_cursor_caret
 FNLDR R0,fnd_string
 MOV R1,#0			; cursor
 LDR R3,[R10,#c_off]		; start offset
 MOV R4,#-1			; backward
 BL search_data
 FNRTS

 DCD 7+(1<<15)
Lineedit
 MOV R0,#0
 MOV R1,#1<<14
 B new_wind_format_set

 DCD 7+(2<<3)+(1<<15)
Linenos
 LDR R3,[R0]			; 0=none 1=log 2=phy 3=addresses
 MOV R0,#&100			; none mask
 MOV R1,#0			; none eor
 TEQ R3,#1
 MOVEQ R0,#&B00
 MOVEQ R1,#&300
 TEQ R3,#2
 MOVEQ R0,#&B00
 MOVEQ R1,#&B00
 TEQ R3,#3
 MOVEQ R0,#&300
 MOVEQ R1,#&100
 B new_format_select

 LOCAL

 DCD 7 + (1<<15)
Lineselect
 FNJSR
 MOV R0,#0
 MOV R1,#(1<<6)
 BL new_info_set
 FNRTS

 LOCAL

 DCD 7+(2<<3)+(1<<17)
Linespacing
 TEQ R2,#0
 BNE a$l
 LDR R5,[R0]
 CMP R5,#0
 MOVLE R5,#0
a$l
 TEQ R8,#0
 MOVEQ R3,#opt_linesp
 MOVNE R3,#w_linesp
 ADR R4,s$l
 B new_w_num_checked
s$l FNS ("zap_m_linesep")

 LOCAL

 DCD 7+(3<<3)+(1<<6)
Loadmodule
 FNJSR
 TEQ R2,#6
 BEQ p$l
 ORR R0,R0,#1<<31			; extra * command not given
 BL load_mode_module
 FNRTS
p$l
 ADR R0,s$l
 BL minibuffer_prompt_token
 FNRTS
s$l = "zap_p_loadmodule",0
 ALIGN

 LOCAL

tochangeibmode
 FNJSR "R8"
 MOV R8,#0
 MOV R1,#1		; ???
 MOV R2,#0		; ???
 BL new_mode
 FNRTS

 DCD 1
Makedefault
 FNJSR
 FNLDR R11,opt_format
 LDRB R0,[R8,#w_format]		; the mode whose options we're interested in
 BL tochangeibmode		; change mode from IB first!!!

 ; suspicious code to deal with *other modes.*..!?
;  MOV R1,#0			; start mode
; a$l
;  BL make_default_mode
;  FNRTS VS
;  ADD R1,R1,#1
;  CMP R1,#max_mode
;  BCC a$l

 LDRB R1,[R8,#w_format]		; the mode whose options we're interested in
 BL make_default_mode

 FNLDR R2,opt_flags
 LDR R0,[R8,#w_flags]
 LDR R1,wmask$l
 BIC R2,R2,R1
 AND R0,R0,R1
 ORR R2,R2,R0
 LDR R0,[R9,#f_flags]
 LDR R1,fmask$l
 BIC R1,R1,#&0F			; don't copy the 'Undo' flag for the file...
; BIC R1,R1,#&F8000000		; don't copy DOS / spool / non-standrd attr
 AND R0,R0,R1
 BIC R2,R2,R1
 ORR R2,R2,R0
 BIC R2,R2,#&110		; *not* the read-only flags &c...
 FNSTR R2,opt_flags		; this works

 FNLDR R2,opt_format
 LDR R0,[R8,#w_format]
 LDR R1,wform$l
 AND R0,R0,R1
 BIC R2,R2,R1
 ORR R2,R2,R0
 TST R2,#bit_autosoftwrap
 BICNE R2,R2,#bit_softwrap
 FNSTR R2,opt_format ; this doesn't work...?

 FNLDR R2,opt_info
 ;LDR R2,[R8,#w_info]
 LDR R0,[R8,#w_info]
 LDR R1,winfo$l
 AND R0,R0,R1
 BIC R2,R2,R1
 ORR R2,R2,R0
 FNSTR R2,opt_info ; this doesn't work...?

 LDR R0,[R8,#w_tab]
 FNSTR R0,opt_tab
 LDR R0,[R8,#w_linesp]
 FNSTR R0,opt_linesp ; this works!
 LDR R0,[R8,#w_mwidth]
 FNSTR R0,opt_mwidth
 LDR R0,[R8,#w_tabchar]
 FNSTR R0,opt_tabchar ; this works!
 LDR R0,[R8,#w_addr]			; to avoid code mode problems...?
 FNSTR R0,opt_addr
 LDR R0,[R8,#w_stline]
 FNSTR R0,opt_stline
 LDR R0,[R8,#w_wrapwidth]
 FNSTR R0,opt_wrapwidth ; this works!
 BL copy_back_a_mode_buffer
 AND R0,R11,#&FF
 BL tochangeibmode		; back to how it was before...
 FNRTS

wmask$l DCD wflags_mask
fmask$l DCD fflags_mask
wform$l DCD (wformat_mask:AND:&FFFFFF00)	; don't copy the mode
winfo$l DCD winfo_mask

 LOCAL

;E R8=window to copy from.
;X If mode valid then block copied #

copy_back_a_mode_buffer
 FNJSR "R1-R5,R11"
 LDRB R0,[R8,#w_format]
 ADD R1,R12,#opt_modebase
 ADD R4,R1,R0,LSL #2 ; LDR R4,[R1,R0,LSL#2]	; mode word
 ADD R5,R8,#w_mode0
 ADD R5,R5,R0,LSL #2		; destination mode word address
 BL read_mode			; R1=linked table
 CMP R1,#0
 FNRTS LE			; not valid
 LDR R0,[R1,#e_mode*2]
 TST R0,#1<<10
 LDR R1,[R5]
 STREQ R1,[R4]
 FNRTS EQ			; finished - it was a single word
 ;MOV R1,R5			; source block
 LDR R0,[R4]
 BL heap_free ; hope this works... though it's rubbish code...
 LDR R0,[R1]			; block length
 MOV R3,R0			; save
 BL heap_claim ; what happens to the value this overwrites?
 STRVC R0,[R4]
 MOVVC R2,R0			; ? huh???
 SWIVC XZapRedraw_MoveBytes	; copy ; wrong...
 FNRTS

 LOCAL

 DCD 7+(1<<3)+(1<<17)
Margin
 TEQ R2,#0
 BNE a$l
 LDR R5,[R0]
 CMP R5,#0
 MOVMI R5,#0
a$l
 TEQ R8,#0
 MOVEQ R3,#opt_mwidth
 MOVNE R3,#w_mwidth
 ADR R4,s$l
 B new_w_num_checked
s$l FNS ("zap_m_margin")

	DCD     7 + (2<<3)
Menuopen				; R0 -> menu handle to open
	STMFD	R13!,{R14}		; stack some registers
	LDR	R4,[R0]			; = index
	SUB	R1,R13,#20		; steal some stack space
	SWI	XWimp_GetPointerInfo	; get the pointer state
	LDMVSFD	R13!,{PC}		; exit if we barfed
	MOV	R0,R4			; restore pointer
	LDR	R2,[R13,#-20]		; = mouse X
	LDR	R3,[R13,#-16]		; = mouse Y
	BL	read_menu_handle	; read the menu handle
	BLVC	create_menu		; ... and open it
	LDMFD	R13!,{PC}		; return to caller

 DCD 7+(1<<16)
Minimenu
 FNLDR R0,menu_memory
 LDR R0,[R0,#12]
 MOV PC,R14

 LOCAL

 DCD 7+(2<<3)+(1<<15)
Miscops
 LDR R3,[R0]			; number of the option - don't change this!
 MOV R0,#0			; mask

 CMP R3,#21			; one beyond highest valid op
 ADDLO PC,PC,R3,LSL #3
 MOVS PC,R14

 MOV R1,#flags_AutoDeleteFiles		; 0
  B new_wind_flags_clear
 MOV R1,#flags_SelectionsVanish		; 1
  B new_wind_flags_set
 MOV PC,R14				; 2
  & 0
 B caret$l				; 3
  & 0
 MOV R1,#switch_CheckDate		; 4
  B new_switches_set
 MOV R1,#switch_ClearSearchWindow	; 5
  B new_switches_set
 MOV R1,#switch_ConfineCursor		; 6
  B new_switches_set
 MOV R1,#switch_TrapCRLF		; 7
  B new_switches_set
 MOV R1,#switch_Autoload_flashcar	; 8
  B new_switches_set
 MOV R1,#switch_Autoload_lineeditor	; 9
  B new_switches_set
 MOV R1,#switch_Autoload_disassembler	;10
  B new_switches_set
 MOV R1,#switch_Autoload_assembler	;11
  B new_switches_set
 MOV R1,#switch_Autoload_hidepointer	;12
  B new_switches_set
 MOV R1,#switch_TolerateBrokenMessages	;13
  B new_switches_set
 MOV R1,#switch_InhibitBeeping		;14
  B new_switches_set
 MOV R1,#switch_SuppressAntialiasedDSA	;15
  B new_switches_set
 MOV R1,#switch_Autoload_iclear		;16
  B new_switches_set
 MOV R1,#switch_Autoload_keyboardextend	;17
  B new_switches_set
 B hscroll$l				;18
  & 0
 MOV R1,#switch_ExecuteStartCom		;19
  B new_switches_set
 MOV R1,#switch_MinibufferAutoWidth	;20
  B new_switches_set

caret$l
 FNJSR
 MOV R0,#2
 MOV R1,#1
 BL new_switches_set
 TEQ R2,#0
 FNRTS NE
 BL init_flash
 FNRTS VS
 BL get_cursor_caret
 BLCC set_caret
 FNRTS

hscroll$l
	FNJSR
	MOV	R0,#0
	MOV	R1,#1<<29
	BL	new_switches_set
	TEQ	R2,#0
	ADREQ	R10,hscroll_op$l
	BLEQ	do_allwindow
	FNRTS
hscroll_op$l
	MOV	R1,R8
	B	open_window

; DCD 7+(2<<3)+(1<<15)
;Minifont
; STMFD R13!,{R14}
; MOV R1,#1<<27
; BL new_switches_set
; TEQ R2,#0
; LDMNEFD R13!,{PC}
; BL get_MiniBuf
; LDR R0,[R7,#8]
; CMP R0,#0
; BLPL minibuffer_update
; LDMFD R13!,{PC}

;local_spacecnt
; DCD 0

tempmoveselr8
 DCD 0

tempmoveselr9
 DCD 0

 DCD (1<<15)
Movesel
 FNJSR
 MOV R6,R9			; save the input caret file
 BL shade_no_sel
 FNRTS CS			; R1=off R2=len R8/R9=wind with sel
 STR R8,tempmoveselr8
 STR R9,tempmoveselr9
 BL default_caret
 LDR R7,[R10,#c_off]		; save offset of input caret
 BL read_selection		; sets up R3...
 FNRTS VS

 PUSH "R1,R2"
 MOV R4,R9			; save file with selection
 TEQ R6,R9			; are we operating on same file
 BLEQ start_operation		; concatenate ops if so ; EQ
 ;BL setupmoveseloff
 BL get_input_caret		; find input caret window
 BL getnoofspaces

 MOV R5,R1			; r5 = noofspaces to be inserted.
 PULL "R1,R2"

 LDR R8,tempmoveselr8
 LDR R9,tempmoveselr9

  ; er, operate on some window or another...
  LDR R10,[R8,#w_format]
  BIC R14,R10,#(1 << 15)	; no non-standard
  STR R14,[R8,#w_format]

 LDR R11,[R9,#f_flags]
 ORR R14,R11,#(1 << 14)		; unlink cursor (o/wise moves input caret)
 STR R14,[R9,#f_flags]
 MOV R0,#&52			; delete selected block (reslect if undo)
 BL execute_command		; delete the selection data
 ORR R11,R11,#(1 << 3)		; it's been altered anyway...!!!
 STR R11,[R9,#f_flags]		; restore the flags

  STR R10,[R8,#w_format]

 BVS in61			;
 TEQ R6,R9			; is it the same file
 BNE in27			; different file
 BL get_cursor_caret		; get R8/R9/R10 of where to insert data
 CMP R7,R1			; was R7 >= start of deleted block
 BCC in27
 SUB R7,R7,R2			; reduce offset
 CMP R7,R1			; ? TT still OK ?
 MOVLT R7,R1			; and clip below
in27
 BL get_cursor_caret		; get R8/R9/R10 of where to insert data
 BVS in61			; error...

  ; er, operate on some window or another...
  LDR R11,[R8,#w_format]
  BIC R14,R11,#(1 << 15)	; no non-standard
  STR R14,[R8,#w_format]

 BL start_operation		; concatenate ops if so ; EQ
 BVS prein61			; error...
 ;CMP R1,R4
 ;SUBLE R4,R4,R2
 ;STR R4,[R10,#c_off]
 ;STR R5,[R10,#c_col]
 ;LDR R1,local_spacecnt
 ;CMP R1,#0
 MOVS R1,R5
 MOVLE R0,#0

 BLGT actuallyinsertthemspaces	; expects R10, too...
 ADD R7,R7,R0			; increment offset
 MOV R0,#&51			; insert block ; 51
 MOVS R1,R7			; saved offset

; BMI problem$l
; LDR R14,[R9,#f_len]
; CMP R1,R14
; BGT problem$l			; this is debugging code...

 BL execute_command		; insert the new data ; (PL)
prein61
 BL stop_operation

  STR R11,[R8,#w_format]

in61
 TEQ R4,R9
 BLEQ stop_operation
; BLVC new_title		; not needed...
 MOV R0,R3
 BL heap_free			; free the selection data
 FNRTS

;problem$l			; this is debugging code...
; SWI &107
; B prein61

; setupmoveselcol
;  FNJSR "R0,R1,R8-R10"
;  BL get_input_caret		; get R8/R9 of where to insert data
;  LDR R4,[R10,#c_off]
;  LDR R5,[R10,#c_col]
;  FNRTS

;  DCD (1<<15)
; Movesel
;  FNJSR
;  MOV R6,R9			; save the input caret file
;  BL shade_no_sel
;  FNRTS CS			; R1=off R2=len R8/R9=wind with sel
;  LDR R7,[R10,#c_off]		; save offset of input caret
;  BL read_selection
;  FNRTS VS			; read selection to heap block R3
;  BL clear_selection
;  FNRTS VS			; remove the selection
;  TEQ R6,R9			; are we operating on same file
;  BLEQ start_operation
;  FNRTS VS			; concatenate ops if so
;  MOV R0,#&12			; delete block
;  BL execute_command		; delete the selection data
;  BVS in61			; (moves input caret)
;  MOV R6,R9			; save file with selection
;  BL get_input_caret		; get R8/R9 of where to insert data
;  TEQ R9,R6			; is it the same file
;  BNE in27			; different file
;  CMP R7,R1			; was R7 >= start of deleted block
;  BCC in27
;  SUB R7,R7,R2			; reduce offset
;  CMP R7,R1
;  MOVLT R7,R1			; and clip below
; in27
;  MOV R0,#&11			; insert block
;  MOV R1,R7			; saved offset
;  BL execute_command		; insert the new data
;  BVS in61
;  TEQ R6,R9
;  BLEQ stop_operation
;  FNRTS VS
;  MOV R0,R3
;  BL heap_free			; free the selection data
;  FNRTS
; in61
;  BL stop_operation
;  FNRTS

;  DCD 4<<3
; Multicommand
;  B execute_strokes

 LOCAL

; want to have current mode mirrored first :-/
 DCD 7+(2<<3)+(1<<15)+(1<<18)+(1<<19)+(1<<20)+(1<<23)+(1<<28)
Mode
 TEQ R2,#23
 BEQ Mode_fn
 FNJSR
 LDR R0,[R0]			; mode number
 CMP R0,#255
 BLEQ to_get_mode$l
 TEQ R2,#18
 BEQ a$l
 TEQ R2,#20
 BEQ b$l
 TEQ R2,#19
 BEQ c$l
 TEQ R2,#0
 BEQ m$l			; set main/options mode
 TEQ R8,#0
 FNLDRB R1,opt_format,EQ
 LDRNEB R1,[R8,#w_format]	; mode number
 TEQ R0,R1
 MOVEQ R0,#1
 MOVNE R0,#0
 FNRTS
m$l
 TEQ R8,#0
 FNLDRB R1,opt_format,EQ
 LDRNEB R1,[R8,#w_format]	; mode number
 TEQ R0,R1
 BLNE new_mode			; only change if to a different mode
 FNRTS
a$l				; find replacement text (mode name)
 BL read_mode
 CMP R1,#0
 MOVLE R0,#0			; mode doesn't exist
; FNRTS LE
 LDRGT R0,[R1,#2*e_title]
 FNRTS
b$l
 BL read_mode
 CMP R1,#0
 MOVLE R0,#1			; remove the entry as the mode doesn't exist
 MOVGT R0,#0
 FNRTS
c$l				; handle the submenu
 BL read_mode			; get the mode table
 LDR R0,[R1,#2*e_menu]		; pointer to the external menu
 FNRTS				; (or 0 if none)
to_get_mode$l
 CMP R2,#15
 MOVEQ R0,#0
 FNRTS EQ
; B get_mode_number
; fall through...

;E R8
;X R0 = relevant mode number.
get_mode_number
 TEQ R8,#0
 FNLDRB R0,opt_format,EQ
 LDRNEB R0,[R8,#w_format]
 MOV PC,R14

 LOCAL

 DCD 7+(3<<3)+(1<<6)+(1<<23)+(1<<28)
Moden
 TEQ R2,#23
 BEQ Moden_fn
 FNJSR
 TEQ R2,#6
 BEQ p$l
 BL find_mode_number		; find mode + load module
 FNRTS VS
 CMP R0,#0
 FNRTS LT			; no mode found
 TEQ R8,#0
 FNLDRB R1,opt_format,EQ
 LDRNEB R1,[R8,#w_format]	; mode number
 TEQ R0,R1
 BLNE new_mode			; only change if to different mode
 FNRTS
p$l
 ADR R0,s$l
 BL minibuffer_prompt_token
 FNRTS
s$l
 = "zap_p_moden",0
 ALIGN

 DCD 7
Null
 MOV PC,R14

 DCD (7)+(3<<3)+(1<<6)+(1<<10)+(1<<27)+(1<<28)
 ; String is of the format:
 ; [<mode name>] [<filetype>]
Newfile
 FNJSR

 CMP R2,#6			; kill off the minibuffer
 ADREQ R0,noparam$l
 FNRTS EQ

 ; Okay, so time to do it.
 PUSH "R0"

 ; Defaults
 CMP R9,#0
 MOVEQ R6,#&1000
 SUBEQ R6,R6,#1			; &FFF
 BEQ donetypedefault$l

 LDR R0,[R9,#f_load]
 BL calc_ftype			; \X R0=filetype
 MOVCC R6,#&1000		; &1000 - untyped
 MOVCS R6,R0			; save

donetypedefault$l
 CMP R8,#0
 MOVEQ R7,#-1			; Calculate from filetype if not specified
 LDRNEB R7,[R8,#w_format]

 ; First try to convert the start of the
 ; string into a mode number. Then try to
 ; read the rest as a decimal number.
 ; Plonk these in R7, R6 respectively, but
 ; leave those registers alone otherwise (so
 ; that the defaults remain).

 ; Now we've got the mode and filetype
 ; \E R6=filetype, R7=mode number
 PULL "R0"			; string pointer
 LDRB R1,[R0]
 CMP R1,#32
 BLT doit$l			; no overrides

 MOV R1,R0			; save
 BL find_mode_number		; \E R0=>mode name string
 CMP R0,#-1
 MOVNE R7,R0			; done mode number
 BEQ readftype$l		; don't skip: there wasn't a mode

skip$l
 LDRB R0,[R1],#1
 CMP R0,#32
 BLT doit$l			; terminator
 BGT skip$l			; skip non spaces

skip2$l
 LDRB R0,[R1],#1
 CMP R0,#32
 BEQ skip2$l			; skip spaces
 SUB R1,R1,#1			; back to start of next bit

 ; \E R1 => potential filetype string
readftype$l
 MOV R2,#&1000
 MOV R0,#(10 + 1:SHL:29)	; base 10 default, &1000 max (= untyped)
 SWI XOS_ReadUnsigned
 BVS doit$l			; don't override - error
 MOV R6,R2			; override filetype

doit$l
 MOV R0,R6			; filetype
 BL create_empty		; \X R8/R9
 BLVC create_window_caret
 FNRTS VS
 MOVS R0,R7
 BLGE new_mode			; \E R0=mode, R8/R9
 FNRTS
noparam$l
 = 0
 ALIGN

 DCD 1<<12
Nextcylinder
 MOV R0,R1
 MOV R1,#0
 MOV R2,#0
 MOV R3,#1
 B new_read_disc

 DCD 1<<12
Nextsector
 MOV R0,R1
 MOV R1,#1
 MOV R2,#0
 MOV R3,#0
 B new_read_disc

 DCD 1<<12
Nexttrack
 MOV R0,R1
 MOV R1,#0
 MOV R2,#1
 MOV R3,#0
 B new_read_disc

 LOCAL

 DCD 0
Nextmatch
 FNJSR
 BL default_search_flags	; set up R5
 BLVC get_cursor_caret
 FNRTS CS
 FNLDR R0,fnd_string
 MOV R1,#0			; to cursor
 LDR R3,[R10,#c_off]		; start offset
 MOV R4,#1			; forward
 BL search_data
 FNRTS

 LOCAL

 DCD 7+(2<<3)+(1<<15)
Newtype
 FNJSR
 LDR R5,[R0]			; file type
 TEQ R8,#0
 BNE a$l
 FNLDR R14,wimp_flagbits	; is it from savesel...?
 TST R14,#1			; *very* temporary
 BNE sel$l			; no; cos don't work.
 TEQ R2,#0
 MOVNE R0,#0
 FNRTS NE
 MOV R0,R5
 BL create_empty
 BLVC create_window_caret
 FNRTS

sel$l
 PUSH "R2"
 BL get_selection		; just to set up r8/R9 properly :(
 MOV R8,#-1
 PULL "R2"
 FNRTS CS
a$l				; change type of already existing file
 TEQ R2,#15
 BEQ b$l			; work out tick state
 LDR R2,[R9,#f_load]
 AND R2,R2,#&000000FF		; save top bit of date
 ORR R2,R2,#&FF000000
 ORR R2,R2,#&00F00000
 ORR R2,R2,R5,LSL#8
 ;FNLDR R0,wimp_flagbits	; is it from savesel...?
 ;TST R0,#1			; *very* temporary
 STR R2,[R9,#f_load]		; new file type
 ;SWI &107
 ;FNRTS
 ;BLNE updatefbits
 BL update_all_save_boxes	; <- this line?

 ; FNLDR R14,wimp_flagbits	; is it from savesel...?
 ; TST R14,#1			; *very* temporary
 ; BLEQ get_SaveBox
 ; FNLDR R14,wimp_flagbits	; is it from savesel...?
 ; TST R14,#1			; *very* temporary
 ; BLNE get_SaveSelBox
 ; MOV R7,R1
 ; LDR R0,[R7,#8]			; window handle
 ; MOV R5,#&FF
 ; CMP R0,#0
 ; FNRTS MI
 ; ;FNRTS
 ; BL leaf_update			; was BLPL - dunno what's wrong with this...
 ; PUSH "R6,R7"
 ; LDR R6,[R7]			; window data
 ; BL conv_index_offs
 ; ;FNRTS VS
 ; FNLDR R1,wimp_block
 ; LDR R0,[R7,#8]			; window handle
 ; STR R0,[R1]
 ; BL redraw_request
 ; PULL "R6,R7"
 FNRTS

;updatefbits
; FNJSR
; ORR R0,R0,R2,LSL#4
; FNSTR R0,wimp_flagbits
; FNRTS

b$l
 LDR R0,[R9,#f_load]
 BL calc_ftype
 MOVCC R0,#0
 FNRTS CC			; file wasn't typed
 TEQ R0,R5
 MOVEQ R0,#1
 MOVNE R0,#0
 FNRTS

 LOCAL

 DCD 7+(1<<28)
Newview
 FNJSR
 BL new_view			; may be called from menu with cursor
 FNRTS VS			; not set up
 TEQ R8,#0
 TEQNE R10,#0
 BEQ ne22
 LDR R0,[R10,#c_off]
 BL put_caret
 FNRTS
ne22
 MOV R0,#0
 BL put_caret
 FNRTS

 LOCAL

 DCD 0+(1<<28)
Nextmark
 FNJSR
 BL get_cursor_caret
 BL next_mark
 FNRTS

 LOCAL

 DCD 7+(1<<15)
Nonstandard
 MOV R0,#0
 MOV R1,#1<<15
 B new_wind_format_set

 LOCAL

; DCD 7+(1<<15)
;Nosubstyles
; MOV R0,#0		; clear zilch
; MOV R1,#1<<4		; toggle separating colons
; B new_info_set
;
; LOCAL

 DCD 7+(3<<3)+(1<<6)+(1<<14)+(1<<9)+(1<<28)	; tabs for filenames
Oscli
 MOV R3,#1
 B os_cli

 LOCAL

 DCD (3<<3)+(1<<6)+(1<<10)+(1<<15)
Outdent
 CMP R2,#6
 BEQ prompt$l
 FNJSR
 MOV R6,R0
 BL shade_no_sel
 FNRTS CS
 ORR R0,R6,#1<<31
 BL indent_selection
 FNRTS
prompt$l
 FNLDR R0,wimp_indentstring
 MOV PC,R14

 LOCAL

 DCD 7
Openprinter
 FNJSR
 ADR R0,op_s1
 SWI XOS_CLI
 FNRTS
op_s1
 FNS ("Filer_OpenDir Printer:$")

 LOCAL

 DCD 0
Paste
 B paste_command

 LOCAL

 DCD 0
PasteGC
 B pastegc_command

 LOCAL

 DCD 1 ; was 3 and 7, but this /may/ have been a bad idea...?
 ; Indeed save_text uses r8,r9 UNCHECKED. Get it right!
Quicksave
 B save_text

 LOCAL

 DCD 0+(1<<28)
Quote
 FNJSR
 FNLDR R0,key_flags
 ORR R0,R0,#1<<3		; set quote flag
 FNSTR R0,key_flags
 ADR R0,qu_s0
 BL minibuffer_write_token
 FNRTS
qu_s0
 FNS ("zap_m_quote")

 LOCAL

 DCD (1<<12)
Return
 FNJSR
 BL default_caret		; Cancel copy mode; cause caret blks to change
 BLVC get_input_caret		; get new input caret block
 BL get_input_caret		; get new input caret block
 FNRTS VS
 FNRTS CS			; none
 MOV R0,#0
 MOV R11,#e_return
 BL call_mode			; do whatever the mode wants
 ADRVC R0,(Quote - 4)		; ptrtotfs$l
 MOVVC R5,#1			; possible bug...
 BLVC tellzapspell
 FNRTS

 LOCAL

 DCD 7+(1<<3)+(1<<17)+(1<<23)
Returnchar
 TEQ R2,#23
 BEQ Returnchar_fn
 TEQ R2,#0
 BNE a$l
 LDRB R5,[R0]
 ORR R5,R5,R5,LSL#8
 ORR R5,R5,R5,LSL#16		; create tab mask
a$l
 TEQ R8,#0
 MOVEQ R3,#opt_cr
 MOVNE R3,#w_cr
 ADR R4,s$l
 B new_w_num_checked
s$l FNS ("zap_m_retchr")

 DCD 0
Returnnoindent
 FNJSR
 BL default_caret		; Cancel copy mode; cause caret blks to change
 BLVC get_input_caret		; get new input caret block
 FNRTS VS
 FNRTS CS			; none
 LDR R5,[R8,#w_format]
 BIC R0,R5,#1<<16		; switch off auto indent
 STR R0,[R8,#w_format]
 AND R5,R5,#1<<16		; save the current state
 STMFD R13!,{R5,R8}
 MOV R0,#1
 MOV R11,#e_return
 BL call_mode			; perform the return action
 LDMFD R13!,{R5,R8}
 LDR R14,[R8,#w_format]
 BIC R14,R14,#1<<16
 ORR R14,R14,R5			; restore previous option
 STR R14,[R8,#w_format]
 FNRTS

 DCD 7+(1<<15)
Renumber
 CMP R2,#15
 BEQ returnifonibmenu
 MOV R11,#e_renumber
 B call_mode

returnifonibmenu
 CMP R8,#0
 MOVEQ R0,#2
 MOVNE R0,#0
 MOV PC,R14

 DCD 7+(1<<15)
Readonly
 FNJSR
 LDR R0,[R9,#f_flags]
 TST R0,#flags_PermanentReadOnly
 MOV R0,#0			; mask
 MOV R1,#0			; eor
 MOVEQ R1,#flags_ReadOnly	; allowed to change state
 BL new_file_flags_set
 FNRTS

 DCD 0
Redo
 MOV R0,R1			; redo R1 chars
 B redo_command

 DCD 7+(1<<28)
Reloadkeys
 FNJSR
 BL init_settings
 BLVC init_keys
 FNRTS
; MOV R0,#0
; FNSTR R0,menu_count

; BLVC init_menus
; BLVC load_menus
; FNRTS				; doesn't work...

 DCD (1<<12)
Right
 MOV R2,#1
 MOV R3,#0
 B move_cursor

 DCD 7+(1<<14)+(1<<15)
Run
 CMP R2,#15
 BEQ returnifonibmenu
 MOV R11,#e_run
 B call_mode

 DCD 7+(1<<14)+(1<<15)
Runandquit
 CMP R2,#15
 BEQ returnifonibmenu
 MOV R11,#e_runandquit
 B call_mode

 DCD (3<<3)+(7<<6)
Searchback
 MVN R4,#0			; direction =-1
 B search_as_you_type

 DCD (3<<3)+(7<<6)	; set b6,7,8
Searchforward
 MOV R4,#1
 B search_as_you_type

 DCD 7+(1<<15)
Softwrap
 FNJSR
 TEQ R2,#15
 BEQ softwrap_justtest
 MOV R0,#2			; sw possible...?
 MOV R11,#e_interrogate
 BL call_mode
 CMP R0,#2
 FNRTS NE			; no SW possible
 PUSH "R2"
 TEQ R8,#0
 BLNE blat_cache_of_this_window
 MOVVC R0,#1<<26	; clear linewrap
 MOVVC R1,#0 ; 		; toggle nothing
 BLVC new_wind_flags
 PULL "R2"
 MOVVC R0,#0		; clear nothing
 MOVVC R1,#1<<27	; toggle softwrap
 BLVC new_wind_format_set
 TEQ R8,#0
 FNRTS EQ
 BLVC reflect_window_height
 BLVC Updatewindow		; redraw screen
 FNRTS

softwrap_justtest
 MOV R0,#0		; clear nothing
 MOV R1,#1<<27		; toggle softwrap
 BL new_wind_format_set
 FNRTS

;  DCD 7+(1<<15)
; Strongsoftwrap
;  FNJSR
;  TEQ R2,#15
;  BEQ strongsoftwrap_justtest
;  MOV R0,#2			; sw possible...?
;  MOV R11,#e_interrogate
;  BL call_mode
;  CMP R0,#2
;  FNRTS NE			; no SW possible
;  MOV R0,#0			; clear nothing
;  MOV R1,#1<<9			; toggle strongsoftwrap
;  BL new_wind_info_set
;  FNRTS
;
; strongsoftwrap_justtest
;  MOV R0,#0		; clear nothing
;  MOV R1,#1<<9		; toggle strongsoftwrap
;  BL new_wind_info_set
;  FNRTS

; DCD 0
;Swapcase
; FNJSR
; BL get_selection
; BCC in29			; there is a valid selection
; BL get_input_caret		; no valid sel so restore R8,R9
; LDR R7,[R10,#c_off]
; LDR R0,[R9,#f_len]
; CMP R7,R0
; FNRTS CS
; MOV R0,R7
; BL cln_readc
; MOV R5,R0			; save char
; BL swap_case
; TEQ R0,R5
; BEQ in18
; FNLDR R3,wimp_kbdbuf
; STRB R0,[R3]
; MOV R0,#3
; MOV R1,R7
; MOV R2,#1
; BL execute_command
; FNRTS VS
;in18
; ADD R7,R7,#1
; STR R7,[R10,#c_off]
; BL reflect_caret
; FNRTS
;in29
; BL read_selection		; R2=len R3=heap block
; FNRTS VS
; MOV R4,R2			; count
; MOV R5,R3
;in34
; LDRB R0,[R5]
; BL swap_case
; STRB R0,[R5],#1
; SUBS R4,R4,#1
; BGT in34			; swap the case of the block
; MOV R0,#&13			; block replace
; BL execute_command
; FNRTS VS
; MOV R0,R3
; BL heap_free			; free the selected data
; FNRTS

	DCD	7
Selectbuffer
	B	select_buffer

	DCD	0
Selectline
	FNJSR
	MOV	R1,#3
	LDR	R2,[R10,#c_col]
	LDR	R3,[R10,#c_line]
	MOV	R4,#4
	BL	mouse_click	; hope ALT not pressed...
	FNRTS

 DCD 7+(1<<14)+(1<<15)
Saveandrun
 CMP R2,#15
 BEQ returnifonibmenu
 MOV R11,#e_saveandrun
 B call_mode

 DCD (3<<3)+(1<<6)+(1<<9)+(1<<10)
Savefile
 FNJSR
 TEQ R2,#6
 BEQ sa11			; starting minibuffer
 BL save_to_file		; this has the intelligence to get it right in exceptional cases
; BL new_file_name
; BLVC save_text
 FNRTS
sa11
 LDR R0,[R9,#f_name]
 BL check_file_name
; FNcall Zap_CheckFileName,R11	; does name contain path
 FNRTS VS
 TEQ R0,#0
 LDREQ R0,[R9,#f_name]		; path to save with
 FNRTS EQ			; we'll be called again
sa12				; if no path...
 ADR R0,sa_s0
 BL minibuffer_prompt_token
; FNcall Zap_MiniPrompt,R11
 BLVC find_current_directory
; FNcallc Zap_GetCurrDir,VC,R11
 BLVC minibuffer_write
; FNcallc Zap_MiniWrite,VC,R11	; insert current directory name
 MOVVC R0,#'.'
 BLVC minibuffer_writec
; FNcallc Zap_MiniWriteC,VC,R11
 LDRVC R0,[R9,#f_name]		; leaf name
 BLVC minibuffer_write
; FNcallc Zap_MiniWrite,VC,R11
 MOVVC R0,#0			; open minibuffer
 FNRTS
sa_s0
 FNS ("zap_p_savefile")

 DCD 0
Splitline
 MOV R11,#e_splitline
 B call_mode

 DCD 0
Sdown
 MOV R3,#2
 B pagemove_cursor

 DCD 0
Sleft
 MVN R2,#1
 MOV R3,#0
 B move_cursor

 DCD 0
Sright
 MOV R2,#2
 MOV R3,#0
 B move_cursor

 DCD 0
Sup
 MVN R3,#1
 B pagemove_cursor

 LOCAL

 DCD (1 << 12)
Scleft
 LDR R2,[R8,#w_format]
 TST R2,#bit_windowwrap
 MOVNE PC,R14
 MVN R2,#0
 MOV R3,#0
 B scroll_cursor

 LOCAL

 DCD (1 << 12)
Scright
 LDR R2,[R8,#w_format]
 TST R2,#bit_windowwrap
 MOVNE PC,R14
 MOV R2,#1
 MOV R3,#0
 B scroll_cursor

 LOCAL

 DCD (1 << 12)
Scdown
 MOV R2,#0
 MOV R3,#1
 B scroll_cursor

 LOCAL

 DCD (1 << 12)
Scup
 MOV R2,#0
 MVN R3,#0
 B scroll_cursor

 LOCAL

; DCD 0
;Selregion
; FNJSR
; FNLDR R0,car_mode
; TEQ R0,#3
; BEQ se39			; already in sel mode
; TEQ R0,#1
; FNRTS NE
; BL reflect_caret
; MOV R0,#3
; BL set_caret_mode
; FNRTS
;se39
; BL default_caret
; BL get_selection
; FNRTS CS
; ADD R3,R1,R2
; MOV R2,R1
; BL alter_selected_region
; BL update_selection		; turn off select area...?
; FNRTS

 DCD 0
Selregion
 FNJSR
 FNLDR R0,car_mode
 TEQ R0,#3
 BEQ se39			; already in sel mode
 TEQ R0,#1
 FNRTS NE
 MOV R0,#3
 BL set_caret_mode
 FNRTS
se39
 BL default_caret		; turn off select area
 FNRTS

 LOCAL

 DCD 7 + (3<<3) + (1<<6) + (1<<10) + (1<<15); string...
Sendsel
 FNJSR
 CMP R2,#6
 ADREQ R0,Sendsel		; anywhere - to abort minibuffer
 FNRTS EQ
 CMP R0,#0
 LDRPLB R0,[R0]
 STR R0,local_sendtemp + 12
 BL shade_no_sel
 FNRTS CS			; R1=file off R2=len R8/R9=wind with sel
 LDR R14,local_sendtemp
 CMP R14,#0
 FNRTS NE
 BL read_selection
 BVS copyselexit
 CMP R2,#0			; none.
 FNRTS EQ
 STR R3,local_sendtemp
 STR R2,local_sendtemp + 4
 MOV R14,#0
 STR R14,local_sendtemp + 8	; index.
 MOV R1,#-1			; no delay
 ADR R2,sub$l			; typesel sub
 BL call_back			; schedule
 FNRTS
local_sendtemp
 DCD 0
 DCD 0
 DCD 0
 DCD 0
sub$l
 FNJSR "R7"
 MOV R0,#&70			; escape
 BL test_forkey
 BCS atend$l

 MOV R0,#138
 MOV R1,#0
 LDR R2,local_sendtemp
 LDR R7,local_sendtemp + 8
 ADD R2,R2,R7
 LDRB R2,[R2]
 CMP R2,#31
 LDRLE R14,local_sendtemp + 12
 CMPLE R14,#'X'
 SWINE XOS_Byte
 FNRTS VS
 ADD R7,R7,#1
 LDR R0,local_sendtemp + 4
 CMP R7,R0
 BGE atend$l
 STR R7,local_sendtemp + 8
 MOV R1,#-1			; no delay
 ADR R2,sub$l			; typesel sub
 BL call_back			; schedule
 FNRTS
atend$l
 LDR R0,local_sendtemp
 CMP R0,#0
 BLNE heap_free
 MOV R14,#0
 STR R14,local_sendtemp
 FNRTS
;special_cc$l
; PUSH "R1-R11"
; FNLDR R6,car_mode
; CMP R6,#0
; BEQ tonomorectrl$l
; FNLDR R10,car_cursor
; LDR R8,[R10,#c_wind]
; CMP R8,#0
; BMI tonomorectrl$l
; BL conv_wind_off
; CMP R2,#9
; BEQ totab$l
; CMP R2,#10
; CMPNE R2,#13
; BNE tonomorectrl$l
; MOV R0,#0
; BL Return
; B tonomorectrl$l
;totab$l
; BL Tab
;tonomorectrl$l
; PULL "R1-R11"
; B nomorectrl$l

 LOCAL

 DCD 0
Dropmark
 FNJSR
 BL get_cursor_caret
 LDR R0,[R10,#c_off]
 BL set_mark
 FNRTS

 LOCAL

 DCD 7+(3<<3)+(1<<6)+(1<<17)
Setmarginwidth
 FNJSR
 TEQ R2,#6
 BEQ p$l
 TEQ R2,#17
 BEQ a$l
 BL minibuffer_eval
 FNRTS CS

 SUBS R2,R0,#1			; save new width
 MOVMI R2,#0
 CMP R2,#7
 MOVGT R2,#7
 BL save_window_status
 FNRTS VS
 TEQ R8,#0
 FNLDR R1,opt_info,EQ
 LDRNE R1,[R8,#w_info]
 BIC R1,R1,#7
 ORR R1,R1,R2
 FNSTR R1,opt_info,EQ
 STRNE R1,[R8,#w_info]
 BLVC new_window_status
 FNRTS
p$l
 ADR R0,s$l
 BL minibuffer_prompt_token
 FNRTS
a$l
 TEQ R0,#0
 ADREQ R0,s$l
 BLEQ lookup_token_R0
 TEQ R0,#2
 MOVEQ R0,#0			; number of permitted characters...?
 FNRTS EQ
 TEQ R0,#1
 FNRTS NE
 MOV R0,#-1
 TEQ R8,#0
 FNLDR R0,opt_info,EQ
 LDRNE R0,[R8,#w_info]
 AND R0,R0,#7
 ADD R0,R0,#1
 ORR R0,R0,#1<<31		; it's a number
 FNRTS
s$l = "zap_m_setmarginwidth",0
 ALIGN

 LOCAL

 ;E R0=new width
reallysetwidth
 FNJSR
 B inreallysetwidth

local_bpltemp
 DCD 0

 DCD 7 + (3<<3) + (1<<6) + (1<<17)
Setwidth
 FNJSR
 TEQ R2,#6
 BEQ p$l
 TEQ R2,#17
 BEQ a$l
 BL minibuffer_eval		; coz it's a string up to here...
 FNRTS CS
inreallysetwidth
 MOV R11,R0			; save new width
 TEQ R8,#0
 LDRNE R14,[R8,#w_bpl]
 STRNE R14,local_bpltemp
 BLNE save_window_status	; cautious_save_window_status
 FNRTS VS
; SWI &107			; gets here...
 TEQ R8,#0
 FNLDR R1,opt_flags,EQ
 LDRNE R1,[R8,#w_flags]
 BIC R1,R1,#1<<6		; switch off auto-width
 FNSTR R1,opt_flags,EQ
 STRNE R1,[R8,#w_flags]
 MOV R0,R11 ; was R2
 MOV R11,#e_setwidth
 TEQ R8,#0			; again???
 FNLDRB R10,opt_format,EQ
 LDRNEB R10,[R8,#w_format]	; mode number
; AND R10,R1,#&FF		; mode number
 BL call_given_mode		; write the new width
 TEQ R8,#0			; LDREQ R0,[R8,#w_format]
 FNRTS EQ
 BLVC new_window_status
 FNRTS VS
 LDR R14,[R8,#w_format]
 TST R14,#bit_windowwrap
 FNRTS EQ
abnormalwidthsetting
 BL blat_window_wrap_cache	; hopeful...
 LDR R0,local_bpltemp
 BL new_window_status_forcebpl ; _preserve
 FNRTS
p$l
 ;CMP R9,#0			; not needed any more...
 ;BEQ abort$l			; this doesn't work :( why not!
 ADR R0,s$l
 BL minibuffer_prompt_token
 FNRTS
a$l
 TEQ R0,#0
 ADREQ R0,s$l
 BLEQ lookup_token_R0
 TEQ R0,#2
 MOVEQ R0,#8
 TEQ R0,#1
 FNRTS NE
 MOV R0,#-1			; just read it...
 MOV R11,#e_setwidth
 TEQ R8,#0
 FNLDRB R10,opt_format,EQ
 LDRNEB R10,[R8,#w_format]	; mode number
 BL call_given_mode		; read the current width value
 ORRVC R0,R0,#1<<31		; it's a number
 FNRTS
s$l = "zap_m_setwidth",0
 ALIGN

 LOCAL

 DCD 7 + (1<<15)
Spellasyoutype
 FNJSR
 MOV R0,#0
 MOV R1,#(1<<7)
 BL new_info_set
; CMP R2,#15
; BEQ grey$l
 FNRTS

; grey$l
;  MOV R10,R0
;  MOV R0,#13			; sw possible...?
;  MOV R11,#e_interrogate
;  BL call_mode
;  CMP R0,#13
;  MOVEQ R0,R10
;  ORRNE R0,R10,#2
;  FNRTS

 LOCAL

 DCD 7+(2<<3)+(1<<17)+(1<<23)
Startaddr
 TEQ R2,#23
 BEQ function$l
 TEQ R8,#0
 MOVEQ R3,#opt_addr
 MOVNE R3,#w_addr
 ADR R4,s$l
 ORR R2,R2,#1<<31		; hex
 B new_w_number
s$l FNS ("zap_m_starta")
function$l
 TEQ R8,#0
 LDREQ R0,[R12,#opt_addr]
 LDRNE R0,[R8,#w_addr]
 MOV R1,#2			; word literal
 MOV PC,R14

 LOCAL

 DCD 7+(2<<3)+(1<<17)+(1<<23)
Startline
 TEQ R2,#23
 BEQ function$l
 TEQ R8,#0
 MOVEQ R3,#opt_stline
 MOVNE R3,#w_stline		; offset of the data
 ADR R4,s$l
 B new_w_number
s$l FNS ("zap_m_startl")
function$l
 TEQ R8,#0
 LDREQ R0,[R12,#opt_stline]
 LDRNE R0,[R8,#w_stline]
 MOV R1,#2			; word literal
 MOV PC,R14

 LOCAL

 DCD 7
Startop
 B start_operation

 DCD 7
Stopop
 B stop_operation

 DCD (1<<12)
Stilldown
 FNJSR
 ;PUSH "R0-R12"
 ;BL scrub_caret
 ;PULL "R0-R12"
 PUSH "R0-R12"
 BL Scdown
 PULL "R0-R12"
 BL Down
 FNRTS

 DCD (1<<12)
Stillup
 FNJSR
 ;PUSH "R0-R12"
 ;BL scrub_caret
 ;PULL "R0-R12"
 PUSH "R0-R12"
 BL Scup
 PULL "R0-R12"
 BL Up
 FNRTS

 DCD (2<<3)
Stripspaces
 LDR R0,[R0]			; get the word argument
 B strip_spaces

 LOCAL

 DCD 7
Suspend
 FNJSR
 ADR R0,s$l
 SWI XWimp_StartTask
 FNRTS
s$l FNS ("ShellCLI")

 LOCAL

 DCD 0
Swapchars
 FNJSR
 LDR R5,[R10,#c_off]		; file offset
 LDR R2,[R9,#f_len]
 CMP R5,R2
 FNRTS CS			; too near end
 CMP R5,#0
 FNRTS LE			; too near start
 FNLDR R3,wimp_kbdbuf		; buffer
 LDRB R6,[R8,#w_cr]
 SUB R0,R5,#1
 BL cln_readc
 TEQ R0,R6
 FNRTS EQ			; don't swap returns
 STRB R0,[R3,#1]
 MOV R0,R5
 BL cln_readc
 TEQ R0,R6
 FNRTS EQ			; don't swap returns
 STRB R0,[R3]			; characters swapped
 MOV R0,#&13			; block replace
 SUB R1,R5,#1			; offset to replace
 MOV R2,#2
 BL execute_command		; replace the chars
 LDRVC R0,[R10,#c_off]
 SUBVC R0,R0,#1
 STRVC R0,[R10,#c_off]
 BLVC reflect_caret		; move caret back one
 FNRTS

 DCD 0+(1<<28)
Swapwindow
 B command_swap_window

 LOCAL

 DCD 7
Switchtab
 FNJSR
 LDR R0,[R8,#w_flags]
 ANDS R14,R0,#3<<9		; extract current tab mode
 BICNE R0,R0,#3<<9		; Unix tab mode
 ORREQ R0,R0,#1<<9		; set edit tab mode
 STR R0,[R8,#w_flags]
 FNRTS

 LOCAL

 DCD 1
Toback
 MOV R0,#4
 MOV R1,R8
 B open_a_window

 LOCAL

 DCD 1
Tofront
 MOV R0,#3
 MOV R1,R8
 B open_a_window

 LOCAL

 DCD 7+(1<<15)
Togglehex
 MOV R0,#&000
 MOV R1,#&400
 B new_format_set

 LOCAL

 DCD 0
Togglemark
 FNJSR
 BL get_cursor_caret
 LDR R0,[R10,#c_off]
 BL toggle_mark
 FNRTS

 LOCAL

 DCD 7+(1<<15)
Toggleundo
 FNJSR
 TEQ R8,#0
 LDRNE R7,[R9,#f_flags]
 FNLDR R7,opt_flags,EQ
 TEQ R2,#15
 ANDEQ R0,R7,#1			; the undo bit
 FNRTS EQ
 TEQ R8,#0
 BNE a$l
 EOR R7,R7,#1
 FNSTR R7,opt_flags
 FNRTS
a$l				; its on a window
 TST R7,#1
 BEQ b$l			; undo off
 BL open_UndoBox		; question whether to switch off
 FNRTS
b$l				; switch it on
 ORR R7,R7,#1
 STR R7,[R9,#f_flags]
 BL new_file_title
 FNRTS

 DCD 0
Togglewind
 FNJSR
 BL update_wind_state
 FNRTS VS
 LDR R0,[R8,#w_windowflags]
 TST R0,#1<<18
 BEQ to11			; open fully up
 LDR R0,[R8,#w_togminx]
 STR R0,[R8,#w_minx]
 LDR R0,[R8,#w_togminy]
 STR R0,[R8,#w_miny]
 LDR R0,[R8,#w_togmaxx]
 STR R0,[R8,#w_maxx]
 LDR R0,[R8,#w_togmaxy]
 STR R0,[R8,#w_maxy]
 MOV R1,R8
 B to12				; open it
to11
 BL ccd_workxy			; find window size R2,R3<0
 LDR R0,[R8,#w_minx]
 ADD R0,R0,R2
 FNLDR R2,wimp_leftgap
 ADD R0,R0,R2
 STR R0,[R8,#w_maxx]
 LDR R0,[R8,#w_maxy]
 ADD R0,R0,R3
 STR R0,[R8,#w_miny]
 MOV R2,R8			; proposed open block
 FNLDR R1,wimp_block		; workspace
 BL calculate_open_block
 FNRTS VS
 ;SWI &107
 ;LDR R14,[R8,#w_format]
 ;PUSH "R14"
 ;BIC R14,R14,#bit_windowwrap
 ;STR R14,[R8,#w_format]
 ;BL reopen_window
 ;PULL "R14"
 ;STR R14,[R8,#w_format]
 ;BL blat_window_wrap_cache
 ;BL Updatewindow
 ;FNRTS
to12
 BL reopen_window
 MOVVC R1,R8
 BLVC open_window		; kludge to get hscroll removal working here
 FNRTS

; reopen_window_kludge
;  FNJSR "R11"
;  ;LDR R0,[R8,#w_format]
;  ;ANDS R0,R0,#1 << 26
;  ;BLNE preprocesswindowwrap
;  MOV R0,#0
;  MOV R11,#e_openwindow
;  BL call_mode
;  BLVC reopen_minibuffer
;  BLVC open_window_constrict
;  BLVC update_wind_state		; read values at R8
;  FNRTS VS
;  ;LDR R0,[R8,#w_format]
;  ;ANDS R0,R0,#1 << 26
;  ;BLNE postprocesswindowwrap
;  MOV R0,#1
;  MOV R11,#e_openwindow
;  BL call_mode
;  BLVC reflect_title		; don't redraw for moves
;  FNRTS VS
;  LDR R0,[R8,#w_windowflags]
;  TST R0,#1<<18
;  BLEQ reflect_toggle		; save toggle size if need be
;  FNRTS

 DCD (1<<12)
Tab
 FNJSR
 MOV R11,#e_tab
 BL call_mode
 ADRVC R0,(Togglewind - 4)	; ptrtotfs$l
 MOVVC R5,#1			; possible bug...
 BLVC tellzapspell
 FNRTS

 LOCAL

 DCD 7+(1<<3)+(1<<17)+(1<<23)
Tabchar
 TEQ R2,#23
 BEQ Tabchar_fn
 TEQ R2,#0
 BNE a$l
 LDRB R5,[R0]
 ORR R5,R5,R5,LSL#8
 ORR R5,R5,R5,LSL#16		; create tab mask
a$l
 TEQ R8,#0
 MOVEQ R3,#opt_tabchar
 MOVNE R3,#w_tabchar
 ADR R4,s$l
 B new_w_num_checked
s$l FNS ("zap_m_tabchr")

 DCD 7+(2<<3)+(1<<15)
Tabdisplay
 LDR R3,[R0]
 MOV R0,#&3000			; mask
 CMP R3,#4
 MOVCS R3,#0
 MOV R1,R3,LSL#12
 B new_format_select

 DCD 7+(2<<3)+(1<<15)
Tabmode
 LDR R3,[R0]
 MOV R0,#3<<9
 MOV R1,#0			; default=unix tab
 TEQ R3,#1
 MOVEQ R1,#1<<9
 TEQ R3,#2
 MOVEQ R1,#2<<9
 B new_wind_flags_select

 DCD 7+(1<<15)
Tabsasspaces
 MOV R0,#0
 MOV R1,#1<<11		; toggle
 B new_wind_flags_set

 DCD 7+(1<<15)
Toggleinsert
 MOV R0,#0
 MOV R1,#2
 B new_wind_flags_set

 DCD (3<<3)+(1<<6)+(1<<8)
Universalarg
 FNJSR
 TEQ R2,#6
 BEQ un16
 CMP R2,#&8000
 BCS un18
 BL minibuffer_eval
 FNRTS CS			; no number found
 SWI XHourglass_On
 BL universal_arg
 SWIVC XHourglass_Off
 ADRVC R0,un_s1
 BLVC minibuffer_write_token
 FNRTS
un16
 ADR R0,un_s0
 BL minibuffer_prompt_token
 FNRTS
un18
 SUB R0,R2,#&8000		; number of the key
 TEQ R0,#&7F			; pass on delete,
 TEQNE R0,#&1C			;  backspace,
 TEQNE R0,#&1D			;  return,
 SUB R14,R0,#&100
 TEQNE R14,#&66			;  enter
 FNRTS EQ
 CMP R14,#10			; pass on keypad digits,
 SUBHS R14,R0,#'0'
 CMP R14,#10			;  main digits
 ADDHS R0,R0,#&8000		; but do the rest
 FNRTS
un_s0 FNS ("zap_p_universalarg_1")
un_s1 FNS ("zap_p_universalarg_2")

 LOCAL

 DCD 0
Unspace				; remove excess spacing
 FNJSR
 LDR R2,[R10,#c_off]		; start of white space
 MOV R3,R2			; end of white space
 LDR R4,[R9,#f_len]
 LDRB R5,[R8,#w_tabc]		; tab char
a$l
 CMP R3,R4
 BCS b$l
 MOV R0,R3
 BL cln_readc
 TEQ R0,#&20
 TEQNE R0,R5
 ADDEQ R3,R3,#1
 BEQ a$l
b$l
 SUBS R0,R2,#1
 BLT c$l
 BL cln_readc
 TEQ R0,#&20
 TEQNE R0,R5
 SUBEQ R2,R2,#1
 BEQ b$l
c$l				; R2-R3 = spaced region about cursor
 MOV R4,#1			; length of replacement string
 SUBS R0,R3,R2			; length of source
 FNRTS LE			; nothing to replace
 CMP R0,#1
 BGT d$l
 MOV R0,R2
 BL cln_readc			; it is a single space?
 TEQ R0,#&20
 MOVEQ R4,#0			; delete if so
d$l				; replace
 MOV R1,R2			; start
 SUB R2,R3,R2			; len
 ADR R3,sp$l
 BL replace_area
 FNRTS
sp$l = " "
 ALIGN

 DCD (1<<12)
Up
 MOV R2,#0
 MOV R3,#-1
 B move_cursor

 DCD 7+(3<<3)+(1<<6)+(1<<14)+(1<<9)	; tabs for filenames
Wimptask
 MOV R3,#2
 B os_cli

 DCD 7+(2<<3)+(1<<15)
Wflags_alter
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 BL new_flags_set
 FNRTS

 DCD 7+(2<<3)+(1<<15)
Wflags_toggle
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 BL new_wind_flags_set
 FNRTS

 DCD 7+(2<<3)+(1<<15)
Wformat_alter
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 TST R0,#&FF
 TSTNE R1,#&FF
 BLEQ new_wind_format_set	; swapped with below
 FNRTS

 DCD 7+(2<<3)+(1<<15)
Wformat_toggle
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 TST R0,#&FF
 TSTNE R1,#&FF
 FNRTS NE
 BLEQ new_format_set		; swapped with below
; BL Updatewindow		; seems to be needed...!?
 FNRTS

 DCD 7+(2<<3)+(1<<15)
Winfo_alter
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 BL new_wind_info_set
 FNRTS

 DCD 7+(2<<3)+(1<<15)
Winfo_toggle
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 BL new_info_set
 FNRTS

	LOCAL

 DCD 7+(1<<15)
Windowwrap
 FNJSR
 MOV R0,#0		; clear nothing
 MOV R1,#bit_windowwrap	; 1<<26	; toggle windowwrap
 BL new_wind_format_set
 TEQ R2,#15
 BEQ ww_new_wind_format_set
; FNRTS EQ
 TEQ R8,#0
 FNRTS EQ
 MOV R1,R8
 BL open_window
 BL blat_cache_of_this_window
 LDR R0,[R8,#w_info]
 TST R0,#bit_infiniteww			; iww bit?
 BEQ skipwidthcomplications
 BL translate_into_new_width
 BLVC Updatewindow		; redraw screen
 FNRTS

ww_new_wind_format_set
; TST R1,#bit_windowwrap
; BNE loc_test_for_ww
; FNRTS

loc_test_for_ww
 PUSH "R0,R10,R11"
 TEQ R8,#0
 FNLDRB R10,opt_format,EQ
 LDRNEB R10,[R8,#w_format]
 MOV R0,#1
 MOV R11,#e_interrogate
 BL call_given_mode
 CMP R0,#1
 PULL "R0,R10,R11"
 ORRNE R0,R0,#2
 BICNE R0,R0,#1
 FNRTS

blat_cache_of_this_window
 MOV R0,#0
 STR R0,[R8,#w_txth]		; invalidate cache
 STR R0,[R8,#w_txtn]
 STR R0,[R8,#w_coff]
 STR R0,[R8,#w_cline]
 STR R0,[R8,#w_clogl]
 MOV PC,R14

skipwidthcomplications
 BL save_window_status ; cautious_save_window_status ; save_window_status
 BL new_window_status ; new_window_status_preserve ; new_window_status
 BL Updatewindow		; redraw screen
 FNRTS

translate_into_new_width
 FNJSR "R2-R12"
 LDR R1,[R8,#w_bpl]
 MOV R0,#3
 MOV R11,#e_interrogate
 BL call_mode
 BL reallysetwidth
 FNRTS

 DCD 7+(1<<15)
Wordwrap
 MOV R0,#1<<26		; clear linewrap
 MOV R1,#1<<13		; toggle wordwrap
 B new_wind_flags_set

 LOCAL

local_store1
 & 0
local_store2
 & 0
local_store3			; file offset
 & 0

 DCD (3<<3)+(1<<6)
Editbyte
 FNJSR
 MOV R4,R0			; save data string
 LDR R6,[R10,#c_off]		; offset of the instruction
 LDR R5,[R9,#f_len]		; offset of the instruction
 CMP R6,R5
 FNRTS GT			; was CS
 STR R6,local_store3
 LDR R5,[R8,#w_addr]		; address of offset 0
 ADD R5,R5,R6			; address instruction came from
 TEQ R2,#6
 BEQ Byte_prompt$l
 BIC R0,R6,#3
 BL cln_readw			; get word in r0
 STR R0,local_store1
; MOV R11,R0
 ;STR R10,local_store2

 MOV R0,#&100
 BL heap_claim
 MOVVC R6,R0
 MOVVC R2,R4			; source
 MOVVC R1,R6
 BLVC strcopy			; copy string to be assembled
 ADRVC R0,assmbl$l
 BLVC find_key_command
 FNRTS VS
 CMP R0,#0
 FNRTS EQ
 MOV R7,R0
 BL start_operation
 MOV R0,R6
 BL str_len			; length
 MOV R1,R0
 MOV R2,#(1 << 31)		; don't learn...
 MOV R0,R6
 BL process_command

; LDR R10,local_store2

 LDRVC R0,local_store3
 BLVC goto_file_offset
 BVS forcedstop$l

 ;LDR R10,local_store2
 LDR R0,[R10,#c_off]		; offset of the instruction
 BIC R0,R0,#3
 BL cln_readw			; get word in r0...
; AND R0,R0,#&FF
 LDR R1,[R10,#c_off]		; offset of the instruction
 AND R1,R1,#3
 MOV R1,R1,LSL #3
 MOV R14,#&FF
 MOV R14,R14,LSL R1		; = &FF000000 etc...
 LDR R11,local_store1
 BIC R11,R11,R14
 ORR R11,R11,R0,LSL R1
 MOV R1,R6
 ADR R2,dcd$l
 BL strcpy
 MOV R0,R11
; LDR R0,local_store1
 MOV R2,#&100
 SWI XOS_ConvertHex8		; start off with the address in hex
 MOVVC R14,#0
 STRVCB R14,[R1]

 ADRVC R0,assmbl$l
 BLVC find_key_command
 BVS forcedstop$l
 MOVS R7,R0
; FNRTS EQ
 MOV R0,R6
 BL str_len			; length
 MOV R1,R0
 MOV R2,#(1 << 31)		; don't learn...
 MOV R0,R6
 BL process_command

 LDRVC R0,local_store3
 ADDVC R0,R0,#1
 BLVC goto_file_offset		; gets here :-)
 BVS forcedstop$l
 BL stop_operation
 MOVVC R0,R6
 BLVC heap_free
 FNRTS

forcedstop$l
 PUSH "R0"
 BL stop_operation
 MOVVC R0,R6
 BLVC heap_free
 PULL "R0"
 FNRTV

Byte_prompt$l
 MOV R0,R5
 FNLDR R1,wimp_block		; some workspace...
 MOV R2,#&100
 SWI XOS_ConvertHex8		; start off with the address in hex
 FNRTS VS
 FNLDR R0,wimp_block
 BL minibuffer_prompt
 FNRTS VS
 LDR R0,[R9,#f_len]		; offset of the instruction
 CMP R6,R0
 MOVCS R0,#&00			; off end...!
 MOVCC R0,R6
 BLCC cln_readc
 MOV R7,R0
 MOV R0,#16			; what base?
 MOV R11,#e_interrogate
 BL call_mode
 CMP R0,#2
 BEQ Byte_inbinary$l

 FNLDR R1,wimp_block		; buffer to copy detokenised line
 ADR R2,dcd$l
 MOV R3,R1			; save start of line address
 BL strcpy
 MOV R0,R7
 ;SUB R1,R1,#1
 MOV R2,#&100
 SWI XOS_ConvertHex2		; start off with the address in hex
 MOV R0,#0
 STRB R0,[R1]
 MOV R0,R3
 BL minibuffer_write
 FNRTS
Byte_inbinary$l
 FNLDR R1,wimp_block		; buffer to copy detokenised line
 ADR R2,binarydcd$l
 MOV R3,R1			; save start of line address
 BL strcpy
 MOV R0,R7
 ;SUB R1,R1,#1
 MOV R2,#&28
 SWI XOS_ConvertBinary1		; to binary
 MOV R0,#0
 STRB R0,[R1,R2]
 MOV R0,R3
 BL minibuffer_write
 FNRTS

 DCD (3<<3)+(1<<6)
Editword
 FNJSR
 MOV R4,R0			; save data string
 LDR R6,[R10,#c_off]		; offset of the instruction
 BIC R6,R6,#3			; word align
 LDR R5,[R8,#w_addr]		; address of offset 0
 ADD R5,R5,R6			; address instruction came from
 TEQ R2,#6
 BEQ prompt$l
 MOV R0,#&100
 BL heap_claim
 MOVVC R6,R0
 MOVVC R2,R4			; source
 MOVVC R1,R6
 BLVC strcopy			; copy string to be assembled
 ADRVC R0,assmbl$l
 BLVC find_key_command
 FNRTS VS
 CMP R0,#0
 FNRTS EQ
 MOV R7,R0
 MOV R0,R6
 BL str_len			; length
 MOV R1,R0
 MOV R2,#(1 << 31)
 MOV R0,R6
 BL process_command
 MOV R0,R6
 BL heap_free
 FNRTS
prompt$l
 MOV R0,R5
 FNLDR R1,wimp_block		; some workspace...
 MOV R2,#&100
 SWI XOS_ConvertHex8		; start off with the address in hex
 FNRTS VS
 FNLDR R0,wimp_block
 BL minibuffer_prompt
 MOVVC R0,R6
 BLVC cln_readw
 FNRTS VS
 MOV R7,R0
 MOV R0,#16			; what base?
 MOV R11,#e_interrogate
 BL call_mode
 CMP R0,#2
 BEQ inbinary$l

 FNLDR R1,wimp_block		; buffer to copy detokenised line
 ADR R2,dcd$l
 MOV R3,R1			; save start of line address
 BL strcpy
 MOV R0,R7
 ;SUB R1,R1,#1
 MOV R2,#&100
 SWI XOS_ConvertHex8		; start off with the address in hex
 MOV R0,#0
 STRB R0,[R1]
 MOV R0,R3
 BL minibuffer_write
 FNRTS
inbinary$l
 FNLDR R1,wimp_block		; buffer to copy detokenised line
 ADR R2,binarydcd$l
 MOV R3,R1			; save start of line address
 BL strcpy
 MOV R0,R7
 ;SUB R1,R1,#1
 MOV R2,#&28
 SWI XOS_ConvertBinary4		; to binary
 MOV R0,#0
 STRB R0,[R1,R2]
 MOV R0,R3
 BL minibuffer_write
 FNRTS
dcd$l FNS ("DCD &")
binarydcd$l FNS ("DCD %")
assmbl$l FNS ("ASSEMBLE")

 LOCAL

 DCD 7+(2<<3)+(1<<17)
Wrapwidth
 FNJSR
 TEQ R2,#17
 BEQ a$l
 LDR R0,[R0]
 CMP R0,#8
 MOVLE R0,#8
 TEQ R8,#0
 FNSTR R0,opt_wrapwidth,EQ
 STRNE R0,[R8,#w_wrapwidth]
 FNRTS
a$l
 TEQ R0,#0
 ADREQ R0,s$l
 BLEQ lookup_token_R0
 TEQ R0,#2
 MOVEQ R0,#8
 TEQ R0,#1
 FNRTS NE
 TEQ R8,#0
 ADDEQ R0,R12,#opt_wrapwidth
 ADDNE R0,R8,#w_wrapwidth
 FNRTS
s$l FNS ("zap_m_wrapwidth")

 LOCAL

 DCD (3:SHL:3):OR:(1:SHL:6):OR:(1:SHL:9)
Writebuffer
 CMP R9,#0
 MOVEQ PC,R14
 TEQ R2,#6
 BEQ prompt$l

 FNJSR
 MOV R4,R0			; save filename
 LDR R0,[R9,#f_len]
 MOV R1,#0
 BL split_buffer		; coagulate buffer
 LDR R0,[R9,#f_load]
 BL calc_ftype
 MOVCC R2,R0
 MOVCC R0,#0
 LDRCC R3,[R9,#f_exec]
 MOVCS R2,R0
 MOVCS R0,#10
 MOV R1,R4			; target filename
 LDR R4,[R9,#f_ptr]
 LDR R5,[R9,#f_len]
 ADD R5,R4,R5
 SWI XOS_File
 FNRTS

prompt$l
 ADR R0,p$l
 B minibuffer_prompt_token
p$l
 FNS ("zap_p_writebuffer")

 DCD (3<<3)+(1<<6)+(1<<9)
Writefile
 FNJSR
 TEQ R2,#6
 BEQ wr10
 BL save_to_file		; this has the intelligence to get it right in exceptional cases
; BL new_file_name
; BLVC save_text
 FNRTS
wr10
 LDR R0,[R9,#f_name]
 BL check_file_name		; does name contain path
 MOVVC R7,R0			; save whether it conatins a path
 ADRVC R0,wr_s0
 BLVC minibuffer_prompt_token
 FNRTS VS
 TEQ R7,#0
 BEQ wr11			; path given
 BL find_current_directory
 BLVC minibuffer_write		; insert current directory name
 MOVVC R0,#'.'
 BLVC minibuffer_writec
 FNRTS VS
wr11
 LDR R0,[R9,#f_name]		; leaf name/path
 BL minibuffer_write
 FNRTS
wr_s0
 FNS ("zap_p_writefile")

 DCD 0
Yank
 B yank_command

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Toggle flags subs						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=4 x 8 bit instruction blocks. Each block has format:
;     b0-b4 = 0-31 number of bit in the word to toggle
;     b5/b6 = 00 => toggle the bit
;	      01 => set the bit
;	      10 => clear the bit
;	      11 => reserved
;     b7    = must be set to show this block active (except lowest byte
;	      where its unused by this sub - others may use it)
;X R0=mask R1=eor to accomplish this

calculate_masks
 FNJSR "R2-R3"
 ORR R2,R0,#1<<7		; lowest byte always contains a block
 MOV R0,#0
 MOV R1,#0			; default mask/eor (does nothing)
a$l
 TST R2,#1<<7			; active block?
 FNRTS EQ			; no - finished
 AND R3,R2,#&1F			; bit number
 MOV R14,#1
 MOV R14,R14,LSL R3		; bit mask
 ANDS R3,R2,#&60		; action
 ORREQ R1,R1,R14		; toggle
 TEQ R3,#&20
 ORREQ R0,R0,R14
 ORREQ R1,R1,R14		; set the bit
 TEQ R3,#&40
 ORREQ R0,R0,R14		; clear the bit
 MOV R2,R2,LSR#8
 B a$l

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Adding command tables					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=command table to add R12=zaps workspace
;X command table added / VS

add_command_table
 STMFD R13!,{R1,R14}
 FNLDR R14,com_number
 CMP R14,#max_ctable
 BCS ad16			; table full
 FNADD R1,R12,command_store
 ADD R1,R1,R14,LSL#2
 STR R0,[R1]			; save new command table pointer
 ADD R14,R14,#1
 FNSTR R14,com_number
 LDMFD R13!,{R1,PC}
ad16
 BL err$l
 LDMFD R13!,{R1,PC}
err$l ERR "zap_e_manycmdtables"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Command tick updating subs					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R2=action code
;X If R2=15 then returns R0 for menu info and CS
;  If R2<>15 then returns R1=sel off R2=sel len R8/R9=sel or CS if invalid
;  (ie calls get_selection)

shade_no_sel
 FNJSR
 TEQ R2,#15
 BEQ a$l
 BL get_selection		; just read the selection position
 FNRTS
a$l
 BL get_selection
 MOVCC R0,#0
 MOVCS R0,#2			; shade if none
 SUBS R0,R0,#0			; sec
 FNRTS

 LOCAL

;E R2=action code
;X If R2=15 then returns R0 for menu info and CS
;  If R2<>15 then returns R1=sel off R2=sel len R8/R9=sel or CS if invalid
;  (ie calls get_selection)

shade_no_sel_at_all
 FNJSR
 TEQ R2,#15
 BEQ a$l
 BL get_selection		; just read the selection position
 FNRTS CC
 CMP R1,R2
 BNE return_set$l
 ADDS R14,R14,#0		; CLC
 FNRTS
a$l
 BL get_selection
 MOVCC R0,#0
 MOVCS R0,#2			; shade if none
 CMP R1,R2
 MOVEQ R0,#0
return_set$l
 SUBS R0,R0,#0			; sec
 FNRTS

; Darren's condional-related commands start here...

	LOCAL

checklearn			; are we going through any REPEAT loop
	FNJSR	"R0-R3"		; for at least the 2nd time? (NE if so)
	FNLDR	R1,if_bits
	FNLDR	R2,if_stop
	FNLDR	R3,if_count
learn$l	TEQ	R2,R3
	LDRNE	R14,[R1,R2,LSL #3]
	FNRTS	EQ
	ADD	R2,R2,#1
	MOV	R0,R14,LSR #28
	TEQ	R0,#1
	TEQNE	R0,#2
	BNE	learn$l
	TST	R14,#2
	BEQ	learn$l
	FNRTS


checkloop			; are we in a REPEAT/WHILE/CASE structure?
	FNJSR	"R1-R3"		; NE if so, with R0 = type
	FNLDR	R1,if_bits
	FNLDR	R2,if_count
	FNLDR	R3,if_stop
	SUB	R3,R3,#1
loop$l	SUB	R2,R2,#1
	TEQ	R2,R3
	LDRNE	R0,[R1,R2,LSL #3]
	FNRTS	EQ
	MOV	R0,R0,LSR #28
	CMP	R0,#1
	RSBHSS	R14,R0,#3
	BLO	loop$l
	TEQ	R0,#0
	FNRTS


checktrue		; is the most recent IF/WHILE/WHEN/DEFAULT true?
	FNJSR	"R1-R3"		; (NE if so, or no IF)
	FNLDR	R1,if_bits
	FNLDR	R2,if_count
if$l	SUBS	R2,R2,#1
	LDRPL	R14,[R1,R2,LSL #3]
	MOVMI	R14,#1
	MOV	R3,R14,LSR #28
	TEQ	R3,#0
	TEQNE	R3,#2
	TEQNE	R3,#3
	BNE	if$l
	TST	R14,#1
	FNRTS


	LOCAL

	&	7 :OR: 3<<3 :OR: 1<<10 :OR: 1<<21 :OR: 1<<23 :OR: 3<<24
		; b21 stops cmd blk exec code checking IF state
If
	FNJSR
	TEQ	R2,#23
	BEQ	If_fn$l
	BL	checktrue
	BEQ	skip$l
noskip$l
	MOV	R1,#0
	BL	evaluate_string
	FNRTS	VS
	MOVS	R0,R1
	FNLDR	R2,if_count
	MOVNE	R0,#1
	CMP	R2,#if_limit
	FNLDR	R1,if_bits,LO
	STRLO	R0,[R1,R2,LSL #3]
	ADDLO	R2,R2,#1
	FNSTR	R2,if_count,LO
	FNRTS	LO
	ADR	R0,toomanyIFs_etc
	BL	lookup_error
	FNRTV
skip$l	FNLDR	R0,if_skip
	ADD	R0,R0,#1
	FNSTR	R0,if_skip
	FNRTS
toomanyIFs_etc
	&	0
	=	"zap_e_deepstruct",0
	ALIGN
If_fn$l	MOV	R10,R0		; parameter string
	MOV	R11,R10
	BL	str_comma	; find comma
	CMP	R0,#32
	BLLO	badif_msg$l	; no comma? error
	FNRTS	VS
	MOV	R7,R0
	MOV	R0,#0
	STRB	R0,[R10,#-1]	; temporary NUL
	MOV	R0,R11
	MOV	R1,#0
	BL	evaluate_string	; evaluate (allow int only)
	STRB	R7,[R10,#-1]
	FNRTS	VS
	TEQ	R1,#0
	BEQ	else$l		; false? check for ELSE part
	BL	str_skip
	TEQ	R0,#','		; if null & there's an ELSE part
	MOVEQ	R0,#0		;   return null
	MOVEQ	R1,#3
	FNRTS	EQ
	MOV	R11,R10
	MOV	R0,R10
	BL	str_comma	; find comma
	MOV	R7,R0
	MOV	R0,#0
	STRB	R0,[R10,#-1]	; temporary NUL
	MOV	R0,R11
	MOV	R1,#256
	BL	evaluate_string
	STRB	R7,[R10,#-1]
ret$l	TEQ	R0,#0
	MOVEQ	R0,R1
	MOVEQ	R1,#2
	MOVNE	R1,#3
	FNRTS
else$l	MOV	R11,R10
	BL	str_comma	; find comma
	CMP	R0,#32
	MOVLO	R0,#0
	MOVLO	R1,#3		; none? return null
	FNRTS	LO
	MOV	R0,R10
	MOV	R1,#256
	BL	evaluate_string
	B	ret$l
badif_msg$l
	ERR	"zap_e_insuffargs"


	&	7
	; E: R4 = address of next command, or 0
Repeat
	FNLDR	R2,if_count
	CMP	R2,#if_limit
	FNLDR	R1,if_bits,LO
	ORRLO	R4,R4,#1<<28
	STRLO	R4,[R1,R2,LSL #3]
	ADDLO	R2,R2,#1
	FNSTR	R2,if_count,LO
	MOVLO	R0,#0
	MOVLO	PC,R14
	ADR	R0,toomanyIFs_etc
	ORREQ	PC,R14,#1<<28


	LOCAL

	&	7 :OR: 3<<3 :OR: 1<<10 :OR: 1<<21
		; b21 stops cmd blk exec code checking IF state
While
	FNJSR
;	FNLDR	R2,if_skip
;	TEQ	R2,#0
;	BEQ	noskip$l
	BL	checktrue
	BEQ	skip$l
noskip$l
	MOV	R3,R0			; point at argument
	MOV	R1,#0
	BL	evaluate_string
	FNRTS	VS
	TEQ	R1,#0
	FNLDR	R2,if_count
	ORRNE	R3,R3,#1
	CMP	R2,#if_limit
	FNLDR	R1,if_bits,LO
	ORRLO	R3,R3,#2<<28
	STRLO	R3,[R1,R2,LSL #3]!
	STRLO	R4,[R1,#4]
	ADDLO	R2,R2,#1
	FNSTR	R2,if_count,LO
	FNRTS	LO
	ADR	R0,toomanyIFs_etc
	FNRTV
skip$l	FNLDR	R1,if_skip
	MOV	R0,#0
	ADD	R1,R1,#1
	FNSTR	R1,if_skip
	FNRTS


	LOCAL

	&	7 :OR: 3<<3 :OR: 1<<10 :OR: 1<<21
Case
	FNJSR
	FNLDR	R2,if_skip
	TEQ	R2,#0
	BEQ	noskip$l
	BL	checktrue
	BEQ	skip$l
noskip$l
	FNLDR	R2,if_count
	CMP	R2,#if_limit-1
	ADRHS	R0,toomanyIFs_etc
	FNRTV	HS
	MOV	R1,#256
	BL	evaluate_string
	FNLDR	R3,if_bits,VC
	ORRVC	R0,R0,#3<<28
	ADDVC	R3,R3,R2,LSL #3
	STMVCIA	R3,{R0,R1}
	ADDVC	R2,R2,#1
	FNSTR	R2,if_count,VC
	FNRTS
skip$l	FNLDR	R0,if_skip
	ADD	R0,R0,#1
	FNSTR	R0,if_skip
	FNRTS


	LOCAL

	&	7 :OR: 1<<21
Else
	FNJSR
	FNLDR	R0,if_skip
	TEQ	R0,#0
	FNRTS	NE
	MOV	R1,#0
	BL	typecheck
	FNRTS	VS
	FNLDR	R0,if_count
	FNLDR	R1,if_bits
	SUB	R0,R0,#1
	LDR	R0,[R1,R0,LSL #3]!
	EOR	R0,R0,#1
	STR	R0,[R1]
	FNRTS


	&	7 :OR: 1<<21
Endif
	FNJSR
	FNLDR	R0,if_skip
	SUBS	R0,R0,#1
	FNSTR	R0,if_skip,PL
	FNRTS	PL
	MOV	R1,#0
	BL	typecheck
	FNLDR	R0,if_count,VC
	SUBVC	R0,R0,#1
	FNSTR	R0,if_count,VC
	FNRTS


	LOCAL

	&	3<<3 :OR: 1<<10
	; X: R0 = address of next command / 0 / error
Until
	FNJSR
	MOV	R1,#1
	BL	typecheck
	MOVVC	R1,#0
	BLVC	evaluate_string
	FNRTS	VS
	TEQ	R1,#0
	BNE	true$l
	BL	altesc
	BCC	false$l
	ADR	R0,query_escape
	ADR	R4,repeat$l
	BL	query_abort
	BEQ	true$l
false$l	FNLDR	R2,if_count
	FNLDR	R1,if_bits
	SUB	R2,R2,#1
	LDR	R0,[R1,R2,LSL #3]!
	ORR	R2,R0,#2		; prevent learning :-)
	STR	R2,[R1]
	FNRTS
true$l	FNLDR	R2,if_count
	MOV	R0,#0
	SUB	R2,R2,#1
	FNSTR	R2,if_count
	FNRTS
query_escape
	& 0
	= "zap_q_escrep",0
repeat$l
	= "REPEAT",0
	ALIGN

	LOCAL

query_abort
	FNJSR
	BL	lookup_error
	MOV	R4,R0
	ADR	R0,btn$l
	BL	lookup_token_R0
	MOV	R5,R0
	ADR	R1,title$l
	FNLDR	R2,wimp_data
	MOV	R3,#256
	BL	lookup_token
	FNLDR	R1,wimp_realver
	CMP	R1,#320
	MOVHS	R1,#&910
	MOVLO	R1,#&13
	MOV	R0,R4
	ADR	R3,zap$l
	MOV	R4,#1
	SWI	XWimp_ReportError	; this calls XHourglass_Smash
	FNRTS	VS
	MOV	R0,#5
	SWI	XHourglass_Start
	TEQ	R1,#1
	TEQNE	R1,#3
	FNRTS
title$l = "zap_q_msg",0
btn$l	= "zap_q_btns",0
zap$l	= "!zap",0
	ALIGN

	LOCAL

;X CS if Alt+Esc pressed
;  R0-R2 corrupt

altesc	MOV	R0,#129
	MOV	R1,#256-113
	MOV	R2,#255
	SWI	XOS_Byte
	MOVCS	R0,#129
	MOVCS	R1,#256-3
	MOVCS	R2,#255
	SWICS	XOS_Byte
	MOV	PC,R14

	LOCAL

	&	7 :OR: 1<<10 :OR: 1<<21
	; X: R0 = address of next command / 0 / error
Endwhile
	FNLDR	R1,if_skip
	SUBS	R1,R1,#1
	FNSTR	R1,if_skip,PL
	MOVPL	PC,R14
	FNJSR
	MOV	R1,#2
	BL	typecheck
	FNRTS	VS
	FNLDR	R1,if_count
	FNLDR	R4,if_bits
	SUB	R1,R1,#1
	LDR	R0,[R4,R1,LSL #3]!
	MOV	R1,#0
	BIC	R0,R0,#&FC000003
	BL	evaluate_string
	FNRTS	VS
	TEQ	R1,#0
	BEQ	false$l
	BL	altesc
	BCC	true$l
	ADR	R0,query_escape
	ADR	R4,while$l
	BL	query_abort
	BEQ	false$l
true$l	LDR	R0,[R4]
	ORR	R0,R0,#2		; prevent learning :-)
	STR	R0,[R4]
	LDR	R0,[R4,#4]
	FNRTS
false$l	FNLDR	R2,if_count
	MOV	R0,#0
	SUB	R2,R2,#1
	FNSTR	R2,if_count
	FNRTS
while$l	=	"WHILE",0
	ALIGN


	&	7 :OR: 3<<3 :OR: 1<<10 :OR: 1<<21
CWhen
	FNJSR
	FNLDR	R1,if_skip
	TEQ	R1,#0
	FNRTS	NE
	MOV	R1,#3
	BL	typecheck
	FNRTS	VS
	BL	checktrue
	BEQ	When_internal
	FNRTS


	&	7 :OR: 3<<3 :OR: 1<<10 :OR: 1<<21
When
	FNJSR
	FNLDR	R1,if_skip
	TEQ	R1,#0
	FNRTS	NE
	MOV	R1,#3
	BL	typecheck
	FNRTS	VS
When_internal
	FNLDR	R1,if_bits
	FNLDR	R2,if_count
	ADD	R1,R1,R2,LSL #3
	LDMDB	R1,{R5,R6}	; string,len OR 0,int
	MOV	R10,R0
	BIC	R5,R5,#&FC000003
	BL	compare_in
	FNRTS	VS
	LDR	R2,[R1,#-8]
	BIC	R2,R2,#1
	ORREQ	R2,R2,#&08000001
	STR	R2,[R1,#-8]
	FNRTS


	&	7 :OR: 1<<21
Default
	FNJSR
	FNLDR	R0,if_skip
	TEQ	R0,#0
	FNRTS	NE
	MOV	R1,#3
	BL	typecheck
	FNRTS	VS
	FNLDR	R1,if_bits
	FNLDR	R2,if_count
	ADD	R1,R1,R2,LSL #3
	LDR	R2,[R1,#-8]
	TST	R2,#&08000000
	BIC	R2,R2,#1
	ORREQ	R2,R2,#1
	STR	R2,[R1,#-8]
	FNRTS


	&	7 :OR: 1<<21
Endcase
	FNJSR
	FNLDR	R0,if_skip
	SUBS	R0,R0,#1
	FNSTR	R0,if_skip,PL
	FNRTS	PL
	MOV	R1,#3
	BL	typecheck
	FNRTS	VS
	FNLDR	R2,if_count
	FNLDR	R1,if_bits
	SUB	R2,R2,#1
	FNSTR	R2,if_count
	LDR	R0,[R1,R2,LSL #3]
	BICS	R0,R0,#&FC000003
	BLNE	heap_free
	FNRTS

	LOCAL

;E R0=struct block type R4=pointer in command block
;X R0=corresponding command in current command block / -> -1
find_command_in_block
	FNJSR	"R1-R5"
	MOV	R5,#0
	TEQ	R0,#1
	ADREQ	R5,Until
	TEQ	R0,#2
	ADREQ	R5,Endwhile
	TEQ	R0,#3
	ADREQ	R5,Endcase
;	TEQ	R0,#4
;	ADREQ	R5,Endproc
;	TEQ	R0,#5
;	ADREQ	R5,Result
	MOV	R0,#0
loop$l	LDR	R1,[R0,R4]!
	TEQ	R1,R5
	CMPNE	R1,#-1
	FNRTS	EQ
	ADD	R4,R0,#12
	LDR	R6,[R4,#-8]
	LDR	R1,[R4,#-4]
	MOV	R0,R4
	BL	command_data
	B	loop$l

	LOCAL

;E R0=struct block type
;X Blocks popped from struct stack until type R0 encountered or stack 'empty'

popblocks
	FNJSR	"R0-R5"
	FNLDR	R1,if_stop
	MOV	R3,R0
	FNLDR	R4,if_bits
	FNLDR	R5,if_count
pop$l
	FNSTR	R5,if_count
	SUB	R5,R5,#1
	CMP	R5,R1
	FNRTSS	LT
	LDR	R0,[R4,R5,LSL #3]
	MOV	R14,R0,LSR #28
	TEQ	R14,R3
	FNRTSS	EQ
	TEQ	R14,#3
	BICEQ	R0,R0,#&FC000003
	BLEQ	heap_free
	B	pop$l


	LOCAL
;X Single block popped from struct stack (unles stack is 'empty')

popblock
	FNJSR	"R0-R5"
	FNLDR	R1,if_stop
	MOV	R3,R0
	FNLDR	R4,if_bits
	FNLDR	R5,if_count
	SUB	R5,R5,#1
	CMP	R5,R1
	FNRTSS	LT
	FNSTR	R5,if_count
	LDR	R0,[R4,R5,LSL #3]
	MOV	R14,R0,LSR #28
	TEQ	R14,#3
	BICEQ	R0,R0,#&FC000003
	BLEQ	heap_free
	FNRTSS

	LOCAL

	&	7 :OR: 1<<10
	; E: R4 = address of next command / 0
	; X: R0 = address of next command / 0 / error
Continue
	TEQ	R4,#0
	MOVEQ	PC,R14
	FNJSR
	BL	checkloop
	BLNE	popblocks
	BL	find_command_in_block
	FNRTS


	&	7 :OR: 1<<10
	; E: R4 = address of next command / 0
	; X: R0 = address of next command / 0 / error
Break
	TEQ	R4,#0
	MOVEQ	PC,R14
	FNJSR
	BL	checkloop
	BLNE	popblocks
	BL	find_command_in_block
	LDR	R1,[R0]
	CMP	R1,#-1		; no point in skipping an end-of-block marker
	FNRTS	EQ
	ADD	R4,R0,#12	; skip command :-)
	LDR	R6,[R4,#-8]
	LDR	R1,[R4,#-4]
	MOV	R0,R4
	BL	command_data
	ADD	R0,R4,R0
	BL	popblock
	FNRTS


	LOCAL

	&	7 :OR: 3<<3:OR:1<<12
Set
	FNJSR
	MOV	R6,R0
	BL	validate_varname
	BLEQ	bad_zap_variable
	FNRTS	VS
	MOV	R2,R0
	MOV	R0,R6
	SUB	R1,R2,R6
	BL	make_varname
spc$l	LDRB	R1,[R2],#1
	TEQ	R1,#'='
	BEQ	eq$l
	TEQ	R1,#' '
	BEQ	spc$l
	BL	bad_zap_variable
	FNRTS
eq$l	MOV	R0,R2
	MOV	R1,#-1
	BL	evaluate_string	; parse only :-)
	MOVVS	R7,#0
	BVS	free$l
	MOV	R7,R0
	MOV	R4,#3
	MOV	R3,#0
	MOV	R2,R1
	MOV	R1,R0
	FNLDR	R0,wimp_buffer
	SWI	XOS_SetVarVal
free$l	MOVVC	R1,#0
	MOVVS	R1,R0
	MOVS	R0,R7
	BLNE	heap_free
	MOVS	R0,R1
	FNRTS	EQ
	FNRTV

bad_zap_variable
	ERR	"zap_e_badvar"


	LOCAL

	&	7 :OR: 3<<3:OR:1<<12
Unset
	FNJSR
	MOV	R7,R0
	BL	validate_varname_wild
	BLEQ	bad_zap_variable
	FNRTS	VS
	CMP	R1,#32
	BLHI	bad_zap_variable
	FNRTS	VS
	SUB	R1,R0,R7
	MOV	R0,R7
	BL	make_varname
	FNRTS	VS
	MOV	R3,#0
wipe$l	MOV	R4,#0
	MOV	R2,#-1
	MOV	R1,#0
	FNLDR	R0,wimp_buffer
	SWI	XOS_SetVarVal
	BVC	wipe$l
	FNRTVC


	LOCAL

	&	7 :OR: 3<<3:OR:1<<12
Local
	TEQ	R4,#0
	MOVEQ	PC,R14
	FNJSR
loop$l	MOV	R7,R0
	BL	validate_varname	; get var name
	BEQ	bad$l
	MOV	R2,R0
spc$l	LDRB	R1,[R2],#1		; skip spaces after name, find comma
	TEQ	R1,#','
	BEQ	comma$l
	CMP	R1,#' '
	BEQ	spc$l
	BGT	bad$l
	MOVLT	R2,#0			; ...if end-of-string found
comma$l	MOV	R6,R2
	SUB	R1,R0,R7
	MOV	R5,R1
	MOV	R0,R7
	BL	make_varname
	FNLDR	R1,wimp_kbdbuf
	MOV	R2,#256
	MOV	R3,#0
	SWI	XOS_ReadVarVal		; get value & type
	MOVVS	R4,#-1
	MOVVS	R2,#0
	BICVC	R4,R4,#16
	ADD	R1,R5,#12		; we want (LEN name+LEN value+1+8)
	ADD	R1,R1,R2		;  bytes
	TEQ	R4,#2
	TEQNE	R4,#4
	ADDNE	R1,R1,#1		; plus one for null...
	BIC	R1,R1,#3
	FNLDR	R0,local_varlist
	TEQ	R0,#0
	ADDEQ	R1,R1,#4
	BL	heap_extend		; extend list by this amount
	FNRTS	VS
	FNLDR	R3,local_varlist
	FNSTR	R0,local_varlist
	TEQ	R3,#0
	LDRNE	R3,[R0]
	ADD	R1,R3,R1
	MOVEQ	R3,#4
	STR	R1,[R0],R3
	STMIA	R0!,{R2,R4}		; store value len & type
	MOV	R3,R2
	MOV	R1,R0
	FNLDR	R2,wimp_buffer
	ADD	R2,R2,#8
	BL	strcopy			; copy var name
	MOV	R2,R1
	FNLDR	R1,wimp_kbdbuf
	TEQ	R4,#2
	TEQNE	R4,#4
	MOVNE	R0,#0			; null-terminate space for value
	SUBNE	R3,R3,#1		;   if required
	STRNE	R0,[R2,R3]
	SWI	XZapRedraw_MoveBytes	; copy var value
	MOVS	R0,R6
	FNRTS	LE			; return if no more
spc2$l	LDRB	R1,[R0],#1		; skip spaces
	TEQ	R1,#' '
	BEQ	spc2$l
	SUB	R0,R0,#1
	B	loop$l			; and do next
bad$l	BL	bad_zap_variable
	FNRTS	VS


	LOCAL

typecheck
	FNJSR	"R1-R4"
	FNLDR	R3,if_count
	FNLDR	R2,if_stop
	SUB	R3,R3,#1
	CMP	R3,R2
	ADRLT	R0,nomatching$l
	BLT	fail$l
	FNLDR	R2,if_bits
	LDR	R2,[R2,R3,LSL #3]
	TEQ	R1,R2,LSR #28
	FNRTVC	EQ
	MOV	R1,R2,LSR #28
	ADR	R0,required$l
	ADD	R1,R1,#4
fail$l	ADR	R14,cmd$l
	LDRB	R4,[R14,R1]
	ADD	R4,R4,R14
	MOV	R2,#0
	BL	lookup_error
	FNRTS

nomatching$l
	&	0
	FNS	("zap_e_nostruct")
required$l
	&	0
	FNS	("zap_e_misstruct")
	ALIGN
cmd$l	=	 if$l-cmd$l, rep$l-cmd$l, whi$l-cmd$l, cas$l-cmd$l
	=	eif$l-cmd$l, unt$l-cmd$l, ewh$l-cmd$l, whn$l-cmd$l
if$l	=	"IF",0
rep$l	=	"REPEAT",0
whi$l	=	"WHILE",0
cas$l	=	"CASE",0
eif$l	=	"ENDIF",0
unt$l	=	"UNTIL",0
ewh$l	=	"ENDWHILE",0
whn$l	=	"WHEN, DEFAULT, ENDCASE",0
	ALIGN


; Functions

; function 'Char'
Char_fn
	MOV	R0,#0
	B	Charoff

	&	3<<22 :OR: 2<<24
Charoff
	MOV	R1,R0
	FNJSR	"R8-R10"
	BL	find_input			; please don't...
	LDR	R2,[R9,#f_ptr]
	LDR	R3,[R9,#f_splito]
	ADD	R0,R0,R1
	CMP	R0,R3
	LDRHS	R3,[R9,#f_splits]
	ADDHS	R2,R2,R3
	LDR	R3,[R9,#f_len]
	CMP	R0,R3
	LDRLOB	R0,[R2,R0]
	MVNHS	R0,#0
	MOV	R1,#1
	FNRTS

Returnchar_fn
;	FNJSR
 	CMP	R8,#0
	FNLDRB	R0,opt_cr,EQ
	LDRNEB	R0,[R8,#w_cr]
	MOV 	R1,#1	; byte
	MOV	PC,R14
;	FNRTS

Tabchar_fn
;	FNJSR
 	CMP	R8,#0
	FNLDRB	R0,opt_tabchar,EQ
	LDRNEB	R0,[R8,#w_tabc]
	MOV 	R1,#1	; byte
	MOV	PC,R14
;	FNRTS

	&	3<<22
Charstr
	MOV	R0,#0
	B	Charoffstr

	&	3<<22 :OR: 2<<24
Charoffstr
	FNJSR
	BL	Charoff
	MOV	R1,R0
	MOV	R0,#5
	BL	heap_claim
	FNRTS	VS
	MOV	R2,#0
	STR	R2,[R0]
	TEQ	R1,#0
	MOVMI	R1,#3
	FNRTS	MI
	LDRB	R2,[R8,#w_cr]
	TEQ	R1,R2
	ADREQ	R2,cr$l
	BEQ	wr$l
	LDRB	R2,[R8,#w_tabc]
	TEQ	R1,R2
	ADREQ	R2,tab$l
	BEQ	wr$l
	TEQ	R1,#127
	ADREQ	R2,del$l
	BEQ	wr$l
	CMP	R1,#32
	STRHS	R1,[R0]
	MOVHS	R1,#3
	FNRTS	HS
	BL	ctrllist
	ADD	R2,R2,R1,LSL #2
wr$l	MOV	R1,#'\'
	STRB	R1,[R0]
	LDRB	R1,[R2]
	STRB	R1,[R0,#1]
	LDRB	R1,[R2,#1]
	TEQ	R1,#0
	STRNEB	R1,[R0,#2]
	MOV	R1,#3
	FNRTS
cr$l	=	"n",0
tab$l	=	"t",0
del$l	=	"?",0
	ALIGN

	&	7 :OR: 3<<22
False	MOV	R0,#0
	MOV	R1,#2
	MOVS	PC,R14

; function 'Filename'
 DCD (1<<22+1<<23)
Filename
	CMP	R2,#23
	MOVNE	PC,R14
	FNJSR "R2"
	CMP	R9,#0
	ADREQ	R0,anull$l
	LDRNE	R2,[R9,#f_name]
	FNLDR	R1,wimp_block
	BL	strcopy
	FNLDR	R0,wimp_block
	MOV	R1,#3
	FNRTS
anull$l	 DCD	0

	&	7 :OR: 3<<22
True	MVN	R0,#0
	MOV	R1,#2
	MOVS	PC,R14

	LOCAL

	&	4 :OR: 3<<22
Modified
	FNJSR
	BL	test_changed
	MOVEQ	R0,#0
	MOVNE	R0,#-1
	MOV	R1,#2
	FNRTS

	&	7 :OR: 3<<22
Shift	MOV	R1,#255
inkey$l	MOV	R0,#129
	MOV	R2,#255
	SWI	XOS_Byte
	MOVCC	R0,#0
	MOVCS	R0,#-1
	MOV	R1,#2
	MOV	PC,R14

	&	7 :OR: 3<<22
Ctrl	MOV	R1,#254
	B	inkey$l

	&	7 :OR: 3<<22
Alt	MOV	R1,#253
	B	inkey$l

	&	7 :OR: 3<<22
Modifiers
	FNJSR
	BL	Shift
	AND	R3,R0,#1
	BL	Ctrl
	AND	R0,R0,#2
	ORR	R3,R3,R0
	BL	Shift
	AND	R0,R0,#4
	ORR	R0,R3,R0
	FNRTS

	LOCAL

	&	7 :OR: 3<<22
Select	MOV	R2,#4
mouse$l	SUB	R13,R13,#32
	MOV	R1,R13
	SWI	XWimp_GetPointerInfo
	LDRVC	R0,[R13,#8]
	ADD	R13,R13,#32
	MOVVS	PC,R14
	MOV	R1,#1
	TEQ	R2,#7
	MOVEQ	PC,R14
	ANDS	R0,R0,R2
	MOVNE	R0,#-1
	MOV	PC,R14

	&	3<<22
Menu	MOV	R2,#2
	B	mouse$l

	&	3<<22
Adjust	MOV	R2,#1
	B	mouse$l

	&	3<<22
Buttons	MOV	R2,#7
	B	mouse$l

; function 'Mode'
Mode_fn
	TEQ	R8,#0
	FNLDRB	R0,opt_format,EQ
	LDRNEB	R0,[R8,#w_format]	; mode number
	MOV	R1,#1
	MOVS	PC,R14

	LOCAL

; function 'Moden'
Moden_fn
	FNJSR
	BL	Mode_fn
	BL	read_mode
null$l	CMP	R1,#0
	LDRGT	R0,[R1,#8]
	ADRLE	R0,null$l
	MOV	R1,R0
	BL	str_len
	ADD	R0,R0,#1
	BL	heap_claim
	FNRTS	VS
	MOV	R2,R0
copy$l	LDRB	R3,[R1],#1
	CMP	R3,#'A'
	RSBHSS	R14,R3,#'Z'
	ADDHS	R3,R3,#32	; to lower case
	STRB	R3,[R2],#1
	TEQ	R3,#0
	BNE	copy$l
	MOV	R1,#3
	FNRTS

	&	1<<15 + 1<<23
Selanywhere
	CMP	R2,#15
	BEQ	shade_no_sel_at_all ; shdenosel$l
	CMP	R2,#23
	MOVNE	PC,R14
	FNJSR
	MOV	R7,R8
	BL	get_selection
	FNRTS	VS
	MOV	R1,#2
	MOVCC	R0,#-1
	MOVCS	R0,#0			; no sel = FALSE
	FNRTS
;shdenosel$l
;	B shade_no_sel_at_all

	&	1<<15 + 1<<23
Selhere
	FNJSR
	MOV	R7,R8
	TEQ	R2,#23			; was CMP!?
	BNE	shdenoselhere$l
	BL	get_selection		; corrupts R2...
	FNRTS	VS
	MOV	R1,#2
	TEQ	R7,R8
	MOVEQ	R0,#-1
	MOVNE	R0,#0
	MOVCS	R0,#0
	FNRTS
shdenoselhere$l
	BL	get_selection		; corrupts R2...
	FNRTS	VS
	MOV	R1,#2
	TEQ	R7,R8
	MOVEQ	R0,#0
	MOVNE	R0,#2
	MOVCS	R0,#2
	FNRTS

	&	3<<22
Selsize
	FNJSR
	MOV	R7,R8
	BL	get_selection
	FNRTS	VS
	MOV	R1,#2
	MOVCC	R0,R2
	MOVCS	R0,#-1
	FNRTS

	LOCAL

	&	3<<22 :OR: 3<<24
Ticked	MOV	R3,#1
tick$l
	FNJSR	"R10"
	MOV	R10,R0
	BL	read_one_command
	FNRTS	VS
	BL	check_arg_valid
	BVS	error$l
	LDR	R0,[R7,#-4]
	TST	R0,#1<<15
	BEQ	no_15$l
	STMFD	R13!,{R1,R6}
	MOV	R2,#15
	MOV	R0,R1
	BL	process_key_command
	LDMFD	R13!,{R1,R6}
	BVS	error$l
	TST	R0,R3
	MOVNE	R0,#-1
no_15$l	MOVEQ	R0,#0
	MOV	R1,#2
	FNRTS
error$l	MOV	R2,R0
	CMP	R6,#3
	MOV	R0,R1
	BL	heap_free
	MOV	R0,R2
	FNRTV

	&	3<<22 :OR: 3<<24
Greyed	MOV	R3,#2
	B	tick$l

	&	3<<22
Eof
	FNJSR	"R8-R10"
	BL	find_input
	LDR	R1,[R9,#f_len]
	TEQ	R0,R1
	MOVEQ	R0,#-1
	MOVNE	R0,#0
	MOV	R1,#2
	FNRTS

	&	3<<22
Sof
	FNJSR	"R8-R10"
	BL	find_input
	TEQ	R0,#0
	MOVEQ	R0,#-1
	MOVNE	R0,#0
	MOV	R1,#2
	FNRTS

	LOCAL

	&	7 :OR: 3<<22 :OR: 3<<24
In
	FNJSR
	MOV	R10,R0		; parameter string
	MOV	R11,R10
	BL	str_comma	; find comma
	CMP	R0,#32
	BLLO	badin_msg$l	; no comma? error
	FNRTS	VS
	MOV	R7,R0
	MOV	R0,#0
	STRB	R0,[R10,#-1]	; temporary NUL
	MOV	R0,R11
	MOV	R1,#256
	BL	evaluate_string	; evaluate (allow string or int)
	STRB	R7,[R10,#-1]
	FNRTS	VS
	MOV	R5,R0		; string to search for (if <>0)
	MOV	R6,R1		; int to search for (if R5=0)
	BL	compare_in
	MOVEQ	R2,#-1
	MOVNE	R2,#0
	MOVVS	R2,R0
	MOV	R0,R5
	BL	heap_free	; free the first string even if error
	MOV	R0,R2
	CMP	R0,#0
	MOVLE	R1,#2
	CMPLE	R1,R1		; ensure V clear
	FNRTS	EQ
	FNRTV
badin_msg$l
	ERR	"zap_e_insuffargs"


	LOCAL

;E R5,R6=arg (R5!=0 if string) R10=comma-separated list to compare agait
;X EQ if match found; R10 corrupt

compare_in
	FNJSR	"R1-R4,R7,R11"
loop$l	MOV	R11,R10		; start of current substring
	BL	str_comma	; find comma / EOS
	MOV	R7,R0
	MOV	R0,#0
	STRB	R0,[R10,#-1]	; temporary NUL
	MOV	R0,R11
	MOVS	R1,R5
	MOVNE	R1,#256		; allow string if first param was string
	BL	evaluate_string	; evaluate
	STRB	R7,[R10,#-1]
	BVS	err1$l
	TEQ	R5,#0
	BEQ	donum$l		; ... if an int was returned
	MOV	R4,R0		; we have a string
	MOVS	R1,R0		; are we looking for an int?
	BEQ	mismatch$l	; error if we are
	MOV	R2,R5
	BL	strcmp		; do the comparison
	BEQ	strmatch$l
	MOV	R0,R4		; no match
	BL	heap_free	; free the string
	LDRB	R0,[R10,#-1]
	CMP	R0,#32
	BHS	loop$l		; any more to compare against?
	FNRTS
strmatch$l
	MOV	R0,R4		; we have a matching string
	BL	heap_free	; - free it
match$l	CMP	R0,R0
	FNRTS
donum$l	TEQ	R0,#0		; comparing numbers... is this one?
	BNE	notnum$l	; ...no
	TEQ	R1,R6		; ...yes - does it match?
	BEQ	match$l		; ...yes - return -1
	LDRB	R0,[R10,#-1]	; ...no
	CMP	R0,#32
	BHS	loop$l		; any more to compare against?
	FNRTS
notnum$l
	BL	heap_free	; not a number (free the string)
mismatch$l
	ADR	R0,mismatch_msg$l
	MOV	R2,#0
	BL	lookup_error
err1$l	MOV	R7,R0		; error return
	MOVS	R0,R5
	BLNE	heap_free
	MOV	R0,R7
	FNRTV
mismatch_msg$l
	&	0
	FNS	("zap_e_listmismatch")

	LOCAL

	&	3<<22
ModeT
	MOV	R0,#14
	MOV	R1,#2
	MOV	R11,#e_interrogate
	B	call_mode

;E R0=pointer to key sequence blk ending in -1
;  (see buffer_strokes for format)
;X Key strokes executed (as a multiop) for input caret #

 DCD 7 :OR: 4<<3 :OR: 1<<28
Multicommand
execute_strokes
 FNJSR "R1-R11"
 FNLDR R1,if_count
 FNLDR R2,if_skip
 FNLDR R3,if_stop
 FNLDR R4,local_varlist
 STMFD R13!,{R1-R4}
 FNSTR R1,if_stop
 MOV R1,#0
 FNSTR R1,if_skip
 FNSTR R1,local_varlist
 MOV R6,R0			; save start of list
 FNLDR R5,key_flags		; preserve key_flags
 ORR R0,R5,#2			; set multi strokes flag
 BIC R0,R0,#&1D			; clear rest (only learn once)
 FNSTR R0,key_flags		; mark in the execute_strokes loop
 BL get_input_caret		; get input position
 BCS ret$l
 BL start_operation		; start operations on this file
loop$l
 LDR R7,[R6],#4			; next command address
 CMP R7,#0
 BLE end$l			; finished
 TST R7,#1
 BEQ got$l
 BL validate_command
 BVS end$l			; error
; BVS end$l			; error
 STR R7,[R6,#-4]		; new command address
got$l				; got a validated command
 ADD R6,R6,#4			; skip past data type
 LDR R1,[R6],#4			; number of times
 LDR R4,[R7,#-4]		; flags (abort?)
 AND R4,R4,#7<<3		; mask in data type
 CMP R4,#4<<3
 LDRCS R14,[R6,#-8]		; parameter type
 LDRCS R0,[R6],#4		; pointer to data block
 BCS gotdata$l
 MOV R0,R6			; start of data
 PUSH "R6"
 LDR R6,[R6,#-8];MOV R6,R4,LSR#3	; data type
 BL command_data		; find length
 PULL "R6"
 MOV R14,R0			; save the length
 MOV R0,R6			; data address
 ADD R6,R6,R14			; next command
 LDR R14,[R0,#-8]		; get parameter type
gotdata$l			; R0=command data
 ADRL R2,Repeat
 TEQ R7,R2
 ADDNE R2,R2,#While-Repeat
 TEQNE R7,R2
 ADDNE R2,R2,#Until-While
 TEQNE R7,R2
 ADDNE R2,R2,#Endwhile-Until
 TEQNE R7,R2
 ADDNE R2,R2,#Continue-Endwhile
 TEQNE R7,R2
 ADDNE R2,R2,#Break-Continue
 TEQNE R7,R2
 ADDNE R2,R2,#Local-Break
 TEQNE R7,R2
 MOV R2,R14,LSL #24		; normal call
 ORREQ R2,R2,#1<<30		; looping cmd call
 BL process_command		; do the command
 BVS end$l			; error
; BVS end$l
 BICS R0,R0,#&FC000003
 TSTNE R2,#1<<30
 MOVNE R6,R0
 MOV R4,R9			; save file
 BL get_input_caret		; may have changed due to the op
 MOVCS R9,R4
 BCS end$l			; we've lost it!
 TEQ R4,R9
 BEQ loop$l			; still on the same file
 PUSH "R9"
 MOV R9,R4
 BL stop_operation		; finished with that file
 PULL "R9"
 BLVC start_operation		; starting with this file
 BVC loop$l
 B ret$l
end$l				; end or error
 FNSTR R5,key_flags		; reset key flags
 BL stop_operation		; stop operation on this file
ret$l
 MOVVC R0,#0
 STMFD R13!,{R0}
 FNLDR R11,local_varlist
 TEQ R11,#0
 BEQ freedvar$l
 LDR R5,[R11]
 ADD R5,R5,R11
 ADD R11,R11,#4
freevar$l
 LDMIA R11!,{R2,R4}
 MOV R0,R11
svar$l
 LDRB R1,[R11],#1		; skip var name
 TEQ R1,#0
 BNE svar$l
 SUB R1,R11,R0			; so that R11 points to contents
 SUB R1,R1,#1
 BL make_varname
 MOV R1,R11
 CMP R4,#0
 MOVLT R2,#-1
 MOVLT R4,#0
 SWI XOS_SetVarVal		; restore variable (unset if necesary)
 TEQ R2,#0
 ADDPL R11,R11,R2
 ADD R11,R11,#3
 BIC R11,R11,#3
 CMP R11,R5
 BLT freevar$l
 FNLDR R0,local_varlist		; free local vars list
 BL heap_free
freedvar$l
 LDMFD R13,{R1-R3}
 FNLDR R4,if_bits
 FNLDR R5,if_count
freecase$l
 SUB R5,R5,#1
 CMP R5,R1
 BLT freedcase$l
 LDR R0,[R4,R5,LSL #3]
 MOV R14,R0,LSR #28
 TEQ R14,#3
 BICEQ R0,R0,#&FC000003
 BLEQ heap_free
 B freecase$l
freedcase$l
 LDMFD R13!,{R0-R4}
 FNSTR R1,if_count
 FNSTR R2,if_skip
 FNSTR R3,if_stop
 FNSTR R4,local_varlist
 TEQ R0,#0
 FNRTS EQ
 FNRTV



 END
