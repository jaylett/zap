; Contains processing command code and Zap command table.
; $Id: Commands,fff,v 2.19 2002/11/10 22:49:01 christian Exp $
; -*- armasm -*-

c_Conditional	* (1<<21)

	GET	h.ZapHeader
	GET	h.Messages
	GET	h.Template
	GET	h.CreateWind
	GET	h.KeyBits
	GET	h.MiniBuff
	GET	h.Heap
	GET	h.ModeBits
	GET	h.Cursors
	GET	h.AlterTxt
	GET	h.Search
	GET	h.CreateFile
	GET	h.Undo
	GET	h.Redraw
	GET	h.Strings
	GET	h.Menus
	GET	h.StartUp
	GET	h.StartCode
	GET	h.ModuleBits
	GET	h.Fonts
	GET	h.Mode1+2
	GET	h.Mode4
	GET	h.Mode11
	GET	h.Update
	GET	h.TMTVars
	GET	h.Execute
	GET	h.Boxes
	GET	h.TMFs
	GET	h.ModeBits
	GET	h.LineEditor

	IMPORT	Countmatches
	IMPORT	TotalSel
	IMPORT	WC
	IMPORT	WCSel
	IMPORT	Dzapbox
	IMPORT	Movebox
	IMPORT	Goto
	IMPORT	Infobox
	IMPORT	Mzapbox
	IMPORT	Printfile
	IMPORT	Quickprint
	IMPORT	Quit
	IMPORT	Replace
	IMPORT	Save
	IMPORT	Savelist
	IMPORT	Savesel
	IMPORT	Searchbuf
	IMPORT	Searchcur
	IMPORT	Tofrontlist
	IMPORT	Closelist
	IMPORT	CmdTHROWBACKflagstoggle

	IMPORT	get_DyingBox
	IMPORT	get_SaveBox
	IMPORT	get_SaveSelBox
	IMPORT	open_UndoBox
	IMPORT	message_send
	IMPORT	update_all_save_boxes
	IMPORT	char_del_dispatch

	EXPORT	add_command_table
	EXPORT	bad_zap_variable
	EXPORT	execute_strokes
	EXPORT	key_command_table
	EXPORT	reallysetwidth
	EXPORT	insertsomespaces
	EXPORT	shade_no_sel
	EXPORT	tellzapspell
	EXPORT	blat_cache_of_this_window
	EXPORT	shade_no_sel_at_all
	EXPORT	checktrue
	EXPORT	checklearn
	EXPORT	disknav_tick
	EXPORT	altesc
	EXPORT	query_abort

	EXPORT	Autosoftwrap
	EXPORT	Basemap
	EXPORT	Beep
	EXPORT	Break
	EXPORT	Cancel
	EXPORT	Cdown
	EXPORT	Char
	EXPORT	ClearGC
	EXPORT	CloneCreate
	EXPORT	Continue
	EXPORT	Copy
	EXPORT	Copysel
	EXPORT	Clearsel
	EXPORT	Command
	EXPORT	Cup
	EXPORT	Delete
	EXPORT	Endwhile
	EXPORT	Execute
	EXPORT	Insertgs
	EXPORT	Return
	EXPORT	Lastcylinder
	EXPORT	Lasttrack
	EXPORT	Lastsector
	EXPORT	Learn
	EXPORT	Local
	EXPORT	Moden
	EXPORT	Movesel
	EXPORT	Multicommand
	EXPORT	Nextcylinder
	EXPORT	Nexttrack
	EXPORT	Nextsector
	EXPORT	Null
	EXPORT	PasteGC
	EXPORT	Quote
	EXPORT	Repeat
	EXPORT	Mode
	EXPORT	Newfile
	EXPORT	Newtype
	EXPORT	Right
	EXPORT	Selregion
	EXPORT	Searchforward
	EXPORT	Searchback
	EXPORT	Tofront
	EXPORT	Until
	EXPORT	While

; define a new command $a=command name $b=label for the command

	MACRO
$la	FNcom $a,$b
$la	= "$a",0
	ALIGN
	DCD $b
	MEND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; KEY COMMAND TABLE					      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; command table in ALPHABETICAL order (so can do binary search)
; and so we have no duplications

key_command_table
	DCD	key_command_table		; offset from module start
	DCD	0				; flags (don't kill module)
;;;;;;;;;;;; FNcom "ADDLF",Addlf
;;;;;;;;;;;; FNcom "ADDLFSEL",Addlfsel
	FNcom	"ALLFILES",Allfiles
	FNcom	"ALLMODES",Allmodes	; ALLOPTIONS?
	FNcom	"ALLWINDOWS",Allwindows
	FNcom	"ALTERSEL",Altersel
	FNcom	"ASYOUTYPE",Spellasyoutype
	FNcom	"AUTOINDENT",Autoindent
	FNcom	"AUTOSOFTWRAP",Autosoftwrap
	FNcom	"BASEMAP",Basemap
	FNcom	"BASEMAPLIST",Basemaplist
	FNcom	"BASEMAPN",Basemapn
	FNcom	"BASIC",Basic
	FNcom	"BEEP",Beep
	FNcom	"BINDTOKEY",Bindtokey
	FNcom	"BITMAPLIST",Bitmaplist
	FNcom	"BITMAPFONT",Bitmapfont
	FNcom	"BYTE_CONTROLREPLACE",CmdBYTEctrlreplace
	FNcom	"BYTE_FLAGSTOGGLE",CmdBYTEflagstoggle
	FNcom	"BYTE_GROUPSIZE",CmdBYTEgroupsize
	FNcom	"CANCEL",Cancel
	FNcom	"CDOWN",Cdown
	FNcom	"CHAR",Char
	FNcom	"CLEARSEL",Clearsel
	FNcom	"CLEARGC",ClearGC
	FNcom	"CLEFT",Cleft
	FNcom	"CLI",Cli
	FNcom	"CLONEBASE",CloneBase
	FNcom	"CLONEBOX",Clonebox
	FNcom	"CLONECREATE",CloneCreate
	FNcom	"CLONEDELETE",CloneDelete
	FNcom	"CLONEHIDE",CloneHide
	FNcom	"CLOSEFILE",Deletefile
	FNcom	"CLOSELIST",Closelist
	FNcom	"CLOSEOTHER",Closeother
	FNcom	"CLOSEPRINTER",Closeprinter
	FNcom	"CLOSEWINDOW",Closewindow
	FNcom	"CODE_FLAGSTOGGLE",CmdCODEflagstoggle
	FNcom	"CODE_DISASMTOGGLE",Code_disasmtoggle
	FNcom	"COLONSEPARATOR",Colonseparator
	FNcom	"COLOURLIST",Colourlist
	FNcom	"COLUMNTAB",Columntab
	FNcom	"COMMAND",Command
	FNcom	"COMPILE",Compile
	FNcom	"CONFINEHORIZONTALLY",Confinehorizontally
	FNcom	"CONFINEVERTICALLY",Confinevertically
	FNcom	"COPY",Copy
	FNcom	"COPYSEL",Copysel
	FNcom	"COREDUMP",Coredump
	FNcom	"COUNTMATCHES",Countmatches
	FNcom	"CREATEFILE",Createfile
; FNcom "CRASH",Crash ; !!!!!!!!!!
; FNcom "CRUNCH",Crunch ; !!!!!!!!!!
; FNcom "CRUMPLE",Crumple ; !!!!!!!!!!
	FNcom	"CRIGHT",Cright
	FNcom	"CUP",Cup
	FNcom	"CURSORMENU",Cursormenu
	FNcom	"CUT",Cut
	FNcom	"DATE",Date
	FNcom	"DEFAULTMAP",Defaultmap
	FNcom	"DELETE",Delete
	FNcom	"DELETENEXT",Deletenext
	FNcom	"DELETENEXTNOCOPY",Deletenextnocopy
	FNcom	"DELLINE",Delline
	FNcom	"DELTOEND",Deltoend
	FNcom	"DELTOSTART",Deltostart
	FNcom	"DELWORDEND",Deletewordnext
	FNcom	"DELWORDSTART",Deletewordprev
	FNcom	"DISCARDFILE",discard_file
	FNcom	"DISCARDWINDOW",discard_window
	FNcom	"DOUBLEWORD_CONTROLREPLACE",CmdDOUBLEWORDctrlreplace
	FNcom	"DOUBLEWORD_FLAGSTOGGLE",CmdDOUBLEWORDflagstoggle
	FNcom	"DOUBLEWORD_GROUPSIZE",CmdDOUBLEWORDgroupsize
	FNcom	"DOWN",Down
	FNcom	"DUMPFILE",Dumpfile
	FNcom	"DZAPBOX",Dzapbox
	FNcom	"EMACS",Emacs
	FNcom	"ESCAPE",Escape
	FNcom	"EXECUTE",Execute
	FNcom	"FASTUNDO",Fastundo
	FNcom	"FFLAGS_TOGGLE",Fflags_toggle
	FNcom	"FINDFILE",Findfile
	FNcom	"FINDFILEREADONLY",Findfilereadonly
	FNcom	"FINDFUNCTION",Findfunction
	FNcom	"FONTASPECT",Fontaspect			; in s.Fonts
	FNcom	"FONTLIST",Fontlist
; FNcom "FONTOFFSETS",Fontoffsets
	FNcom	"FONTSIZE",Fontsize			; in s.Fonts
	FNcom	"FONTTYPE",Fonttype
	FNcom	"FORMATTEXT",Formattext
	FNcom	"FREECLICK",Freeclick
	FNcom	"FULLUNDO",Fullundo
	FNcom	"GETMODULE",Getmodule
	FNcom	"GETVAR",Getvar
	FNcom	"GETWORKSPACE",Getworkspace
	FNcom	"GETDYNAMICAREA",Getdynamicarea
	FNcom	"GOTO",Goto
; FNcom "GOTOADDR",Gotoaddr
	FNcom	"HALFWORD_CONTROLREPLACE",CmdHALFWORDctrlreplace
	FNcom	"HALFWORD_FLAGSTOGGLE",CmdHALFWORDflagstoggle
	FNcom	"HALFWORD_GROUPSIZE",CmdHALFWORDgroupsize
	FNcom	"HELP",Help
	FNcom	"HELPCOM",Helpcom
	FNcom	"HELPFN",Helpfn
	FNcom	"HELPKEY",Helpkey
	FNcom	"HELPVAR",Helpvar
	FNcom	"HEXASCII",Hexascii
	FNcom	"ICONISE",Iconise
	FNcom	"INDENT",Indent
	FNcom	"INDENTBY",Indentby
	FNcom	"INDIRECT",Indirect
	FNcom	"INFINITEWRAP",Infinitewrap
	FNcom	"INFOBOX",Infobox
	FNcom	"INSERT",Insert
	FNcom	"INSERTBLOCK",Insertblock
	FNcom	"INSERTBLOCKGS",Insertblockgs
	FNcom	"INSERTDATE",Insertdate
	FNcom	"INSERTGS",Insertgs
	FNcom	"INSERTTIME",Inserttime
	FNcom	"INSTALLICON",Installicon
	FNcom	"JOINLINE",Joinline
	FNcom	"KEEPREGION",Keepregion
	FNcom	"KEYMAP",Keymap
	FNcom	"KEYMAPN",Keymapn
	FNcom	"KILLFILES",Killfiles
	FNcom	"LASTCYLINDER",Lastcylinder
	FNcom	"LASTMARK",Lastmark
	FNcom	"LASTMATCH",Lastmatch
	FNcom	"LASTSECTOR",Lastsector
	FNcom	"LASTTRACK",Lasttrack
	FNcom	"LEARN",Learn
	FNcom	"LEFT",Left
	FNcom	"LINEEDIT",Lineedit
	FNcom	"LINENOS",Linenos
	FNcom	"LINESELECT",Lineselect
	FNcom	"LINESPACING",Linespacing
	FNcom	"LINEWRAP",Linewrap
 ;FNcom "LISTFILES",Listfiles
	FNcom	"LISTFNS",Listfns
	FNcom	"LOADMODULE",Loadmodule
	FNcom	"LOCALPASTE",Paste
	FNcom	"MAKEDEFAULT",Makedefault
	FNcom	"MARGIN",Margin
	FNcom	"MENUOPEN",Menuopen
; FNcom "MCV",Mcv
; FNcom "MENUCOMMAND",Menucommand
; FNcom "MINIFONT",Minifont
	FNcom	"MINIMENU",Minimenu
	FNcom	"MINIMISEMEMORY",minimise_memory
	FNcom	"MISCOPS",Miscops
	FNcom	"MODE",Mode
	FNcom	"MODELIST",Modelist
	FNcom	"MODEN",Moden
	FNcom	"MODENMENU",Modenmenu
	FNcom	"MOVEBOX",Movebox
	FNcom	"MOVESEL",Movesel
	FNcom	"MULTICOMMAND",Multicommand
	FNcom	"MZAPBOX",Mzapbox
	FNcom	"NEWFILE",Newfile
	FNcom	"NEWTYPE",Newtype
	FNcom	"NEWVIEW",Newview
	FNcom	"NEWVIEWLIST",Newviewlist
	FNcom	"NEXTCYLINDER",Nextcylinder
	FNcom	"NEXTMARK",Nextmark
	FNcom	"NEXTMATCH",Nextmatch
	FNcom	"NEXTSECTOR",Nextsector
	FNcom	"NEXTTRACK",Nexttrack
	FNcom	"NONSTANDARD",Nonstandard
; FNcom "NOSUBSTYLES",Nosubstyles
	FNcom	"NULL",Null
	FNcom	"OPENPARENT",Openparent
	FNcom	"OPENPRINTER",Openprinter
	FNcom	"OSCLI",Oscli
	FNcom	"OUTDENT",Outdent
	FNcom	"OUTLINEFONT",Outlinefont
	FNcom	"OWNEDBY",OwnedBy
	FNcom	"PASTE",PasteGC
	FNcom	"PASSTHROUGH",Passthrough
; FNcom "PASTEGC",PasteGC
	FNcom	"PRINTFILE",Printfile
	FNcom	"QUICKPRINT",Quickprint
	FNcom	"QUICKSAVE",Quicksave
	FNcom	"QUIT",Quit
	FNcom	"QUOTE",Quote
	FNcom	"READONLY",Readonly
	FNcom	"REDO",Redo
	FNcom	"RELOADKEYS",Reloadkeys
;;;;;;;;;;;;;;;;;;; FNcom "REMOVELF",Removelf
;;;;;;;;;;;;;;;;;;; FNcom "REMOVELFSEL",Removelfsel
	FNcom	"REMOVELIST",Removelist
	FNcom	"RENUMBER",Renumber
	FNcom	"REPLACE",Replace
	FNcom	"RETURN",Return
	FNcom	"RETURNCHAR",Returnchar
	FNcom	"RETURNNOINDENT",Returnnoindent
	FNcom	"RIGHT",Right
	FNcom	"RUN",Run
	FNcom	"RUNANDQUIT",Runandquit
	FNcom	"SAVE",Save
	FNcom	"SAVEANDRUN",Saveandrun
	FNcom	"SAVEFILE",Savefile
	FNcom	"SAVELIST",Savelist
	FNcom	"SAVEOPTIONS",Saveoptions
	FNcom	"SAVESEL",Savesel
	FNcom	"SCDOWN",Scdown
	FNcom	"SCLEFT",Scleft
	FNcom	"SCRIGHT",Scright
	FNcom	"SCUP",Scup
	FNcom	"SDOWN",Sdown
	FNcom	"SEARCHBACK",Searchback
	FNcom	"SEARCHBUF",Searchbuf
	FNcom	"SEARCHCUR",Searchcur
	FNcom	"SEARCHFORWARD",Searchforward
	FNcom	"SELECTBUFFER",Selectbuffer
	FNcom	"SELECTLINE",Selectline
	FNcom	"SELREGION",Selregion
	FNcom	"DROPMARK",Dropmark
	FNcom	"SENDSEL",Sendsel
	FNcom	"SETMARGINWIDTH",Setmarginwidth
	FNcom	"SETWIDTH",Setwidth
	FNcom	"SLEFT",Sleft
	FNcom	"SOFTWRAP",Softwrap
	FNcom	"SPLITLINE",Splitline
	FNcom	"SRIGHT",Sright
	FNcom	"STARTADDR",Startaddr
	FNcom	"STARTLINE",Startline
	FNcom	"STARTOP",Startop
	FNcom	"STILLDOWN",Stilldown
	FNcom	"STILLUP",Stillup
	FNcom	"STOPOP",Stopop
	FNcom	"STRIPSPACES",Stripspaces
; FNcom "STRONGSOFTWRAP",Strongsoftwrap
	FNcom	"SUP",Sup
	FNcom	"SUSPEND",Suspend
; FNcom "SWAPCASE",Swapcase
	FNcom	"SWAPCHARS",Swapchars
	FNcom	"SWAPWINDOW",Swapwindow
	FNcom	"SWITCHTAB",Switchtab
	FNcom	"TAB",Tab
	FNcom	"TABCHAR",Tabchar
	FNcom	"TABDISPLAY",Tabdisplay
	FNcom	"TABMODE",Tabmode
	FNcom	"TABSASSPACES",Tabsasspaces
	FNcom	"THROWBACK_FLAGSTOGGLE",CmdTHROWBACKflagstoggle
	FNcom	"TOBACK",Toback
	FNcom	"TOFRONT",Tofront
	FNcom	"TOFRONTLIST",Tofrontlist
	FNcom	"TOGGLEHEX",Togglehex
	FNcom	"TOGGLEINSERT",Toggleinsert
	FNcom	"TOGGLEMARK",Togglemark
	FNcom	"TOGGLEUNDO",Toggleundo
	FNcom	"TOGGLEWIND",Togglewind
	FNcom	"TOTALSEL",TotalSel
	FNcom	"TYPELIST",Typelist
	FNcom	"UNIVERSALARG",Universalarg
;;;;;;;;;;;;; FNcom "UNSPACE",Unspace
	FNcom	"UP",Up
	FNcom	"UPDATEWINDOW",Updatewindow
	FNcom	"WC",WC
	FNcom	"WCSEL",WCSel
	FNcom	"WFLAGS_ALTER",Wflags_alter
	FNcom	"WFLAGS_TOGGLE",Wflags_toggle
	FNcom	"WFORMAT_ALTER",Wformat_alter
	FNcom	"WFORMAT_TOGGLE",Wformat_toggle
	FNcom	"WINFO_ALTER",Winfo_alter
	FNcom	"WINFO_TOGGLE",Winfo_toggle
	FNcom	"WIMPTASK",Wimptask
	FNcom	"WINDOWWRAP",Windowwrap
	FNcom	"WORDWRAP",Wordwrap
	FNcom	"EDITBYTE",Editbyte
	FNcom	"EDITHALFWORD",Edithalfword
	FNcom	"EDITWORD",Editword
	FNcom	"WORD_CONTROLREPLACE",CmdWORDctrlreplace
	FNcom	"WORD_FLAGSTOGGLE",CmdWORDflagstoggle
	FNcom	"WORD_GROUPSIZE",CmdWORDgroupsize
	FNcom	"WRAPWIDTH",Wrapwidth
	FNcom	"WRITEBUFFER",Writebuffer
	FNcom	"WRITEFILE",Writefile
	FNcom	"YANK",Yank

; Temp home for Darren's functions and related comands...
	FNcom	"BREAK",Break
	FNcom	"CASE",Case
	FNcom	"CONTINUE",Continue
	FNcom	"CWHEN",CWhen
	FNcom	"DEFAULT",Default
	FNcom	"ELSE",Else
	FNcom	"ENDCASE",Endcase
	FNcom	"ENDIF",Endif
	FNcom	"ENDWHILE",Endwhile
	FNcom	"IF",If
	FNcom	"LOCAL",Local
	FNcom	"REPEAT",Repeat
	FNcom	"SET",Set
	FNcom	"UNSET",Unset
	FNcom	"UNTIL",Until
	FNcom	"WHILE",While
	FNcom	"WHEN",When
;  The following are functions, for testing IF
	FNcom	"ADJUST",Adjust
	FNcom	"ALT",Alt
	FNcom	"BUTTONS",Buttons
	FNcom	"CHAROFF",Charoff
	FNcom	"CHAROFFSTR",Charoffstr
	FNcom	"CHARSTR",Charstr
	FNcom	"CTRL",Ctrl
	FNcom	"EOF",Eof
	FNcom	"FALSE",False
	FNcom	"FILENAME",Filename
	FNcom	"GREYED",Greyed
	FNcom	"IN",In
	FNcom	"MATCH",Match
	FNcom	"MENU",Menu
	FNcom	"MODET",ModeT
	FNcom	"MODIFIED",Modified
	FNcom	"MODIFIERS",Modifiers
	FNcom	"SELANYWHERE",Selanywhere
	FNcom	"SELECT",Select
	FNcom	"SELHERE",Selhere
	FNcom	"SELSIZE",Selsize
	FNcom	"SHIFT",Shift
	FNcom	"SOF",Sof
	FNcom	"TICKED",Ticked
	FNcom	"TRUE",True

	DCD	0				; end of table

	ALIGN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; KEY COMMAND SUBS					      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

	DCD	7+c_Param_String+c_PreMinibuffer+c_MovesInputOrKeymap
Allfiles
	CMP	R2,#6
	ADREQ	R0,s$l
	MOVEQ	R1,#lineed_buf_zapcommand
	BEQ	minibuffer_prompt_token_and_history
	ADR	R10,callallroutine$l
	B	do_allfiles
s$l
	FNS	("zap_p_allfiles")
callallroutine$l
	FNJSR	"R0-R12"
	MOV	R8,#0
	BL	command_string
	STRVS	R0,[R13]			; report errors...
	FNRTS

	LOCAL

	DCD	7+c_Param_String+c_PreMinibuffer+c_MovesInputOrKeymap
Allmodes
	CMP	R2,#6
	ADREQ	R0,s$l
	MOVEQ	R1,#lineed_buf_zapcommand
	BEQ	minibuffer_prompt_token_and_history
	FNJSR
	MOV	R7,R0
	LDRB	R0,[R7]
	TEQ	R0,#':'
	ADDEQ	R7,R7,#1
	MOVNE	R8,#0
 ; suspicious code to deal with *other modes.*..!?
	BL	get_wind_off
	MOVS	R6,R0
	FNLDRB	R11,opt_format,MI
	LDRPLB	R11,[R8,#w_format]
	MOV	R5,#0			; start mode
a$l	MOV	R0,R6
	BL	conv_wind_off
	TEQ	R8,#0			; were we given a window?
	BNE	ok$l
	CMP	R0,#0			; has it been closed?
	FNRTS	PL			; ... yes - return
ok$l	MOV	R0,R5
	BL	read_mode
	TEQ	R0,#0
	BEQ	next$l
	MOV	R0,R5
	BL	mode$l
	BL	callallroutine2$l
next$l	ADD	R5,R5,#1
	CMP	R5,#max_mode
	BCC	a$l
	MOV	R0,R11
	BL	mode$l
	FNRTS
s$l
	FNS	("zap_p_allmodes")

callallroutine2$l
	FNJSR	"R0-R12"
	ORR	R0,R7,#1<<31
	MOV	R10,#0
	BL	command_string		; execute the string
	STRVS	R0,[R13]
	FNRTS

mode$l	TEQ	R6,#0
	BPL	new_mode
	B	tochangeibmode		; change mode from IB first!!!

	LOCAL

	DCD	7+c_Param_String+c_PreMinibuffer+c_MovesInputOrKeymap
Allwindows
	CMP	R2,#6
	ADREQ	R0,s$l
	MOVEQ	R1,#lineed_buf_zapcommand
	BEQ	minibuffer_prompt_token_and_history
	FNJSR
	ADR	R10,callallroutine$l
	MOV	R7,R0
	BL	do_allwindow
	CMP	R8,#0
	BLNE	enter_window
	CMP	R8,#0
	MOVEQ	R0,#0
	BLEQ	set_caret_mode		; no caret
	FNRTS
callallroutine$l
	FNJSR	"R0-R12"
	BL	enter_window
	MOV	R0,R7
	BL	command_string		; execute the string
	STRVS	R0,[R13]
	FNRTS
s$l	FNS	("zap_p_allwindows")

	LOCAL

	DCD	0
Altersel
	FNJSR
	MOV	R6,R8
	MOV	R7,R9
	BL	get_selection
	TEQ	R6,R8
	SUBNES	R8,R6,#0
	MOV	R9,R7
	ADD	R4,R1,R2,LSR	#1
	ADD	R3,R1,R2
	MOV	R2,R1
	LDR	R0,[R10,#c_off]
	ADDCS	R3,R0,#1
	CMPCC	R4,R0
	MOVHS	R2,R0
	MOVLO	R3,R0
	BL	select_region		; alter_selection
	FNRTS

	LOCAL

	DCD	7+c_TickableMenuEntry
Autoindent
	MOV	R0,#0
	MOV	R1,#1<<16
	B	new_wind_format_set

	DCD	7+c_TickableMenuEntry
Autosoftwrap
	FNJSR
	MOV	R0,#0		; clear nothing
	MOV	R1,#1<<22		; toggle windowwrap
	BL	new_wind_format_set
	BLVC	test_for_sw
	FNRTS

	LOCAL
;	now produces tickable menu entries...
	DCD	7+c_Param_Words+c_TickableMenuEntry+c_CommandAndFunction+c_MovesInputOrKeymap
Basemap
	TEQ	R2,#15
	BEQ	tick$l
	TEQ	R2,#23
	BEQ	function$l
	SUB	R1,R1,#1
	LDR	R0,[R0,R1,LSL#2]		; last word in list
basemap_entry
	FNJSR	"R0"
	BL	find_key_table
	FNPULL
	BPL	put_basemap$l
	B	bad_keymap
function$l
	FNJSR
	BL	get_basemap$l
	MOV	R1,#1
	FNRTS
tick$l	SUB	R1,R1,#1
	LDR	R0,[R0,R1,LSL#2]		; last word in list
tick_keymap
	CMP	R8,#0
	BEQ	ibtick$l
	LDRB	R2,[R8,#w_basemap]
	CMP	R2,R0
	MOVNE	R0,#0
	MOVEQ	R0,#1
	MOV	PC,R14
ibtick$l
	FNJSR	"R2"
	MOV	R2,R0
	BL	get_basemap$l
	CMP	R2,R0
	MOVNE	R0,#0
	MOVEQ	R0,#1
	FNRTS

get_basemap$l
	CMP	R8,#0
	LDRNEB	R0,[R8,#w_basemap]
	MOVNE	PC,R14
	MOV	R0,#-1
	FNJSR	"R1,R2"
	FNLDRB	R1,opt_format
	MOV	R2,#2
	BL	mode_data			; mode's base map
	AND	R0,R0,#&FF			; mask out rest...
	FNRTS
put_basemap$l
	CMP	R8,#0
	BEQ	putoptbasemap$l
	STRB	R0,[R8,#w_basemap]	; this is a convenience copy...
	STRB	R0,[R8,#w_currentmap]
	STRB	R0,[R8,#w_helpmap]
	MOV	PC,R14
putoptbasemap$l
	FNJSR	"R0-R2"
	MOV	R0,#-1
	FNLDRB	R1,opt_format
	MOV	R2,#2
	BL	mode_data			; mode's base map in low byte
	LDR	R14,[R13]
	BIC	R0,R0,#255
	ORR	R0,R0,R14
	FNLDRB	R1,opt_format
	MOV	R2,#2
	BL	mode_data
	FNRTS

	LOCAL

	&	c_Param_String+c_PreMinibuffer+c_CommandAndFunction+c_MovesInputOrKeymap
Basemapn
	TEQ	R2,#23
	LDREQB	R0,[R8,#w_basemap]
	FNJSR
	BEQ	keymap_name
	TEQ	R2,#6
	BEQ	prompt$l
	BL	find_key_table_number
	TEQ	R2,#15
	BEQ	tick_keymap
	TEQ	R0,#0
	FNPULL
	BNE	basemap_entry
	B	bad_keymap
prompt$l
	ADR	R0,s$l
	FNPULL
	MOV	R1,#lineed_buf_keymap
	B	minibuffer_prompt_token_and_history
s$l	FNS	("zap_p_basemap")
keymap_name ; R14 on stack
	BL	find_key_table
	TEQ	R0,#0
	LDRNE	R1,[R0,#16]
	TEQNE	R1,#0
	MOVEQ	R0,#0
	BLNE	strdup
	MOV	R1,#3
	FNRTS

	DCD	7
Beep
	FNJSR
	FNLDR	R14,opt_switches
	TST	R14,#switch_InhibitBeeping
	SWIEQ	&20107			; BEEP command
	FNRTS

	LOCAL

	DCD	c_Param_String+c_PreMinibuffer+c_MinibufferKey+c_MovesInputOrKeymap
Bindtokey
	FNJSR
	FNLDR	R14,key_flags		; turn off learn mode
	BIC	R14,R14,#4		; turn off learn mode
	FNSTR	R14,key_flags		; turn off learn mode
	TEQ	R2,#6
	BEQ	p$l
	SUB	R1,R2,#&8000
	CMP	R1,#&200
	BCC	prekey$l		; user has pressed a key
	BL	minibuffer_eval		; read num in R0
	FNRTS	VS
	FNRTS	CS
	MOV	R1,R0
	LDRB	R0,[R8,#w_basemap]
	BL	find_key_entry		; R0=entry address (don't validate th
	FNRTS	VS			; command as we're overwriting it!)
	CMP	R0,#0
	FNRTS	LE
	MOV	R4,R0			; save address of key entry
	FNLDR	R3,key_llen		; current length of learnt string
	ADD	R0,R3,#4		; add room for -1 at end
	BL	heap_claim
	FNRTS	VS			; claim a block for it
	MOV	R2,R0			; dest
	ADD	R3,R3,#4		; len (inc -1)
	FNLDR	R1,key_learn		; source
	ADRL	R0,Multicommand
	STR	R0,[R4]			; command address
	STR	R2,[R4,#4]		; data parameter
	SWI	XZapRedraw_MoveBytes	; copy the data into the block
	FNRTS
prekey$l
	MOV	R0,R1			; number
	TEQ	R0,#&1B			; escape?
	FNRTS	EQ			; pass on if so
	FNLDR	R1,wimp_kbdbuf
	MOV	R2,#16
	SWI	XOS_ConvertHex4
	MOVVC	R14,#'&'
	STRVCB	R14,[R0]		; put & at start
	BLVC	minibuffer_write
	MOVVC	R0,#&8000001D		; return operation finished
	FNRTS
p$l	FNPULL
	ADR	R0,s$l
	MOV	R1,#lineed_buf_keymap
	B	minibuffer_prompt_token_and_history
s$l
	FNS	("zap_p_bindtokey")

	DCD	7+c_TickableMenuEntry
Basic
	CMP	R2,#15
	BEQ	returnifonibmenu
	FNJSR
	MOV	R11,#e_basic
	BL	call_mode
	FNRTS

	DCD	7+c_Param_String+c_PreMinibuffer+c_TrojanCommand+c_MinibufferTabCompletion	; tabs for filenames
Cli
	MOV	R3,#0
	B	os_cli

	DCD	0
Cancel
	B	yank_cancel		; cancel any yank operation

	DCD	7+c_TickableMenuEntry
Clearsel
	FNJSR
	BL	shade_no_sel_at_all
	FNRTS	CS

	MOV	R14,#1
	FNSTR	R14,clk_depth		; current click depth

	BL	caret_writable		; make caret 1,2
	BLVC	clear_selection
	FNRTS

	DCD	7+c_TrojanCommand+c_TickableMenuEntry
Compile
	CMP	R2,#15
	BEQ	returnifonibmenu
	MOV	R11,#e_compile
	B	call_mode

	DCD	0
Cleft
	MVN	R2,#2
	MOV	R3,#0
	B	move_cursor

	DCD	0
Cright
	MOV	R2,#3
	MOV	R3,#0
	B	move_cursor

	DCD	0
Cdown
	FNJSR
	BL	get_cursor_caret
	LDR	R0,[R9,#f_len]
	BL	goto_offset
	FNRTS

	DCD	8+c_UniversalArg+c_CommandAndFunction	; byte input
Char
	TEQ	R2,#23
	BEQ	Char_fn
	FNJSR
	MOV	R7,R0			; save address of data
	PUSH	"R0"
	MOV	R5,R1			; save number of bytes
	LDR	R6,[R8,#w_format]
	LDR	R4,[R8,#w_flags]
	MOV	R11,#e_char
	BL	call_mode		; insert the chars
	BVS	problemexit
	PULL	"R0"
	BL	tellzapspell
	FNRTS
problemexit
	PULL	"R14"
	FNRTS
tellzapspell				; expects R0, pointer to char, R5 = 1
	FNJSR				;  "R10"
	LDR	R14,[R8,#w_info]
	TST	R14,#1<<7
	FNRTS	EQ
	CMP	R5,#1			; /how/ many characters...?
	FNRTS	GT
	STR	R0,local_key_number
	LDR	R0,spellasyoutypenum
	BLEQ	getsaytnom
	CMP	R0,#0
	FNRTS	EQ
	PUSH	"R1-R12"
	MOV	R7,R0
	LDR	R0,local_key_number
	MOV	R1,#4
	MOV	R2,#1<<31		; don't learn
	BL	process_command
	PULL	"R1-R12"
	ADDS	R14,R14,#0		; no error - already reported...
	FNRTS

getsaytnom
	FNJSR
	ADR	R0,spellasyoutypenamed
	BL	find_key_command
	STR	R0,spellasyoutypenum
	FNRTS

local_key_number
	DCD	0

spellasyoutypenum
	DCD	0

spellasyoutypenamed
	FNS ("SPELL_ASYOUTYPE")

	DCD	7+c_TickableMenuEntry
ClearGC
	FNLDR	R0,opt_switches
	CMP	R2,#15
	BEQ	tick$l
	BIC	R0,R0,#bit_got_gclip
	FNSTR	R0,opt_switches
	MOV	PC,R14
tick$l
	ANDS	R0,R0,#bit_got_gclip
	MOVEQ	R0,#2
	MOVNE	R0,#0
	MOV	PC,R14

	LOCAL

	DCD	7+c_Param_String+c_TickableMenuEntry
CloneBase
	TEQ	R2,#15
	MOVNE	PC,R14
	FNJSR
	BL	test_mode_name
	CMP	R0,#0
	MOVMI	R0,#2
	FNRTS	MI
	BL	isthisaclonebase	; we just want the mode numbers
	CMP	R14,#-1
	CMPNE	R0,R14
	MOVEQ	R0,#0
	MOVNE	R0,#2
	FNRTS

	LOCAL

	DCD	7+c_Param_String+c_PreMinibuffer+c_TrojanCommand
CloneCreate
	TEQ	R2,#6
	ADREQ	R0,p$l
	MOVEQ	R1,#lineed_buf_mode
	BEQ	minibuffer_prompt_token_and_history
	FNJSR
	SUB	R6,R0,#1
	BL	str$l			; get clone name
	SUBS	R3,R7,R6
	ADREQ	R0,noclone$l
	BEQ	error$l
	CMP	R3,#10
	ADRHI	R0,badclone$l
	BHI	error$l
	FNLDR	R1,wimp_kbdbuf		; copy clone name
	MOV	R2,R6
	ADD	R3,R3,#1
	MOV	R4,#32
	BL	strmove
	FNLDR	R0,wimp_kbdbuf
	BL	test_mode_name		; does a mode of this name exist?
	CMP	R0,#0
	ADRGE	R0,cloneexists$l	; if so, error
	FNLDR	R4,wimp_kbdbuf
	BGE	error$l
	MOV	R0,R4
	BL	find_ext_mode
	ADRNE	R0,cloneexists$l
	BNE	error$l
	FNLDR	R1,wimp_kbdbuf
	BL	find_clone_mode_entry
	TEQ	R0,#0
	ADRNE	R0,cloneexists$l
	BNE	error$l
	MOV	R6,R7			; get clone base name
	BL	str$l
	SUBS	R3,R7,R6
	ADREQ	R0,noclonebase$l
	BEQ	error$l
	MOV	R0,R6
	BL	find_mode_number
	TEQ	R0,#0
	ADRMI	R0,clonefail$l
	BMI	error$l
	BL	read_mode
	LDR	R0,[R1,#e_mode*2]
	TST	R0,#emode_MayBeCloned
	ADREQ	R0,cantclone$l
	MOVEQ	R4,R6
	BEQ	error$l
	FNLDR	R1,wimp_kbdbuf		; copy clone base name
s$l	LDRB	R0,[R1],#1
	TEQ	R0,#0
	BNE	s$l
	MOV	R2,R6
	MOV	R3,#48
	MOV	R4,#32
	BL	strmove
	FNLDR	R1,wimp_kbdbuf
	BL	add_clone_mode_entry
	FNLDR	R0,wimp_kbdbuf,VC
	BLVC	find_mode_number	; create the clone mode
	FNRTS	VS
	TEQ	R0,#0
	FNRTS	PL
	ADR	R0,clonefail$l
error$l	FNPULL
	B	lookup_error

str$l	LDRB	R0,[R6,#1]!
	TEQ	R0,#32
	BEQ	str$l
	SUB	R7,R6,#1
find$l	LDRB	R0,[R7,#1]!
	CMP	R0,#32
	BHI	find$l
	MOV	PC,R14

p$l	FNS	("zap_p_mkclone")
noclone$l &	0
	FNS	("zap_e_noclone")
badclone$l &	0
	FNS	("zap_e_badclone")
noclonebase$l &	0
	FNS	("zap_e_noclonebase")
cloneexists$l &	0
	FNS	("zap_e_cloneexists")
clonefail$l &	0
	FNS	("zap_e_clonefail")
cantclone$l &	0
	FNS	("zap_e_badclonebase")

	LOCAL

	DCD	7+c_Param_String+c_PreMinibuffer+c_TrojanCommand
CloneDelete
	MOV	R3,#0
	B	clone_dh$l

	DCD	7+c_Param_String+c_PreMinibuffer+c_TrojanCommand
CloneHide
	MOV	R3,#1
clone_dh$l
	TEQ	R2,#6
	ADREQ	R0,p$l
	MOVEQ	R1,#lineed_buf_mode
	BEQ	minibuffer_prompt_token_and_history
	FNJSR
	SUB	R1,R0,#1
s$l	LDRB	R0,[R1,#1]!
	TEQ	R0,#32
	BEQ	s$l
	MOV	R2,R3
	BL	remove_clone_mode_entry
	FNRTS
p$l	=	"zap_p_delclone",0
	ALIGN

	DCD	0
Closeother
	FNJSR
	BL	find_next_window
	FNRTS	VS
	CMP	R0,#0
	BLPL	delete_window		; window to swap to? close it (with prompt)
	FNRTS

	DCD	7
Closeprinter
	FNJSR
	ADR	R0,op_s2
	SWI	XOS_CLI
	FNRTS
op_s2
	FNS	("Filer_CloseDir Printer:$")

	DCD	c_MovesInputOrKeymap
Closewindow
	FNJSR
	BL	test_delete_window	; what will happen when we delete?
	FNRTS	VS
	TEQ	R0,#0
	BEQ	cl18			; promt will come up...?
	BL	swap_window		; move to another winodow
	BLVC	delete_window		; and original window
	MOVVC	R1,#-1
	SWIVC	XWimp_CreateMenu	; close all menus to prevent adjust-click bug
	FNRTS
cl18
	BL	delete_window
	BLVC	get_DyingBox
	MOVVC	R7,R1
	LDRVC	R0,[R7,#4]
	ORRVC	R0,R0,#1<<4		; swap window on dying
	STRVC	R0,[R7,#4]
	FNRTS

	LOCAL

	DCD	7+c_Param_String+c_PreMinibuffer+c_MinibufferOpen+c_UniversalArg+c_ProvidesDefaultMenuString+c_MovesInputOrKeymap
Command					; R1=number of times (inc uni arg)
	TEQ	R2,#6
	ADREQ	R0,s$l
	MOVEQ	R1,#lineed_buf_zapcommand
	BEQ	minibuffer_prompt_token_and_history
	FNJSR
	TEQ	r2,#17
	BEQ	m$l
	LDRB	R14,[R0]		; get first character
	TEQ	R14,#0
	MOVEQ	R0,#0			; close minibuffer
	FNRTS	EQ			; quit if empty
	MOV	R6,R0			; save argument
	MOV	R0,R1
	BL	universal_arg		; repeat time for next command
	FNRTS	VS
	ORR	R0,R6,#1<<31		; don't learn
	BL	command_string		; execute the string
	FNRTS	VS
	CMP	R0,#0
	MOVPL	R0,#0			; close minibuffer
	MOVMI	R0,#1			; leave it open as command uses it
	FNRTS
m$l
	CMP	r0,#0
	ADREQ	r0,s$l			; menu title
	FNPULL	EQ
	BEQ	lookup_token_R0
	CMP	r0,#1
	MOVEQ	r0,#0			; clear entry
	CMP	r0,#2
	FNLDR	r0,mini_bufl,EQ		; get minibuffer size into r0
	FNRTS
s$l	FNS	("zap_p_command")

	DCD	c_CommandAndFunction
Copy
	FNLDR	R0,car_mode
	TEQ	R2,#23
	BEQ	Copy_fn
	TEQ	R0,#2
	MOVEQ	R0,R1			; number of bytes to copy
	BEQ	copy_text		; copy already initiated
	TEQ	R0,#1
	MOVNE	PC,R14			; not in a state to initiate copy
	FNJSR
	MOV	R0,#2
	BL	set_caret_mode		; initialise copy
	MOV	R14,#-1
	FNSTR	R14,car_column		; column preferred by cursor
	FNRTS
Copy_fn
	TEQ	R0,#2
	MVNEQ	R0,#0
	MOVNE	R0,#0
	MOV	R1,#2
	FNRTS

	LOCAL

	DCD	7+c_Param_Words+c_ProvidesDefaultMenuString
Columntab
	TEQ	R2,#0
	BNE	a$l
	LDR	R5,[R0]
	CMP	R5,#1
	MOVLT R5,#1
a$l
	TEQ	R8,#0
	MOVEQ	R3,#opt_tab
	MOVNE	R3,#w_tab
	ADR	R4,s$l
	B	new_w_num_checked
s$l	FNS	("zap_m_tabw")

	DCD	7+c_TickableMenuEntry
Confinehorizontally
	MOV	R0,#0			; 1<<21	; clear freeclick?
	MOV	R1,#1<<24		; toggle Confinehorizontally
	B	new_wind_format_set

	DCD	7+c_TickableMenuEntry
Colonseparator
	MOV	R0,#0			; clear zilch
	MOV	R1,#info_LineNumberColons
	B	new_info_set

	LOCAL

	DCD	7+c_TickableMenuEntry
Confinevertically
	MOV	R0,#0			; clear nothing
	MOV	R1,#1<<23		; toggle Confinevertically
	B	new_wind_format_set

;\E R2 = Length
;   R3 = 0/ptr to data to be inserted... R8/R9/R10
;\X R1 number of spaces (also flags, EQ or NE)

getnoofspaces
	FNJSR	"R11"
	CMP	R3,#0
	BEQ	zerospaces		; no data = no need...
	MOV	R0,#10
	MOV	R11,#e_interrogate	; R3=ptr to data?
	BL	call_mode
	CMP	R0,#0
	BEQ	zerospaces
	LDR	R0,[R10,#c_loff]
	LDR	R1,[R10,#c_off]
	BL	cln_lineoff		; \X R0 = column on screen...
	BVS	zerospaces
	MOV	R11,R0
	LDR	R0,[R10,#c_off]
	LDR	R14,[R9,#f_len]
	CMP	R0,R14
	BLCC	cln_readc
	CMP	R0,#32
	BCS	zerospaces
	LDR	R1,[R8,#w_margin]
	ADD	R0,R11,R1		; add margin
	LDR	R1,[R10,#c_col]
	SUBS	R1,R1,R0		; number of spaces to insert before entry
	MOVMIS	R1,#0			; number of spaces to insert before entry
	FNRTS

zerospaces
	MOVS	R1,#0			; problems solved
	FNRTS

; R1 = noofspaces... R8/R9/R10...
; X R0 = spaces inserted.
actuallyinsertthemspaces
 FNJSR "R1-R4"
 LDR R4,[R8,#w_format]
 BIC R14,R4,#(1 << 15)			; clear non-standard editing
 STR R14,[R8,#w_format]
 ADD R0,R1,#8				; r1 = length
 BL ensure_redblk			; ensure enough spaces in spaces buffer
 MOVVC R2,R1				; number of spaces
 LDRVC R1,[R10,#c_off]
 FNLDR R3,red_blkbuf,VC
 MOVVC R0,#&11
 BLVC execute_command			; insert the spaces
 STRVC R4,[R8,#w_format]		; restore the flags
 MOVVC R0,R2
 FNRTS

;E R8/R9/R10
;X R0 = length of nofspaces done...
insertsomespaces
 FNJSR "R1-R7"
 BL getnoofspaces			; returns it in R1.
 CMP R1,#0
 BLE nonespacesatall
 BL actuallyinsertthemspaces
 FNRTS
nonespacesatall
 MOV R0,#0				; R0=column offset on screen - margin
 FNRTS

; Sigh. to avoid what appear to be bugs in start_operation/stop_operation,
; this command has turned into a right mess...

copyseltmp
 DCD 0
 DCD 0

 DCD c_TickableMenuEntry
Copysel
 FNJSR
 BL shade_no_sel
 FNRTS CS				; R1=file off R2=len R8/R9=window
 MOV R6,R1				; start off of selection
 ADD R7,R1,R2				; end off of selection
 BL read_selection			; into heap block in R2...
 BVS copyselexit			; copyselerrorexit2
 STR R2,copyseltmp + 4			; length...
 MOV R4,R8
 MOV R5,R9				; save window containing selection
 BL get_input_caret			; find input caret window R8,R9,R10
 LDR R1,[R10,#c_off]			; input caret offset
 STR R1,copyseltmp
 BL getnoofspaces			; returns it in R1.
 CMP R1,#0				; needed?
 MOVLE R11,#0
 BLE endoffudge$l
 MOV R11,R1
 MOV R0,R3
 BL heap_extend				; extend selected block (yuck code)
 BVS copyselerrorexit
 MOV R3,R2
 ADD R2,R11,R0
 MOV R1,R0
 MOV R10,R0
 SWI XZapRedraw_MoveBytes ; BL move_bytes
 MOV R3,R10
 MOV R2,#0
 ADD R2,R10,R11
 MOV R14,#32
loop1$l
 STRB R14,[R10],#1
 CMP R10,R2
 BCC loop1$l

 LDR R2,copyseltmp + 4		; length...
 ADD R2,R2,R11			; new length...
endoffudge$l			; ...?
 BL get_input_caret		; find input caret window (set up R10)
 LDR R1,[R10,#c_off]		; input caret offset
 MOV R0,#&11			; insert block
 BL execute_command
 BVS copyselerrorexit		; copyselexit
 MOV R0,R3
 BL heap_free			; free selected block
 BVS copyselexit		; copyselerrorexit
 TEQ R9,R5
 BNE co2			; block was inserted in another file
 LDR R1,copyseltmp
 CMP R6,R1	 		; a problem
 ADDCS R6,R6,R2			; a problem
 CMP R7,R1			; a problem
 ADDGT R7,R7,R2			; find new start end of region
co2
 MOV R8,R4
 MOV R9,R5			; window with selection
 MOV R2,R6
 MOV R3,R7
 BL select_region		; select the region
copyselexit
 FNRTS

copyselerrorexit
 PUSH "R0"
 MOV R0,R3
 BL heap_free			; free selected block
 PULL "R0"
 FNRTV

 DCD 7
Coredump
 B core_dump

 DCD 7+c_Param_Words+c_MovesInputOrKeymap
Createfile
 FNJSR
 LDR R0,[R0]			; file type
 BL create_empty
 BLVC create_window_caret
 FNRTS

 DCD 0
Cup
 FNJSR
 BL get_cursor_caret
 MOV R0,#0
 BL goto_offset
 FNRTS

 DCD 7+c_CanCreateSubMenu
Cursormenu
 FNLDR R0,menu_memory
 LDR R0,[R0,#16]
 MOV PC,R14

 DCD c_Param_Words + c_TickableMenuEntry
Cut
 LDR R6,[R0]
 FNJSR
 MOV R7,R8
 BL shade_no_sel		; get R8/R9 containg the selection
 FNRTS CS
 BL caret_writable
 BL shade_no_sel		; get R1 off, R2 len, R8/R9
 CMP R7,R8
 LDRNE R0,[R8,#w_poff]
 LDREQ R0,[R10,#c_off]
 BL goto_file_offset		; if in different window, go to the selection
 FNRTS VS
 TEQ R6,#0
 BNE noundo$l
 LDR R0,[R9,#f_flags]
 TST R0,#1
 BEQ noundo$l

 BL read_selection
 FNRTS VS
 LDR R14,[R9,#f_flags]
 TST R14,#&110			; read only?
 BLEQ clear_selection		; remove selected area if not
 CMP R3,#0
 FNRTS EQ			; was there a selection?

 MOV R0,#&52			; delete no concat
 LDR R14,[R10,#c_off]
 CMP R14,R1
 MOVEQ R0,#&55			; cursor at start...!
 FNLDR R14,opt_switches		; ask for no returned heap block...
 ORR R14,R14,#bit_return_deletions
 FNSTR R14,opt_switches
 BL execute_command
 FNLDR R14,opt_switches		; ask for no returned heap block...
 BIC R14,R14,#bit_return_deletions
 FNSTR R14,opt_switches
 FNRTS VS
 MOV R0,#0			; add last deletion on this file
 BL add_yank_region		; add it to the yank list
 MOV R0,R3
 BL heap_free
 FNRTS

noundo$l
 LDR R14,[R9,#f_flags]
 TST R14,#&110			; read only?
 BLEQ clear_selection		; remove selected area if not
 FNRTS VS
 MOV R0,#&52			; delete no concat
 LDR R14,[R10,#c_off]
 CMP R14,R1
 MOVEQ R0,#&55			; cursor at start...!
 FNLDR R14,opt_switches		; ask for no returned heap block...
 ORR R14,R14,#bit_return_deletions
 FNSTR R14,opt_switches
 BL execute_command
 FNLDR R14,opt_switches		; ask for no returned heap block...
 BIC R14,R14,#bit_return_deletions
 FNSTR R14,opt_switches
 FNRTS

 DCD c_Param_String+c_PreMinibuffer
Date
 TEQ R2,#6
 BNE insert_date
 ADR R0,da_s0
 MOV R1,#lineed_buf_datetime
 B minibuffer_prompt_token_and_history
da_s0
 FNS ("zap_p_date")

 DCD c_MovesInputOrKeymap
Defaultmap
 TEQ R8,#0
 FNLDR R0,key_default,EQ
 LDRNEB R0,[R8,#w_defaultmap]
 B basemap_entry

goifmatched$l
 FNJSR
 MOV R2,R7
 BL strcmp
 FNRTS NE
 PULL "R14"
 MOV R1,R5
 MOV R2,#0
 MOV PC,R4

delnorm$l
 MOV R7,#0			; normal delete type
de10
 MOV R5,R1			; save number of bytes
 LDR R6,[R8,#w_format]		; window format
 MOV R11,#e_delete
 BL call_mode
 ADRVC R0,ptrtotfs$l
 BLVC tellzapspell
 FNRTS				; !!! /should/ match a simple one...

update_caret_call_mode
 LDR R0,[R10,#c_loff]
 LDR R1,[R10,#c_off]
 LDR R2,[R10,#c_col]
 LDR R3,[R8,#w_margin]
 SUBS R2,R2,R3
 MOVMI R2,#0
 B call_mode			; find start of next line

delprev$l		= "PREV",0
delnext$l		= "NEXT",0
delprevword$l		= "WORDSTART",0
delnextword$l		= "WORDEND",0
delword$l		= "WORD",0
dellinestart$l		= "LINESTART",0
dellineend$l		= "LINEEND",0
delline$l		= "LINE",0
delparagraphstart$l	= "PARASTART",0
delparagraphend$l	= "PARAEND",0
delparagraph$l		= "PARA",0
delfilestart$l		= "FILESTART",0
delfileend$l		= "FILEEND",0
delfile$l		= "FILE",0
delselection$l		= "SEL",0
delnonselection$l	= "NONSEL",0
	ALIGN

 DCD c_Param_String+c_PreMinibuffer+c_MinibufferKill+c_OmitParameter ; !later!
Delete
 FNJSR
 CMP R2,#6
 ADREQ R0,delprev$l
 FNRTS EQ
 MOV R5,R1			; save number of bytes
 CMP R0,#0
 BEQ delnorm$l
 LDRB R14,[R0]
 CMP R14,#0
 BEQ delnorm$l
 MOV R7,R0
 ADR R4,delnorm$l
 ADR R1,delprev$l
 BL goifmatched$l
 ADR R4,Deletenextnocopy + 4
 ADR R1,delnext$l
 BL goifmatched$l
 ADR R4,Deletewordprev + 4
 ADR R1,delprevword$l
 BL goifmatched$l
 ADR R4,Deletewordnext + 4
 ADR R1,delnextword$l
 BL goifmatched$l
 ADR R4,Deleteword + 4
 ADR R1,delword$l
 BL goifmatched$l
 ADR R4,to_Deltostart			; Deltostart + 4
 ADR R1,dellinestart$l
 BL goifmatched$l
 ADR R4,to_Deltoend			; Deltoend + 4
 ADR R1,dellineend$l
 BL goifmatched$l
 ADR R4,Delline + 4
 ADR R1,delline$l
 BL goifmatched$l
 ADR R4,Deltosof + 4
 ADR R1,delfilestart$l
 BL goifmatched$l
 ADR R4,Deltoeof + 4
 ADR R1,delfileend$l
 BL goifmatched$l
 ADR R4,Delfile + 4
 ADR R1,delfile$l
 BL goifmatched$l
 MOV R6,#0
 ADR R4,Cut + 8
 ADR R1,delselection$l
 BL goifmatched$l
 ADR R4,Delnonsel + 4
 ADR R1,delnonselection$l
 BL goifmatched$l

 MOV R1,R5
 MOV R2,#0
 B delnorm$l

ptrtotfs$l
 DCD 65 ; lie...

 & 1+c_MovesInputOrKeymap
Deletefile
 B delete_file

 DCD 0
Deletenext
 FNLDR R0,car_mode
 TEQ R0,#2
 BEQ Copy			; perform copy action
 ; fall through (safe because DCD 0 == ANDEQ R0,R0,R0)

 DCD 0
Deletenextnocopy
 FNJSR
 MOV R7,#1
 B de10

 DCD 0
Delline
 FNJSR
 LDR R0,[R10,#c_off]
 MOV R11,#e_linenext
 BL call_mode			; find start of next line
 MOVVC R2,R0			; save
 LDRVC R0,[R10,#c_off]
 MOVVC R11,#e_lineprev
 BLVC call_mode			; find start of this line
 FNRTS VS
 LDR R14,[R9,#f_len]
 CMP R0,R14
 FNRTS EQ
 MOV R1,R0			; first char to delete
 SUB R2,R2,R1			; number to delete
 MOV R0,#&12			; del block
 BL execute_command
 ANDVC R0,R3,#1
 MOVVC R0,R0,LSL#30		; is this a repeat block
 BLVC add_yank_region
 FNRTS

 DCD 0
Deletewordnext
 FNJSR
 BL	isitBASICmode
 BEQ	BASICfudge1$l
 LDR R7,[R10,#c_off]
 MOV R11,#e_splus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 LDR R14,[R9,#f_len]
 CMP R1,R14
 MOVCS R1,R14
 SUB R14,R1,#1
 CMP R14,R7
 BGT carryon$l
 STR R1,[R10,#c_off]
 BL update_caret
 MOV R11,#e_splus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 LDR R14,[R9,#f_len]
 CMP R1,R14
 MOVCS R1,R14
carryon$l
 MOV R6,R1
 STR R1,[R10,#c_off]
 BL update_caret
 MOV R11,#e_sminus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 SUB R14,R1,#1
 CMP R14,R7
 MOVGT R6,R1
 MOV R1,R7
 SUB R2,R6,R1			; number to delete
 MOV R0,#&15			; del block
 BL execute_command
 ANDVC R0,R3,#1
 MOVVC R0,R0,LSL#30		; is this a repeat block
 BLVC add_yank_region
 FNRTS
DELWORDLEFTcmd$l
 = "DELWORDLEFT",0
DELWORDRIGHTcmd$l
 FNS ("DELWORDRIGHT")

BASICfudge1$l
	ADR	R0,DELWORDRIGHTcmd$l
	BL	command_string
	FNRTS

isitBASICmode
	FNJSR	"R0,R11"
	MOV	R0,#14
	MOV	R11,#e_interrogate
	BL	call_mode
	AND	R0,R0,#255
	TEQ	R0,#2 ; tokenised mode
	FNRTS

 DCD 0
Deletewordprev
 FNJSR
 BL	isitBASICmode
 BEQ	BASICfudge2$l
 LDR R7,[R10,#c_off]
 MOV R11,#e_sminus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 CMP R1,#0
 MOVMI R1,#0
 ADD R14,R1,#1
 CMP R14,R7
 BLT carryon2$l
 STR R1,[R10,#c_off]
 BL update_caret
 MOV R11,#e_sminus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 CMP R1,#0
 MOVMI R1,#0
carryon2$l
 MOV R6,R1
 STR R1,[R10,#c_off]
 BL update_caret
 MOV R11,#e_splus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE
 ADD R14,R1,#1
 CMP R14,R7
 MOVGE R1,R6
 SUB R2,R7,R1			; number to delete
 MOV R0,#&12			; del block
 BL execute_command
 ANDVC R0,R3,#1
 MOVVC R0,R0,LSL#30		; is this a repeat block
 BLVC add_yank_region
 FNRTS

BASICfudge2$l
	ADR	R0,DELWORDLEFTcmd$l
	BL	command_string
	FNRTS

 DCD 0
Delfile
 FNJSR
 MOV R1,#0
 LDR R2,[R9,#f_len]
 MOV R0,#&12			; del block
 BL execute_command
 AND R0,R3,#1
 MOV R0,R0,LSL#30		; is this a repeat block
 BL add_yank_region
 FNRTS

 DCD 0
Delnonsel
 FNJSR
 BL shade_no_sel
 FNRTS CS
 MOV R7,R1
 BL start_operation
 ADD R1,R1,R2
 LDR R2,[R9,#f_len]
 SUB R2,R2,R1
 MOV R0,#&12			; del block
 BL execute_command
 MOVVC R1,#0
 MOVVC R2,R7
 MOVVC R0,#&12			; del block
 BLVC execute_command
 BL stop_operation		; stopop even if errors
 FNRTS

 DCD 0
Deleteword
 FNJSR
 MOV R11,#e_sminus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE

 CMP R1,#0
 MOVMI R1,#0
 MOV R7,R1
 MOV R11,#e_splus
 BL update_caret_call_mode
 FNRTS VS
 CMP R2,#-2
 FNRTS LE

 LDR R14,[R9,#f_len]
 CMP R1,R14
 MOVCS R1,R14
 SUB R2,R1,R7
 MOV R1,R7
 MOV R0,#&12			; del block
 BL execute_command
 ANDVC R0,R3,#1
 MOVVC R0,R0,LSL#30		; is this a repeat block
 BLVC add_yank_region
 FNRTS

 DCD 0
Deltosof
 FNJSR
 MOV R1,#0
 LDR R2,[R10,#c_off]
 MOV R0,#&12			; del block
 BL execute_command
 MOVVC R0,#0
 BLVC add_yank_region
 FNRTS

 DCD 0
Deltoeof
 FNJSR
 LDR R1,[R10,#c_off]
 LDR R2,[R9,#f_len]
 SUB R2,R2,R1
 MOV R0,#&12			; del block
 BL execute_command
 MOVVC R0,#0
 BLVC add_yank_region
 FNRTS

to_Deltostart
 FNPULL
 B Deltostart

 DCD 0
Deltostart
	TST	R3,#1
	ADR	R3,Deltostart_main
	B	Delto_common
Deltostart_main
 FNJSR
 LDR R0,[R10,#c_off]
 MOV R11,#e_linestart
 BL call_mode			; start of line
 MOVVC R1,R0
 LDRVC R2,[R10,#c_off]
 SUBVC R2,R2,R1			; num chars to delete
 MOVVC R0,#&12			; del block
 BLVC execute_command
 MOVVC R0,#0
 BLVC add_yank_region
 FNRTS

to_Deltoend
 FNPULL
 B Deltoend

 DCD 0
Deltoend
	TST	R3,#1
	ADR	R3,Deltoend_main
Delto_common
	ORR	R3,R3,#1<<31
	ORRNE	R3,R3,#1
	LDR	R4,[R8,#w_flags]
	MVN	R5,#1<<31
	LDR	R6,[R8,#w_format]
	B	char_del_dispatch
Deltoend_main
 FNJSR
 MOV R5,R0
 LDR R0,[R10,#c_off]
 LDR R14,[R9,#f_len]
 CMP R0,R14
 FNRTS CS
 MOV R11,#e_lineend
 BL call_mode			; find end of line
 FNRTS VS
 MOV R2,R0			; end of del area
 LDR R0,[R10,#c_off]
 TEQ R0,R2			; is this line empty
 TEQEQ R5,#0
 BEQ de11			; join the next line if so
 MOV R1,R0
 SUB R2,R2,R1			; num chars to delete
 MOV R0,#&15			; del block
 BL execute_command
 B de17				; finished
de11
 PUSH "R3"
 BL Joinline
 LDMFD R13!,{R3}
 FNRTS VS			; return on error
de17
 AND R0,R3,#1
 MOV R0,R0,LSL#30
 BL add_yank_region		; add it
 FNRTS

 DCD c_UniversalArg
Down
 MOV R2,#0
 MOV R3,#1
 B move_cursor

 DCD 7
Dumpfile
 FNJSR
 BL get_wind_off
 ADR R10,sub$l
 BL do_longop
 FNRTS
sub$l B dump_file

 DCD c_MovesInputOrKeymap
Emacs
 ADR R0,emacs$l
 B Basemapn
emacs$l FNS ("Emacs")

 DCD 0
Escape
 B default_caret

 DCD c_MovesInputOrKeymap
Execute
 FNLDR R3,key_flags
 BIC R3,R3,#4
 FNSTR R3,key_flags		; turn off learn first!
 FNLDR R0,key_learn		; learn buffer
 B execute_strokes

 DCD 0
Fastundo
 MOV R0,R1			; undo R1 chars
 MOV R1,#0			; fast undo
 B undo_command

 DCD 7+c_Param_Words+c_TickableMenuEntry
Fflags_toggle
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 BL new_file_flags_set
 FNRTS

 LOCAL

 DCD 7+c_Param_String+c_PreMinibuffer+c_MinibufferTabCompletion+c_MovesInputOrKeymap
Findfile
 FNJSR
 TEQ R2,#6
 BEQ mini$l
 ; need to fix this to cope with DDEUtils...
 BL find_file
 MOVVC R0,#3			; bring to front
 MOVVC R1,R8
 BLVC open_a_window
 LDRVC R0,[R8,#w_poff]		; cursor position ; ? poff
 BLVC put_caret
 FNRTS
mini$l
 ADR R0,fi_s0
fi11
 MOV R1,#lineed_buf_filename
 BL minibuffer_prompt_token_and_history
 FNRTS VS
 BL find_current_directory_dde
 TEQVC R0,#0
 TEQVS R0,R0
 BNE fi13
 CMP R9,#0
 BEQ fi12
 LDR R0,[R9,#f_name]
 BL check_file_name		; does name contain path
 FNRTS VS
 TEQ R0,#0
 BNE fi12			; no path
 LDR R0,[R9,#f_name]		; assosiated file name
 MOV R2,R0
 BL find_leaf_name		; find leaf name part
 FNRTS VS
 MOV R3,R0			; save start of leaf name
 LDRB R4,[R3]			; first char of leaf name
 MOV R0,#0
 STRB R0,[R3]			; chop it off
 MOV R0,R2
 BL minibuffer_write		; write name into buffer (default)
 STRB R4,[R3]			; restore name
 FNRTS
fi12
 BL find_current_directory
 FNRTVC VS			; cope with things like "disk not present"
fi13
 BL minibuffer_write 		; write name into buffer (default)
 MOVVC R0,#'.'
 BLVC minibuffer_writec		; insert current dir as prompt
 FNRTS
fi_s0 FNS ("zap_p_findfile")
fi_s1 FNS ("zap_p_findfilero")

 DCD 7+c_Param_String+c_PreMinibuffer+c_MinibufferTabCompletion+c_MovesInputOrKeymap
Findfilereadonly
 FNJSR
 TEQ R2,#6
 ADREQ R0,fi_s1
 BEQ fi11
 BL find_file
 LDRVC R0,[R9,#f_flags]
 ORRVC R0,R0,#1<<8
 STRVC R0,[R9,#f_flags]
 BLVC new_file_title
 FNRTS

 LOCAL

 DCD c_CommandAndFunction
Findfunction
 FNJSR "R2"
 TEQ R2,#23
 LDRNE R0,[R10,#c_off]
 MOV R1,#12
 MOV R11,#e_init
 BL call_mode
 LDR R2,[R13]
 CMP R1,#12
 CMPNE R1,#0
 CMPNE R1,#2
 BEQ foundfunction
 TEQ R2,#23
 ADRNE R0,err_notfunfound
 MOVNE R1,#warn_UseMessageTrans
 BLNE warn_user
 MOV R0,#0
 FNRTS
foundfunction
 TEQ R1,#0
 TEQNE R1,#2
 MOVEQ R0,#-1
 MOVEQ R1,#3 ; return an alleged string if fn definition found
 MOVNE R0,#0
 MOVNE R1,#0 ; else return nothing
 FNRTS
err_notfunfound
 FNS ("zap_FnNotFound")

 LOCAL

 DCD 7+c_Param_Words+c_TickableMenuEntry
Fonttype
 LDR R3,[R0]
 MOV R0,#&320000		; mask
 CMP R3,#5
 MOVHI R3,#1			; scaled font as default
 ADR R1,type$l
 LDR R1,[R1,R3,LSL #2]
 B new_flags_select
type$l
 & 0, &100000, &020000, &200000, &120000, &220000

 DCD 0
Formattext
 MOV R11,#e_formattext
 B call_mode

 DCD 7+c_TickableMenuEntry
Freeclick
 MOV R0,#0 ; 1<<24	; clear CONFINE HORIZ... nothing
 MOV R1,#1<<21		; toggle freeclick
 B new_wind_format_set

 DCD 0
Fullundo
 MOV R0,R1			; undo R1 chars
 MOV R1,#1			; full undo
 B undo_command

 DCD 7+c_TickableMenuEntry
Hexascii
 MOV R0,#0
 MOV R1,#1<<5
 B new_wind_flags_set

 LOCAL

 DCD 7+c_Param_String+c_PreMinibuffer+c_MinibufferKey+c_MinibufferOpen
Help
 FNJSR
 TEQ R2,#6
 BEQ p$l
 SUB R14,R2,#&8000
 CMP R14,#&200
 BCC key$l
 LDRB R0,[R0]			; first byte of string
 CMP R0,#'a'
 SUBGE R0,R0,#'a'-'A'		; make upper case
 TEQ R0,#'K'
 ADREQ R7,Helpkey
 BEQ helpon$l
 TEQ R0,#'F'
 ADREQ R7,Helpfn
 BEQ helpon$l
 TEQ R0,#'C'
 ADREQ R7,Helpcom
 BEQ helpon$l
 TEQ R0,#'V'
 ADREQ R7,Helpvar
 BEQ helpon$l
 TEQ R0,#'M'
 BEQ mode$l
 TEQ R0,#'D'
 TEQNE R0,#'Z'
 BNE end$l			; not recognised
 MOV R11,R0
 MOV R0,#21
 BL minibuffer_writec		; avoid problems if help file not found
 FNLDR R1,opt_flags		; save old flags
 ORR R0,R1,#(1<<4)+(1<<8)	; file fixed as read only
 FNSTR R0,opt_flags
 TEQ R11,#'Z'
 ADREQ R0,help$l
 ADRNE R0,docs$l
 SWI XWimp_StartTask
 FNSTR R1,opt_flags
end$l				; exit closing the minibuffer
 MOVVC R0,#0			; close minibuffer
 FNRTS
mode$l				; help on mode
 FNLDR R1,wimp_block
 ADR R2,m$l
 BL strcpy
 TEQ R8,#0
 FNLDRB R0,opt_format,EQ
 LDRNEB R0,[R8,#w_format]
 BL mode_name
 BLVC strcopy
 MOVVC R2,#-1			; not a command
 FNLDR R0,wimp_block,VC
 MOVVC R3,#0
 BLVC find_command_help
 BLVC display_help
 B end$l
helpon$l
 MOV R0,#0
 MOV R1,#1
 MOV R2,#0
 BL process_command		; do the help command
 MOVVC R0,#1			; leave minibuffer open
 FNRTS
key$l
 MOV R0,R14
 BL minibuffer_writec		; write that value
 MOVVC R0,#&8000001D		; finish
 FNRTS
p$l
 ADR R0,s$l
 BL minibuffer_prompt_token
 FNRTS
s$l	= "zap_p_help",0
m$l	= "mode_",0
help$l	= "/",|zapdir$|,".!Help",0
docs$l	= "Filer_OpenDir ZapResources:Docs",0
	ALIGN

 LOCAL

 DCD 7+c_Param_String+c_PreMinibuffer
Helpcom
 TEQ R2,#6
 ADREQ R0,s$l
 MOVEQ R1,#lineed_buf_help
 BEQ minibuffer_prompt_token_and_history
 FNJSR
 MOV R2,#0
 MOV R3,#0
 BL find_command_help
 BLVC display_help
 FNRTS
s$l FNS ("zap_p_helpcom")

	LOCAL

	DCD 7+c_Param_String+c_PreMinibuffer
Helpfn
	TEQ	R2,#6
	ADREQ	R0,s$l
	MOVEQ	R1,#lineed_buf_help
	BEQ	minibuffer_prompt_token_and_history
	FNJSR
	MOV	R2,#0
	MOV	R3,#1<<31 ; fn
	BL	find_command_help
	BLVC	display_help
	FNRTS
s$l	FNS	("zap_p_helpfn")

 LOCAL

 DCD 7+(3:SHL:3)+(1:SHL:6)
Helpvar
 TEQ R2,#6
 ADREQ R0,s$l
 MOVEQ R1,#lineed_buf_help
 BEQ minibuffer_prompt_token_and_history
 FNJSR
 MOV R2,#0
 MOV R3,#1<<30 ; c-var
 BL find_command_help
 BLVC display_help
 FNRTS
s$l
 FNS ("zap_p_helpvar")

 LOCAL

 DCD 7+c_Param_String+c_PreMinibuffer+c_MinibufferKey
Helpkey
 TEQ R2,#6
 ADREQ R0,s$l
 BEQ minibuffer_prompt_token
 FNJSR
 SUB R1,R2,#&8000
 CMP R1,#&200
 BCC prekey$l			; user has pressed a key
 BL minibuffer_eval		; read num in R0
 FNRTS VS
 FNRTS CS
 MOV R1,R0
 LDRB R2,[R8,#w_basemap]
 LDRB R0,[R8,#w_helpmap]	; use 'current' keymap
 STRB R2,[R8,#w_helpmap]
 BL find_key_entry_mapped	; R0=entry address (don't validate)
 FNRTS VS			; only want the command name
 CMP R0,#0
 FNRTS LE
 MOV R4,R0			; save address of key entry
 LDR R0,[R4]			; key command
 CMP R0,#0
 FNRTS LE			; no command given
 TST R0,#1
 BICNE R0,R0,#3			; command name
 MOVNE R2,#0			; command flags (assume none)
 BNE do$l
 LDR R1,[R4,#4]			; command data
 LDR R2,[R0,#-4]		; command flags
 BL find_command_fromkey	; R0=command string
 FNRTS VS
 CMP R0,#0
 FNRTS LE
do$l
 LDR R3,[R4,#8]
 BL find_command_help
 BLVC display_help
 FNRTS
prekey$l
 MOV R0,R1			; number
 FNLDR R1,wimp_kbdbuf
 MOV R2,#16
 SWI XOS_ConvertHex4
 MOVVC R14,#'&'
 STRVCB R14,[R0]		; put & at start
 BLVC minibuffer_write
 MOVVC R0,#&8000001D		; return operation finished
 FNRTS
s$l FNS ("zap_p_helpkey")

 LOCAL

 DCD 1+c_MovesInputOrKeymap
Iconise
 FNJSR
 FNLDR R1,wimp_block
 LDR R0,[R8,#w_handle]		; window handle
 STR R0,[R1,#20]
 FNLDR R0,wimp_task		; Zap's task handle
 STR R0,[R1,#24]
 LDR R0,[R9,#f_name]
 BL find_leaf_name
 MOV R2,R0
 ADD R1,R1,#28
 BL strcopy
 LDR R0,iconise$l
 FNLDR R1,wimp_block
 MOV R2,#0			; broadcast
 MOV R3,#48			; length
 BL message_send
 FNRTS
iconise$l DCD &400CA

 DCD 0
Indirect
 FNJSR
 LDR R0,[R8,#w_format]
 ANDS R0,R0,#&FF
 TEQ R0,#2			; word
 TEQNE R0,#4			; code
 FNRTS NE
 LDR R0,[R10,#c_off]
 BIC R0,R0,#3			; word align
 BL cln_readw			; get address in r0
 LDR R1,[R8,#w_addr]
 SUB R0,R0,R1
 BL goto_offset
 FNRTS

 DCD 7+c_TickableMenuEntry
Infinitewrap
 FNJSR ; why - "R3"
 MOV R0,#0			; clear zilch
 MOV R1,#bit_infiniteww		; toggle separating colons
 BL new_info_set
 CMP R2,#15
 BEQ ww_new_wind_format_set
 CMP R8,#0			; ib menu...?
 LDRNE R0,[R8,#w_format]
 TSTNE R0,#bit_windowwrap
 FNRTS EQ

 LDR R0,[R8,#w_width]
 BL setwidth_as_a_service
 BLVC reflect_window_height
 BLVC Updatewindow		; redraw screen
 FNRTS

reflect_window_height
 FNJSR
 BL update_wind_state
 BLVC find_work_height		; find new height
 STRVC R0,[R8,#w_height]	; save work height
 BLVC new_extent		; call Wimp_SetExtent & modify open coords
 BLVC reflect_carets		; reposition caret if in this window
 BLVC change_extent		; do first or constrict will move them
 MOVVC R1,R8
 BLVC reopen_window		; open window in new position
 FNRTS

 LOCAL

 DCD c_Param_String+c_PreMinibuffer		; string input
Insertblock
 TEQ R2,#6
 BEQ is2
 FNJSR
 PUSH "R0-R12"
 BL Startop
 PULL "R0-R12"
 BL Insert
 BL Stopop
 FNRTS

 DCD c_Param_String+c_PreMinibuffer		; string input
Insert
 TEQ R2,#6
 BEQ is2
 FNJSR
 SUB R1,R0,#1
is1
 LDRB R14,[R1,#1]!
 TEQ R14,#0
 BNE is1
 SUB R1,R1,R0
 BL Char			; insert the chars
 FNRTS
is_s0
 FNS ("zap_p_insert")
is2
 ADR R0,is_s0
 MOV R1,#lineed_buf_string
 B minibuffer_prompt_token_and_history

 DCD c_Param_String+c_PreMinibuffer		; string input
Insertblockgs
 TEQ R2,#6
 BEQ is3
 FNJSR
 PUSH "R0-R12"
 BL Startop
 PULL "R0-R12"
 BL Insertgs
 BL Stopop
 FNRTS

 LOCAL

 DCD c_Param_String+c_PreMinibuffer
Insertgs
 TEQ R2,#6
 BEQ is3
 FNJSR
 FNLDR R1,wimp_kbdbuf
 MOV R2,#kbdbuf_size*4
 SWI XOS_GSTrans
 FNLDR R0,wimp_kbdbuf,VC	; address of text
 MOVVC R1,R2			; length
 BLVC Char
 FNRTS
is_s1
 FNS ("zap_p_insertgs")
is3
 ADR R0,is_s1
 MOV R1,#lineed_buf_string
 B minibuffer_prompt_token_and_history

 DCD c_Param_String+c_OmitParameter
Insertdate
 FNLDR R2,wimp_dateformat
 B insert_date

 DCD c_Param_String+c_OmitParameter
Inserttime
 FNLDR R2,wimp_timeformat
 B insert_date

 DCD c_Param_String+c_OmitParameter
Indent
 FNJSR
 FNLDR R2,wimp_indentstring
 BL strdefault
 BL indent_selection
 FNRTS

 LOCAL

 DCD c_Param_String+c_PreMinibuffer+c_MinibufferKey+c_ProvidesDefaultMenuString
Indentby
 TEQ R2,#6
 ADREQ R0,s$l
 MOVEQ R1,#lineed_buf_string
 BEQ minibuffer_prompt_token_and_history
 FNJSR
 CMP R2,#&8000
 BCS q$l
 TEQ R2,#17
 BEQ m$l
 MOV R5,R0			; save string
 BL str_len
 ADD R1,R0,#1
 FNLDR R0,wimp_indentstring
 BL heap_ensure
 FNSTR R0,wimp_indentstring,VC
 MOVVC R1,R0
 MOVVC R2,R5
 BLVC strcopy			; copy to current indent string
 FNLDR R0,wimp_indentstring,VC
 BLVC indent_selection
 FNRTS
q$l
 SUB R14,R2,#&8100
 TEQ R14,#&8A
 TEQNE R14,#&9A
 TEQNE R14,#&AA
 SUBNE R0,R2,#&8000
 FNRTS NE
 ADR R0,clearstr$l
 BL minibuffer_write
 FNLDR R0,wimp_indentstring
 BL minibuffer_write
 MOV R0,#-1
 FNRTS
m$l
 TEQ R0,#0
 ADREQ R0,s$l			; menu title
 BLEQ lookup_token_R0
 TEQ R0,#1
 FNLDR R0,wimp_indentstring,EQ
 TEQ R0,#2
 MOVEQ R0,#32
 FNRTS

s$l = "zap_m_indentby",0
clearstr$l = 21,0

 ALIGN

 DCD 0
Joinline
 MOV R11,#e_joinline
 B call_mode

 DCD 2<<3 :OR: 1<<23 :OR: 1<<28
Keymap
 TEQ R2,#23
 LDREQB R0,[R8,#w_currentmap]
 MOVEQ R1,#1
 MOVEQ PC,R14
 FNJSR
 SUB R1,R1,#1
 LDR R0,[R0,R1,LSL#2]		; last word in list
 MOV R1,R0
 BL find_key_table_number
 BMI bad_keymap_jump
 STRPLB R1,[R8,#w_currentmap]
 STRPLB R1,[R8,#w_helpmap]
 FNLDR R0,key_last
 BL get_key_string
 BLVC minibuffer_write
 ADRVC R0,ke_s0
 BLVC minibuffer_write
 FNRTS
ke_s0
 FNS (" - ")

	LOCAL

	&	c_Param_String+c_PreMinibuffer+c_CommandAndFunction+c_MovesInputOrKeymap
Keymapn
	TEQ	R2,#6
	ADREQ	R0,s$l
	MOVEQ	R1,#lineed_buf_string
	BEQ	minibuffer_prompt_token_and_history
	FNJSR
	TEQ	R2,#23
	LDREQB	R0,[R8,#w_currentmap]
	BEQ	keymap_name
	BL	find_key_table_number
	STRPLB	R0,[R8,#w_currentmap]
	STRPLB	R0,[R8,#w_helpmap]
	FNRTS	PL
bad_keymap_jump
	FNPULL
	B	bad_keymap
s$l	FNS	("zap_p_keymap")

 DCD c_TickableMenuEntry
Keepregion
 FNJSR
 BL shade_no_sel		; R1=off R2=len
 FNRTS CS
 BL read_selection		; R3=heap block
 BLVC clear_selection
 ORRVC R0,R3,#1<<31		; block pointer
 MOVVC R1,R2			; length
 BLVC add_yank_region
 BLVC default_caret
 BLVC plot_caret
 FNRTS

 DCD c_UniversalArg:OR:c_TickableMenuEntry
Lastcylinder
 TEQ R2,#15
 BEQ disknav_tick
 MOV R0,R1
 MOV R1,#0
 MOV R2,#0
 MVN R3,#0
 B new_read_disc

 DCD c_UniversalArg:OR:c_TickableMenuEntry
Lastsector
 TEQ R2,#15
 BEQ disknav_tick
 MOV R0,R1
 MVN R1,#0
 MOV R2,#0
 MOV R3,#0
 B new_read_disc

 DCD c_UniversalArg:OR:c_TickableMenuEntry
Lasttrack
 TEQ R2,#15
 BEQ disknav_tick
 MOV R0,R1
 MOV R1,#0
 MVN R2,#0
 MOV R3,#0
 B new_read_disc

disknav_tick
	LDR	R0,[R9,#f_cmode]
	TEQ	R0,#1			; is it a dzap created file?
	MOVEQ	R0,#0
	MOVNE	R0,#2
	MOV	PC,R14

 DCD 0
Learn
 FNLDR R0,key_flags
 TST R0,#4
 EOR R0,R0,#4			; toggle mode
 FNSTR R0,key_flags
 MOVNE PC,R14			; switch off learn mode
 MOV R0,#0
 FNSTR R0,key_llen		; reset buffer
 FNRTS

 DCD 7+c_TickableMenuEntry
Listfns
 CMP R2,#15
 BEQ returnifonibmenu
 MOV R11,#e_listfns
 B call_mode

 LOCAL

 DCD c_UniversalArg
Left
 MVN R2,#0
 MOV R3,#0
 B move_cursor

 DCD 7+c_TickableMenuEntry
Linewrap
 FNJSR "R2"
 TEQ R2,#15
 BEQ linewrap_justtest
 MOV R0,#1 << 27		; clear softwrap
 MOV R1,#0			; toggle nothing
 BL new_wind_format
 TEQ R8,#0
 BLNE blat_cache_of_this_window
 TEQ R8,#0
 BLNE Updatewindow		; redraw screen
linewrap_justtest
 MOV R0,#1 << 13		; clear wordwrap
 MOV R1,#1 << 26		; toggle linewrap
 BL new_wind_flags_set		; was flags?????
 FNRTS

 DCD c_MovesInputOrKeymap
Lastmark
 FNJSR
 BL get_cursor_caret
 BL previous_mark
 FNRTS

 DCD 0
Lastmatch
 FNJSR
 BL default_search_flags	; set up R5
 BL get_cursor_caret
 FNLDR R0,fnd_string
 MOV R1,#0			; cursor
 LDR R3,[R10,#c_off]		; start offset
 MOV R4,#-1			; backward
 BL search_data
 FNRTS

 DCD 7+c_TickableMenuEntry
Lineedit
 MOV R0,#0
 MOV R1,#1<<14
 B new_wind_format_set

 DCD 7+c_Param_Words+c_TickableMenuEntry
Linenos
 LDR R3,[R0]			; 0=none 1=log 2=phy 3=addresses
 MOV R0,#&100			; none mask
 MOV R1,#0			; none eor
 TEQ R3,#1
 MOVEQ R0,#&B00
 MOVEQ R1,#&300
 TEQ R3,#2
 MOVEQ R0,#&B00
 MOVEQ R1,#&B00
 TEQ R3,#3
 MOVEQ R0,#&300
 MOVEQ R1,#&100
 B new_format_select

 LOCAL

 DCD 7+c_TickableMenuEntry
Lineselect
 MOV R0,#0
 MOV R1,#(1<<6)
 B new_info_set

 LOCAL

 DCD 7+c_Param_Words+c_ProvidesDefaultMenuString
Linespacing
 TEQ R2,#0
 BNE a$l
 LDR R5,[R0]
 CMP R5,#0
 MOVLE R5,#0
a$l
 TEQ R8,#0
 MOVEQ R3,#opt_linesp
 MOVNE R3,#w_linesp
 ADR R4,s$l
 B new_w_num_checked
s$l FNS ("zap_m_linesep")

 LOCAL

 DCD 7+c_Param_String+c_PreMinibuffer
Loadmodule
 TEQ R2,#6
 ADREQ R0,s$l
 BEQ minibuffer_prompt_token
 ORR R0,R0,#1<<31			; extra * command not given
 B load_mode_module
s$l = "zap_p_loadmodule",0
 ALIGN

 LOCAL

tochangeibmode
 FNJSR "R8"
 MOV R8,#0
 MOV R1,#1		; ???
 MOV R2,#0		; ???
 BL new_mode
 FNRTS

	DCD	1:OR:c_Param_Words
Makedefault
	FNJSR
	LDR	R0,[R0]
	FNLDRB	R11,opt_format
	TEQ	R0,#0
	BEQ	makedefault$l
	MOV	R6,R8
	MOV	R5,#0
	FNLDRB	R4,opt_format
loop$l	MOV	R0,R5
	BL	read_mode
	TEQ	R0,#0
	BEQ	next$l
	MOV	R1,R5
	BL	make_default_mode
	MOVVC	R0,R5
	BLVC	copy_back_a_mode_buffer
	FNRTS	VS
	TEQ	R5,R4
	MOV	R8,#0
	BLEQ	modes_start		; fiddle it for the default mode
	MOV	R8,R6
next$l	ADD	R5,R5,#1
	CMP	R5,#max_mode
	BLO	loop$l

makedefault$l
 LDRB R0,[R8,#w_format]
 BL tochangeibmode
 LDRVCB R1,[R8,#w_format]
 BLVC make_default_mode
 FNRTS VS

 FNLDR R2,opt_flags
 LDR R0,[R8,#w_flags]
 LDR R1,wmask$l
 BIC R2,R2,R1
 AND R0,R0,R1
 ORR R2,R2,R0
  [ (fflags_mask :AND: :NOT: &11F) <> 0
 LDR R0,[R9,#f_flags]
 LDR R1,fmask$l
 BIC R1,R1,#&0F			; don't copy the 'Undo' flag for the file...
 AND R0,R0,R1
 BIC R2,R2,R1
 ORR R2,R2,R0
  ]
 BIC R2,R2,#&110		; *not* the read-only flags &c...
 FNSTR R2,opt_flags		; this works

 FNLDR R2,opt_format
 LDR R0,[R8,#w_format]
 LDR R1,wform$l
 AND R0,R0,R1
 BIC R2,R2,R1
 ORR R2,R2,R0
 TST R2,#bit_autosoftwrap
 BICNE R2,R2,#bit_softwrap
 FNSTR R2,opt_format ; this doesn't work...?

 FNLDR R2,opt_info
 LDR R0,[R8,#w_info]
 LDR R1,winfo$l
 AND R0,R0,R1
 BIC R2,R2,R1
 ORR R2,R2,R0
 FNSTR R2,opt_info ; this doesn't work...?

 LDR R0,[R8,#w_tab]
 FNSTR R0,opt_tab
 LDR R0,[R8,#w_linesp]
 FNSTR R0,opt_linesp ; this works!
 LDR R0,[R8,#w_mwidth]
 FNSTR R0,opt_mwidth
 LDR R0,[R8,#w_tabchar]
 FNSTR R0,opt_tabchar ; this works!
 LDR R0,[R8,#w_addr]			; to avoid code mode problems...?
 FNSTR R0,opt_addr
 LDR R0,[R8,#w_stline]
 FNSTR R0,opt_stline
 LDR R0,[R8,#w_wrapwidth]
 FNSTR R0,opt_wrapwidth ; this works!
 LDRB R0,[R8,#w_format]
 BL copy_back_a_mode_buffer
 AND R0,R11,#&FF
 BL tochangeibmode		; back to how it was before...
 FNRTS

wmask$l DCD wflags_mask
  [ (fflags_mask :AND: :NOT: &11F) <> 0
fmask$l DCD fflags_mask
  ]
wform$l DCD (wformat_mask:AND:&FFFFFF00)	; don't copy the mode
winfo$l DCD winfo_mask

 LOCAL

;E R0=mode, R8=window from which to copy
;X If mode valid then block copied #

copy_back_a_mode_buffer
 FNJSR "R1-R5,R11"
 ADD R1,R12,#opt_modebase
 ADD R4,R1,R0,LSL #2 ; LDR R4,[R1,R0,LSL#2]	; mode word
 ADD R5,R8,#w_mode0
 ADD R5,R5,R0,LSL #2		; destination mode word address
 BL read_mode			; R1=linked table
 CMP R1,#0
 FNRTS LE			; not valid
 LDR R0,[R1,#e_mode*2]
 TST R0,#1<<10
 LDR R1,[R5]
 STREQ R1,[R4]
 FNRTS EQ			; finished - it was a single word
 LDR R0,[R4]
 BL heap_free ; hope this works... though it's rubbish code...
 LDR R0,[R1]			; block length
 MOV R3,R0			; save
 BL heap_claim ; what happens to the value this overwrites?
 STRVC R0,[R4]
 MOVVC R2,R0			; ? huh???
 SWIVC XZapRedraw_MoveBytes	; copy ; wrong...
 FNRTS

 LOCAL

 DCD 7+c_Param_Bytes+c_ProvidesDefaultMenuString
Margin
 TEQ R2,#0
 BNE a$l
 LDR R5,[R0]
 CMP R5,#0
 MOVMI R5,#0
a$l
 TEQ R8,#0
 MOVEQ R3,#opt_mwidth
 MOVNE R3,#w_mwidth
 ADR R4,s$l
 B new_w_num_checked
s$l FNS ("zap_m_margin")

	DCD     7 + c_Param_Words
Menuopen				; R0 -> menu handle to open
	FNJSR		; stack some registers
	LDR	R4,[R0]			; = index
	SUB	R1,R13,#20		; steal some stack space
	SWI	XWimp_GetPointerInfo	; get the pointer state
	FNRTS	VS		; exit if we barfed
	MOV	R0,R4			; restore pointer
	LDR	R2,[R13,#-20]		; = mouse X
	LDR	R3,[R13,#-16]		; = mouse Y
	BL	read_menu_handle	; read the menu handle
	BLVC	create_menu		; ... and open it
	FNRTS		; return to caller

 DCD 7+c_CanCreateSubMenu
Minimenu
 FNLDR R0,menu_memory
 LDR R0,[R0,#12]
 MOV PC,R14

 LOCAL

 DCD 7+c_Param_Words+c_TickableMenuEntry
Miscops
 LDR R3,[R0]			; number of the option - don't change this!
 MOV R0,#0			; mask

 CMP R3,#22			; one beyond highest valid op
 ADDLO PC,PC,R3,LSL #3
 MOV PC,R14

 MOV R1,#flags_AutoDeleteFiles		; 0
  B new_wind_flags_clear
 MOV R1,#flags_SelectionsVanish		; 1
  B new_wind_flags_set
 MOV PC,R14				; 2
  & 0
 B caret$l				; 3
  & 0
 MOV R1,#switch_CheckDate		; 4
  B new_switches_set
 MOV R1,#switch_ClearSearchWindow	; 5
  B new_switches_set
 MOV R1,#switch_ConfineCursor		; 6
  B new_switches_set
 MOV R1,#switch_TrapCRLF		; 7
  B new_switches_set
 MOV R1,#switch_Autoload_flashcar	; 8
  B new_switches_set
 MOV R1,#switch_Autoload_lineeditor	; 9
  B new_switches_set
 MOV R1,#switch_Autoload_disassembler	;10
  B new_switches_set
 MOV R1,#switch_Autoload_assembler	;11
  B new_switches_set
 MOV R1,#switch_Autoload_hidepointer	;12
  B new_switches_set
 MOV R1,#switch_TolerateBrokenMessages	;13
  B new_switches_set
 MOV R1,#switch_InhibitBeeping		;14
  B new_switches_set
 MOV R1,#switch_SuppressAntialiasedDSA	;15
  B new_switches_set
 MOV R1,#switch_Autoload_iclear		;16
  B new_switches_set
 MOV R1,#switch_Autoload_keyboardextend	;17
  B new_switches_set
 B hscroll$l				;18
  & 0
 MOV R1,#switch_ExecuteStartCom		;19
  B new_switches_set
 MOV R1,#switch_MinibufferAutoWidth	;20
  B new_switches_set
 MOV R1,#switch_CustomWindowTiles	;21
  B new_switches_set

caret$l
 FNJSR
 MOV R0,#2
 MOV R1,#1
 BL new_switches_set
 TEQ R2,#0
 FNRTS NE
 BL init_flash
 FNRTS VS
 BL get_cursor_caret
 BLCC set_caret
 FNRTS

hscroll$l
	FNJSR
	MOV	R0,#0
	MOV	R1,#1<<29
	BL	new_switches_set
	TEQ	R2,#0
	ADREQ	R10,hscroll_op$l
	BLEQ	do_allwindow
	FNRTS
hscroll_op$l
	MOV	R1,R8
	B	open_window

tempmoveselr8
 DCD 0

tempmoveselr9
 DCD 0

 DCD c_TickableMenuEntry
Movesel
 FNJSR
 MOV R6,R9			; save the input caret file
 BL shade_no_sel
 FNRTS CS			; R1=off R2=len R8/R9=wind with sel
 STR R8,tempmoveselr8
 STR R9,tempmoveselr9
 BL default_caret
 LDR R7,[R10,#c_off]		; save offset of input caret
 BL read_selection		; sets up R3...
 FNRTS VS

 PUSH "R1,R2"
 MOV R4,R9			; save file with selection
 TEQ R6,R9			; are we operating on same file
 BLEQ start_operation		; concatenate ops if so ; EQ
 BL get_input_caret		; find input caret window
 BL getnoofspaces

 MOV R5,R1			; r5 = noofspaces to be inserted.
 PULL "R1,R2"

 LDR R8,tempmoveselr8
 LDR R9,tempmoveselr9

  ; er, operate on some window or another...
  LDR R10,[R8,#w_format]
  BIC R14,R10,#(1 << 15)	; no non-standard
  STR R14,[R8,#w_format]

 LDR R11,[R9,#f_flags]
 ORR R14,R11,#(1 << 14)		; unlink cursor (o/wise moves input caret)
 STR R14,[R9,#f_flags]
 MOV R0,#&52			; delete selected block (reslect if undo)
 BL execute_command		; delete the selection data
 ORR R11,R11,#(1 << 3)		; it's been altered anyway...!!!
 STR R11,[R9,#f_flags]		; restore the flags

  STR R10,[R8,#w_format]

 BVS in61			;
 TEQ R6,R9			; is it the same file
 BNE in27			; different file
 BL get_cursor_caret		; get R8/R9/R10 of where to insert data
 CMP R7,R1			; was R7 >= start of deleted block
 BCC in27
 SUB R7,R7,R2			; reduce offset
 CMP R7,R1			; ? TT still OK ?
 MOVLT R7,R1			; and clip below
in27
 BL get_cursor_caret		; get R8/R9/R10 of where to insert data
 BVS in61			; error...

  ; er, operate on some window or another...
  LDR R11,[R8,#w_format]
  BIC R14,R11,#(1 << 15)	; no non-standard
  STR R14,[R8,#w_format]

 BL start_operation		; concatenate ops if so ; EQ
 BVS prein61			; error...
 MOVS R1,R5
 MOVLE R0,#0

 BLGT actuallyinsertthemspaces	; expects R10, too...
 ADD R7,R7,R0			; increment offset
 MOV R0,#&51			; insert block ; 51
 MOVS R1,R7			; saved offset

 BL execute_command		; insert the new data ; (PL)
prein61
 BL stop_operation

  STR R11,[R8,#w_format]

in61
 TEQ R4,R9
 BLEQ stop_operation
 MOV R0,R3
 BL heap_free			; free the selection data
 FNRTS

 LOCAL

; want to have current mode mirrored first :-/
 DCD 7+c_Param_Words+c_TickableMenuEntry+c_ProvidesMenuEntryText+c_SpecifiesSubMenu+c_RemoveMenuEntry+c_CommandAndFunction+c_MovesInputOrKeymap
Mode
 TEQ R2,#23
 BEQ Mode_fn
 FNJSR
 LDR R0,[R0]			; mode number
 TEQ R0,#255
 BLEQ to_get_mode$l
 TEQ R2,#18
 BEQ a$l
 TEQ R2,#20
 BEQ b$l
Mode_entry
 TEQ R2,#19
 BEQ c$l
 TEQ R8,#0
 FNLDRB R1,opt_format,EQ
 LDRNEB R1,[R8,#w_format]	; mode number
 TEQ R2,#15
 BEQ m$l
 TEQ R0,R1
 BLNE new_mode			; only change if to a different mode
 FNRTS
m$l
 TEQ R0,R1
 MOVEQ R0,#1
 MOVNE R0,#0
 FNRTS
a$l				; find replacement text (mode name)
 BL read_mode
 CMP R1,#0
 MOVLE R0,#0			; mode doesn't exist
 LDRGT R0,[R1,#2*e_title]
 FNRTS
b$l
 BL read_mode
 CMP R1,#0
 MOVLE R0,#1			; remove the entry as the mode doesn't exist
 MOVGT R0,#0
 FNRTS
c$l				; handle the submenu
 BL read_mode			; get the mode table
 LDR R0,[R1,#2*e_menu]		; pointer to the external menu
 FNRTS				; (or 0 if none)
to_get_mode$l
 CMP R2,#15
 MOVEQ R0,#0
 FNRTS EQ
; fall through...

;E R8
;X R0 = relevant mode number.
get_mode_number
 TEQ R8,#0
 FNLDRB R0,opt_format,EQ
 LDRNEB R0,[R8,#w_format]
 MOV PC,R14

 LOCAL

 DCD 7+c_Param_String+c_PreMinibuffer+c_TickableMenuEntry+c_SpecifiesSubMenu+c_CommandAndFunction+c_MovesInputOrKeymap
Moden
 TEQ R2,#23
 BEQ Moden_fn
 TEQ R2,#6
 ADREQ R0,s$l
 MOVEQ R1,#lineed_buf_string
 BEQ minibuffer_prompt_token_and_history
 FNJSR
 ADR R14,ret$l
 CMP R2,#1
 BHI test_mode_name		; find mode, don't load
 LDRB R2,[R0]
 TEQ R2,#'*'
 LDREQB R2,[R0,#1]
 TEQEQ R2,#0			; if not "*",
 BNE find_mode_number		; find mode + load module
 TEQ R9,#0
 FNRTS EQ
 MOV R0,#1<<31
 BL get_file_mode		; let Zap suggest which mode to use
 MOVVC R0,R10
 BLVC find_mode_number
ret$l
 FNRTS VS
 CMP R0,#0
 BGE Mode_entry
 MOV R0,#0
 FNRTS				; no mode found
s$l
 FNS ("zap_p_moden")

 LOCAL

; You can't call this!
 & (c_NoR10 :OR: c_Param_String :OR: c_TickableMenuEntry :OR: c_SpecifiesSubMenu)
Modenmenu
 TEQ R2,#15
 TEQNE R2,#19
 MOVNE PC,R14
 FNJSR
 BL find_mode_number			; \E r0=name \X r0=number or -1
 CMP R0,#-1
 BNE gotmode$l
 CMP R8,#0
 LDRNEB R0,[R8,#w_format]
 FNLDRB R0,opt_format,EQ
gotmode$l
 PUSH "R0"
 BL read_mode				; can't fail - this *is* a valid menu!
 LDR R1,[R1,#2*e_menu]			; menu
 CMP R1,#0
 PULL "R0"
 BNE okay$l
 TEQ R2,#15
 MOVEQ R0,#2				; shaded
 MOVNE R0,#-1				; no valid menu
 FNRTS
okay$l
 TEQ R2,#15
 MOVEQ R0,#0				; normal menu entry
 BLNE set_mode_menu_title
 MOVNE R0,R1
 FNRTS

 DCD 7
Null
 MOV PC,R14

 DCD 7+c_Param_String+c_PreMinibuffer+c_MinibufferKill+c_OmitParameter+c_MovesInputOrKeymap
 ; String is of the format:
 ; [<mode name>] [<filetype>]
Newfile
 FNJSR
 CMP R2,#6			; kill off the minibuffer
 ADREQ R0,noparam$l
 FNRTS EQ

 ; Okay, so time to do it.
 PUSH "R0"

 ; Defaults
 CMP R9,#0
 MOVEQ R6,#&1000
 SUBEQ R6,R6,#1			; &FFF
 BEQ donetypedefault$l

 LDR R0,[R9,#f_load]
 BL calc_ftype			; \X R0=filetype
 MOVCC R6,#&1000		; &1000 - untyped
 MOVCS R6,R0			; save

donetypedefault$l
 CMP R8,#0
 MOVEQ R7,#-1			; Calculate from filetype if not specified
 LDRNEB R7,[R8,#w_format]

 ; First try to convert the start of the
 ; string into a mode number. Then try to
 ; read the rest as a decimal number.
 ; Plonk these in R7, R6 respectively, but
 ; leave those registers alone otherwise (so
 ; that the defaults remain).

 ; Now we've got the mode and filetype
 ; \E R6=filetype, R7=mode number
 PULL "R0"			; string pointer
 LDRB R1,[R0]
 CMP R1,#32
 BLT doit$l			; no overrides

 MOV R1,R0			; save
 BL find_mode_number		; \E R0=>mode name string
 CMP R0,#-1
 MOVNE R7,R0			; done mode number
 BEQ readftype$l		; don't skip: there wasn't a mode

skip$l
 LDRB R0,[R1],#1
 CMP R0,#32
 BLT doit$l			; terminator
 BGT skip$l			; skip non spaces

skip2$l
 LDRB R0,[R1],#1
 CMP R0,#32
 BEQ skip2$l			; skip spaces
 SUB R1,R1,#1			; back to start of next bit

 ; \E R1 => potential filetype string
readftype$l
 MOV R2,#&1000
 MOV R0,#(10 + 1:SHL:29)	; base 10 default, &1000 max (= untyped)
 SWI XOS_ReadUnsigned
 BVS doit$l			; don't override - error
 MOV R6,R2			; override filetype

doit$l
 MOV R0,R6			; filetype
 BL create_empty		; \X R8/R9
 BLVC create_window_caret
 FNRTS VS
 MOVS R0,R7
 BLGE new_mode			; \E R0=mode, R8/R9
 FNRTS
noparam$l
 = 0
 ALIGN

 DCD c_UniversalArg:OR:c_TickableMenuEntry
Nextcylinder
 TEQ R2,#15
 BEQ disknav_tick
 MOV R0,R1
 MOV R1,#0
 MOV R2,#0
 MOV R3,#1
 B new_read_disc

 DCD c_UniversalArg:OR:c_TickableMenuEntry
Nextsector
 TEQ R2,#15
 BEQ disknav_tick
 MOV R0,R1
 MOV R1,#1
 MOV R2,#0
 MOV R3,#0
 B new_read_disc

 DCD c_UniversalArg:OR:c_TickableMenuEntry
Nexttrack
 TEQ R2,#15
 BEQ disknav_tick
 MOV R0,R1
 MOV R1,#0
 MOV R2,#1
 MOV R3,#0
 B new_read_disc

 LOCAL

 DCD 0
Nextmatch
 FNJSR
 BL default_search_flags	; set up R5
 BLVC get_cursor_caret
 FNRTS CS
 FNLDR R0,fnd_string
 MOV R1,#0			; to cursor
 LDR R3,[R10,#c_off]		; start offset
 MOV R4,#1			; forward
 BL search_data
 FNRTS

 LOCAL

 DCD 7+c_Param_Words+c_TickableMenuEntry
Newtype
 FNJSR
 LDR R5,[R0]			; file type
 TEQ R8,#0
 BNE a$l
 FNLDR R14,wimp_flagbits	; is it from savesel...?
 TST R14,#1			; *very* temporary
 BNE sel$l			; no; cos don't work.
 TEQ R2,#0
 MOVNE R0,#0
 FNRTS NE
 MOV R0,R5
 BL create_empty
 BLVC create_window_caret
 FNRTS

sel$l
 PUSH "R2"
 BL get_selection		; just to set up r8/R9 properly :(
 MOV R8,#-1
 PULL "R2"
 FNRTS CS
a$l				; change type of already existing file
 TEQ R2,#15
 BEQ b$l			; work out tick state
 LDR R2,[R9,#f_load]
 AND R2,R2,#&000000FF		; save top bit of date
 ORR R2,R2,#&FF000000
 ORR R2,R2,#&00F00000
 ORR R2,R2,R5,LSL#8
 STR R2,[R9,#f_load]		; new file type
 BL update_all_save_boxes	; <- this line?
 MOVVC R0,#0
 FNRTS

b$l
 LDR R0,[R9,#f_load]
 BL calc_ftype
 MOVCC R0,#0
 FNRTS CC			; file wasn't typed
 TEQ R0,R5
 MOVEQ R0,#1
 MOVNE R0,#0
 FNRTS

 LOCAL

 DCD 7+c_MovesInputOrKeymap
Newview
 FNJSR
 BL new_view			; may be called from menu with cursor
 FNRTS VS			; not set up
 TEQ R8,#0
 TEQNE R10,#0
 BEQ ne22
 LDR R0,[R10,#c_off]
 BL put_caret
 FNRTS
ne22
 MOV R0,#0
 BL put_caret
 FNRTS

 LOCAL

 DCD c_MovesInputOrKeymap
Nextmark
 FNJSR
 BL get_cursor_caret
 BL next_mark
 FNRTS

 LOCAL

 DCD 7+c_TickableMenuEntry
Nonstandard
 MOV R0,#0
 MOV R1,#1<<15
 B new_wind_format_set

 LOCAL

 DCD 7+c_Param_String+c_PreMinibuffer+c_TrojanCommand+c_MinibufferTabCompletion+c_MovesInputOrKeymap	; tabs for filenames
Oscli
 MOV R3,#1
 B os_cli

 DCD c_Param_String+c_OmitParameter
Outdent
 FNJSR
 FNLDR R2,wimp_indentstring
 BL strdefault
 ORR R0,R0,#1<<31
 BL indent_selection
 FNRTS

 LOCAL

 DCD 7
Openprinter
 FNJSR
 ADR R0,op_s1
 SWI XOS_CLI
 FNRTS
op_s1
 FNS ("Filer_OpenDir Printer:$")

	LOCAL

	DCD	c_Param_String+c_OmitParameter+c_TickableMenuEntry
OwnedBy
	TEQ	R2,#15
	MOVNE	PC,R14
	FNJSR
	BL	test_mode_name
	LDR	R14,[R9,#f_cmode]
	TEQ	R0,R14
	MOVEQ	R0,#0
	MOVNE	R0,#2
	FNRTS

 LOCAL

 DCD 0
Paste
 B paste_command

 LOCAL

 DCD 0
PasteGC
 B pastegc_command

 LOCAL

 DCD 1 ; was 3 and 7, but this /may/ have been a bad idea...?
 ; Indeed save_text uses r8,r9 UNCHECKED. Get it right!
Quicksave
 B save_text

 LOCAL

 DCD c_MovesInputOrKeymap
Quote
 FNLDR R0,key_flags
 ORR R0,R0,#1<<3		; set quote flag
 FNSTR R0,key_flags
 ADR R0,qu_s0
 B minibuffer_write_token
qu_s0
 FNS ("zap_m_quote")

 LOCAL

 DCD c_UniversalArg
Return
 FNJSR
 BL default_caret		; Cancel copy mode; cause caret blks to change
 BLVC get_input_caret		; get new input caret block
 BL get_input_caret		; get new input caret block
 FNRTS VS
 FNRTS CS			; none
 MOV R0,#0
 MOV R11,#e_return
 BL call_mode			; do whatever the mode wants
 ADRVC R0,(Quote - 4)		; ptrtotfs$l
 MOVVC R5,#1			; possible bug...
 BLVC tellzapspell
 FNRTS

 LOCAL

 DCD 7+c_Param_Bytes+c_ProvidesDefaultMenuString+c_CommandAndFunction
Returnchar
 TEQ R2,#23
 BEQ Returnchar_fn
 TEQ R2,#0
 BNE a$l
 LDRB R5,[R0]
 ORR R5,R5,R5,LSL#8
 ORR R5,R5,R5,LSL#16		; create tab mask
a$l
 TEQ R8,#0
 MOVEQ R3,#opt_cr
 MOVNE R3,#w_cr
 ADR R4,s$l
 B new_w_num_checked
s$l FNS ("zap_m_retchr")

 DCD 0
Returnnoindent
 FNJSR
 BL default_caret		; Cancel copy mode; cause caret blks to change
 BLVC get_input_caret		; get new input caret block
 FNRTS VS
 FNRTS CS			; none
 LDR R5,[R8,#w_format]
 BIC R0,R5,#1<<16		; switch off auto indent
 STR R0,[R8,#w_format]
 AND R5,R5,#1<<16		; save the current state
 PUSH "R5,R8"
 MOV R0,#1
 MOV R11,#e_return
 BL call_mode			; perform the return action
 LDMFD R13!,{R5,R8}
 LDR R14,[R8,#w_format]
 BIC R14,R14,#1<<16
 ORR R14,R14,R5			; restore previous option
 STR R14,[R8,#w_format]
 FNRTS

 DCD 7+c_TickableMenuEntry
Renumber
 CMP R2,#15
 MOVNE R11,#e_renumber
 BNE call_mode

returnifonibmenu
 CMP R8,#0
 MOVEQ R0,#2
 MOVNE R0,#0
 MOV PC,R14

 DCD 7+c_TickableMenuEntry
Readonly
 LDR R0,[R9,#f_flags]
 TST R0,#flags_PermanentReadOnly
 MOV R0,#0			; mask
 MOV R1,#0			; eor
 MOVEQ R1,#flags_ReadOnly	; allowed to change state
 B new_file_flags_set

 DCD 0
Redo
 MOV R0,R1			; redo R1 chars
 B redo_command

 DCD 7+c_MovesInputOrKeymap
Reloadkeys
 FNJSR
 BL init_settings
 BLVC init_keys
 FNRTS

 DCD c_UniversalArg
Right
 MOV R2,#1
 MOV R3,#0
 B move_cursor

 DCD 7+c_TrojanCommand+c_TickableMenuEntry
Run
 CMP R2,#15
 BEQ returnifonibmenu
 MOV R11,#e_run
 B call_mode

 DCD 7+c_TrojanCommand+c_TickableMenuEntry
Runandquit
 CMP R2,#15
 BEQ returnifonibmenu
 MOV R11,#e_runandquit
 B call_mode

 DCD c_Param_String+c_PreMinibuffer+c_MinibufferUpdate+c_MinibufferKey
Searchback
 MVN R4,#0			; direction =-1
 B search_as_you_type

 DCD c_Param_String+c_PreMinibuffer+c_MinibufferUpdate+c_MinibufferKey
Searchforward
 MOV R4,#1
 B search_as_you_type

 DCD 7+c_TickableMenuEntry
Softwrap
 TEQ R2,#15
 BEQ softwrap_justtest
 FNJSR
 MOV R0,#2			; sw possible...?
 MOV R11,#e_interrogate
 BL call_mode
 CMP R0,#2
 FNRTS NE			; no SW possible
 PUSH "R2"
 TEQ R8,#0
 BLNE blat_cache_of_this_window
 MOVVC R0,#1<<26	; clear linewrap
 MOVVC R1,#0 ; 		; toggle nothing
 BLVC new_wind_flags
 PULL "R2"
 MOVVC R0,#0		; clear nothing
 MOVVC R1,#1<<27	; toggle softwrap
 BLVC new_wind_format_set
 TEQ R8,#0
 FNRTS EQ
 BLVC reflect_window_height
 BLVC Updatewindow		; redraw screen
 FNRTS

softwrap_justtest
 MOV R0,#0		; clear nothing
 MOV R1,#1<<27		; toggle softwrap
 B new_wind_format_set

	DCD	7
Selectbuffer
	B	select_buffer

	DCD	0
Selectline
	FNJSR
	MOV	R1,#3
	LDR	R2,[R10,#c_col]
	LDR	R3,[R10,#c_line]
	MOV	R4,#4
	BL	mouse_click	; hope ALT not pressed...
	FNRTS

 DCD 7+c_TrojanCommand+c_TickableMenuEntry
Saveandrun
 CMP R2,#15
 BEQ returnifonibmenu
 MOV R11,#e_saveandrun
 B call_mode

 DCD c_Param_String+c_PreMinibuffer+c_MinibufferTabCompletion+c_MinibufferKill
Savefile
 FNJSR
 TEQ R2,#6
 BEQ sa11			; starting minibuffer
 BL save_to_file		; this has the intelligence to get it right in exceptional cases
 FNRTS
sa11
 LDR R0,[R9,#f_name]
 BL check_file_name
 FNRTS VS
 TEQ R0,#0
 LDREQ R0,[R9,#f_name]		; path to save with
 FNRTS EQ			; we'll be called again
sa12				; if no path...
 ADR R0,sa_s0
 BL minibuffer_prompt_token
 BLVC find_current_directory
 BLVC minibuffer_write
 MOVVC R0,#'.'
 BLVC minibuffer_writec
 LDRVC R0,[R9,#f_name]		; leaf name
 BLVC minibuffer_write
 MOVVC R0,#0			; open minibuffer
 FNRTS
sa_s0
 FNS ("zap_p_savefile")

 DCD 0
Splitline
 MOV R11,#e_splitline
 B call_mode

 DCD 0
Sdown
 MOV R3,#2
 B pagemove_cursor

 DCD 0
Sleft
 MVN R2,#1
 MOV R3,#0
 B move_cursor

 DCD 0
Sright
 MOV R2,#2
 MOV R3,#0
 B move_cursor

 DCD 0
Sup
 MVN R3,#1
 B pagemove_cursor

 LOCAL

 DCD c_UniversalArg
Scleft
 LDR R2,[R8,#w_format]
 TST R2,#bit_windowwrap
 MOVNE PC,R14
 MVN R2,#0
 MOV R3,#0
 B scroll_cursor

 LOCAL

 DCD c_UniversalArg
Scright
 LDR R2,[R8,#w_format]
 TST R2,#bit_windowwrap
 MOVNE PC,R14
 MOV R2,#1
 MOV R3,#0
 B scroll_cursor

 DCD c_UniversalArg
Scdown
 MOV R2,#0
 MOV R3,#1
 B scroll_cursor

 DCD c_UniversalArg
Scup
 MOV R2,#0
 MVN R3,#0
 B scroll_cursor

 DCD 0
Selregion
 FNLDR R0,car_mode
 TEQ R0,#3
 BEQ default_caret		; already in sel mode: turn off select area
 TEQ R0,#1
 MOVNE PC,R14
 MOV R0,#3
 B set_caret_mode

 LOCAL

 DCD 7+c_Param_String+c_PreMinibuffer+c_MinibufferKill+c_TickableMenuEntry; string...
Sendsel
 FNJSR
 CMP R2,#6
 ADREQ R0,Sendsel		; anywhere - to abort minibuffer
 FNRTS EQ
 CMP R0,#0
 LDRPLB R0,[R0]
 STR R0,local_sendtemp + 12
 BL shade_no_sel
 FNRTS CS			; R1=file off R2=len R8/R9=wind with sel
 LDR R14,local_sendtemp
 CMP R14,#0
 FNRTS NE
 BL read_selection
 BVS copyselexit
 CMP R2,#0			; none.
 FNRTS EQ
 STR R3,local_sendtemp
 STR R2,local_sendtemp + 4
 MOV R14,#0
 STR R14,local_sendtemp + 8	; index.
 MOV R1,#-1			; no delay
 ADR R2,sub$l			; typesel sub
 BL call_back			; schedule
 FNRTS
local_sendtemp
 DCD 0
 DCD 0
 DCD 0
 DCD 0
sub$l
 FNJSR "R7"
 MOV R0,#&70			; escape
 BL test_forkey
 BCS atend$l

 MOV R0,#138
 MOV R1,#0
 LDR R2,local_sendtemp
 LDR R7,local_sendtemp + 8
 ADD R2,R2,R7
 LDRB R2,[R2]
 CMP R2,#31
 LDRLE R14,local_sendtemp + 12
 CMPLE R14,#'X'
 BLNE send$l
 FNRTS VS
 ADD R7,R7,#1
 LDR R0,local_sendtemp + 4
 CMP R7,R0
 BGE atend$l
 STR R7,local_sendtemp + 8
 MOV R1,#-1			; no delay
 ADR R2,sub$l			; typesel sub
 BL call_back			; schedule
 FNRTS
atend$l
 LDR R0,local_sendtemp
 CMP R0,#0
 BLNE heap_free
 MOV R14,#0
 STR R14,local_sendtemp
 FNRTS
send$l
	FNJSR	"R0-R2"
	CMP	R2,#0
	CMPNE	R2,#128
	MOVHS	R2,#0
	SWIHS	XOS_Byte
	FNRTS	VS
	FNPULL
	SWI	XOS_Byte
	MOV	PC,R14

 LOCAL

 DCD 0
Dropmark
 FNJSR
 BL get_cursor_caret
 LDR R0,[R10,#c_off]
 BL set_mark
 FNRTS

 LOCAL

 DCD 7+c_Param_String+c_PreMinibuffer+c_ProvidesDefaultMenuString
Setmarginwidth
 TEQ R2,#6
 ADREQ R0,s$l
 MOVEQ R1,#lineed_buf_number
 BEQ minibuffer_prompt_token_and_history
 BEQ minibuffer_prompt_token
 FNJSR
 TEQ R2,#17
 BEQ a$l
 BL minibuffer_eval
 FNRTS CS

 SUBS R2,R0,#1			; save new width
 MOVMI R2,#0
 CMP R2,#7
 MOVGT R2,#7
 BL save_window_status
 FNRTS VS
 TEQ R8,#0
 FNLDR R1,opt_info,EQ
 LDRNE R1,[R8,#w_info]
 BIC R1,R1,#7
 ORR R1,R1,R2
 FNSTR R1,opt_info,EQ
 STRNE R1,[R8,#w_info]
 BLVC new_window_status
 FNRTS
a$l
 TEQ R0,#0
 ADREQ R0,s$l
 BLEQ lookup_token_R0
 TEQ R0,#2
 MOVEQ R0,#0			; number of permitted characters...?
 FNRTS EQ
 TEQ R0,#1
 FNRTS NE
 MOV R0,#-1
 TEQ R8,#0
 FNLDR R0,opt_info,EQ
 LDRNE R0,[R8,#w_info]
 AND R0,R0,#7
 ADD R0,R0,#1
 ORR R0,R0,#1<<31		; it's a number
 FNRTS
s$l = "zap_m_setmarginwidth",0
 ALIGN

 LOCAL

 ;E R0=new width
reallysetwidth
 FNJSR
 B inreallysetwidth

local_bpltemp
 DCD 0

 DCD 7+c_Param_String+c_PreMinibuffer+c_ProvidesDefaultMenuString
Setwidth
 TEQ R2,#6
 ADREQ R0,s$l
 MOVEQ R1,#lineed_buf_number
 BEQ minibuffer_prompt_token_and_history
 FNJSR
 TEQ R2,#17
 BEQ a$l
 BL minibuffer_eval		; coz it's a string up to here...
 FNRTS CS
inreallysetwidth
 MOV R11,R0			; save new width
 TEQ R8,#0
 LDRNE R14,[R8,#w_bpl]
 STRNE R14,local_bpltemp
 BLNE save_window_status	; cautious_save_window_status
 FNRTS VS
 TEQ R8,#0
 FNLDR R1,opt_flags,EQ
 LDRNE R1,[R8,#w_flags]
 BIC R1,R1,#1<<6		; switch off auto-width
 FNSTR R1,opt_flags,EQ
 STRNE R1,[R8,#w_flags]
 MOV R0,R11 ; was R2
 MOV R11,#e_setwidth
 TEQ R8,#0			; again???
 FNLDRB R10,opt_format,EQ
 LDRNEB R10,[R8,#w_format]	; mode number
 BL call_given_mode		; write the new width
 TEQ R8,#0			; LDREQ R0,[R8,#w_format]
 FNRTS EQ
 BLVC new_window_status
 FNRTS VS
 LDR R14,[R8,#w_format]
 TST R14,#bit_windowwrap
 FNRTS EQ
abnormalwidthsetting
 BL blat_window_wrap_cache	; hopeful...
 LDR R0,local_bpltemp
 BL new_window_status_forcebpl ; _preserve
 FNRTS
a$l
 TEQ R0,#0
 ADREQ R0,s$l
 BLEQ lookup_token_R0
 TEQ R0,#2
 MOVEQ R0,#8
 TEQ R0,#1
 FNRTS NE
 MOV R0,#-1			; just read it...
 MOV R11,#e_setwidth
 TEQ R8,#0
 FNLDRB R10,opt_format,EQ
 LDRNEB R10,[R8,#w_format]	; mode number
 BL call_given_mode		; read the current width value
 ORRVC R0,R0,#1<<31		; it's a number
 FNRTS
s$l = "zap_m_setwidth",0
 ALIGN

 LOCAL

 DCD 7+c_TickableMenuEntry
Spellasyoutype
 MOV R0,#0
 MOV R1,#(1<<7)
 B new_info_set

 LOCAL

 DCD 7+c_Param_Words+c_ProvidesDefaultMenuString+c_CommandAndFunction
Startaddr
 TEQ R2,#23
 BEQ function$l
 TEQ R8,#0
 MOVEQ R3,#opt_addr
 MOVNE R3,#w_addr
 ADR R4,s$l
 ORR R2,R2,#1<<31		; hex
 B new_w_number
s$l FNS ("zap_m_starta")
function$l
 TEQ R8,#0
 LDREQ R0,[R12,#opt_addr]
 LDRNE R0,[R8,#w_addr]
 MOV R1,#2			; word literal
 MOV PC,R14

 LOCAL

 DCD 7+c_Param_Words+c_ProvidesDefaultMenuString+c_CommandAndFunction
Startline
 TEQ R2,#23
 BEQ function$l
 TEQ R8,#0
 MOVEQ R3,#opt_stline
 MOVNE R3,#w_stline		; offset of the data
 ADR R4,s$l
 B new_w_number
s$l FNS ("zap_m_startl")
function$l
 TEQ R8,#0
 LDREQ R0,[R12,#opt_stline]
 LDRNE R0,[R8,#w_stline]
 MOV R1,#2			; word literal
 MOV PC,R14

 LOCAL

 DCD 7
Startop
 B start_operation

 DCD 7
Stopop
 B stop_operation

 DCD c_UniversalArg
Stilldown
 FNJSR "R0-R12"
 BL Scdown
 FNPULL
 B Down

 DCD c_UniversalArg
Stillup
 FNJSR "R0-R12"
 BL Scup
 FNPULL
 B Up

 DCD c_Param_Words
Stripspaces
 LDR R0,[R0]			; get the word argument
 B strip_spaces

 LOCAL

 DCD 7
Suspend
 FNJSR
 ADR R0,s$l
 SWI XWimp_StartTask
 FNRTS
s$l FNS ("ShellCLI")

 LOCAL

 DCD 0
Swapchars
 FNJSR
 LDR R5,[R10,#c_off]		; file offset
 LDR R2,[R9,#f_len]
 CMP R5,R2
 FNRTS CS			; too near end
 CMP R5,#0
 FNRTS LE			; too near start
 FNLDR R3,wimp_kbdbuf		; buffer
 LDRB R6,[R8,#w_cr]
 SUB R0,R5,#1
 BL cln_readc
 TEQ R0,R6
 FNRTS EQ			; don't swap returns
 STRB R0,[R3,#1]
 MOV R0,R5
 BL cln_readc
 TEQ R0,R6
 FNRTS EQ			; don't swap returns
 STRB R0,[R3]			; characters swapped
 MOV R0,#&13			; block replace
 SUB R1,R5,#1			; offset to replace
 MOV R2,#2
 BL execute_command		; replace the chars
 LDRVC R0,[R10,#c_off]
 SUBVC R0,R0,#1
 STRVC R0,[R10,#c_off]
 BLVC reflect_caret		; move caret back one
 FNRTS

 DCD 0+c_MovesInputOrKeymap
Swapwindow
 B command_swap_window

 LOCAL

 DCD 7
Switchtab
 LDR R0,[R8,#w_flags]
 TST R0,#3<<9			; extract current tab mode
 BICNE R0,R0,#3<<9		; Unix tab mode
 ORREQ R0,R0,#1<<9		; set edit tab mode
 STR R0,[R8,#w_flags]
 MOV PC,R14

 LOCAL

 DCD 1
Toback
 MOV R0,#4
 MOV R1,R8
 B open_a_window

 LOCAL

 DCD 1
Tofront
 MOV R0,#3
 MOV R1,R8
 B open_a_window

 LOCAL

 DCD 7+c_TickableMenuEntry
Togglehex
 MOV R0,#&000
 MOV R1,#&400
 B new_format_set

 LOCAL

 DCD 0
Togglemark
 FNJSR
 BL get_cursor_caret
 LDR R0,[R10,#c_off]
 BL toggle_mark
 FNRTS

 LOCAL

 DCD 7+c_TickableMenuEntry
Toggleundo
 TEQ R8,#0
 LDRNE R7,[R9,#f_flags]
 FNLDR R7,opt_flags,EQ
 TEQ R2,#15
 ANDEQ R0,R7,#1			; the undo bit
 MOVEQ PC,R14
 TEQ R8,#0
 EOREQ R7,R7,#1
 FNSTR R7,opt_flags,EQ
 MOVEQ PC,R14
 TST R7,#1			; it's on a window
 BNE open_UndoBox		; if on, question whether to switch off
 ORR R7,R7,#1			; switch it on
 STR R7,[R9,#f_flags]
 B new_file_title

 DCD 0
Togglewind
 FNJSR
 BL update_wind_state
 FNRTS VS
 LDR R0,[R8,#w_windowflags]
 TST R0,#1<<18
 BEQ to11			; open fully up
 LDR R0,[R8,#w_togminx]
 STR R0,[R8,#w_minx]
 LDR R0,[R8,#w_togminy]
 STR R0,[R8,#w_miny]
 LDR R0,[R8,#w_togmaxx]
 STR R0,[R8,#w_maxx]
 LDR R0,[R8,#w_togmaxy]
 STR R0,[R8,#w_maxy]
 MOV R1,R8
 B to12				; open it
to11
 BL ccd_workxy			; find window size R2,R3<0
 LDR R0,[R8,#w_minx]
 ADD R0,R0,R2
 FNLDR R2,wimp_leftgap
 ADD R0,R0,R2
 STR R0,[R8,#w_maxx]
 LDR R0,[R8,#w_maxy]
 ADD R0,R0,R3
 STR R0,[R8,#w_miny]
 MOV R2,R8			; proposed open block
 FNLDR R1,wimp_block		; workspace
 BL calculate_open_block
 FNRTS VS
to12
 BL reopen_window
 MOVVC R1,R8
 BLVC open_window		; kludge to get hscroll removal working here
 FNRTS

 DCD c_UniversalArg
Tab
 FNJSR
 MOV R11,#e_tab
 BL call_mode
 ADRVC R0,(Togglewind - 4)	; ptrtotfs$l
 MOVVC R5,#1			; possible bug...
 BLVC tellzapspell
 FNRTS

 LOCAL

 DCD 7+c_Param_Bytes+c_ProvidesDefaultMenuString+c_CommandAndFunction
Tabchar
 TEQ R2,#23
 BEQ Tabchar_fn
 TEQ R2,#0
 BNE a$l
 LDRB R5,[R0]
 ORR R5,R5,R5,LSL#8
 ORR R5,R5,R5,LSL#16		; create tab mask
a$l
 TEQ R8,#0
 MOVEQ R3,#opt_tabchar
 MOVNE R3,#w_tabchar
 ADR R4,s$l
 B new_w_num_checked
s$l FNS ("zap_m_tabchr")

 DCD 7+c_Param_Words+c_TickableMenuEntry
Tabdisplay
 LDR R3,[R0]
 MOV R0,#format_TabDisplayFormat; mask
 CMP R3,#4
 MOVCS R3,#0
 MOV R1,R3,LSL#tab_DisplayFormat_shift
 B new_format_select

 DCD 7+c_Param_Words+c_TickableMenuEntry
Tabmode
 LDR R3,[R0]
 MOV R0,#flags_TabMode
 MOV R1,#0			; default=unix tab
 TEQ R3,#tab_AsAbove
 TEQNE R3,#tab_Column
 MOVEQ R1,R3,LSL #tab_Mode_shift
 B new_wind_flags_select

 DCD 7+c_TickableMenuEntry
Tabsasspaces
 MOV R0,#0
 MOV R1,#flags_InsertTabsAsSpaces ; toggle
 B new_wind_flags_set

 DCD 7+c_TickableMenuEntry
Toggleinsert
 MOV R0,#0
 MOV R1,#2
 B new_wind_flags_set

 DCD c_Param_String+c_PreMinibuffer+c_MinibufferKey
Universalarg
 TEQ R2,#6
 ADREQ R0,un_s0
 MOVEQ	R1,#lineed_buf_number
 BEQ minibuffer_prompt_token_and_history
 FNJSR
 CMP R2,#&8000
 BCS un18
 BL minibuffer_eval
 FNRTS CS			; no number found
 SWI XHourglass_On
 BL universal_arg
 SWIVC XHourglass_Off
 ADRVC R0,un_s1
 BLVC minibuffer_write_token
 FNRTS
un18
 SUB R0,R2,#&8000		; number of the key
 TEQ R0,#&7F			; pass on delete,
 TEQNE R0,#&1C			;  backspace,
 TEQNE R0,#&1D			;  return,
 SUB R14,R0,#&100
 TEQNE R14,#&66			;  enter
 FNRTS EQ
 CMP R14,#10			; pass on keypad digits,
 SUBHS R14,R0,#'0'
 CMP R14,#10			;  main digits
 ADDHS R0,R0,#&8000		; but do the rest
 FNRTS
un_s0 FNS ("zap_p_universalarg_1")
un_s1 FNS ("zap_p_universalarg_2")

 LOCAL

 DCD 0
Unspace				; remove excess spacing
 FNJSR
 LDR R2,[R10,#c_off]		; start of white space
 MOV R3,R2			; end of white space
 LDR R4,[R9,#f_len]
 LDRB R5,[R8,#w_tabc]		; tab char
a$l
 CMP R3,R4
 BCS b$l
 MOV R0,R3
 BL cln_readc
 TEQ R0,#&20
 TEQNE R0,R5
 ADDEQ R3,R3,#1
 BEQ a$l
b$l
 SUBS R0,R2,#1
 BLT c$l
 BL cln_readc
 TEQ R0,#&20
 TEQNE R0,R5
 SUBEQ R2,R2,#1
 BEQ b$l
c$l				; R2-R3 = spaced region about cursor
 MOV R4,#1			; length of replacement string
 SUBS R0,R3,R2			; length of source
 FNRTS LE			; nothing to replace
 CMP R0,#1
 BGT d$l
 MOV R0,R2
 BL cln_readc			; it is a single space?
 TEQ R0,#&20
 MOVEQ R4,#0			; delete if so
d$l				; replace
 MOV R1,R2			; start
 SUB R2,R3,R2			; len
 ADR R3,sp$l
 BL replace_area
 FNRTS
sp$l = " "
 ALIGN

 DCD c_UniversalArg
Up
 MOV R2,#0
 MOV R3,#-1
 B move_cursor

 DCD 7+c_Param_String+c_PreMinibuffer+c_TrojanCommand+c_MinibufferTabCompletion	; tabs for filenames
Wimptask
 MOV R3,#2
 B os_cli

 DCD 7+c_Param_Words+c_TickableMenuEntry
Wflags_alter
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 BL new_flags_set
 FNRTS

 DCD 7+c_Param_Words+c_TickableMenuEntry
Wflags_toggle
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 BL new_wind_flags_set
 FNRTS

 DCD 7+c_Param_Words+c_TickableMenuEntry
Wformat_alter
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 TST R0,#&FF
 TSTNE R1,#&FF
 BLEQ new_wind_format_set	; swapped with below
 FNRTS

 DCD 7+c_Param_Words+c_TickableMenuEntry
Wformat_toggle
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 TST R0,#&FF
 TSTNE R1,#&FF
 FNRTS NE
 BLEQ new_format_set		; swapped with below
 FNRTS

 DCD 7+c_Param_Words+c_TickableMenuEntry
Winfo_alter
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 BL new_wind_info_set
 FNRTS

 DCD 7+c_Param_Words+c_TickableMenuEntry
Winfo_toggle
 FNJSR
 LDR R0,[R0]
 BL calculate_masks
 BL new_info_set
 FNRTS

	LOCAL

 DCD 7+c_TickableMenuEntry
Windowwrap
 FNJSR
 MOV R0,#0		; clear nothing
 MOV R1,#bit_windowwrap
 BL new_wind_format_set
 TEQ R2,#15
 BEQ ww_new_wind_format_set
 TEQ R8,#0
 FNRTS EQ
 MOV R1,R8
 BL open_window
 BL blat_cache_of_this_window
 LDR R0,[R8,#w_info]
 TST R0,#bit_infiniteww			; iww bit?
 BEQ skipwidthcomplications
 BL translate_into_new_width
 BLVC Updatewindow		; redraw screen
 FNRTS

ww_new_wind_format_set
loc_test_for_ww
 PUSH "R0,R10,R11"
 TEQ R8,#0
 FNLDRB R10,opt_format,EQ
 LDRNEB R10,[R8,#w_format]
 MOV R0,#1
 MOV R11,#e_interrogate
 BL call_given_mode
 CMP R0,#1
 PULL "R0,R10,R11"
 ORRNE R0,R0,#2
 BICNE R0,R0,#1
 FNRTS

blat_cache_of_this_window
 MOV R0,#0
 STR R0,[R8,#w_txth]		; invalidate cache
 STR R0,[R8,#w_txtn]
 STR R0,[R8,#w_coff]
 STR R0,[R8,#w_cline]
 STR R0,[R8,#w_clogl]
 MOV PC,R14

skipwidthcomplications
 BL save_window_status
 BL new_window_status
 BL Updatewindow		; redraw screen
 FNRTS

translate_into_new_width
 FNJSR "R2-R12"
 LDR R1,[R8,#w_bpl]
 MOV R0,#3
 MOV R11,#e_interrogate
 BL call_mode
 BL reallysetwidth
 FNRTS

 DCD 7+c_TickableMenuEntry
Wordwrap
 MOV R0,#1<<26		; clear linewrap
 MOV R1,#1<<13		; toggle wordwrap
 B new_wind_flags_set

 LOCAL

local_store1	& 0
local_store2	& 0
local_store3	& 0		; file offset
local_store4	& 0		; data length

 DCD c_Param_String+c_PreMinibuffer
Editbyte
 FNJSR
 MOV R1,#1
Editbyte_halfword_internal
 STR R1,local_store4
 MOV R4,R0			; save data string
 LDR R6,[R10,#c_off]		; offset of the instruction
 LDR R5,[R9,#f_len]		; offset of the instruction
 STR R6,local_store3
 LDR R5,[R8,#w_addr]		; address of offset 0
 ADD R5,R5,R6			; address instruction came from
 TEQ R2,#6
 BEQ Byte_prompt$l
 BIC R0,R6,#3
 BL cln_readw			; get word in r0
 STR R0,local_store1
 MOV R0,#&100
 BL heap_claim
 MOVVC R6,R0
 MOVVC R2,R4			; source
 MOVVC R1,R6
 BLVC strcopy			; copy string to be assembled
 ADRVC R0,assmbl$l
 BLVC find_key_command
 FNRTS VS
 CMP R0,#0
 FNRTS EQ
 MOV R7,R0
 BL start_operation
 MOV R0,R6
 BL str_len			; length
 MOV R1,R0
 MOV R2,#(1 << 31)		; don't learn...
 MOV R0,R6
 BL process_command
 LDRVC R0,local_store3
 BLVC goto_file_offset
 BVS forcedstop$l
 LDR R0,[R10,#c_off]		; offset of the instruction
 BIC R0,R0,#3
 BL cln_readw			; get word in r0...
 LDR R1,[R10,#c_off]		; offset of the instruction
 LDR R14,[R8,#w_format]
 TST R14,#format_BigEndian
 EORNE R1,R1,#3
 LDR R14,local_store4
 TEQ R14,#1
 ANDEQ R1,R1,#3
 ANDNE R1,R1,#2
 MOV R1,R1,LSL #3
 MOV R14,#&FF
 ORRNE R14,R14,#&FF00
 LDR R11,local_store1
 BIC R11,R11,R14,LSL R1
 ORR R11,R11,R0,LSL R1
 MOV R1,R6
 ADR R2,dcd$l
 BL strcpy
 MOV R0,R11
 MOV R2,#&100
 SWI XOS_ConvertHex8		; start off with the address in hex
 MOVVC R14,#0
 STRVCB R14,[R1]
 ADRVC R0,assmbl$l
 BLVC find_key_command
 BVS forcedstop$l
 MOVS R7,R0
 MOV R0,R6
 BL str_len			; length
 MOV R1,R0
 MOV R2,#(1 << 31)		; don't learn...
 MOV R0,R6
 BL process_command
 BVS forcedstop$l
 LDR R0,local_store3
 LDR R14,local_store4
 ADD R0,R0,R14
 BL goto_file_offset		; gets here :-)
 BVS forcedstop$l
 BL stop_operation
 MOVVC R0,R6
 BLVC heap_free
 FNRTS

forcedstop$l
 PUSH "R0"
 BL stop_operation
 MOVVC R0,R6
 BLVC heap_free
 PULL "R0"
 FNRTV

Byte_prompt$l
 MOV R0,R5
 FNLDR R1,wimp_block		; some workspace...
 MOV R2,#&100
 SWI XOS_ConvertHex8		; start off with the address in hex
 FNRTS VS
 FNLDR R0,wimp_block
 BL minibuffer_prompt
 MOVVC R0,#lineed_buf_asm
 BLVC lineeditor_select
 FNRTS VS
 LDR R2,local_store4		; byte count
 MOV R3,#0
 MOV R7,#0
byte$l
 LDR R0,[R9,#f_len]		; offset of the instruction
 CMP R6,R0
 MOVCS R0,#&00			; off end...!
 MOVCC R0,R6
 BLCC cln_readc
 LDR R11,[R8,#w_format]
 TST R11,#format_BigEndian
 ORRNE R7,R0,R7,LSL #8		; big endian
 ORREQ R7,R7,R0,LSL R3		; little endian
 ADD R3,R3,#8
 ADD R6,R6,#1
 SUBS R2,R2,#1
 BNE byte$l
 MOV R0,#16			; what base?
 MOV R11,#e_interrogate
 BL call_mode
 CMP R0,#2
 BEQ Byte_inbinary$l

 FNLDR R1,wimp_block		; buffer to copy detokenised line
 LDR R14,local_store4
 TEQ R14,#1
 ADREQ R2,dcb$l
 ADRNE R2,dcw$l
 MOV R3,R1			; save start of line address
 BL strcpy
 MOV R0,R7
 MOV R2,#&100
 LDR R14,local_store4
 TEQ R14,#1
 BEQ Byte_hex$l
 SWI XOS_ConvertHex4		; to hex
 B Byte_hex$l+4
Byte_hex$l
 SWI XOS_ConvertHex2		; start off with the address in hex
 MOV R0,#0
 STRB R0,[R1]
 MOV R0,R3
 BL minibuffer_write
 FNRTS
Byte_inbinary$l
 FNLDR R1,wimp_block		; buffer to copy detokenised line
 LDR R14,local_store4
 TEQ R14,#1
 ADREQ R2,binarydcb$l
 ADRNE R2,binarydcw$l
 ADR R2,binarydcw$l
 MOV R3,R1			; save start of line address
 BL strcpy
 MOV R0,R7
 MOV R2,#&28
 LDR R14,local_store4
 TEQ R14,#1
 BEQ Byte_bin$l
 SWI XOS_ConvertBinary2		; to binary
 B Byte_bin$l+4
Byte_bin$l
 SWI XOS_ConvertBinary1		; to binary
 MOV R0,#0
 STRB R0,[R1,R2]
 MOV R0,R3
 BL minibuffer_write
 FNRTS

	DCD	c_Param_String+c_PreMinibuffer
Edithalfword
	FNJSR
	MOV	R1,#2
	B	Editbyte_halfword_internal

 DCD c_Param_String+c_PreMinibuffer
Editword
 FNJSR
 MOV R4,R0			; save data string
 LDR R6,[R10,#c_off]		; offset of the instruction
 BIC R6,R6,#3			; word align
 LDR R5,[R8,#w_addr]		; address of offset 0
 ADD R5,R5,R6			; address instruction came from
 TEQ R2,#6
 BEQ prompt$l
 MOV R0,#&100
 BL heap_claim
 MOVVC R6,R0
 MOVVC R2,R4			; source
 MOVVC R1,R6
 BLVC strcopy			; copy string to be assembled
 ADRVC R0,assmbl$l
 BLVC find_key_command
 FNRTS VS
 CMP R0,#0
 FNRTS EQ
 MOV R7,R0
 MOV R0,R6
 BL str_len			; length
 MOV R1,R0
 MOV R2,#(1 << 31)
 MOV R0,R6
 BL process_command
 MOVVC R1,#0
 MOVVS R1,R0
 MOV R0,R6
 BL heap_free
 MOVS R0,R1
 FNRTS EQ
 FNRTV
prompt$l
 MOV R0,R5
 FNLDR R1,wimp_block		; some workspace...
 MOV R2,#&100
 SWI XOS_ConvertHex8		; start off with the address in hex
 FNRTS VS
 FNLDR R0,wimp_block
 BL minibuffer_prompt
 MOVVC R0,#lineed_buf_asm
 BLVC lineeditor_select
 MOVVC R0,R6
 BLVC cln_readw
 FNRTS VS
 MOV R7,R0
 MOV R0,#16			; what base?
 MOV R11,#e_interrogate
 BL call_mode
 CMP R0,#2
 BEQ inbinary$l

 FNLDR R1,wimp_block		; buffer to copy detokenised line
 ADR R2,dcd$l
 MOV R3,R1			; save start of line address
 BL strcpy
 MOV R0,R7
 MOV R2,#&100
 SWI XOS_ConvertHex8		; start off with the address in hex
 MOV R0,#0
 STRB R0,[R1]
 MOV R0,R3
 BL minibuffer_write
 FNRTS
inbinary$l
 FNLDR R1,wimp_block		; buffer to copy detokenised line
 ADR R2,binarydcd$l
 MOV R3,R1			; save start of line address
 BL strcpy
 MOV R0,R7
 MOV R2,#&28
 SWI XOS_ConvertBinary4		; to binary
 MOV R0,#0
 STRB R0,[R1,R2]
 MOV R0,R3
 BL minibuffer_write
 FNRTS
dcd$l FNS ("DCD &")
binarydcd$l FNS ("DCD %")
dcw$l FNS ("DCW &")
binarydcw$l FNS ("DCW %")
dcb$l FNS ("DCB &")
binarydcb$l FNS ("DCB %")
assmbl$l FNS ("ASSEMBLE")

 LOCAL

 DCD 7+c_Param_Words+c_ProvidesDefaultMenuString
Wrapwidth
 FNJSR
 TEQ R2,#17
 BEQ a$l
 LDR R0,[R0]
 CMP R0,#8
 MOVLE R0,#8
 TEQ R8,#0
 FNSTR R0,opt_wrapwidth,EQ
 STRNE R0,[R8,#w_wrapwidth]
 MOV R1,#einit_MiscVarChanged
 MOVEQ R2,#0
 MOVEQ R3,#opt_wrapwidth
 MOVNE R2,#8
 MOVNE R3,#w_wrapwidth
 MOV R11,#e_init
 BL call_mode
 FNRTS
a$l
 TEQ R0,#0
 ADREQ R0,s$l
 BLEQ lookup_token_R0
 TEQ R0,#2
 MOVEQ R0,#8
 TEQ R0,#1
 FNRTS NE
 TEQ R8,#0
 ADDEQ R0,R12,#opt_wrapwidth
 ADDNE R0,R8,#w_wrapwidth
 FNRTS
s$l FNS ("zap_m_wrapwidth")

 LOCAL

 DCD c_Param_String+c_PreMinibuffer+c_MinibufferTabCompletion
Writebuffer
 CMP R9,#0
 MOVEQ PC,R14
 TEQ R2,#6
 ADREQ R0,p$l
 MOVEQ R1,#lineed_buf_filename
 BEQ minibuffer_prompt_token_and_history
 FNJSR
 MOV R4,R0			; save filename
 LDR R0,[R9,#f_len]
 MOV R1,#0
 BL split_buffer		; coagulate buffer
 LDR R0,[R9,#f_load]
 BL calc_ftype
 MOVCC R2,R0
 MOVCC R0,#0
 LDRCC R3,[R9,#f_exec]
 MOVCS R2,R0
 MOVCS R0,#10
 MOV R1,R4			; target filename
 LDR R4,[R9,#f_ptr]
 LDR R5,[R9,#f_len]
 ADD R5,R4,R5
 SWI XOS_File
 FNRTS

p$l
 FNS ("zap_p_writebuffer")

 DCD c_Param_String+c_PreMinibuffer+c_MinibufferTabCompletion
Writefile
 TEQ R2,#6
 BNE save_to_file		; this has the intelligence to get it right in exceptional cases
 FNJSR
 LDR R0,[R9,#f_name]
 BL check_file_name		; does name contain path
 MOVVC R7,R0			; save whether it conatins a path
 ADRVC R0,wr_s0
 MOVVC R1,#lineed_buf_filename
 BLVC minibuffer_prompt_token_and_history
 FNRTS VS
 TEQ R7,#0
 BEQ wr11			; path given
 BL find_current_directory
 BLVC minibuffer_write		; insert current directory name
 MOVVC R0,#'.'
 BLVC minibuffer_writec
 FNRTS VS
wr11
 LDR R0,[R9,#f_name]		; leaf name/path
 BL minibuffer_write
 FNRTS
wr_s0
 FNS ("zap_p_writefile")

 DCD 0
Yank
 B yank_command

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Toggle flags subs						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=4 x 8 bit instruction blocks. Each block has format:
;     b0-b4 = 0-31 number of bit in the word to toggle
;     b5/b6 = 00 => toggle the bit
;	      01 => set the bit
;	      10 => clear the bit
;	      11 => reserved
;     b7    = must be set to show this block active (except lowest byte
;	      where its unused by this sub - others may use it)
;X R0=mask R1=eor to accomplish this

calculate_masks
 FNJSR "R2-R3"
 ORR R2,R0,#1<<7		; lowest byte always contains a block
 MOV R0,#0
 MOV R1,#0			; default mask/eor (does nothing)
a$l
 TST R2,#1<<7			; active block?
 FNRTS EQ			; no - finished
 AND R3,R2,#&1F			; bit number
 MOV R14,#1
 MOV R14,R14,LSL R3		; bit mask
 ANDS R3,R2,#&60		; action
 ORREQ R1,R1,R14		; toggle
 TEQ R3,#&20
 ORREQ R0,R0,R14
 ORREQ R1,R1,R14		; set the bit
 TEQ R3,#&40
 ORREQ R0,R0,R14		; clear the bit
 MOV R2,R2,LSR#8
 B a$l

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Adding command tables					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=command table to add R12=zaps workspace
;X command table added / VS

add_command_table
 FNJSR "R1"
 FNLDR R14,com_number
 CMP R14,#max_ctable
 BCS ad16			; table full
 FNADD R1,R12,command_store
 ADD R1,R1,R14,LSL#2
 STR R0,[R1]			; save new command table pointer
 ADD R14,R14,#1
 FNSTR R14,com_number
 FNRTS
ad16
 BL err$l
 FNRTS
err$l ERR "zap_e_manycmdtables"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Command tick updating subs					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R2=action code
;X If R2=15 then returns R0 for menu info and CS
;  If R2<>15 then returns R1=sel off R2=sel len R8/R9=sel or CS if invalid
;  (ie calls get_selection)

shade_no_sel
 TEQ R2,#15
 BNE get_selection		; just read the selection position
 FNJSR
 BL get_selection
 MOVCC R0,#0
 MOVCS R0,#2			; shade if none
 SUBS R0,R0,#0			; sec
 FNRTS

 LOCAL

;E R2=action code
;X If R2=15 then returns R0 for menu info and CS
;  If R2<>15 then returns R1=sel off R2=sel len R8/R9=sel or CS if invalid
;  (ie calls get_selection)

shade_no_sel_at_all
 FNJSR
 TEQ R2,#15
 BEQ a$l
 BL get_selection		; just read the selection position
 FNRTS CC
 CMP R1,R2
 BNE return_set$l
 ADDS R14,R14,#0		; CLC
 FNRTS
a$l
 BL get_selection
 MOVCC R0,#0
 MOVCS R0,#2			; shade if none
 CMP R1,R2
 MOVEQ R0,#0
return_set$l
 SUBS R0,R0,#0			; sec
 FNRTS

; Darren's conditional-related commands start here...

	LOCAL

checklearn			; are we going through any REPEAT loop
	FNJSR	"R0-R3"		; for at least the 2nd time? (NE if so)
	FNLDR	R1,if_bits
	FNLDR	R2,if_stop
	FNLDR	R3,if_count
learn$l	TEQ	R2,R3
	LDRNE	R14,[R1,R2,LSL #3]
	FNRTS	EQ
	ADD	R2,R2,#1
	MOV	R0,R14,LSR #28
	TEQ	R0,#1
	TEQNE	R0,#2
	BNE	learn$l
	TST	R14,#2
	BEQ	learn$l
	FNRTS


checkloop			; are we in a REPEAT/WHILE/CASE structure?
	FNJSR	"R1-R3"		; NE if so, with R0 = type
	FNLDR	R1,if_bits
	FNLDR	R2,if_count
	FNLDR	R3,if_stop
	SUB	R3,R3,#1
loop$l	SUB	R2,R2,#1
	TEQ	R2,R3
	LDRNE	R0,[R1,R2,LSL #3]
	FNRTS	EQ
	MOV	R0,R0,LSR #28
	CMP	R0,#1
	RSBHSS	R14,R0,#3
	BLO	loop$l
	TEQ	R0,#0
	FNRTS


checktrue		; is the most recent IF/WHILE/WHEN/DEFAULT true?
	FNJSR	"R1-R3"		; (NE if so, or no IF)
	FNLDR	R1,if_bits
	FNLDR	R2,if_count
if$l	SUBS	R2,R2,#1
	LDRPL	R14,[R1,R2,LSL #3]
	MOVMI	R14,#1
	MOV	R3,R14,LSR #28
	TEQ	R3,#0
	TEQNE	R3,#2
	TEQNE	R3,#3
	BNE	if$l
	TST	R14,#1
	FNRTS


	LOCAL

	&	7+c_Param_String+c_MinibufferKill+c_Conditional+c_CommandAndFunction+c_FunctionParam_String
		; b21 stops cmd blk exec code checking IF state
If
	FNJSR
	TEQ	R2,#23
	BEQ	If_fn$l
	BL	checktrue
	BEQ	skip$l
noskip$l
	MOV	R1,#0
	BL	evaluate_string
	FNRTS	VS
	MOVS	R0,R1
	FNLDR	R2,if_count
	MOVNE	R0,#1
	CMP	R2,#if_limit
	FNLDR	R1,if_bits,LO
	STRLO	R0,[R1,R2,LSL #3]
	ADDLO	R2,R2,#1
	FNSTR	R2,if_count,LO
	FNRTS	LO
	ADR	R0,toomanyIFs_etc
	BL	lookup_error
	FNRTV
skip$l	FNLDR	R0,if_skip
	ADD	R0,R0,#1
	FNSTR	R0,if_skip
	FNRTS
toomanyIFs_etc
	&	0
	=	"zap_e_deepstruct",0
	ALIGN
If_fn$l	MOV	R10,R0		; parameter string
	MOV	R11,R10
	BL	str_comma	; find comma
	CMP	R0,#32
	BLLO	badif_msg$l	; no comma? error
	FNRTS	VS
	MOV	R7,R0
	MOV	R0,#0
	STRB	R0,[R10,#-1]	; temporary NUL
	MOV	R0,R11
	MOV	R1,#0
	BL	evaluate_string	; evaluate (allow int only)
	STRB	R7,[R10,#-1]
	FNRTS	VS
	TEQ	R1,#0
	BEQ	else$l		; false? check for ELSE part
	BL	str_skip
	TEQ	R0,#','		; if null & there's an ELSE part
	MOVEQ	R0,#0		;   return null
	MOVEQ	R1,#3
	FNRTS	EQ
	MOV	R11,R10
	MOV	R0,R10
	BL	str_comma	; find comma
	MOV	R7,R0
	MOV	R0,#0
	STRB	R0,[R10,#-1]	; temporary NUL
	MOV	R0,R11
	MOV	R1,#256
	BL	evaluate_string
	STRB	R7,[R10,#-1]
ret$l	TEQ	R0,#0
	MOVEQ	R0,R1
	MOVEQ	R1,#2
	MOVNE	R1,#3
	FNRTS
else$l	MOV	R11,R10
	BL	str_comma	; find comma
	CMP	R0,#32
	MOVLO	R0,#0
	MOVLO	R1,#3		; none? return null
	FNRTS	LO
	MOV	R0,R10
	MOV	R1,#256
	BL	evaluate_string
	B	ret$l
badif_msg$l
	ERR	"zap_e_insuffargs"


	&	7
	; E: R4 = address of next command, or 0
Repeat
	FNLDR	R2,if_count
	CMP	R2,#if_limit
	FNLDR	R1,if_bits,LO
	ORRLO	R4,R4,#1<<28
	STRLO	R4,[R1,R2,LSL #3]
	ADDLO	R2,R2,#1
	FNSTR	R2,if_count,LO
	MOVLO	R0,#0
	MOVLO	PC,R14
	ADR	R0,toomanyIFs_etc
	ORREQ	PC,R14,#1<<28


	LOCAL

	&	7+c_Param_String+c_MinibufferKill+c_Conditional
While
	FNJSR
	BL	checktrue
	BEQ	skip$l
noskip$l
	MOV	R3,R0			; point at argument
	MOV	R1,#0
	BL	evaluate_string
	FNRTS	VS
	TEQ	R1,#0
	FNLDR	R2,if_count
	ORRNE	R3,R3,#1
	CMP	R2,#if_limit
	FNLDR	R1,if_bits,LO
	ORRLO	R3,R3,#2<<28
	STRLO	R3,[R1,R2,LSL #3]!
	STRLO	R4,[R1,#4]
	ADDLO	R2,R2,#1
	FNSTR	R2,if_count,LO
	FNRTS	LO
	ADR	R0,toomanyIFs_etc
	FNRTV
skip$l	FNLDR	R1,if_skip
	MOV	R0,#0
	ADD	R1,R1,#1
	FNSTR	R1,if_skip
	FNRTS


	LOCAL

	&	7+c_Param_String+c_MinibufferKill+c_Conditional
Case
	FNJSR
	FNLDR	R2,if_skip
	TEQ	R2,#0
	BEQ	noskip$l
	BL	checktrue
	BEQ	skip$l
noskip$l
	FNLDR	R2,if_count
	CMP	R2,#if_limit-1
	ADRHS	R0,toomanyIFs_etc
	FNRTV	HS
	MOV	R1,#256
	BL	evaluate_string
	FNLDR	R3,if_bits,VC
	ORRVC	R0,R0,#3<<28
	ADDVC	R3,R3,R2,LSL #3
	STMVCIA	R3,{R0,R1}
	ADDVC	R2,R2,#1
	FNSTR	R2,if_count,VC
	FNRTS
skip$l	FNLDR	R0,if_skip
	ADD	R0,R0,#1
	FNSTR	R0,if_skip
	FNRTS


	LOCAL

	&	7+c_Conditional
Else
	FNJSR
	FNLDR	R0,if_skip
	TEQ	R0,#0
	FNRTS	NE
	MOV	R1,#0
	BL	typecheck
	FNRTS	VS
	FNLDR	R0,if_count
	FNLDR	R1,if_bits
	SUB	R0,R0,#1
	LDR	R0,[R1,R0,LSL #3]!
	EOR	R0,R0,#1
	STR	R0,[R1]
	FNRTS


	&	7+c_Conditional
Endif
	FNJSR
	FNLDR	R0,if_skip
	SUBS	R0,R0,#1
	FNSTR	R0,if_skip,PL
	FNRTS	PL
	MOV	R1,#0
	BL	typecheck
	FNLDR	R0,if_count,VC
	SUBVC	R0,R0,#1
	FNSTR	R0,if_count,VC
	FNRTS


	LOCAL

	&	c_Param_String+c_MinibufferKill
	; X: R0 = address of next command / 0 / error
Until
	FNJSR
	MOV	R1,#1
	BL	typecheck
	MOVVC	R1,#0
	BLVC	evaluate_string
	FNRTS	VS
	TEQ	R1,#0
	BNE	true$l
	BL	altesc
	BCC	false$l
	ADR	R0,query_escape
	ADR	R4,repeat$l
	BL	query_abort
	BEQ	true$l
false$l	FNLDR	R2,if_count
	FNLDR	R1,if_bits
	SUB	R2,R2,#1
	LDR	R0,[R1,R2,LSL #3]!
	ORR	R2,R0,#2		; prevent learning :-)
	STR	R2,[R1]
	FNRTS
true$l	FNLDR	R2,if_count
	MOV	R0,#0
	SUB	R2,R2,#1
	FNSTR	R2,if_count
	FNRTS
query_escape
	& 0
	= "zap_q_escrep",0
repeat$l
	= "REPEAT",0
	ALIGN

	LOCAL

query_abort
	FNJSR	"R1-R5"
	BL	lookup_error
	MOV	R4,R0
	ADR	R0,btn$l
	BL	lookup_token_R0
	MOV	R5,R0
	ADR	R1,title$l
	FNLDR	R2,wimp_data
	MOV	R3,#256
	BL	lookup_token
	FNLDR	R1,wimp_realver
	CMP	R1,#320
	MOVHS	R1,#&910
	MOVLO	R1,#&13
	MOV	R0,R4
	ADR	R3,zap$l
	MOV	R4,#1
	SWI	XWimp_ReportError	; this calls XHourglass_Smash
	FNRTS	VS
	MOV	R0,#5
	SWI	XHourglass_Start
	TEQ	R1,#1
	TEQNE	R1,#3
	FNRTS
title$l = "zap_q_msg",0
btn$l	= "zap_q_btns",0
zap$l	= "!zap",0
	ALIGN

	LOCAL

;X CS if Alt+Esc pressed
;  R0-R2 corrupt

altesc	MOV	R0,#129
	MOV	R1,#256-113
	MOV	R2,#255
	SWI	XOS_Byte
	MOVCS	R0,#129
	MOVCS	R1,#256-3
	MOVCS	R2,#255
	SWICS	XOS_Byte
	MOV	PC,R14

	LOCAL

	&	7+c_MinibufferKill+c_Conditional
	; X: R0 = address of next command / 0 / error
Endwhile
	FNLDR	R1,if_skip
	SUBS	R1,R1,#1
	FNSTR	R1,if_skip,PL
	MOVPL	PC,R14
	FNJSR
	MOV	R1,#2
	BL	typecheck
	FNRTS	VS
	FNLDR	R1,if_count
	FNLDR	R4,if_bits
	SUB	R1,R1,#1
	LDR	R0,[R4,R1,LSL #3]!
	MOV	R1,#0
	BIC	R0,R0,#&FC000003
	BL	evaluate_string
	FNRTS	VS
	TEQ	R1,#0
	BEQ	false$l
	BL	altesc
	BCC	true$l
	ADR	R0,query_escape
	ADR	R4,while$l
	BL	query_abort
	BEQ	false$l
	FNLDR	R4,if_bits		; restore!
true$l	LDR	R0,[R4]
	ORR	R0,R0,#2		; prevent learning :-)
	STR	R0,[R4]
	LDR	R0,[R4,#4]
	FNRTS
false$l	FNLDR	R2,if_count
	MOV	R0,#0
	SUB	R2,R2,#1
	FNSTR	R2,if_count
	FNRTS
while$l	=	"WHILE",0
	ALIGN


	&	7+c_Param_String+c_MinibufferKill+c_Conditional
CWhen
	FNJSR
	FNLDR	R1,if_skip
	TEQ	R1,#0
	FNRTS	NE
	MOV	R1,#3
	BL	typecheck
	FNRTS	VS
	BL	checktrue
	BEQ	When_internal
	FNRTS


	&	7+c_Param_String+c_MinibufferKill+c_Conditional
When
	FNJSR
	FNLDR	R1,if_skip
	TEQ	R1,#0
	FNRTS	NE
	MOV	R1,#3
	BL	typecheck
	FNRTS	VS
When_internal
	FNLDR	R1,if_bits
	FNLDR	R2,if_count
	ADD	R1,R1,R2,LSL #3
	LDMDB	R1,{R5,R6}	; string,len OR 0,int
	MOV	R10,R0
	BIC	R5,R5,#&FC000003
	BL	compare_in
	FNRTS	VS
	LDR	R2,[R1,#-8]
	BIC	R2,R2,#1
	ORREQ	R2,R2,#&08000001
	STR	R2,[R1,#-8]
	FNRTS


	&	7+c_Conditional
Default
	FNJSR
	FNLDR	R0,if_skip
	TEQ	R0,#0
	FNRTS	NE
	MOV	R1,#3
	BL	typecheck
	FNRTS	VS
	FNLDR	R1,if_bits
	FNLDR	R2,if_count
	ADD	R1,R1,R2,LSL #3
	LDR	R2,[R1,#-8]
	TST	R2,#&08000000
	BIC	R2,R2,#1
	ORREQ	R2,R2,#1
	STR	R2,[R1,#-8]
	FNRTS


	&	7+c_Conditional
Endcase
	FNJSR
	FNLDR	R0,if_skip
	SUBS	R0,R0,#1
	FNSTR	R0,if_skip,PL
	FNRTS	PL
	MOV	R1,#3
	BL	typecheck
	FNRTS	VS
	FNLDR	R2,if_count
	FNLDR	R1,if_bits
	SUB	R2,R2,#1
	FNSTR	R2,if_count
	LDR	R0,[R1,R2,LSL #3]
	BICS	R0,R0,#&FC000003
	BLNE	heap_free
	FNRTS

	LOCAL

;E R0=struct block type R4=pointer in command block
;X R0=corresponding command in current command block / -> -1
find_command_in_block
	FNJSR	"R1-R5"
	MOV	R5,#0
	TEQ	R0,#1
	ADREQ	R5,Until
	TEQ	R0,#2
	ADREQ	R5,Endwhile
	TEQ	R0,#3
	ADREQ	R5,Endcase
	MOV	R0,#0
loop$l	LDR	R1,[R0,R4]!
	TEQ	R1,R5
	CMPNE	R1,#-1
	FNRTS	EQ
	ADD	R4,R0,#12
	LDR	R6,[R4,#-8]
	LDR	R1,[R4,#-4]
	MOV	R0,R4
	BL	command_data
	B	loop$l

	LOCAL

;E R0=struct block type
;X Blocks popped from struct stack until type R0 encountered or stack 'empty'

popblocks
	FNJSR	"R0-R5"
	FNLDR	R1,if_stop
	MOV	R3,R0
	FNLDR	R4,if_bits
	FNLDR	R5,if_count
pop$l
	FNSTR	R5,if_count
	SUB	R5,R5,#1
	CMP	R5,R1
	FNRTS	LT
	LDR	R0,[R4,R5,LSL #3]
	MOV	R14,R0,LSR #28
	TEQ	R14,R3
	FNRTS	EQ
	TEQ	R14,#3
	BICEQ	R0,R0,#&FC000003
	BLEQ	heap_free
	B	pop$l


	LOCAL
;X Single block popped from struct stack (unles stack is 'empty')

popblock
	FNJSR	"R0-R5"
	FNLDR	R1,if_stop
	MOV	R3,R0
	FNLDR	R4,if_bits
	FNLDR	R5,if_count
	SUB	R5,R5,#1
	CMP	R5,R1
	FNRTS	LT
	FNSTR	R5,if_count
	LDR	R0,[R4,R5,LSL #3]
	MOV	R14,R0,LSR #28
	TEQ	R14,#3
	BICEQ	R0,R0,#&FC000003
	BLEQ	heap_free
	FNRTS

	LOCAL

	&	7+c_MinibufferKill
	; E: R4 = address of next command / 0
	; X: R0 = address of next command / 0 / error
Continue
	TEQ	R4,#0
	MOVEQ	PC,R14
	FNJSR
	BL	checkloop
	BLNE	popblocks
	BL	find_command_in_block
	FNRTS


	&	7+c_MinibufferKill
	; E: R4 = address of next command / 0
	; X: R0 = address of next command / 0 / error
Break
	TEQ	R4,#0
	MOVEQ	PC,R14
	FNJSR
	BL	checkloop
	BLNE	popblocks
	BL	find_command_in_block
	LDR	R1,[R0]
	CMP	R1,#-1		; no point in skipping an end-of-block marker
	FNRTS	EQ
	ADD	R4,R0,#12	; skip command :-)
	LDR	R6,[R4,#-8]
	LDR	R1,[R4,#-4]
	MOV	R0,R4
	BL	command_data
	ADD	R0,R4,R0
	BL	popblock
	FNRTS


	LOCAL

	&	7+c_Param_String+c_UniversalArg
Set
	FNJSR
	MOV	R6,R0
	BL	validate_varname
	BLEQ	bad_zap_variable
	FNRTS	VS
	MOV	R2,R0
	MOV	R0,R6
	SUB	R1,R2,R6
	BL	make_varname
spc$l	LDRB	R1,[R2],#1
	TEQ	R1,#'='
	BEQ	eq$l
	TEQ	R1,#' '
	BEQ	spc$l
	BL	bad_zap_variable
	FNRTS
eq$l	MOV	R0,R2
	MOV	R1,#-1
	BL	evaluate_string	; parse only :-)
	MOVVS	R7,#0
	BVS	free$l
	MOV	R7,R0
	MOV	R4,#3
	MOV	R3,#0
	MOV	R2,R1
	MOV	R1,R0
	FNLDR	R0,wimp_buffer
	SWI	XOS_SetVarVal
free$l	MOVVC	R1,#0
	MOVVS	R1,R0
	MOVS	R0,R7
	BLNE	heap_free
	MOVS	R0,R1
	FNRTS	EQ
	FNRTV

bad_zap_variable
	ERR	"zap_e_badvar"


	LOCAL

	&	7+c_Param_String+c_UniversalArg
Unset
	FNJSR
	MOV	R7,R0
	BL	validate_varname_wild
	BLEQ	bad_zap_variable
	FNRTS	VS
	CMP	R1,#32
	BLHI	bad_zap_variable
	FNRTS	VS
	SUB	R1,R0,R7
	MOV	R0,R7
	BL	make_varname
	FNRTS	VS
	MOV	R3,#0
wipe$l	MOV	R4,#0
	MOV	R2,#-1
	MOV	R1,#0
	FNLDR	R0,wimp_buffer
	SWI	XOS_SetVarVal
	BVC	wipe$l
	FNRTVC


	LOCAL

	&	7+c_Param_String+c_UniversalArg
Local
	TEQ	R4,#0
	MOVEQ	PC,R14
	FNJSR
loop$l	MOV	R7,R0
	BL	validate_varname	; get var name
	BEQ	bad$l
	MOV	R2,R0
spc$l	LDRB	R1,[R2],#1		; skip spaces after name, find comma
	TEQ	R1,#','
	BEQ	comma$l
	CMP	R1,#' '
	BEQ	spc$l
	BGT	bad$l
	MOVLT	R2,#0			; ...if end-of-string found
comma$l	MOV	R6,R2
	SUB	R1,R0,R7
	MOV	R5,R1
	MOV	R0,R7
	BL	make_varname
	FNLDR	R1,wimp_kbdbuf
	MOV	R2,#256
	MOV	R3,#0
	SWI	XOS_ReadVarVal		; get value & type
	MOVVS	R4,#-1
	MOVVS	R2,#0
	BICVC	R4,R4,#16
	ADD	R1,R5,#12		; we want (LEN name+LEN value+1+8)
	ADD	R1,R1,R2		;  bytes
	TEQ	R4,#2
	TEQNE	R4,#4
	ADDNE	R1,R1,#1		; plus one for null...
	BIC	R1,R1,#3
	FNLDR	R0,local_varlist
	TEQ	R0,#0
	ADDEQ	R1,R1,#4
	BL	heap_extend		; extend list by this amount
	FNRTS	VS
	FNLDR	R3,local_varlist
	FNSTR	R0,local_varlist
	TEQ	R3,#0
	LDRNE	R3,[R0]
	ADD	R1,R3,R1
	MOVEQ	R3,#4
	STR	R1,[R0],R3
	STMIA	R0!,{R2,R4}		; store value len & type
	MOV	R3,R2
	MOV	R1,R0
	FNLDR	R2,wimp_buffer
	ADD	R2,R2,#8
	BL	strcopy			; copy var name
	MOV	R2,R1
	FNLDR	R1,wimp_kbdbuf
	TEQ	R4,#2
	TEQNE	R4,#4
	MOVNE	R0,#0			; null-terminate space for value
	SUBNE	R3,R3,#1		;   if required
	STRNE	R0,[R2,R3]
	SWI	XZapRedraw_MoveBytes	; copy var value
	MOVS	R0,R6
	FNRTS	LE			; return if no more
spc2$l	LDRB	R1,[R0],#1		; skip spaces
	TEQ	R1,#' '
	BEQ	spc2$l
	SUB	R0,R0,#1
	B	loop$l			; and do next
bad$l	BL	bad_zap_variable
	FNRTS	VS


	LOCAL

typecheck
	FNJSR	"R1-R4"
	FNLDR	R3,if_count
	FNLDR	R2,if_stop
	SUB	R3,R3,#1
	CMP	R3,R2
	ADRLT	R0,nomatching$l
	BLT	fail$l
	FNLDR	R2,if_bits
	LDR	R2,[R2,R3,LSL #3]
	TEQ	R1,R2,LSR #28
	FNRTVC	EQ
	MOV	R1,R2,LSR #28
	ADR	R0,required$l
	ADD	R1,R1,#4
fail$l	ADR	R14,cmd$l
	LDRB	R4,[R14,R1]
	ADD	R4,R4,R14
	MOV	R2,#0
	BL	lookup_error
	FNRTS

nomatching$l
	&	0
	FNS	("zap_e_nostruct")
required$l
	&	0
	FNS	("zap_e_misstruct")
	ALIGN
cmd$l	=	 if$l-cmd$l, rep$l-cmd$l, whi$l-cmd$l, cas$l-cmd$l
	=	eif$l-cmd$l, unt$l-cmd$l, ewh$l-cmd$l, whn$l-cmd$l
if$l	=	"IF",0
rep$l	=	"REPEAT",0
whi$l	=	"WHILE",0
cas$l	=	"CASE",0
eif$l	=	"ENDIF",0
unt$l	=	"UNTIL",0
ewh$l	=	"ENDWHILE",0
whn$l	=	"WHEN, DEFAULT, ENDCASE",0
	ALIGN


; Functions

; function 'Char'
Char_fn
	MOV	R0,#0
	B	Charoff

	&	c_Function+c_FunctionParam_Word
Charoff
	MOV	R1,R0
	FNJSR	"R8-R10"
	BL	find_input			; please don't...
	LDR	R2,[R9,#f_ptr]
	LDR	R3,[R9,#f_splito]
	ADD	R0,R0,R1
	CMP	R0,R3
	LDRHS	R3,[R9,#f_splits]
	ADDHS	R2,R2,R3
	LDR	R3,[R9,#f_len]
	CMP	R0,R3
	LDRLOB	R0,[R2,R0]
	MVNHS	R0,#0
	MOV	R1,#2
	FNRTS

Returnchar_fn
 	CMP	R8,#0
	FNLDRB	R0,opt_cr,EQ
	LDRNEB	R0,[R8,#w_cr]
	MOV 	R1,#1	; byte
	MOV	PC,R14

Tabchar_fn
 	CMP	R8,#0
	FNLDRB	R0,opt_tabchar,EQ
	LDRNEB	R0,[R8,#w_tabc]
	MOV 	R1,#1	; byte
	MOV	PC,R14

	&	c_Function
Charstr
	MOV	R0,#0
	B	Charoffstr

	&	c_Function+c_FunctionParam_Word
Charoffstr
	FNJSR
	BL	Charoff
	MOV	R1,R0
	MOV	R0,#5
	BL	heap_claim
	FNRTS	VS
	MOV	R2,#0
	STR	R2,[R0]
	TEQ	R1,#0
	MOVMI	R1,#3
	FNRTS	MI
	LDRB	R2,[R8,#w_cr]
	TEQ	R1,R2
	ADREQ	R2,cr$l
	BEQ	wr$l
	LDRB	R2,[R8,#w_tabc]
	TEQ	R1,R2
	ADREQ	R2,tab$l
	BEQ	wr$l
	TEQ	R1,#127
	ADREQ	R2,del$l
	BEQ	wr$l
	CMP	R1,#32
	STRHS	R1,[R0]
	MOVHS	R1,#3
	FNRTS	HS
	BL	ctrllist
	ADD	R2,R2,R1,LSL #2
wr$l	MOV	R1,#:CHR:92		; '\' -- works with armasm/objasm/etc
	STRB	R1,[R0]
	LDRB	R1,[R2]
	STRB	R1,[R0,#1]
	LDRB	R1,[R2,#1]
	TEQ	R1,#0
	STRNEB	R1,[R0,#2]
	MOV	R1,#3
	FNRTS
cr$l	=	"n",0
tab$l	=	"t",0
del$l	=	"?",0
	ALIGN

	&	7+c_Function
False	MOV	R0,#0
	MOV	R1,#2
	MOV	PC,R14

; function 'Filename'
	&	c_Function
Filename
	CMP	R2,#23
	MOVNE	PC,R14
	FNJSR "R2"
	CMP	R9,#0
	ADREQ	R0,anull$l
	LDRNE	R2,[R9,#f_name]
	FNLDR	R1,wimp_block
	BL	strcopy
	FNLDR	R0,wimp_block
	MOV	R1,#3
	FNRTS
anull$l	 DCD	0

	LOCAL

	&	7+c_Function+c_FunctionParam_String
Match	FNJSR	"R2-R5"
	MOV	R5,#zsearch_MatchAtCursor+zsearch_DontBeep
	ORR	R5,R5,#zsearch_NoMacros+zsearch_NoHourglass
	LDRB	R1,[R0]
	TEQ	R1,#164 ; ''
	BLEQ	flags$l
	MOV	R1,#zsearch_NoOutput
	BL	search_data
	MVN	R0,R0,ASR #31 ; all bits = ~(top bit)
	MOV	R1,#2
	FNRTS
flags$l	ADD	R0,R0,#1
	MOV	R2,#0
loop$l	LDRB	R1,[R0],#1
	CMP	R1,#164 ; ''
	CMPNE	R1,#31
	MOVLS	PC,R14
	; Controls
	TEQ	R1,#'~' ; toggle
	MOVEQ	R2,#0
	TEQ	R1,#'+' ; set
	MOVEQ	R2,#1
	TEQ	R1,#'-' ; clear
	MOVEQ	R2,#2
	MOV	R4,#0
	; Modifiers
	TEQ	R1,#92 ; '\'
	MOVEQ	R3,#zsearch_NoCommands
	MOVEQ	R4,#3
	BIC	R1,R1,#32
	TEQ	R1,#'C'
	MOVEQ	R3,#zsearch_CaseSensitive
	TEQ	R1,#'M'
	MOVEQ	R3,#zsearch_NoMacros
	MOVEQ	R4,#3
	TEQ	R1,#'R'
	MOVEQ	R3,#zsearch_RawSearch
	; Application of modifiers
	EOR	R4,R4,R2
	TEQ	R4,#1
	ORREQ	R5,R5,R3
	BEQ	loop$l
	TEQ	R4,#2
	BICEQ	R5,R5,R3
	EORNE	R5,R5,R3
	B	loop$l

	&	7+c_Function
True	MVN	R0,#0
	MOV	R1,#2
	MOV	PC,R14

	LOCAL

	&	4+c_Function
Modified
	FNJSR
	BL	test_changed
	MOVEQ	R0,#0
	MOVNE	R0,#-1
	MOV	R1,#2
	FNRTS

	&	7+c_Function
Shift	MOV	R1,#255
inkey$l	MOV	R0,#129
	MOV	R2,#255
	SWI	XOS_Byte
	MOVCC	R0,#0
	MOVCS	R0,#-1
	MOV	R1,#2
	MOV	PC,R14

	&	7+c_Function
Ctrl	MOV	R1,#254
	B	inkey$l

	&	7+c_Function
Alt	MOV	R1,#253
	B	inkey$l

	&	7+c_Function
Modifiers
	FNJSR
	BL	Shift
	AND	R3,R0,#1
	BL	Ctrl
	AND	R0,R0,#2
	ORR	R3,R3,R0
	BL	Shift
	AND	R0,R0,#4
	ORR	R0,R3,R0
	FNRTS

	LOCAL

	&	7+c_Function
Select	MOV	R2,#4
mouse$l	SUB	R13,R13,#32
	MOV	R1,R13
	SWI	XWimp_GetPointerInfo
	LDRVC	R0,[R13,#8]
	ADD	R13,R13,#32
	MOVVS	PC,R14
	MOV	R1,#1
	TEQ	R2,#7
	MOVEQ	PC,R14
	ANDS	R0,R0,R2
	MOVNE	R0,#-1
	MOV	PC,R14

	&	c_Function
Menu	MOV	R2,#2
	B	mouse$l

	&	c_Function
Adjust	MOV	R2,#1
	B	mouse$l

	&	c_Function
Buttons	MOV	R2,#7
	B	mouse$l

; function 'Mode'
Mode_fn
	TEQ	R8,#0
	FNLDRB	R0,opt_format,EQ
	LDRNEB	R0,[R8,#w_format]	; mode number
	MOV	R1,#1
	MOV	PC,R14

	LOCAL

; function 'Moden'
Moden_fn
	FNJSR
	BL	Mode_fn
	BL	read_mode
null$l	CMP	R1,#0
	LDRGT	R0,[R1,#8]
	ADRLE	R0,null$l
	MOV	R1,R0
	BL	str_len
	ADD	R0,R0,#1
	BL	heap_claim
	FNRTS	VS
	MOV	R2,R0
copy$l	LDRB	R3,[R1],#1
	CMP	R3,#'A'
	RSBHSS	R14,R3,#'Z'
	ADDHS	R3,R3,#32	; to lower case
	STRB	R3,[R2],#1
	TEQ	R3,#0
	BNE	copy$l
	MOV	R1,#3
	FNRTS

	&	c_TickableMenuEntry+c_CommandAndFunction
Selanywhere
	CMP	R2,#15
	BEQ	shade_no_sel_at_all ; shdenosel$l
	CMP	R2,#23
	MOVNE	PC,R14
	FNJSR
	MOV	R7,R8
	BL	get_selection
	FNRTS	VS
	MOV	R1,#2
	MOVCC	R0,#-1
	MOVCS	R0,#0			; no sel = FALSE
	FNRTS

	&	c_TickableMenuEntry+c_CommandAndFunction
Selhere
	FNJSR
	MOV	R7,R8
	TEQ	R2,#23			; was CMP!?
	BNE	shdenoselhere$l
	BL	get_selection		; corrupts R2...
	FNRTS	VS
	MOV	R1,#2
	TEQ	R7,R8
	MOVEQ	R0,#-1
	MOVNE	R0,#0
	MOVCS	R0,#0
	FNRTS
shdenoselhere$l
	BL	get_selection		; corrupts R2...
	FNRTS	VS
	MOV	R1,#2
	TEQ	R7,R8
	MOVEQ	R0,#0
	MOVNE	R0,#2
	MOVCS	R0,#2
	FNRTS

	&	c_Function
Selsize
	FNJSR
	MOV	R7,R8
	BL	get_selection
	FNRTS	VS
	MOV	R1,#2
	MOVCC	R0,R2
	MOVCS	R0,#-1
	FNRTS

	LOCAL

	&	c_Function+c_FunctionParam_String
Ticked	MOV	R3,#1
tick$l
	FNJSR	"R10"
	MOV	R10,R0
	BL	read_one_command
	FNRTS	VS
	BL	check_arg_valid
	BVS	error$l
	LDR	R0,[R7,#-4]
	TST	R0,#1<<15
	BEQ	no_15$l
	PUSH	"R1,R6"
	MOV	R2,#15
	MOV	R0,R1
	BL	process_key_command
	PULL	"R1,R6"
	BVS	error$l
	TST	R0,R3
	MOVNE	R0,#-1
no_15$l	MOVEQ	R0,#0
	MOV	R1,#2
	FNRTS
error$l	MOV	R2,R0
	CMP	R6,#3
	MOV	R0,R1
	BL	heap_free
	MOV	R0,R2
	FNRTV

	&	c_Function+c_FunctionParam_String
Greyed	MOV	R3,#2
	B	tick$l

	&	c_Function
Eof
	FNJSR	"R8-R10"
	BL	find_input
	LDR	R1,[R9,#f_len]
	TEQ	R0,R1
	MOVEQ	R0,#-1
	MOVNE	R0,#0
	MOV	R1,#2
	FNRTS

	&	c_Function
Sof
	FNJSR	"R8-R10"
	BL	find_input
	TEQ	R0,#0
	MOVEQ	R0,#-1
	MOVNE	R0,#0
	MOV	R1,#2
	FNRTS

	LOCAL

	&	7+c_Function+c_FunctionParam_String
In
	FNJSR
	MOV	R10,R0		; parameter string
	MOV	R11,R10
	BL	str_comma	; find comma
	CMP	R0,#32
	BLLO	badin_msg$l	; no comma? error
	FNRTS	VS
	MOV	R7,R0
	MOV	R0,#0
	STRB	R0,[R10,#-1]	; temporary NUL
	MOV	R0,R11
	MOV	R1,#256
	BL	evaluate_string	; evaluate (allow string or int)
	STRB	R7,[R10,#-1]
	FNRTS	VS
	MOV	R5,R0		; string to search for (if <>0)
	MOV	R6,R1		; int to search for (if R5=0)
	BL	compare_in
	MOVEQ	R2,#-1
	MOVNE	R2,#0
	MOVVS	R2,R0
	MOV	R0,R5
	BL	heap_free	; free the first string even if error
	MOV	R0,R2
	CMP	R0,#0
	MOVLE	R1,#2
	CMPLE	R1,R1		; ensure V clear
	FNRTS	EQ
	FNRTV
badin_msg$l
	ERR	"zap_e_insuffargs"


	LOCAL

;E R5,R6=arg (R5!=0 if string) R10=comma-separated list to compare agait
;X EQ if match found; R10 corrupt

compare_in
	FNJSR	"R1-R4,R7,R11"
loop$l	MOV	R11,R10		; start of current substring
	BL	str_comma	; find comma / EOS
	MOV	R7,R0
	MOV	R0,#0
	STRB	R0,[R10,#-1]	; temporary NUL
	MOV	R0,R11
	MOVS	R1,R5
	MOVNE	R1,#256		; allow string if first param was string
	BL	evaluate_string	; evaluate
	STRB	R7,[R10,#-1]
	BVS	err1$l
	TEQ	R5,#0
	BEQ	donum$l		; ... if an int was returned
	MOV	R4,R0		; we have a string
	MOVS	R1,R0		; are we looking for an int?
	BEQ	mismatch$l	; error if we are
	MOV	R2,R5
	BL	strcmp		; do the comparison
	BEQ	strmatch$l
	MOV	R0,R4		; no match
	BL	heap_free	; free the string
	LDRB	R0,[R10,#-1]
	CMP	R0,#32
	BHS	loop$l		; any more to compare against?
	FNRTS
strmatch$l
	MOV	R0,R4		; we have a matching string
	BL	heap_free	; - free it
match$l	CMP	R0,R0
	FNRTS
donum$l	TEQ	R0,#0		; comparing numbers... is this one?
	BNE	notnum$l	; ...no
	TEQ	R1,R6		; ...yes - does it match?
	BEQ	match$l		; ...yes - return -1
	LDRB	R0,[R10,#-1]	; ...no
	CMP	R0,#32
	BHS	loop$l		; any more to compare against?
	FNRTS
notnum$l
	BL	heap_free	; not a number (free the string)
mismatch$l
	ADR	R0,mismatch_msg$l
	MOV	R2,#0
	BL	lookup_error
err1$l	MOV	R7,R0		; error return
	MOVS	R0,R5
	BLNE	heap_free
	MOV	R0,R7
	FNRTV
mismatch_msg$l
	&	0
	FNS	("zap_e_listmismatch")

	LOCAL

	&	c_Function
ModeT
	MOV	R0,#14
	MOV	R1,#2
	MOV	R11,#e_interrogate
	B	call_mode

;E R0=pointer to key sequence blk ending in -1
;  (see buffer_strokes for format)
;X Key strokes executed (as a multiop) for input caret #

 DCD 7+c_Param_Data+c_MovesInputOrKeymap
Multicommand
execute_strokes
 FNJSR "R1-R11"
 FNLDR R1,if_count
 FNLDR R2,if_skip
 FNLDR R3,if_stop
 FNLDR R4,local_varlist
 PUSH "R1-R4"
 FNSTR R1,if_stop
 MOV R1,#0
 FNSTR R1,if_skip
 FNSTR R1,local_varlist
 MOV R6,R0			; save start of list
 FNLDR R5,key_flags		; preserve key_flags
 ORR R0,R5,#2			; set multi strokes flag
 BIC R0,R0,#&1D			; clear rest (only learn once)
 FNSTR R0,key_flags		; mark in the execute_strokes loop
 CMN R10,#0			; R1O==0? (note carry clear)
 BLNE get_input_caret		; get input position
 BCS ret$l
 BL start_operation		; start operations on this file
loop$l
 LDR R7,[R6],#4			; next command address
 CMP R7,#0
 BLE end$l			; finished
 TST R7,#1
 BEQ got$l
 BL validate_command
 BVS end$l			; error
; BVS end$l			; error
 STR R7,[R6,#-4]		; new command address
got$l				; got a validated command
 ADD R6,R6,#4			; skip past data type
 LDR R1,[R6],#4			; number of times
 LDR R4,[R7,#-4]		; flags (abort?)
 AND R4,R4,#7<<3		; mask in data type
 CMP R4,#4<<3
 LDRCS R14,[R6,#-8]		; parameter type
 LDRCS R0,[R6],#4		; pointer to data block
 BCS gotdata$l
 MOV R0,R6			; start of data
 PUSH "R6"
 LDR R6,[R6,#-8];MOV R6,R4,LSR#3	; data type
 BL command_data		; find length
 PULL "R6"
 MOV R14,R0			; save the length
 MOV R0,R6			; data address
 ADD R6,R6,R14			; next command
 LDR R14,[R0,#-8]		; get parameter type
gotdata$l			; R0=command data
 ADRL R2,Repeat
 TEQ R7,R2
 ADDNE R2,R2,#While-Repeat
 TEQNE R7,R2
 ADDNE R2,R2,#Until-While
 TEQNE R7,R2
 ADDNE R2,R2,#Endwhile-Until
 TEQNE R7,R2
 ADDNE R2,R2,#Continue-Endwhile
 TEQNE R7,R2
 ADDNE R2,R2,#Break-Continue
 TEQNE R7,R2
 ADDNE R2,R2,#Local-Break
 TEQNE R7,R2
 MOV R2,R14,LSL #24		; normal call
 ORREQ R2,R2,#1<<30		; looping cmd call
 BL process_command		; do the command
 BVS end$l			; error
 BICS R0,R0,#&FC000003
 TSTNE R2,#1<<30
 MOVNE R6,R0
 MOV R4,R9			; save file
 CMN R10,#0
 BLNE get_input_caret		; may have changed due to the op
 MOVCS R9,R4
 BCS end$l			; we've lost it!
 TEQ R4,R9
 BEQ loop$l			; still on the same file
 PUSH "R9"
 MOV R9,R4
 BL stop_operation		; finished with that file
 PULL "R9"
 BLVC start_operation		; starting with this file
 BVC loop$l
 B ret$l
end$l				; end or error
 FNSTR R5,key_flags		; reset key flags
 BL stop_operation		; stop operation on this file
ret$l
 MOVVC R0,#0
 PUSH "R0"
 FNLDR R11,local_varlist
 TEQ R11,#0
 BEQ freedvar$l
 LDR R5,[R11]
 ADD R5,R5,R11
 ADD R11,R11,#4
freevar$l
 LDMIA R11!,{R2,R4}
 MOV R0,R11
svar$l
 LDRB R1,[R11],#1		; skip var name
 TEQ R1,#0
 BNE svar$l
 SUB R1,R11,R0			; so that R11 points to contents
 SUB R1,R1,#1
 BL make_varname
 MOV R1,R11
 CMP R4,#0
 MOVLT R2,#-1
 MOVLT R4,#0
 SWI XOS_SetVarVal		; restore variable (unset if necesary)
 TEQ R2,#0
 ADDPL R11,R11,R2
 ADD R11,R11,#3
 BIC R11,R11,#3
 CMP R11,R5
 BLT freevar$l
 FNLDR R0,local_varlist		; free local vars list
 BL heap_free
freedvar$l
 LDMFD R13,{R1-R3}
 FNLDR R4,if_bits
 FNLDR R5,if_count
freecase$l
 SUB R5,R5,#1
 CMP R5,R1
 BLT freedcase$l
 LDR R0,[R4,R5,LSL #3]
 MOV R14,R0,LSR #28
 TEQ R14,#3
 BICEQ R0,R0,#&FC000003
 BLEQ heap_free
 B freecase$l
freedcase$l
 PULL "R0-R4"
 FNSTR R1,if_count
 FNSTR R2,if_skip
 FNSTR R3,if_stop
 FNSTR R4,local_varlist
 TEQ R0,#0
 FNRTS EQ
 FNRTV



 END
