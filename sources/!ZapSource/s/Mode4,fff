; Contains mode entry points for code mode.
; THIS IS A 1.39+ BETA 8+ Mode 4 - modified to work with Mode4dis
; $Id: Mode4,fff,v 1.1.2.13 1999/04/25 19:58:42 ds Exp $

	GET	h.ZapHeader
	GET	h.Messages
	GET	h.AlterTxt
	GET	h.Commands
	GET	h.Execute
	GET	h.CreateWind
	GET	h.Cursors
	GET	h.Heap
	GET	h.KeyBits
	GET	h.Menus
	GET	h.MiniBuff
	GET	h.Mode0
	GET	h.Mode1+2
	GET	h.Mode3
	GET	h.ModeBits
	GET	h.ModuleBits
	GET	h.Redraw
	GET	h.Strings
	GET	h.Update
	GET	h.TMTVars

	IMPORT	get_pointer_to_code_cols
	IMPORT	mode4_clever_dis
	IMPORT	mode4_clever_search

	EXPORT	mode_table_4
	EXPORT	mode4_return
	EXPORT	mode4_setwidth
	EXPORT	inmode4_return
	EXPORT	CmdCODEflagstoggle
	EXPORT	Code_disasmtoggle
	EXPORT	redrawallcodemodewindows
	EXPORT	but_sortwwout
	EXPORT	mode4_aif_headerstring
	EXPORT	mode4_mod_headerstring

MODE4_COLNUMBS * &21

mode_table_4
	DCD	mode_table_4
	DCD	mode4_title
	DCD	mode4_author
	DCD	1			; based on Word mode...
	DCD	4+emode_BinaryMode+emode_UsesMessageTrans+emode_MayBeCloned
	DCD	mode4_init
	DCD	0
	DCD	mode4_table_end-mode_table_4

	DCD	0			; postload
	DCD	0
	DCD	0
	DCD	mode4_start
	DCD	mode4_end
	DCD	mode4_width
	DCD	mode4_linecol
	DCD	mode4_lineoff
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode4_minus
	DCD	mode4_plus
	DCD	mode4_minus
	DCD	mode4_plus
	DCD	mode3_cminus
	DCD	mode3_cplus
	DCD	mode4_redrawline
	DCD	0
	DCD	mode4_char		; start a new string
	DCD	Null			; no delete char
	DCD	0
	DCD	mode4_return
	DCD	0
	DCD	0
	DCD	mode1_linestart
	DCD	mode1_lineend
	DCD	mode1_lineend
	DCD	mode1_linestart
	DCD	mode4_copy
	DCD	0
	DCD	0
	DCD	mode4_aligncaret
	DCD	command_primative
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode4_search
	DCD	replace_area		; 0
	DCD	0			; selection
	DCD	mode4_click		; click
	DCD	0			; messages
	DCD	mode4_setwidth
	DCD	0			; list fns
	DCD	mode0_prevline
	DCD	0			; Open window
	DCD	mode4_interrogate	; Answer all Zap's questions...
	DCD	0			; e_returnword
	DCD	mode4_help
mode4_table_end

mode4_author
	=	"Dominic Symes, Tim Tyler, Justin Fletcher and Darren Salt",0
	ALIGN

mode4_title
	FNS	("Code")

mode4_init
	TEQ	R1,#7
	BEQ	mode4_menu
	TEQ	R1,#13
	BEQ	mode4_init_13
	TEQ	R1,#14
	BEQ	mode4_init_14
	TEQ	R1,#6
	ADREQ	R1,mode4_cols
	TEQ	R1,#0
	MOVEQ	R0,#-1			; don't kill this module
	MOVEQ	PC,R14
 ;TEQ R1,#1
 ;BEQ start$l ; OK
	TEQ	R1,#2
	MOVNE	PC,R14
	FNJSR	"R0-R4,R8"
	MOV	R8,#0
	MOV	R1,R0			; mode number
; BL like_init_mode_word
	BL	ensure_colours_correct
 ;MOV R0,#MODE4_COLNUMBS
 ;FNcall Zap_ModeColourNum		; change palette size
 ;CMP R0,#MODE4_COLNUMBS
 ;BLNE mode4_UnkPreColBit		; define them

	MOV	r8,#0
	LDR	R1,[R13]		; mode number
	BL	get_mode_word
; FNcall Zap_GetModeWord
	BVS	mode4_dontchangeathing
	TEQ	R0,#0
	BNE	mode4_dontchangeathing
	MOV	R0,#&20000000		; default_mode_word
	BL	put_mode_word
; FNcall Zap_PutModeWord
mode4_dontchangeathing
	LDMFD	R13!,{R0-R4,R8,PC}^	; return no error

mode4_init_13				; set up for redraw
	FNJSR
; SWI &107
	BL	getdisasmdata
	STR	R0,local_disassemblerflags
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R2,[R14,R2,LSL #2]
	BL	readandputdisasmdata
	FNRTS

mode4_init_14				; end of redraw data
	B	readandrestoredisasm

;start$l
; FNJSR
; STR R0,localcopyof_mode_code
; MOV R1,R0
; PUSH "R1"
; ADD R1,R1,#&100			; variable number
; FNcall Zap_ReadVar			; R0=mode word
; PULL "R1"
; TEQ R0,#0
; FNRTS NE
; MOV R0,#&20000000			; default value...!?
; ADD R1,R1,#&100
; FNcall Zap_WriteVar			; width kept here
; FNRTS

;localcopyof_mode_code
;  & 0

;E R0=mode number R8/R9=window /0 for options menu
;X mode word saved #

save_mode_word
; FNJSR "R11"
	B	modes_end
; FNcall Zap_SaveModeWord,R11
; FNRTS

;E R0=mode number R8/R9=window /0 for options
;X mode word restored #

restore_mode_word
; FNJSR "R11"
	B	modes_start
; FNcall Zap_RestoreModeWord,R11
; FNRTS

; mode4_UnkPreColBit
;  FNJSR "R1-R4"
;  ADR R3,mode4_DefaultColours
;  MOV R1,#4				; modenumber = code mode...
; mode4_PreZModColBit
;  MOV R2,#&09				; start colours
; mode4_ZModColBit
;  LDRB  R0,[R3],#1
;  FNcall Zap_ModeColour		; Read colour definitions
;  FNRTS VS
;  ADD R2,R2,#1
;  TEQ R2,#MODE4_COLNUMBS		; max colours
;  BNE mode4_ZModColBit
;  FNRTS

;like_init_mode_word
; FNJSR "R0-R4,R8"
 ;MOV R8,#0				; default options
 ;MOV R1,#4
 ;ADR R3,mode4_col_sup$l
 ;BL Acallsub$l
; BL ensure_colours_correct
; FNRTS

;Acallsub$l				; R1=mode number R3=data block
; FNJSR
; LDR R4,[R3],#4			; number of extra colours
; PUSH "R1"
; ADD R1,R1,#&100			; variable number
; FNcall Zap_ReadVar			; R0=mode word
; PULL "R1"
; TEQ R0,#0
; FNRTS NE				; already set up
; ;PUSH "R1"
; ;LDR R0,[R3]				; get width etc
; ;MOV R0,R0,LSL#16
; ;MOV R0,R0,LSR#16			; save width in mode word
; ;ADD R1,R1,#&100
; ;FNcall Zap_WriteVar			; width kept here
; ;PULL "R1"
; LDR R0,[R3]
; MOV R2,#0
; MOV R1,#4
; ADD R0,R3,#4
; ADD R4,R4,#9
; BL mode4_init_cols			; setup initial colours
; MOVS R0,#0
; FNRTS

mode4_col_sup$l
	DCD	(MODE4_COLNUMBS - 9)	; no of extra colours...
	DCD	&03010000+40		; Code mode width
	DCD	&97070077
	DCD	&3219CFAB		; cols
	DCD	&D23EE584		; cols
	DCD	&123DC191		; cols

ensure_colours_correct
	FNJSR	"R1-R4,R8"
	MOV	R8,#0			; default options
	MOV	R2,#0
; ADR R3,mode4_col_sup$l
; LDR R4,[R3],#4			; number of extra colours
; ADD R0,R3,#4
; ADD R4,R4,#9
	MOV	R4,#MODE4_COLNUMBS
	BL	get_pointer_to_code_cols
	BL	mode4_init_cols		; setup initial colours
	FNRTS

	LOCAL

;local_modecodelraero
; DCD 0

;E R0=pointer to words of wimp colours R1=mode number R4=num of cols
;  R8=window to set /0
;X Default colours set up #

mode4_init_cols
	FNJSR	"R1-R5"
; PUSH "R0"
	MOV	R3,R0
	MVN	R0,#0
	BL	mode_colour_num
; FNcall Zap_ModeColourNum,R5		; Read palette size
; PULL "R3"
	CMP	R0,R4
	FNRTS	"GE"			; why doesn't it work?
	MOV	R5,R0
;thethickofthecols
; STR R0,local_modecodelraero
; PUSH "R3"
	MOV	R0,R4
	BL	mode_colour_num
; FNcall Zap_ModeColourNum		; change palette size
; PULL "R3"
	MOV	R2,#0			; colour number
a$l
	LDR	R0,[R3],#4		; next bit of data
; LDR R5,local_modecodelraero
	CMP	R2,R5
	BLT	postinitcolour		; Debugging - Why doesn't it work?
	BL	mode_colour
; FNcall Zap_ModeColour
	FNRTS	VS
postinitcolour
	ADD	R2,R2,#1
	CMP	R2,R4
	BCC	a$l
	FNRTS

;  FNJSR "R1-R5"
;  PUSH "R0"
;  MVN R0,#0
; FNcall Zap_ModeColourNum		; Read palette size
; PULL "R3"
; CMP R0,R3
; FNRTS "EQ"				; ???
;  PUSH "R3"
;  MOV R0,R4
;  ;FNcall Zap_ModeColourNum		; change palette size
;  PULL "R3"
;  MOV R2,#0				; colour number
; mode4_justa$l
;  TST R2,#7				; 8 colour boundry?
;  LDREQ R5,[R3],#4			; next bit of data
;  AND R0,R5,#&F			; wimp colour
;  ;FNcall Zap_ModeColour
;  FNRTS VS
;  MOV R5,R5,LSR#4			; next colour
;  ADD R2,R2,#1
;  CMP R2,R4
;  BCC mode4_justa$l
;  FNRTS

; mode4_DefaultColours			; Colour Numbers :
;  = &0C				; Comment Colour =&09 09
;  = &0E				; String colour  =&0A 10
;  = &0A				; Punctuation	 =&0B 11
;  = &0F				; Embedded {}	 =&0C 12
;  = &04				; Bs		 =&0D 13
;  = &02				; Misc Punct.	 =&0E 14
;  = &03				; Number colour  =&0F 15
;  = &04				; Error colour	 =&10 16
;  = &04				; GSTrans	 =&11 17
;  = &01				; Unknown	 =&12 18
;  = &0C				; Unknown	 =&13 19
;  = &0E				; Unknown	 =&14 20
;  = &01				; Unknown	 =&15 21
;  = &02				; Unknown	 =&16 22
;  = &03				; Unknown	 =&17 23
;  = &04				; Unknown	 =&18 24
;  = &01				; Unknown	 =&19 25
;  = &09				; Cond		 =&19 26
;  = &0B				; Unrecognised	 =&19 27
;  = &08				; FP		 =&19 28
;  = &08				; CP		 =&19 29
;  = &01				; LDM/STM	 =&19 30
;  = &0
;  = &0					; double zero termination !
;  ALIGN

mode4_cols
	=	"zap_m_codecols",0
	ALIGN

mode4_setwidth
; CMP R2,#0
; BNE mode0_setwidth
	FNJSR
; LDR R14,[R0]
	CMP	R0,#&FF			; 255 limit ?
	MOVGT	R0,#&FF
; STRCS R14,[R0]
	BL	mode0_setwidth
	ANDS	R0,R0,#&FF
	MOVEQ	R0,#1
	FNRTS

mode4_width
	FNJSR	"R1-R2"
	MOV	R0,#4
	STR	R0,[R8,#w_bpl]
	MOV	R0,#-1
	LDRB	R1,[R8,#w_format]	; mode number
	MOV	R2,#0
	BL	mode_data		; read the first word of mode data
	AND	R0,R0,#&FF
	CMP	R0,#1
	MOVLT	R0,#1			; width
	LDRB	R1,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R1,[R14,R1,LSL #2]!	; load in our mode word
	BIC	R1,R1,#255
	ORR	R1,R1,R0
	STR	R1,[R14]		; save in our mode word
	ADD	R0,R0,#18
	TST	R1,#mode4_BinaryOpcodes
	ADDNE	R0,R0,#27
	FNRTS

	LOCAL

localmodeword
	&	0

local_temp4r6
	%	32

; E R0 = offset (4 => -4...) / R7 = current address.
; X R0 -> to addr - offset (as an offset?)

getpreviousaddress
	FNJSR
	SUB	R14,R7,R0
	LDR	R0,[R9,#f_ptr]
	CMP	R14,R0
	MOVCC	R0,#0			; !???
	FNRTS	CC
	LDR	R1,[R9,#f_splito]	; offset of split start
	ADD	R1,R0,R1
	CMP	R14,R1			; R7...?
	MOVCC	R0,R14
	FNRTS	CC
	LDR	R1,[R9,#f_splite]	; offset of split end
	ADD	R1,R0,R1
	CMP	R14,R1
	MOVCS	R0,R14
	FNRTS	CS
	LDR	R1,[R9,#f_splits]	; size of split
	SUB	R14,R14,R1
	SUB	R5,R5,R1
	LDR	R1,[R9,#f_splito]	; offset of split start
	ADD	R10,R0,R1		; yuck code... (apparent buffer end...)
	MOV	R0,R14
	FNRTS

tizhexed
	FNJSR
	MOV	R3,#4
	MOV	R4,#0			; current instruction
hex2$l					; hex dump loop
	CMP	R7,R10
	BLCS	red_overflow
	FNRTS	VS
	LDRB	R0,[R7],#1
	ORR	R4,R4,R0
	MOV	R4,R4,ROR #8		; save byte in instruction
 ; BL hex2
	ADD	R6,R6,#2		; increment R6 like hex2...
	TST	R2,#1<<17
	SUBEQ	R6,R6,#4		; little endian so go back
	SUBS	R3,R3,#1
	BHI	hex2$l
	MOV	R0,R4			; instruction
	TST	R2,#1<<17
	BLNE	reverse_word		; big endian
	SUB	R1,R7,R5
	SUB	R1,R1,#4		; offset in file of instruction
	MOV	R4,R0			; save the instruction
	LDR	R2,[R8,#w_addr]
	FNRTS

;E R2 data
readandputdisasmdata
	LDR	R1,[R8,#w_format]
	TST	R1,#bit_windowwrap	; non-global...?
	MOVNE	PC,R14
	MOV	R1,R2,LSR #8
	BIC	R1,R1,#(&F << 20)	; options - need to update if these change
	ORR	R1,R1,#1<<23		; allow those lower-case letters!
	B	putdisasmdata

search_readandputdisasmdata
	LDR	R1,[R8,#w_format]
	TST	R1,#bit_windowwrap	; non-global...?
	MOVNE	PC,R14
	MOV	R1,R2,LSR #8
	BIC	R1,R1,#(&F << 20)	; options - need to update if these change
	B	putdisasmdata

carefully_readandputdisasmdata
	FNJSR
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_windowwrap
	MOVEQ	R1,R2,LSR #8
	BICEQ	R1,R1,#(&F << 20)	; options - need to update if these change
 ; *don't* allow those lower-case letters!?!?!?!
	BLEQ	putdisasmdata
	SUBS	R14,R14,R14
	FNRTS

carefully_readandrestoredisasm
	FNJSR
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_windowwrap
	BLEQ	restoredisasm
	SUBS	R14,R14,R14
	FNRTS

readandrestoredisasm
	LDR	R0,[R8,#w_format]
	TST	R0,#bit_windowwrap
	MOVNE	PC,R14
; fall through

restoredisasm
	FNJSR	"R0,R1"
	LDR	R1,local_disassemblerflags
	BL	putdisasmdata
	FNRTS

local_disassemblerflags
	DCD	0

; mode word values
 ; 0						In a comment
 ; 1						SWI
 ; 2						Branch
 ; 4						Push R14
 ; 8						Pull PC
 ; 16						this may be SWI names (see below)
 ; 32		; SWI names...			nope - registers ... seems to work though
 ; 64		; &ampersand -> hex...
 ; 128		; # immediates
 ; 256		; logical...
 ; 512		; arithmetic...
 ; 1024		; cond complete.
 ; 2048		; second column reached...
 ; 4096		; asm condition (colouring)
 ; 8192		; asm condition (font)
 ; 16384 (14)	; FP?
 ; 32768 (15)	; CP
 ; 65536 (16)	; LDM/STM?
 ; (17)		; LDR/STR?
 ; (18)		; CP?
 ; (19)		; FP?
 ; (20)		; Undefined instruction
 ; (21)		; rolls...
 ; (22)		; Ins is unconditional... :)
mode4_redrawline
	FNJSR
	STR	R11,local_temp4r6 + 24	; save it...
	STR	R9,local_temp4r6 + 28	; this too...
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R2,R8,R2,LSL #2
	LDR	R2,[R2,#w_mode0]
	STR	R2,localmodeword
	MOV	R1,#0			; important r1=0?
	STR	R1,local_bgcol_please
	MOV	R2,#7
	MOV	R0,#9			; colour
	BL	colour_chars_both	; colour the ascii column
	MOV	R1,#7
	MOV	R2,#11
	LDR	R0,localmodeword
	TST	R0,#mode4_BinaryOpcodes
	ADDNE	R2,R2,#27
	MOV	R0,#10			; colour of hex/binary
	BL	colour_chars_both	; colour the hex dump column
	PUSH	"R5,R7,R10"		; save start of line
	MOV	R3,#4
ascii$l					; ascii characters loop
	CMP	R7,R10
	BLCS	red_overflow
	BVS	asciiblnk$l
	LDRB	R0,[R7],#1
	STRB	R0,[R6],#1
	SUBS	R3,R3,#1
	BHI	ascii$l
asciiend$l				; finished ascii field
	BL	colons
	PULL	"R5,R7,R10"		; get start of line
	LDR	R2,[R8,#w_format]	; format value
 ; fudge...
 ;MOV R0,#4
 ;BL getpreviousaddress			; as an offset...?
	SUB	R0,R7,#4
	LDR	R14,local_temp4r6 + 16	; recover previous attempt...
	TEQ	R0,R14
 ;BNE notprehex$l
 ;BEQ atprehex$l			; we've just done the previous instr...?
 ;MOV R0,#8
 ;BL getpreviousaddress			; as an offset...?
	SUBEQ	R0,R7,#8
	LDREQ	R14,local_temp4r6 + 20	; recover previous attempt...
	TEQEQ	R0,R14
	BEQ	atprehex$l		; we've just done the previous instr...?
notprehex$l
	ADR R0,local_temp4r6		; save it...
	STMIA R0,{R5-R7,R10}

	MOV	R0,#8
	BL	getpreviousaddress
	LDR	R11,[R9,#f_ptr]
	CMP	R0,R11
	MOVCS	R7,R0
	BLCS	tizhexed
 ;LDR R2,[R8,#w_addr]
 ;SUB R1,R7,R5
	ADD	R1,R1,R2		; user file address
	SWI	XDebugger_Disassemble	; discard results...
	ADR	R0,local_temp4r6
	LDMIA	R0,{R5-R7,R10}
	MOV	R0,#4
	BL	getpreviousaddress
	LDR	R11,[R9,#f_ptr]
	CMP	R0,R11
	MOVCS	R7,R0
	BLCS	tizhexed
 ;LDR R2,[R8,#w_addr]
 ;SUB R1,R7,R5
	ADD	R1,R1,R2		; user file address
	SWI	XDebugger_Disassemble	; discard results...
 ; end of fudge...
	ADR	R1,local_temp4r6
	LDMIA	R1,{R5-R7,R10}
atprehex$l
	MOV	R1,#0			;?
	LDR	R2,[R8,#w_format]	; format value
	MOV	R3,#4			; huh?
	MOV	R4,#0			; current instruction
 ; restore...
 ; LDR R0,local_temp4r6 + 16	; recover previous attempt...
	SUB	R0,R7,#4		; ?
	STR	R0,local_temp4r6 + 20	; recover previous attempt...
	STR	R7,local_temp4r6 + 16	; save it...
	LDR	R0,localmodeword
	TST	R0,#mode4_BinaryOpcodes
	BNE	insertbinarydata
	TST	R2,#1<<17
	ADDEQ	R6,R6,#6		; little endian
hex$l					; hex dump loop
	CMP	R7,R10
	BLCS	red_overflow
	BVS	just_exit_from_redraw	; overflow
	LDRB	R0,[R7],#1
	ORR	R4,R4,R0
	MOV	R4,R4,ROR #8		; save byte in instruction
	BL	hex2
	TST	R2,#1<<17
	SUBEQ	R6,R6,#4		; little endian so go back
	SUBS	R3,R3,#1
	BHI	hex$l
	TST	R2,#1<<17
	ADDEQ	R6,R6,#10		; finish hex dump field
backfrominsertbinarydata
	BL	colons			; now print instruction
	MOV	R0,R4			; instruction
	TST	R2,#1<<17
	BLNE	reverse_word		; big endian
	SUB	R1,R7,R5
	SUB	R1,R1,#4		; offset in file of instruction

	LDR	R11,[R9,#f_load]
	MOV	R11,R11,ASR #8
	CMP	R11,#-6			; module?
	BEQ	module$l		; it is a module
	CMP	R11,#-8			; absolute?
	BEQ	absolute$l		; it is an absolute
dis$l					; disassemble the instruction
	MOV	R4,R0			; save the instruction
	LDR	R2,[R8,#w_addr]
	ADD	R1,R1,R2		; user file address
	BL	mode4_clever_dis	; gerph
	ADRVS	R1,stored_blank_string2

	MOV	R2,#0			; standard foreground and flags

	AND	R0,R4,#&F<<28		; condition code region
	TEQ	R0,#&E<<28		; AL
	ORREQ	R2,R2,#1<<22		; No condition check needed...

	AND	R0,R4,#7<<25
	TEQ	R0,#5<<25
	ORREQ	R2,R2,#4		; Branch

	TEQ	R0,#4<<25
	BEQ	ldm$l			; STM or LDM

	AND	R0,R4,#&C << 24		; note that 'undefined instruction' will probably have
	TEQ	R0,#4 << 24		; been weeded out already ...
	BEQ	ldr$l			; STR or LDR

	AND	R0,R4,#&F << 24
	TEQ	R0,#&C << 24		; data xfer (P clear)
	TEQNE	R0,#&D << 24		; data xfer (P set)
	TEQNE	R0,#&E << 24		; data op / register xfer
	BEQ	foundcopro$l		; copro

;pregotcol$l
	AND	R0,R4,#15<<24
	TEQ	R0,#15<<24		; SWI signature
	ORREQ	R2,R2,#2
colouring_colour
 ; LDR R4,[R8,#w_txtw]		; offset to foreground mask
	LDRB	R3,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDRB	R3,[R14,R3,LSL #2]	; width of instructions
dis_loop_in_redraw
	LDRB	R0,[R1],#1		; load next character from R1 index.
	TEQ	R0,#0
	BEQ	pre_exit_from_redraw
	TST	R2,#1			; in a comment
	BNE	alreadyinacomment
	CMP	R0,#' '
	BEQ	tobfnumberreductionpossible
	TST	R2,#1<<20		; undefined ins
	BNE	dontcheckthese_minimal	; theundef
	TST	R2,#3<<12		; asm condition (font/colouring)
	BNE	maybe_bgcondcolour

	LDR	R4,localmodeword	; flags...
	TST	R2,#2048		; second column not reached...
	BLEQ	secondcolnotreached2
notaconditionhere2
; TST R4,#mode4_Unconditional
 ;BNE notaconditionhere ; ???
	TST	R2,#1<<22		; second column not reached...
	BLEQ	tochkcondcode		; ????????????????????
; BL tochkcondcode
 ;BNE notaconditionhere
 ;TST R2,#2048				; second column not reached...
 ;BEQ secondcolnotreached
notaconditionhere
	TST	R4,#mode4_MinimalColouring
	BNE	backfromfoundaregister

	TST	R2,#2048		; second column not reached...
	BEQ	backfromfoundaregister	; secondcolnotreached2

	TST	R2,#&C2			; &... or #... or SWI(?) ... erm &2 is MUL, I think.
	BNE	backfromfoundaregister
 ;TST R2,#1 << 20			; Undefined instruction
 ;BNE backfromfoundaregister
	CMP	R0,#'{'
	BCS	backfromfoundaregister

	BIC	R14,R0,#&20
	TST	R4,#1 << 9		; apcs?
	CMPNE	R14,#'A'			; was 'a'
	BCS	foundanAPCSregister	; hope this still works...???

	CMP	R14,#'R'
	BEQ	foundaregister
	CMP	R14,#'C'		; cp
	BEQ	foundaCPregister
	CMP	R14,#'F'		; fp
	BEQ	foundaFPregister
	CMP	R14,#'P'		; sp, ip
	BEQ	foundaPCpossibly

	CMP	R14,#'A'		; a1
	BEQ	foundanASpossibly
	CMP	R14,#'L'		; lr, sl
	BEQ	foundaLSpossibly

backfromfoundaregister
	MOV	R11,#2			; foreground colour - ie start with the default
	TEQ	R0,#';'			; comment?
	BEQ	foundanasmcommenthere

	CMP	R0,#'Z'
	BICGT	R2,R2,#96		; Registers and Hex...
	TEQ	R0,#','			; comma
	TEQNE	R0,#'-'			; hyphen
	BICEQ	R2,R2,#32		; Registers
	BICEQ	R2,R2,#3 << 14		; fp & cp registers
	TST	R4,#mode4_MinimalColouring
	BNE	dontcheckthese_minimal
	TEQ	R0,#'#'			; hyphen
	ORREQ	R2,R2,#128		; &ampersand -> hex...
	TST	R2,#&80			; in constant expression
	TSTEQ	R2,#32		; 2048	; in SWI name...? (erm ... registers?)
	TEQEQ	R0,#'&'			; otherwide &address/hex no...
	ORREQ	R2,R2,#64		; &ampersand -> hex...
	BICEQ	R2,R2,#30		; &ampersand -> hex...????
	TEQ	R0,#','			; comma?
	BICEQ	R2,R2,#&C0		; end of immediate...
dontcheckthese_minimal
	TST	R2,#1 << 16		; LDM/STM?
	MOVNE	R11,#23
	TST	R2,#1 << 17		; LDR/STR?
	MOVNE	R11,#24
	TST	R2,#1 << 18		; FP instr
	MOVNE	R11,#30
	TST	R2,#1 << 19		; CP instr
	MOVNE	R11,#31
	TST	R2,#16			; Pull PC
	MOVNE	R11,#15
	TST	R2,#8			; Push R14
	MOVNE	R11,#14
	TST	R2,#4			; Branch
	MOVNE	R11,#13
	TST	R2,#2			; SWI
	BNE	saswihere
;	MOV	R11,#12			; hope OK.
	TST	R2,#32			; registers
	MOVNE	R11,#19
	TST	R2,#64			; & -> hex
	MOVNE	R11,#20
	TST	R2,#256
	MOVNE	R11,#22			; logical...
	TST	R2,#512
	MOVNE	R11,#22			; arithmetic...
	TST	R2,#1 << 21;1024
	MOVNE	R11,#22			; rolls...
	CMP	R11,#12			; !!! wtf is this doing here?
	TST	R2,#1 << 20		; undefined instructs
	MOVNE	R11,#27
	TST	R2,#1 << 14		; cp regs
	MOVNE	R11,#29
	TST	R2,#1 << 15		; fp regs
	MOVNE	R11,#28
	TST	R2,#128			; # immediates
	MOVNE	R11,#21

	TST	R4,#mode4_MinimalColouring
	BNE	mode4_keepingitsimple	; ?????????????????????????????????
 ;TST R4,#mode4_Unconditional
 ;BNE bfnumberreductionpossible ; mode4_keepingitsimple

	BIC	R14,R0,#&20
	CMP	R14,#'A'
	RSBCSS	R14,R14,#'Z'
	BCS	bfnumberreductionpossible	; skip complications if possible...

	CMP	R0,#'['
	CMPNE	R0,#']'
	MOVEQ	R11,#16
	CMP	R0,#'{'
	CMPNE	R0,#'}'
	MOVEQ	R11,#17
	CMP	R0,#'#'
	CMPNE	R0,#'!'
	CMPNE	R0,#'^'
	CMPNE	R0,#','
	MOVEQ	R11,#18
mode4_keepingitsimple
	CMP	R0,#'@'
	CMPLE	R11,#2
	BLEQ	numberreductionpossible
	TST	R2,#2048		; after at least a space?
	BICEQ	R0,R0,#&20
bfnumberreductionpossible
	LDR	R4,[R8,#w_txtw]		; offset to foreground mask
	STRB	R11,[R6,R4]		; foreground colour
	ADD	R4,R4,R4
	STRB	R0,[R6],#1		; letter
	LDR	R0,[R8,#w_format]
	TST	R0,#1<<25		; free mouse/as BG colour? (flag is smart shift-cursor)
	BNE	possiblyasbackground
	MOV	R11,#1
	SUB	R4,R4,#1
	STRB	R11,[R6,R4]		; background colour
	ADD	R4,R4,#1
	SUBS	R3,R3,#1		; number of chars...?
	BGT	dis_loop_in_redraw
pre_exit_from_redraw
just_exit_from_redraw
	LDR	R11,local_temp4r6 + 24	; save it...
	ADD	R11,R11,#1		; next log line
 ;STR R2,local_bgcol_please
	FNRTSS				; return no error

;theundef
; MOV R11,#27
; B bfnumberreductionpossible	; mode4_keepingitsimple

tobfnumberreductionpossible
	ORR	R2,R2,#2048		; second column reached...
	BIC	R2,R2,#&3<<12
	B	bfnumberreductionpossible	; mode4_keepingitsimple

numberreductionpossible
	LDR	R4,localmodeword
	TST	R4,#mode4_MinimalColouring
	MOVNE	PC,R14
	MOV	R11,#&14		; 'numbers'
	CMP	R0,#'-'
	MOVEQ	R11,#&12
	MOV	PC,R14

; darrens_helpful_lower_case
;  BIC R0,R0,#&20
;  B asmcondfound

stored_blank_string2
	DCD	0
; ADD R11,R11,#1			; next log line
; PUSH "R0,R1,R6"
; LDR R6,local_temp4r6 + 20		; save it...
; MOV R1,#27
; MOV R0,#0
; ;LDR R1,[R8,#w_txtw]
;blankloop$l
; STRB R0,[R6,R1]
; SUBS R1,R1,#1
; BPL blankloop$l
; PULL "R0,R1,R6"
; FNRTSS				; return no error

asciiblnk$l				; blank non present ascii characters
	ADD	R6,R6,R3
	B	asciiend$l

; decode absolute header
; => r1 = file offset
; return using B dis$l
absolute$l
	CMP		r1,#(end_abs_stab - abs_stab) ; +20 for jump header
	BCS		dis$l		; definitely not in header
	CMP		r1,#20		; compare with start of data block
	BLT		dis$l		; is < header data, so we don't care
; check it is a valid AIF file
	PUSH	"R0"			; save the word
	MOV	R0,#16			; address of SWI "OS_Exit"
	BL	cln_readw		; get word
	EOR	r0,r0,#&EF000000	; clear top bits
	EORS	r0,r0,#&00000011	; clear SWI number
	PULL	"R0"			; word not now needed
	BNE	dis$l			; if not 0 now, it's invalid
	MOV     r0,r1                   ; put the offset in the right reg
        BL      mode4_aif_headerstring
        MOV     r1,r0                   ; return the string in R1
	MOV	R2,#&B			; use comment colour
	B	colouring_colour		; and put it in there


; decode module header
; => r1 = file offset
; return using B dis$l
module$l
        MOV     r11,r0                   ; hang on to instruction
        MOV     r0,r1                    ; r0 = offset
        BL      mode4_mod_headerstring   ; read the string
        TEQ     r0,#0                    ; did we decode it ?
        MOVEQ   r0,r11                   ; if not, restore instruction
        BEQ     dis$l                    ; if not, normal disassembly
        MOV     r1,r0                    ; string in r1
	MOV	R2,#&B			 ; use comment colour
	B	colouring_colour	 ; and colour it

; return a string for the module header
; => r0 = offset in file
; <= r0 = string pointer, or 0 if not known
mode4_mod_headerstring
	FNJSR	"R1-R5,R9"
	CMP	R0,#(end_mod_stab - mod_stab) ;&2C
	MOV     r1,r0                   ; r1 = offset
	MOVCS   r0,#0                   ; if too big, it's not known
	FNRTS	CS			; definitely not in header
	MOV	R2,#0			; check valid loop
	PUSH	"R0"			; save the word
checkoff$l			        ; check it is a valid module offset
	MOV	R0,R2
	BL	cln_readw		; get word
	TEQ	R2,#4
	TEQNE	R2,#8
	BICEQ	R0,R0,#1 << 31		; clear bit 31 if init/final
	MOV	R4,R0			; preserve for later...
	BL	valid_off		; valid offset?
	PULL	"R0",CS
	MOVCS   r0,#0                   ; if too big, it's not known
	FNRTS	CS			; definitely not in header
	CMP	R2,R1
	ADDCC	R2,R2,#4
	BCC	checkoff$l
	PULL	"R0"			; word not now needed
	ADR	R0,mod_stab
	LDR	R14,[R0,R1]		; get string offset
	TST	R14,#1<<31
	BEQ	nostring$l
	BIC	R14,R14,#1<<31
	PUSH	"R14"
	FNLDR	R2,wimp_kbdbuf
	MOV	R5,#127			; should be enough space(!)
	LDR	R9,local_temp4r6 + 28	; get saved R9
	LDR	R3,[R9,#f_len]
copy$l	CMP	R4,R3
	FNLDR	R2,wimp_kbdbuf,HS
	BHS	copied$l		; at or past EOF - nullify
	MOV	R0,R4
	BL	cln_readc
	SUBS	R5,R5,#1
	CMPNE	R0,#0
	STRNEB	R0,[R2],#1		; copy while space in buffer & !NUL
	ADDNE	R4,R4,#1
	BNE	copy$l
copied$l
	MOV	R0,#0			; string terminator
	STRB	R0,[R2]
	PULL	"R14"
nostring$l
	FNLDR	R0,env_modstart		; base for indirected offsets
	ADD	R1,R0,R14		; string address
	FNLDR	R2,wimp_data
	MOV	R3,#256
	FNLDR	R4,wimp_kbdbuf
	BL	lookup_token
	FNLDR	R0,wimp_data,VC
	FNRTS				; return the string


ldm$l
	AND	R0,R4,#3<<23		; direction bits
	TST	R4,#1<<20
	BNE	load$l			; LDM
	ORR	R2,R2,#1 << 16
	TEQ	R0,#2<<23			; DB
	BNE	colouring_colour
	TST	R4,#1<<14		; push r14
	ORRNE	R2,R2,#8
	B	colouring_colour

load$l
	ORR	R2,R2,#1 << 16
	TEQ	R0,#1<<23
	BNE	colouring_colour
	TST	R4,#1<<15		; pull r14
	ORRNE	R2,R2,#16
	B	colouring_colour

ldr$l
; TST R4,#&10			; ???
; BNE precolouring_colour		; ???
simplelsdr
	ORR	R2,R2,#1 << 17
	B	colouring_colour

foundcopro$l
	AND	R0,R4,#&F << 8
	TEQ	R0,#&1 << 8
	TEQNE	R0,#&2 << 8
	ORRNE	R2,R2,#1 << 19		; CP
	BNE	colouring_colour
	TEQ	R0,#&1 << 8
	BEQ	secondary_problem
	AND	R0,R4,#&F << 24
	TEQ	R0,#&E << 24
	ORREQ	R2,R2,#1 << 19		; CP
	ORRNE	R2,R2,#1 << 18		; FP
	B	colouring_colour

saswihere
	MOV	R11,#12
	TST	R2,#2048
	MOVNE	R11,#25
	B	mode4_keepingitsimple

foundaregister
	LDRB	R14,[R1]
	CMP	R14,#'0'
	RSBHSS	R14,R14,#'9'
	BLO	foundaROpossibly
	MOV	R2,#32
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#19
	B	mode4_keepingitsimple

foundanAPCSregister
	TEQ	R14,#'C'		; cp
	BEQ	foundaNAPCSCPreg
	TEQ	R14,#'F'		; fp
	BEQ	foundaNAPCSFPreg
	TEQ	R14,#'P'		; sp, ip
	BEQ	APCSstylep
notAPCSstylep
	MOV	R2,#32
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#19
	B	mode4_keepingitsimple

APCSstylep
	LDRB	R14,[R1,#-2]		; ??? - because r1 has already been advanced ...
	BIC	R14,R14,#&20
	TEQ	R14,#'C'
;	TEQNE	R14,#'F'
	BNE	notAPCSstylep
	MOV	R2,#1 << 14
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#29
	B	mode4_keepingitsimple

foundaNAPCSFPreg
	LDRB	R14,[R1]
	CMP	R14,#':'
	BCS	notAPCSstylep
	CMP	R14,#'0'
	BCC	notAPCSstylep
	MOV	R2,#1 << 15
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#28
	B	mode4_keepingitsimple

foundaNAPCSCPreg
	LDRB	R14,[R1,#-2]
	BIC	R14,R14,#&20
	TEQ	R14,#'P'
	BEQ	mode4_keepingitsimple
;	B	foundaCPregister
;	fall through...

foundaCPregister
	LDRB	R14,[R1,#-2]
	BIC	R14,R14,#&20
	TEQ	R14,#'P'		; for 'pc'...
	MOVEQ	R11,#19
	BEQ	mode4_keepingitsimple
	LDRB	R14,[R1]
	BIC	R14,R14,#&20
	TEQ	R14,#'P'
	LDREQB	R14,[R1,#1]
	BIC	R14,R14,#&20
	TEQ	R14,#'S'
	MOVEQ	R11,#19
	BEQ	mode4_keepingitsimple

	LDRB	R14,[R1]		; hope is OK...
	CMP	R14,#'0'
	RSBHSS	R14,R14,#'9'
	BLO	backfromfoundaregister
	MOV	R2,#1 << 14
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#29
	B	mode4_keepingitsimple

foundaFPregister
	LDRB R14,[R1]
	CMP R14,#'0'
	RSBHSS R14,R14,#'9'
	BLO backfromfoundaregister
	MOV	R2,#1 << 15
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#28
	B	mode4_keepingitsimple

foundaPCpossibly
	LDRB	R14,[R1]
	BIC	R14,R14,#&20
	TEQ	R14,#'C'
	BNE	backfromfoundaregister
	LDRB	R14,[R1,#-2]
	CMP	R14,#'{'
	CMPNE	R14,#'['
	CMPNE	R14,#'@'
	BGT	backfromfoundaregister
	MOV	R2,#32
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#19
	B	mode4_keepingitsimple

foundanASpossibly
	LDRB	R14,[R1]
	TEQ	R14,#'S'
	BNE	backfromfoundaregister
	LDRB	R14,[R1,#1]
	TEQ	R14,#'L'
	TEQNE	R14,#'R'
	BNE	backfromfoundaregister
	MOV	R2,#256
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#22
	B	mode4_keepingitsimple

foundaLSpossibly
	LDRB	R14,[R1]
	TEQ	R14,#'S'
	BNE	backfromfoundaregister
	LDRB	R14,[R1,#1]
	TEQ	R14,#'L'
	TEQNE	R14,#'R'
	BNE	backfromfoundaregister
	MOV	R2,#512
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#22
	B	mode4_keepingitsimple

foundaROpossibly
	LDRB	R14,[R1]
	TEQ	R14,#'R'
	BEQ	mode4_possiblyRRX
	TEQ	R14,#'O'
	BNE	backfromfoundaregister
	LDRB	R14,[R1,#1]
	TEQ	R14,#'L'
	TEQNE	R14,#'R'
	BNE	backfromfoundaregister
itsarolrorrrx
	MOV	R2,#1<<21 ;1024
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#22
	B	mode4_keepingitsimple

mode4_possiblyRRX
	LDRB	R14,[R1,#1]
	TEQ	R14,#'X'
	BNE	backfromfoundaregister
	B	itsarolrorrrx

foundanasmcommenthere
	ORR	R2,R2,#1
	MOV	R11,#11
	LDR	R4,localmodeword
	TST	R4,#mode4_CommentFree
	BEQ	mode4_keepingitsimple
	LDR	R4,[R8,#w_txtw]		; offset to foreground mask
	ADD	R4,R4,R4
	MOV	R11,#0
asmruboutloop
	SUB	R6,R6,#1
	LDRB	R0,[R6]			; letter
	CMP	R0,#32
	STRLEB	R11,[R6,R4]		; foreground colour
	BLE	asmruboutloop
	B	pre_exit_from_redraw

;E R0=word R2=module offset R9=file
;X CC if word valid CS ow |

valid_off
	FNJSR
	CMP	R2,#&10
	BCC	code$l			; code offset
	CMP	R2,#&1C
	BCC	string$l			; string/table offset
	TEQ	R2,#&24
	BEQ	string$l			; string/table offset
	CMP	R2,#&20
	BCS	code$l			; code offset
	CMP	R0,#&01000000		; swi number
	FNRTS
code$l
	AND	R14,R0,#3			; word aligned?
	CMP	R14,#1
	FNRTS	CS			; not word aligned
; does CS need  ^^ to be set here ?
string$l
	LDR	R14,[R9,#f_len]
	CMP	R0,R14			; in file range?
	FNRTS

mod_stab
	DCD	starto$l
	DCD	inito$l
	DCD	fino$l
	DCD	serviceo$l
	DCD	titleo$l+1<<31
	DCD	helpo$l+1<<31
	DCD	commo$l
	DCD	swichunk$l
	DCD	swicode$l
	DCD	switable$l
	DCD	swideccode$l
	DCD	msgdeccode$l+1<<31
end_mod_stab
starto$l	= "zap_d_starto",0
inito$l		= "zap_d_inito",0
fino$l		= "zap_d_fino",0
serviceo$l	= "zap_d_serviceo",0
titleo$l	= "zap_d_titleo",0
helpo$l		= "zap_d_helpo",0
commo$l		= "zap_d_commo",0
swichunk$l	= "zap_d_swichunk",0
swicode$l	= "zap_d_swicode",0
switable$l	= "zap_d_switable",0
swideccode$l	= "zap_d_swidecode",0
msgdeccode$l	= "zap_d_msgdecode",0
	ALIGN

stored_blank_string
	DCD	0

mode4_lineoff
	LDRB R1,[R8,#w_format]	; mode number
	ADD R0,R8,#w_mode0
	LDR R1,[R0,R1,LSL #2]
	MOV R0,#0
	TST R1,#mode4_BinaryOpcodes
	AND R1,R1,#255			; bottom 8 bits
	ADD R1,R1,#18			; hex width
	ADDNE R1,R1,#27		; + bin width
	MOV PC,R14

mode4_linecol
	MOV	PC,R14			; must be at line start

mode4_plus
	FNJSR
	MOV	R0,R1
	MVN	R2,#1			;-2
	BL	follow_branch
	FNRTS

mode4_minus
	FNJSR
	BL	previous_mark
	MVN	R2,#1			; -2 for already moved
	FNRTS

;E R0=instruction word R1=(apparent) address
;X R0=(apparent) address to jump to / CS if none #

find_branch_addr
	STMFD	R13!,{R1-R2,R14}
	SWI	XDebugger_Disassemble
	ADRVS	R1,stored_blank_string
	MOVVS	R2,#1
 ;LDMVSFD R13!,{R1-R2,PC}
fi2
	LDRB	R0,[R1],#1
	TEQ	R0,#'&'
	BEQ	fi3
	CMP	R0,#&20
	BCS	fi2
	SUBS	R0,R0,#0			; sec
	LDMFD	R13!,{R1-R2,PC}
fi3
	MOV	R2,R1			; save first digit
	BL	hex_read
	SUB	R14,R1,R2
	TEQ	R14,#8			; was it 8 chars
	BNE	fi2			; if not then carry on
	ADDS	R0,R0,#0			; clc
	LDMFD	R13!,{R1-R2,PC}

;E R1=apparent address... R2 = 0ffset (4 or 8)
getpreviousinstrs
	FNJSR	"R1"
	SUBS	R1,R1,R2
	MOVS	R0,R1
	MOVMI	R0,#0
	BLPL	cln_readw			; get instruction in R0
	LDR	R2,[R8,#w_addr]		; base address
	ADD	R1,R2,R1
	SWI	XDebugger_Disassemble	; for the sake of ADRLs.
	ADRVS	R1,stored_blank_string
	MOVVS	R2,#1
	FNRTS

; decodes an offset into an AIF header description
; => r0= offset in the file
; <= r0= string to give it, or 0 if none
        LOCAL
mode4_aif_headerstring
	FNJSR	"R1-R3"
        CMP     r0,#&40                 ; is it < start of debugger ?
        BLO     topheader$l             ; if so, it's an explicit header
        MOV     r14,#-4*1               ; -1 string means 'unknown'
        MOVEQ   r14,#-4*2               ; if = start, it's the -2 string
        TEQ     r0,#&44                 ; is it start of zero-init ?
        MOVEQ   r14,#-4*3               ; if so, it's the -3 string
        TEQ     r0,#&7C                 ; is it end of zero-init ?
        MOVEQ   r14,#-4*4               ; if so, it's the -4 string
        MOV     r0,r14                  ; offset = r14
topheader$l
	ADR	R14,abs_stab	        ; take address of offset table
	LDR	R14,[R14,R0]		; get string offset
	FNLDR	R0,env_modstart		; base for indirected offsets
	ADD	R1,R0,R14		; string address
	FNLDR	R2,wimp_data
	MOV	R3,#256
	BL	lookup_token
	MOVVC	R0,R2
	FNLDR	R0,wimp_data,VC
	FNRTS

	DCD	zeroe$l
	DCD	zeros$l
	DCD	debug$l
	DCD	unknown$l
abs_stab
	DCD     decomp$l
        DCD     selfreloc$l
        DCD     zeroinit$l
        DCD     entry$l
        DCD     foolish$l
	DCD	abs_readonly$l
	DCD	abs_readwrite$l
	DCD	abs_debug$l
	DCD	abs_zeroinit$l
	DCD	abs_debugtype$l
	DCD	abs_base$l
	DCD	abs_workspace$l
	DCD	abs_addrmode$l
	DCD	abs_database$l
	DCD	abs_res1$l
	DCD	abs_res2$l
end_abs_stab
zeroe$l         = "zap_d_zeroe",0
zeros$l         = "zap_d_zeros",0
debug$l         = "zap_d_debug",0
unknown$l       = "zap_d_unknown",0
; before here are the 'special' -ve's
decomp$l        = "zap_d_decomp",0
selfreloc$l     = "zap_d_selfreloc",0
zeroinit$l      = "zap_d_zeroinit",0
entry$l         = "zap_d_entry",0
foolish$l       = "zap_d_foolish",0
abs_readonly$l	= "zap_d_abs_readonly",0
abs_readwrite$l	= "zap_d_abs_readwrite",0
abs_debug$l	= "zap_d_abs_debug",0
abs_zeroinit$l	= "zap_d_abs_zeroinit",0
abs_debugtype$l	= "zap_d_abs_debugtype",0
abs_base$l	= "zap_d_abs_base",0
abs_workspace$l	= "zap_d_abs_workspace",0
abs_addrmode$l	= "zap_d_abs_addrmode",0
abs_database$l	= "zap_d_abs_database",0
abs_res1$l	= "zap_d_abs_res1",0
abs_res2$l	= "zap_d_abs_res2",0
	ALIGN


 LOCAL

;E R0=file offset R8/R9 R10=caret
;X Branch at this offset followed #

follow_branch
	FNJSR	"R1-R3"
	STR	R14,local_temp4r6 + 16	; blat cache...
	BIC	R1,R0,#3			; offset of instruction
	STMFD	R13!,{R1}
	BL	getdisasmdata ; carefully_getdisasmdata ;
	STR	R0,local_disassemblerflags
	BL	carefully_readandputdisasmdata
	LDMFD	R13!,{R1}
 ; fudge
	MOV	R2,#8
	BL	getpreviousinstrs
	MOV	R2,#4
	BL	getpreviousinstrs
 ; end fudge
	MOVS	R0,R1
	BLPL	cln_readw			; get instruction in R0
	MOV	R3,R0			; save 'instruction'
	LDR	R2,[R8,#w_addr]		; base address
	ADD	R1,R2,R1
	BL	find_branch_addr
	BVS	exit$l
	BCC	branch$l			; R0=new address
 ; MOV R3,R0 ; tim's ???? fix ????
	BIC	R3,R3,#1 << 31		; clear bit 31...
	SUBS	R0,R3,R2			; file offset corresponding to this address
	BMI	exit$l			; off bottom of file (signed!)
	LDR	R14,[R9,#f_len]
	CMP	R0,R14
	BCS	exit$l			; off end of file
	MOV	R0,R3			; indirect (eg module header)
	SUB	R0,R0,R2			; find file offset
	BL	goto_offset
exit$l
	BL	carefully_readandrestoredisasm
	FNRTS
branch$l
 ;SWI &107
	SUB	R0,R0,R2			; find file offset
	BL	goto_offset
	B	exit$l

mode4_return
	FNJSR
	TEQ	R0,#0
	BNE	inmode1_return
inmode4_return
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R2,[R14,R2,LSL #2]
	STR	R2,localmodeword
	BL	getdisasmdata ; carefully_getdisasmdata VC
	STR	R0,local_disassemblerflags
	BL	loaddisasmwithcare		; if needed VC
	LDR	R2,localmodeword
 ;MOV R1,R2,LSR #8
 ;BIC R1,R1,#(&F << 20)		; options - need to update if these change
	BL	carefully_readandputdisasmdata

	ADR	R0,mo_s0			; command to execute
	ORR	R0,R0,#1 << 31		; don't learn
	BL	command_string
	BL	carefully_readandrestoredisasm
	FNRTS
mo_s0
	FNS	("ASSEMBLE")

mode4_start
	FNJSR	"R1"
	TEQ	R8,#0
	FNLDRB	R0,opt_format,EQ
	LDRNEB	R0,[R8,#w_format]	; mode number
	BL	restore_mode_word
	BL	loaddisasmwithcare	; load it if needed/possible.
	CMP	R8,#0
	FNRTS	EQ
	LDRB	R1,[R8,#w_format]	; mode number
	ADD	R14,R12,#opt_mode0
	LDR	R0,[R14,R1,LSL #2]
	ADD	R14,R8,#w_mode0
	STR	R0,[R14,R1,LSL #2]
	FNRTS

mode4_end
	TEQ	R8,#0
	FNLDRB	R0,opt_format,EQ
	LDRNEB	R0,[R8,#w_format]	; mode number
	B	save_mode_word

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search through a line (detokenise)			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R1=2 => R3=search file offset R4=direction
;  R1=3 => R1=detokenised str R2=offset/-ve R3=file off of line R10=len
;  R1=4 => As for 3 but R2=end of match offset
;X If R1=2 return vals as passed with R1=3
;  If R1=3 return R1=0 R2=file off of match R3=next offset
;  If R1=4 return R1=0 R2=file off of match end

mode4_search
	STR R14,local_temp4r6 + 16	; blat cache...
	TEQ R1,#3
	BEQ next$l			; find match offset and next line
	TEQ R1,#4
	BEQ end$l			; find end of match offset
	TEQ R1,#2
	MOVNE PC,R14
start$l					; get line to search through
	FNJSR
	PUSH	"R1-R10"		; hmm...
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R2,[R14,R2,LSL #2]
  ; STR R2,localmodeword
	MOV	R3,R2
	BL	getdisasmdata
	STR	R0,local_disassemblerflags
	BL	search_readandputdisasmdata
	PULL	"R1-R10"

	CMP	R4,#0
	ADDPL	R3,R3,#3		; offset 1-3 means go to the next line
	BIC	R3,R3,#3		; file offset of 'line start'
	MOVS	R0,R3
	BLPL	cln_readw		; R0=instruction
	LDRVC	R1,[R8,#w_addr]		; address of first byte
	ADDVC	R1,R1,R3		; address to assume instruction came from
	BLVC	mode4_clever_search	; R1=buf R2=len (RET VS???)
	BVS	possibleproblem$l
;	FNRTS	VS			; !???
	MOV	R10,R2			; save the length
	CMP	R4,#0
	MOVPL	R2,#0			; offset in the detokenised line
	SUBMI	R2,R10,#1		; start at the line end

	BL	readandrestoredisasm	; preserves...?

; LDR R2,[R8,#w_mode4]
; STR R2,localmodeword
; BL carefully_getdisasmdata
; STR R0,local_disassemblerflags
; BL loaddisasmwithcare	; if needed
; LDR R2,localmodeword
; ;MOV R1,R2,LSR #8
; ;BIC R1,R1,#(&F << 20)		; options - need to update if these change
; BL carefully_readandputdisasmdata

	FNRTS

possibleproblem$l
	BL	readandrestoredisasm	; preserves...?
	ADDS	R14,R14,#0
	MOV	R1,#-1			; flag...????
	FNRTS

next$l
	MOV	R1,#0
	CMP	R2,#0
	MOVPL	R2,R3			; file offset of match (off in str ignored)
	ADD	R3,R3,R4,LSL #2		; jump a word in the correct direction
	MOV	PC,R14
end$l
	MOV	R1,#0
	ADD	R2,R3,#3
	MOV	PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Insert a character							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	LOCAL

; R4=w_flags R5=num typed R6=w_format R7=address of characters R8-R10=input

mode4_char
	FNJSR
	BL	minibuffer_wipe		; clear the minibuffer
a$l
	LDRB	R0,[R7],#1
	BL	minibuffer_writec
	FNRTS	VS
	SUBS	R5,R5,#1
	BGT	a$l			; fill up minibuffer
	LDR	R6,[R10,#c_off]		; offset of the instruction
	LDR	R5,[R8,#w_addr]		; address of offset 0
	BIC R6,R6,#3			; word align
	ADD	R0,R5,R6		; address instruction came from
	FNLDR	R1,wimp_block
	MOV	R2,#&100
	SWI	XOS_ConvertHex8		; start off with the address in hex
	FNRTS	VS
	FNLDR	R0,wimp_block
	BL	minibuffer_prompt
; FNcall Zap_MiniPrompt			; prompt = address + colon
	FNRTS	VS
	MOV	R1,#0
	MOV	R0,#0			; address to assume instruction came from
	SWI	XDebugger_Disassemble	; R1=buf R2=len
	ADRVSL	R1,stored_blank_string
	ADR	R0,assemble$l
	BL	find_key_command	; locate+load
	FNRTS	VS
	TEQ	R0,#0
	FNRTS	EQ			; not found
	MOV	R7,R0			; command address
	BL	minibuffer_start	; open the minibuffer
	FNRTS
assemble$l FNS ("ASSEMBLE")

local_bgcol_please
	DCD	0

tochkcondcode
	TST	R2,#&F<<10		; second column not reached...
	MOVNE	PC,R14
secondcolnotreached
	CMP	R0,#'a'
	BICCS	R0,R0,#&20
	BCS	asmcondfound

	TST	R4,#mode4_Unconditional
	MOVNE	PC,R14

	CMP	R0,#'V'
	BEQ	aCoranSV
	CMP	R0,#'C'
	BEQ	aCoranSC
	CMP	R0,#'P'
	BEQ	aPLUShere
	CMP	R0,#'M'
	BEQ	aMINUShere
	CMP	R0,#'L'
	BEQ	anLoranL
	CMP	R0,#'H'
	BEQ	anHoranH
	CMP	R0,#'G'
	BEQ	justalonelyTE
	CMP	R0,#'E'
	BEQ	justalonelyQ
	CMP	R0,#'N'
	BEQ	justalonelyEV
	MOV	PC,R14

secondcolnotreached2 ; can corrupt R11?
	CMP	R0,#'U'
	MOVNE	PC,R14
	LDRB	R11,[R1]
	CMP	R11,#'n'
	LDREQB	R11,[R1,#1]
	CMPEQ	R11,#'d'
	MOVNE	PC,R14
	ORR	R2,R2,#5 << 20		; undefined instructs
	ORR	R2,R2,#2048		; after gap...
	MOV	R11,#27
	B	bfnumberreductionpossible

aCoranSV
	LDRB	R14,[R1,#-2]
	CMP	R14,#'O'
	BEQ	notaconditionhere
	LDRB	R14,[R1,#-3]
	CMP	R14,#'B'
	BEQ	skipchk1$l
	LDRB	R14,[R1,#-4]
	CMP	R14,#'!'
	BLE	notaconditionhere
skipchk1$l
	LDRB	R14,[R1]
	CMP	R14,#'C'
	CMPNE	R14,#'S'
	BNE	notaconditionhere
asmcondfound
	TST	R4,#mode4_Unconditional
	MOVNE	PC,R14

	LDR	R14,[R8,#w_format]
	TST	R14,#1<<25		; cond colour as background?
	ORRNE	R2,R2,#1<<13
	STRNE	R2,local_bgcol_please
	BNE	notaconditionhere	; redundant
	ORR	R2,R2,#1<<12
	MOV	R11,#26
	B	mode4_keepingitsimple
;bgcondcolour
; LDR R14,local_bgcol_please
; CMP R14,#0
; BNE notaconditionhere
; MOV R11,#26
; STR R11,local_bgcol_please
; B notaconditionhere

aCoranSC
	LDRB	R14,[R1]
	CMP	R14,#'S'
	CMPNE	R14,#'C'
	BNE	notaconditionhere

	LDRB	R14,[R6,#-1] ; was 3
	CMP	R14,#'B'
	LDRNEB	R14,[R6,#-2] ; was 3
	CMPNE	R14,#'B'
	BEQ	skipchk3a$l ; if a B (as in BL...)
	LDRB	R14,[R6,#-1] ; was 3
	CMP	R14,#'A'
	LDREQB	R14,[R6,#-2] ; was 3
	CMPEQ	R14,#'!'
	BLE	notaconditionhere
	LDRB	R14,[R6,#-3] ; was 4
	CMP	R14,#'!'
	BLE	notaconditionhere
skipchk3a$l
	LDRB	R14,[R1,#-4]
	CMP	R14,#'A'
	BCS	asmcondfound
	LDRB	R14,[R1,#-3]
	CMP	R14,#'!'
	BCC	asmcondfound
	CMP	R14,#'B'
	BNE	notaconditionhere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'I'
	CMPNE	R14,#'C'
	BEQ	notaconditionhere
	B	asmcondfound

aPLUShere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'D'
	CMPNE	R14,#'M'
	BNE	straightfwdPLUS1
	LDRB	R14,[R1,#-3]
	CMP	R14,#'C'
	BEQ	notaconditionhere
straightfwdPLUS1
	LDRB	R14,[R1]
	CMP	R14,#'L'
	BEQ	asmcondfound
	B	notaconditionhere

aMINUShere
	LDRB	R14,[R1]
	CMP	R14,#'I'
	BNE	notaconditionhere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'R'
	CMPNE	R14,#'M'
	BEQ	asmcondfound
	CMP	R14,#'D'
	CMPNE	R14,#'T'
	BNE	asmcondfound		; dontchkanyfuthereSL
	LDRB	R14,[R1,#-3]
	CMP	R14,#'L'
	BEQ	notaconditionhere
	CMP	R14,#'S'
	BNE	asmcondfound
	LDRB	R14,[R1,#-4]
	CMP	R14,#'T'			; for TSTMI
	BEQ	asmcondfound
	B	notaconditionhere

anHoranH
	LDRB	R14,[R1]
	CMP	R14,#'S'
	CMPNE	R14,#'I'
	BEQ	asmcondfound
	B	notaconditionhere

anLoranL
; LDRB R14,[R1,#1]		; ???
; CMP R14,#'Q'
; BEQ notaconditionhere
;	LDRB	R14,[R1,#-2]
;	CMP	R14,#'@'			; for LOGGTP??
;	BLE	backfromfoundaregister;notaconditionhere
;	LDRB	R14,[R1,#-3]
;	CMP	R14,#'@'			; for LOGGTP??
;	BLE	backfromfoundaregister;notaconditionhere
;	LDRB	R14,[R1,#-1]
;	CMP	R14,#'@'			; for LOGGTP??
;	BLE	backfromfoundaregister;notaconditionhere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'U'			; for MULS...
	CMPNE	R14,#'F'			; for FLTGTP...
;	CMPNE	R14,#'@'			; for LOGGTP
	BEQ	backfromfoundaregister ; notaconditionhere
	LDRB	R14,[R1,#-3]
	CMP	R14,#'@'
	BLE	backfromfoundaregister; notaconditionhere		; FOR FLTGTP F5,R10 etc.
	CMP	R14,#'B'			; FOR BLLT...?
	BEQ	skipchk2$l
	LDRB	R14,[R1,#-4]
	CMP	R14,#'@'
	BLE	backfromfoundaregister ; notaconditionhere
; SWI &107
skipchk2$l
	LDRB	R14,[R1,#1]
	CMP	R14,#'G'		; LOG!!!
	BEQ	backfromfoundaregister ; notaconditionhere
	LDRB	R14,[R1]
	CMP	R14,#'S'
	CMPNE	R14,#'O'
	CMPNE	R14,#'E'
	BEQ	asmcondfound
	CMP	R14,#'T'
	BNE	backfromfoundaregister ; notaconditionhere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'F'			; for FTL<cond>
	BNE	asmcondfound
	LDRB	R14,[R1,#-3]
	CMP	R14,#'!'
	BCS	asmcondfound
	B	backfromfoundaregister ; notaconditionhere

justalonelyTE
	LDRB	R14,[R1]
	CMP	R14,#'T'
	CMPNE	R14,#'E'
	BEQ	asmcondfound
	B	notaconditionhere

justalonelyQ
	LDRB	R14,[R1]
	CMP	R14,#'Q'
	BNE	notaconditionhere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'T'
	BNE	asmcondfound
	LDRB	R14,[R1,#-3]
	CMP	R14,#'S'
	BEQ	asmcondfound
	B	notaconditionhere

justalonelyEV
	LDRB	R14,[R1,#-2]
	CMP	R14,#'M'
	BNE	straightfwdCSV1
	LDRB	R14,[R1,#-3]
	CMP	R14,#'C'
	BEQ	notaconditionhere
straightfwdCSV1
	LDRB	R14,[R1,#-2]
	CMP	R14,#'V'
	BNE	straightfwdCSV2
	LDRB	R14,[R1,#-3]
	CMP	R14,#'M'
	BEQ	notaconditionhere
straightfwdCSV2
	LDRB	R14,[R1,#1]
	CMP	R14,#'Q'
	BEQ	notaconditionhere
	LDRB	R14,[R1]
	CMP	R14,#'E'
	CMPNE	R14,#'V'
	BEQ	asmcondfound
	B	notaconditionhere

;X R1=pointer to the menu

mode4_menu
	FNJSR	"R0"
; SWI &107
	MOV	R0,#14			; Code mode menu
	BL	read_menu_handle		; create the code mode menu
;  SUB R1,R1,#8
	FNRTS

redrawallcodemodewindows
	FNJSR	"R10"
	SWI	XHourglass_On
	ADR	R10,callallroutine$l
	BL	do_allwindow
	SWI	XHourglass_Off
	FNRTS
callallroutine$l
	FNJSR	"R0-R12"
	MOV	R0,#4
	BL	isthisaclonebase
	BLEQ	Updatewindow
	FNRTS

	LOCAL

redrawmostcodemodewindows	; 'global' ones anyway...
	FNJSR
	SWI	XHourglass_On
	CMP	R8,#0
	LDRNE	R0,[R8,#w_format]
	LDREQ	R0,[R12,#opt_format]
	TST	R0,#bit_windowwrap
	BLEQ	Updatewindow
	ADR	R10,callallroutine$l
	BL	do_allwindow
	SWI	XHourglass_Off
	FNRTS
callallroutine$l
	FNJSR	"R0-R12"
	MOV	R0,#4
	BL	isthisaclonebase
	FNRTS	NE
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_windowwrap	; ???
	BLNE	Updatewindow
	FNRTS

	DCD	&8017
Code_disasmtoggle		; global cases dealt with here...
	LDR	R6,[R0]		; gets word argument...
	CMP	R6,#&18
	BCS	backtonormal$l
	FNJSR
	MOV	R0,#4
	BL	isthisaclonebase
r$l	MOVNE	R0,#2		; in case R2=15
	FNRTS	NE		; return if not (a clone of) Code mode
	CMP	R2,#15
	MOVLO	R14,R0
	TEQ	R0,R14		; menu - right mode?
	BNE	r$l
	CMP	R8,#0
	ADDEQ	R11,R12,#opt_mode0
	ADDNE	R11,R8,#w_mode0
	LDR	R0,[R11,R0,LSL #2]! ; mode word
	MOV	R7,R0
	CMP	R2,#15
	BEQ	but_tickquery2		; R2=15 indicates a 'tickquery'
	MOV	R5,R7,LSR #28
	BL	getdisasmdata
	MOV	R7,R0,LSL #8
	BIC	R7,R7,#(&F << 28)
	ORR	R7,R7,R5,LSL #28
	MOV	R5,#0
	AND	R1,R6,#&FF
	BL	mode4_execute
	MOV	R1,R6,LSR #8
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #16
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #24
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R7,LSR #8
	BIC	R7,R7,#(&F << 20)
	BL	putdisasmdata
	BL	redrawmostcodemodewindows
	FNRTS

specialcasestosdeal
	CMP	R6,#255
	BEQ	but_tickquery2
	CMP	R6,#254
	BEQ	but_tickquery3a
	CMP	R6,#253
	FNRTS	NE
	MOV	R0,#0		; clear nothing
	MOV	R1,#(1<<25)	; free click?
	BL	new_wind_format_set
	BIC	R0,R0,#2
	CMP	R2,#15
	FNRTS	EQ
	CMP	R8,#0
	BLNE	Updatewindow
	FNRTS

but_tickquery3a
	TEQ	R2,#15
	BEQ	but_tickquery3b
	TEQ	R8,#0
	LDRNEB	R0,[R8,#w_format]
	LDREQB	R0,[R12,#opt_format]
	CMP	R0,#4
	FNRTS	NE
	MOV	R0,#0		; clear nothing
	MOV	R1,#bit_windowwrap ; 1<<26	; toggle softwrap
	BL	new_wind_format_set
	BL	redrawmostcodemodewindows
	FNRTS

but_tickquery3b
	MOV	R0,#0		; clear nothing
	MOV	R1,#bit_windowwrap ; 1<<26	; toggle softwrap
	BL	new_wind_format_set
	FNRTS

getdisasmdata
	MOV	R0,#0
	MOV	R1,#0
	SWI	XDebugger_63
	SUBVS	R1,R1,R1	; 0 on error...
	MOV	PC,R14

putdisasmdata
	MVN	R0,#0
	SWI	XDebugger_63
	SUBS	R0,R0,R0			; clv.
	MOV	PC,R14

but_sortwwout
	FNJSR "R1-R12"
 ;FNcall Zap_GetWindOff
 ;FNcall Zap_ConvWindOff
 ;BL update_whole_window
 ;MOV	  R0,#4
 ;BL	  but_callmiscentrypt
 ;MOV	  R0,#5
 ;BL	  but_callmiscentrypt
 ;FNcall Zap_SaveWinStatus
 ;FNcall Zap_NewWinStatus
	BL	save_window_status
	BL	new_window_status		; update the window
	BL	Updatewindow
	FNRTS

	DCD	&8017
CmdCODEflagstoggle
	TEQ	R8,#0
	LDREQ	R11,[R12,#opt_format]
	LDRNE	R11,[R8,#w_format]
	TST	R11,#bit_windowwrap	; global?
	BNE	Code_disasmtoggle	; yes...
backtonormal$l
	FNJSR
	LDR	R6,[R0]		; gets word argument...
	MOV	R0,#4
	BL	isthisaclonebase
	MOVNE	R0,#2		; in case R2=15
	FNRTS	NE		; return if not (a clone of) Code mode
	CMP	R2,#15
	MOVLO	R14,R0
	TEQ	R0,R14		; menu - right mode?
	BNE	r$l
	TST	R6,#&80
	BNE	specialcasestosdeal
	TEQ	R8,#0
	ADDEQ	R11,R12,#opt_mode0
	ADDNE	R11,R8,#w_mode0
	LDR	R0,[R11,R0,LSL #2]!
	MOV	R7,R0
	CMP	R2,#15
	MOVEQ	R14,R6
	BEQ	but_tickquery		; R2=15 indicates a 'tickquery'
	MOV	R5,#0
	AND	R1,R6,#&FF
	BL	mode4_execute
	MOV	R1,R6,LSR #8
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #16
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #24
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R0,R7
	STR	R0,[R11]
	CMP	R8,#0
	BLNE	but_sortwwout		; window redraw if needed...
	FNRTS

but_tickquery
	AND	R2,R6,#&1F
	MOV	R3,#1
	MOV	R3,R3,LSL R2
	TST	R7,R3 ; r7?
	MOVNE	R0,#1
	MOVEQ	R0,#0
	FNRTSS

but_tickquery2
	CMP	R6,#255
	BEQ	skipd_codestf
	AND	R6,R6,#&1F
	CMP	R6,#&1C
	BCS	but_tickquery
	SUB	R6,R6,#8
	MOV	R7,#1
	MOV	R7,R7,LSL R6 ; ???
	MOV	R0,#0
	MOV	R1,#0
	SWI	XDebugger_63
	MOVVS	R7,#0
	TST	R0,R7
	MOVVC	R0,#0
	MOVVS	R0,#2
	ORRNE	R0,R0,#1
	FNRTSS
skipd_codestf
	MOV	R0,#0
	MOV	R1,#0
	SWI	XDebugger_63
	MOVVS	R0,#2
	MOVVC	R0,#0
	SUBS	R14,R14,R14
	ADDS	R0,R0,#0
	FNRTSS

mode4_execute
	AND	 R2,R1,#&1F
	MOV	 R3,#1
	MOV	 R3,R3,LSL R2
	MOV	 R2,#0
	MOV	 R4,#0
	MOV	 R1,R1,LSR #5
	AND	 R1,R1,#3
	CMP	 R1,#1
	MOVEQ	 R2,R3
	CMP	 R1,#2
	MOVEQ	 R4,R3
	BIC	 R7,R7,R2
	ORR	 R7,R7,R4
	EOR	 R7,R7,R3
	MOV	 PC,R14

insertbinarydata
	TST	R2,#1<<17
	ADDEQ	R6,R6,#27		; little endian
binaryloop$l
	CMP	R7,R10
	BLCS	red_overflow
	BVS	just_exit_from_redraw			; overflow
	LDRB	R0,[R7],#1
	ORR	R4,R4,R0
	MOV	R4,R4,ROR #8		; save byte in instruction
	BL	bin8
	MOV	R0,#32
	STRB	R0,[R6],#1
	TST	R2,#1<<17
	SUBEQ	R6,R6,#18		; little endian so go back
	SUBS	R3,R3,#1
	BHI	binaryloop$l
	SUB	R6,R6,#1
	TST	R2,#1<<17
	ADDEQ	R6,R6,#45		; finish hex dump field
	B	backfrominsertbinarydata

maybe_bgcondcolour		; corrupts R4.
	TST	R2,#1<<12
	BICNE	R2,R2,#1<<12
	MOVNE	R11,#26
	BNE	mode4_keepingitsimple
	TST	R2,#1<<10			; fontbgcol
	BICNE	R2,R2,#1<<13
	ORR	R2,R2,#1<<10		; fontbgcol ; 1<<21 ; cond complete.
	TST	R2,#2048			; after some spaces???
	BNE	notaconditionhere2
	BIC	R0,R0,#&20
	B	mode4_keepingitsimple

; LDR R4,local_bgcol_please
; TST R4,#&FF
; TST R2,#3 << 12
; MOVEQ PC,R14
 ;TST R4,#&80000000
 ;ORREQ R4,R4,#&80000000
 ;MOVNE R4,#&7F000000
 ;STR R4,local_bgcol_please
; MOV PC,R14

alreadyinacomment
	MOV	R11,#11
 ;LDR R4,localmodeword
 ;TST R4,#1 << 22
 ;BEQ mode4_keepingitsimple
 ;MOV R0,#32
	B	bfnumberreductionpossible ; mode4_keepingitsimple

possiblyasbackground
 ;STRB R14,[R6,R4]		; background colour
 ;LDR R14,local_bgcol_please
 ;TST R14,#&FF
	SUB	R4,R4,#1
	TST	R2,#1<<13			; cond bg font...
	MOVEQ	R14,#1			; bg.
	MOVNE	R14,#26			; possible colour
; SUB R4,R4,#1
	STRB	R14,[R6,R4]		; background colour
; ADD R4,R4,#1
	SUBS	R3,R3,#1
	BGT	dis_loop_in_redraw
	B	pre_exit_from_redraw

mode4_interrogate
	CMP	R0,#11
	BNE	couldbeokormaybenot
	LDR	R0,local_bgcol_please
	TST	R0,#3<<12 ; &40000000
	MOVNE	R0,#0
	MOVEQ	R0,#11
	MOV	PC,R14

couldbeokormaybenot
	CMP	R0,#14
	MOVEQ	R0,#1
	MOVEQ	PC,R14
	CMP	R0,#16
	BEQ	binarytest$l
	CMP	R0,#15
	BEQ	colourquery$l
	CMP	R0,#13 ; SAYT
	CMPNE	R0,#5 ; ConfineH
	CMPNE	R0,#6 ; ConfineV
	CMPNE	R0,#7 ; Free click
	CMPNE	R0,#8 ; Smart cursors
	CMPNE	R0,#12 ; Line Select
	CMPNE	R0,#23			; block editing?
	CMPNE	R0,#24			; auto-indent
	MOVEQ	R0,#0
	MOVEQ	PC,R14
	CMP	R0,#1
	CMPNE	R0,#2
	MVNEQ	R0,#0
	MOV	PC,R14

secondary_problem
;	TST	R4,#&00200000		; HMM...
;	ORRNE	R2,R2,#1 << 18		; FP...????????
;	BNE	colouring_colour

;	AND	R0,R4,#&F << 20
;	CMP	R0,#&0 << 20
;	CMPNE	R0,#&1 << 20
;	CMPNE	R0,#&6 << 20
;	CMPNE	R0,#&7 << 20
;	CMPNE	R0,#&8 << 20
;	CMPNE	R0,#&A << 20		; > C D E F
;	ORRLT	R2,R2,#1 << 18		; FP
;	BLT	colouring_colour		; dodgy criteria.

;	CMP	R0,#&C << 20
;	CMPNE	R0,#&D << 20		; > C D E F
;	ORREQ	R2,R2,#1 << 19		; CP
;	BEQ	colouring_colour

;	AND	R0,R4,#&0F << 24
;	CMP	R0,#&0D << 24		; &xDxxx1xx?
;	ORREQ	R2,R2,#1 << 19		; CP
;	BEQ	colouring_colour

	MOV	R0,R4,LSR#20
	AND	R0,R0,#&FF
	CMP	R0,#&C3
	CMPNE	R0,#&DC
	CMPNE	R0,#&DD
	CMPNE	R0,#&E0
	CMPNE	R0,#&E1
	CMPNE	R0,#&E2
	CMPNE	R0,#&E3
	CMPNE	R0,#&E4
	CMPNE	R0,#&E5
	ORREQ	R2,R2,#1 << 18		; FP
	BEQ	colouring_colour

	CMP	R0,#&ED			; better here???
	CMPNE	R0,#&EE			; better here???
	CMPNE	R0,#&EF			; better here???
	BEQ	stage4_problem

	CMP	R0,#&C0
	CMPNE	R0,#&C1
	CMPNE	R0,#&C4
	CMPNE	R0,#&C5
	CMPNE	R0,#&C9
	CMPNE	R0,#&CC
	ORREQ	R2,R2,#1 << 19		; CP
	BEQ	colouring_colour
; ...
;	CMP	R0,#&EB			; here...???

	CMP	R0,#&E6
	CMPNE	R0,#&E7
	CMPNE	R0,#&E8
	CMPNE	R0,#&E9			; different...
	CMPNE	R0,#&EA
	CMPNE	R0,#&EC
	BEQ	moreproblems$l
; ...
;	BEQ	idproblem$l

	AND	R0,R0,#&F0
	TEQ	R0,#&D0			; last...
	ORREQ	R2,R2,#1 << 18		; FP ...?
	BEQ	colouring_colour	; ???

	AND	R0,R4,#&F2 << 20	; was above...
	CMP	R0,#&C2 << 20		; &xC2xx1xx
	ORREQ	R2,R2,#1 << 18		; FP
	BEQ	colouring_colour

	AND	R0,R4,#&FF00
	TEQ	R0,#&F100
	BEQ	tertiaryproblems$l
	TEQ	R0,#&D100 ; ???
	BEQ	tertiaryproblems2$l

	AND	R0,R4,#&F1 << 20	; jusr swapped with above...
	CMP	R0,#&E0 << 20
	ORREQ	R2,R2,#1 << 19		; CP
	BEQ	colouring_colour

;	AND	R0,R4,#&F << 20
;	CMP	R0,#&F << 20
;	ANDEQ	R0,R4,#&E << 24
;	CMPEQ	R0,#&E << 24
;	ORRNE	R2,R2,#1 << 19		; CP ...?
;	BNE	colouring_colour

;	AND	R0,R4,#&F << 20
;	CMP	R0,#&F << 20
;	ANDEQ	R0,R4,#&E << 24
;	CMPEQ	R0,#&E << 24
;	ORRNE	R2,R2,#1 << 19		; CP ...?
;	BNE	colouring_colour

;	TEQ	R0,#&D << 24
;	ORREQ	R2,R2,#1 << 18		; FP
;	BEQ	colouring_colour
;	ORREQ	R2,R2,#1 << 18		; FP
;	ORR	R2,R2,#1 << 18		; FP
	ORR	R2,R2,#1 << 19		; CP ...?
	B	colouring_colour

stage4_problem
;	SWI &107
	TST	R4,#&10
	ORRNE	R2,R2,#1 << 19		; CP ...?
	BNE	colouring_colour

	TST	R4,#&8000
	ORRNE	R2,R2,#1 << 18		; FP
	ORREQ	R2,R2,#1 << 19		; CP ...?
;	BNE	colouring_colour

;	ORREQ	R2,R2,#1 << 19		; CP ...?
	B	colouring_colour

; was here - is it necessary...???
;	AND	R0,R4,#&FB00
;	TEQ	R0,#&1100
;;;	TEQNE	R0,#&5100
;	ORRNE	R2,R2,#1 << 18		; FP
;	ORREQ	R2,R2,#1 << 19		; CP ...?
;	B	colouring_colour

;idproblem$l
;;	SWI &107
;	AND	R0,R4,#&FF << 8
;	CMP	R0,#&F1 << 8
;	ORREQ	R2,R2,#1 << 18		; FP ...?
;	BEQ	colouring_colour		; ???
;
;	ORR	R2,R2,#1 << 19		; CP ...?
;	B	colouring_colour

moreproblems$l
	ANDS	R0,R4,#&10
	ORREQ	R2,R2,#1 << 18		; FP ...?
	BEQ	colouring_colour		; ???

	ORR	R2,R2,#1 << 19		; CP ...?
	B	colouring_colour

tertiaryproblems$l
	AND	R0,R4,#&FF << 20	; was above...
	CMP	R0,#&C8 << 20		; &xC2xx1xx
	ORRNE	R2,R2,#1 << 18		; FP ...?
	BNE	colouring_colour	; ???
	ORR	R2,R2,#1 << 19		; CP
	B	colouring_colour

tertiaryproblems2$l
	TST	R4,#&30
	ORREQ	R2,R2,#1 << 18		; FP ...?
	ORRNE	R2,R2,#1 << 19		; CP
	B	colouring_colour

binarytest$l
	FNJSR
	LDRB	R0,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R0,[R14,R0,LSL #2]	; load in our mode word
	TST	R0,#mode4_BinaryOpcodes
	MOVNE	R0,#2
	MOVEQ	R0,#16
	FNRTS

colourquery$l
	CMP	R1,#26
	MOVNE	PC,R14
	LDR	R0,[R8,#w_format]
	TST	R0,#1 << 25			; is it BG
	MOVNE	R0,#2			; bit 0 clear if it is...
	MOVEQ	R0,#15
	MOV	PC,R14

; e_help entry point, written by James (feel free to replace)
;
; \E r0 offset, r8/r9
; \X r0 = number of possibilities, r1 => block of pointers to possibilities
;  r2-r11 preserved
;
; Note: this can probably be written far better by someone else.
; In particular, it would be nice if branches could offer the symbolic
; function name as a possibility, if it exists. That's really Justin's
; area, though ...

buf$l EQU 50
mode4_help
	FNJSR "r2-r3"
	BIC r0,r0,#3 ; round down to a whole word
	MOV r2,r0 ; store for disassembly
	LDR r1,[r9,#f_splito]
	CMP r0,r1 ; is it past split?
	LDRGT r1,[r9,#f_splits]
	ADDGT r0,r0,r1 ; jump over split
	LDR r1,[r9,#f_ptr] ; start of buffer
	ADD r0,r0,r1 ; address
	LDR r0,[r0] ; get instruction word
	AND r1,r0,#(15:SHL:24) ; SWI identifying fragment
	CMP r1,#(15:SHL:24)
	BNE notswi$l

	BIC r2,r0,#(255:SHL:24) ; clear to SWI number
	MOV r0,#buf$l
	BL heap_claim
	FNRTS VS
	MOV r1,r0 ; buffer
	MOV r0,r2 ; SWI number
	MOV r2,#buf$l
	SWI XOS_SWINumberToString
	FNRTS VS

	MOV r0,#8
	BL heap_claim
	BVS fail$l

	STR r1,[r0,#0] ; first possibility
	MOV r1,r0 ; ready for return
	MOV r0,#4
	BL heap_claim
	BVS fail2$l

	STR r0,[r1,#4] ; second possibility
	LDR r2,swi$l
	STR r2,[r0] ; store "SWI\0"
	MOV r0,#2 ; two possibilities
	FNRTS

fail$l	MOV r2,r0 ; store error pointer
	MOV r0,r1 ; buffer to free
	BL heap_free
	MOV r0,r2 ; restore error pointer
	FNRTS

fail2$l MOV r2,r0 ; store error pointer
	LDR r0,[r1,#0] ; get SWI name buffer
	BL heap_free ; free it
	MOV r0,r1 ; get the other buffer
	BL heap_free ; free it
	MOV r0,r2 ; restore error pointer
	FNRTS

swi$l = "SWI", 0

; /E r0 = instruction word, r2 = file offset
notswi$l
	LDR r1,[r8,#w_addr] ; start address for file
	ADD r1,r1,r2 ; address the instruction "came from"
	BIC r0,r0,#(15:SHL:28) ; clear condition code
	ORR r0,r0,#(14:SHL:28) ; 'AL' (disassembled invisibly)
	SWI XDebugger_Disassemble		; naked???

	MOVVC r0,r2 ; length, including terminator
	BLVC heap_claim ; \X r0 => block
	FNRTS VS

	MOV r2,r1 ; source
	MOV r1,r0 ; destination
	MOV r3,r0 ; save it
	BL strcopy ; copy it, including terminator

	MOV r0,#4
	BL heap_claim
	BVS failnotswi$l

	STR r3,[r0] ; store pointer to disassembly
	MOV r1,r0 ; into position for return

	; this, of course, isn't enough. We now have to find the first
	; lwsp byte and replace it with a NUL, so that lookup will only
	; be on the opcode itself (plus flags. Arg.)
loop$l LDRB r2,[r3],#1
	CMP r2,#32
	BGT loop$l
	MOV r0,#0
	STRB r0,[r3,#-1]

	MOV r0,#1 ; one possibility
	FNRTS

failnotswi$l
	MOV r1,r0 ; store error pointer
	MOV r0,r3 ; get block pointer
	BL heap_free ; free it
	MOV r0,r1 ; restore error pointer
	FNRTS

	LOCAL

mode4_click
	CMP	R1,#2
	BLO	default_click	; simple drag, or single click
	TST	R4,#3		; multiple click + drag
	BNE	default_click
	TST	R1,#1
	BNE	select_buffer	; odd number of clicks -> select all
	FNJSR
	BL	find_offset
	MOV	R2,R0
	ADD	R3,R2,#4
	LDR	R14,[R9,#f_len]
	CMP	R3,R14
	MOVHS	R3,R14
	TEQ	R2,R3
	BNE	sel$l
	BL	clear_selection
	FNRTS
sel$l	BL	alter_selected_region
	FNRTS


mode4_aligncaret
	FNJSR
	LDRB	R14,[R8,#w_format]
	LDR	R0,[R10,#c_off]
	BIC	R0,R0,#3			; word align
	STR	R0,[R10,#c_off]
	FNLDR	R0,car_hex		; copy so can be recovered only
	FNSTR	R0,car_hexold		; by e_char entry point
	MOV	R0,#0
	FNSTR	R0,car_hex		; zero current value
	FNRTS

	LOCAL

mode4_copy
	TEQ	R0,#2
	MOVEQ	R0,#1
	MOVEQ	PC,R14			; enter the text automatically
	FNJSR	"R1,R4-R7"
	MOV	R2,R1			; save number of times
	LDRB	R14,[R8,#w_format]
	FNLDR	R0,wimp_kbdbuf		; output buffer
	ADD	R14,R8,R14,LSL #2
	LDR	R14,[R14,#w_mode0]
	MOV	R1,R2,LSL#2		; words
	BL	heap_ensure
	FNRTS	VS
	FNSTR	R0,wimp_kbdbuf
	MOV	R3,R0			; buffer
	MOV	R4,#0			; number typed
	LDR	R7,[R10,#c_off]		; file offset
	LDR	R6,[R9,#f_len]		; end of file
	LDR	R0,[R8,#w_format]
	PUSH	"R0"
	BIC	R0,R0,#format_BigEndian
	STR	R0,[R8,#w_format]
	LDRB	R14,[R8,#w_format]
	ADD	R14,R8,R14,LSL #2
	LDR	R14,[R14,#w_mode0]
	AND	R14,R14,#mode1_Type
co29$l	CMP	R7,R6
	BCS	co30$l
	MOV	R0,R7
	BL	cln_readw
	STR	R0,[R3,R4,LSL#2]		; word
	ADD	R7,R7,#4
	ADD	R4,R4,#1
	CMP	R4,R2
	BLT	co29$l
co30$l	PULL	"R0"
	MOV	R2,R4,LSL#2		; number actually typed
	STR	R7,[R10,#c_off]
	BL	reflect_caret
	FNRTS

	END
