; Contains mode entry points for code mode.
; THIS IS A 1.39+ BETA 8+ Mode 4 - modified to work with Mode4dis
; $Id: Mode4,fff,v 1.1.2.8 1999/02/10 00:33:25 ds Exp $

	GET	h.ZapHeader
	GET	h.Messages
	GET	h.AlterTxt
	GET	h.Commands
	GET	h.Execute
	GET	h.CreateWind
	GET	h.Cursors
	GET	h.Heap
	GET	h.KeyBits
	GET	h.Menus
	GET	h.MiniBuff
	GET	h.Mode0
	GET	h.Mode1
	GET	h.Mode2
	GET	h.ModeBits
	GET	h.ModuleBits
	GET	h.Redraw
	GET	h.Strings
	GET	h.Update
	GET	h.TMTVars

	IMPORT	get_pointer_to_code_cols
	IMPORT	mode4_clever_dis
	IMPORT	mode4_clever_search

	EXPORT	mode_table_4
	EXPORT	mode4_return
	EXPORT	mode4_setwidth
	EXPORT	inmode4_return
	EXPORT	CmdCODEflagstoggle
	EXPORT	Code_disasmtoggle
	EXPORT	redrawallcodemodewindows
	EXPORT	but_sortwwout
	EXPORT	mode4_aif_headerstring
	EXPORT	mode4_mod_headerstring

MODE4_COLNUMBS * &21

mode_table_4
	DCD	mode_table_4
	DCD	mode4_title
	DCD	mode4_author
	DCD	1			; based on Word mode...
	DCD	4+emode_BinaryMode+emode_UsesMessageTrans+emode_MayBeCloned
	DCD	mode4_init
	DCD	0
	DCD	mode4_table_end-mode_table_4

	DCD	0			; postload
	DCD	0
	DCD	0
	DCD	mode4_start
	DCD	mode4_end
	DCD	mode4_width
	DCD	mode4_linecol
	DCD	mode4_lineoff
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode4_minus
	DCD	mode4_plus
	DCD	mode2_minus
	DCD	mode2_plus
	DCD	mode1_cminus
	DCD	mode1_cplus
	DCD	mode4_redrawline
	DCD	0
	DCD	mode4_char		; start a new string
	DCD	Null			; no delete char
	DCD	0
	DCD	mode4_return
	DCD	0
	DCD	0
	DCD	mode1_linestart
	DCD	mode1_lineend
	DCD	mode1_lineend
	DCD	mode1_linestart
	DCD	mode2_copy
	DCD	0
	DCD	0
	DCD	mode2_aligncaret
	DCD	command_primative
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	0
	DCD	mode4_search
	DCD	replace_area		; 0
	DCD	0			; selection
	DCD	default_click		; click
	DCD	0			; messages
	DCD	mode4_setwidth
	DCD	0			; list fns
	DCD	mode0_prevline
	DCD	0			; Open window
	DCD	mode4_interrogate	; Answer all Zap's questions...
	DCD	0			; e_returnword
	DCD	mode4_help
mode4_table_end

mode4_author
	=	"Dominic Symes, Tim Tyler, Justin Fletcher and Darren Salt",0
	ALIGN

mode4_title
	FNS	("Code")

mode4_init
	TEQ	R1,#7
	BEQ	mode4_menu
	TEQ	R1,#13
	BEQ	mode4_init_13
	TEQ	R1,#14
	BEQ	mode4_init_14
	TEQ	R1,#6
	ADREQ	R1,mode4_cols
	TEQ	R1,#0
	MOVEQ	R0,#-1			; don't kill this module
	MOVEQ	PC,R14
 ;TEQ R1,#1
 ;BEQ start$l ; OK
	TEQ	R1,#2
	MOVNE	PC,R14
	FNJSR	"R0-R4,R8"
	MOV	R8,#0
	MOV	R1,R0			; mode number
; BL like_init_mode_word
	BL	ensure_colours_correct
 ;MOV R0,#MODE4_COLNUMBS
 ;FNcall Zap_ModeColourNum		; change palette size
 ;CMP R0,#MODE4_COLNUMBS
 ;BLNE mode4_UnkPreColBit		; define them

	MOV	r8,#0
	LDR	R1,[R13]		; mode number
	BL	get_mode_word
; FNcall Zap_GetModeWord
	BVS	mode4_dontchangeathing
	TEQ	R0,#0
	BNE	mode4_dontchangeathing
	MOV	R0,#&20000000		; default_mode_word
	BL	put_mode_word
; FNcall Zap_PutModeWord
mode4_dontchangeathing
	LDMFD	R13!,{R0-R4,R8,PC}^	; return no error

mode4_init_13				; set up for redraw
	FNJSR
; SWI &107
	BL	getdisasmdata
	STR	R0,local_disassemblerflags
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R2,[R14,R2,LSL #2]
	BL	readandputdisasmdata
	FNRTS

mode4_init_14				; end of redraw data
	B	readandrestoredisasm

;start$l
; FNJSR
; STR R0,localcopyof_mode_code
; MOV R1,R0
; PUSH "R1"
; ADD R1,R1,#&100			; variable number
; FNcall Zap_ReadVar			; R0=mode word
; PULL "R1"
; TEQ R0,#0
; FNRTS NE
; MOV R0,#&20000000			; default value...!?
; ADD R1,R1,#&100
; FNcall Zap_WriteVar			; width kept here
; FNRTS

;localcopyof_mode_code
;  & 0

;E R0=mode number R8/R9=window /0 for options menu
;X mode word saved #

save_mode_word
; FNJSR "R11"
	B	modes_end
; FNcall Zap_SaveModeWord,R11
; FNRTS

;E R0=mode number R8/R9=window /0 for options
;X mode word restored #

restore_mode_word
; FNJSR "R11"
	B	modes_start
; FNcall Zap_RestoreModeWord,R11
; FNRTS

; mode4_UnkPreColBit
;  FNJSR "R1-R4"
;  ADR R3,mode4_DefaultColours
;  MOV R1,#4				; modenumber = code mode...
; mode4_PreZModColBit
;  MOV R2,#&09				; start colours
; mode4_ZModColBit
;  LDRB  R0,[R3],#1
;  FNcall Zap_ModeColour		; Read colour definitions
;  FNRTS VS
;  ADD R2,R2,#1
;  TEQ R2,#MODE4_COLNUMBS		; max colours
;  BNE mode4_ZModColBit
;  FNRTS

;like_init_mode_word
; FNJSR "R0-R4,R8"
 ;MOV R8,#0				; default options
 ;MOV R1,#4
 ;ADR R3,mode4_col_sup$l
 ;BL Acallsub$l
; BL ensure_colours_correct
; FNRTS

;Acallsub$l				; R1=mode number R3=data block
; FNJSR
; LDR R4,[R3],#4			; number of extra colours
; PUSH "R1"
; ADD R1,R1,#&100			; variable number
; FNcall Zap_ReadVar			; R0=mode word
; PULL "R1"
; TEQ R0,#0
; FNRTS NE				; already set up
; ;PUSH "R1"
; ;LDR R0,[R3]				; get width etc
; ;MOV R0,R0,LSL#16
; ;MOV R0,R0,LSR#16			; save width in mode word
; ;ADD R1,R1,#&100
; ;FNcall Zap_WriteVar			; width kept here
; ;PULL "R1"
; LDR R0,[R3]
; MOV R2,#0
; MOV R1,#4
; ADD R0,R3,#4
; ADD R4,R4,#9
; BL mode4_init_cols			; setup initial colours
; MOVS R0,#0
; FNRTS

mode4_col_sup$l
	DCD	(MODE4_COLNUMBS - 9)	; no of extra colours...
	DCD	&03010000+40		; Code mode width
	DCD	&97070077
	DCD	&3219CFAB		; cols
	DCD	&D23EE584		; cols
	DCD	&123DC191		; cols

ensure_colours_correct
	FNJSR	"R1-R4,R8"
	MOV	R8,#0			; default options
	MOV	R2,#0
; ADR R3,mode4_col_sup$l
; LDR R4,[R3],#4			; number of extra colours
; ADD R0,R3,#4
; ADD R4,R4,#9
	MOV	R4,#MODE4_COLNUMBS
	BL	get_pointer_to_code_cols
	BL	mode4_init_cols		; setup initial colours
	FNRTS

	LOCAL

;local_modecodelraero
; DCD 0

;E R0=pointer to words of wimp colours R1=mode number R4=num of cols
;  R8=window to set /0
;X Default colours set up #

mode4_init_cols
	FNJSR	"R1-R5"
; PUSH "R0"
	MOV	R3,R0
	MVN	R0,#0
	BL	mode_colour_num
; FNcall Zap_ModeColourNum,R5		; Read palette size
; PULL "R3"
	CMP	R0,R4
	FNRTS	"GE"			; why doesn't it work?
	MOV	R5,R0
;thethickofthecols
; STR R0,local_modecodelraero
; PUSH "R3"
	MOV	R0,R4
	BL	mode_colour_num
; FNcall Zap_ModeColourNum		; change palette size
; PULL "R3"
	MOV	R2,#0			; colour number
a$l
	LDR	R0,[R3],#4		; next bit of data
; LDR R5,local_modecodelraero
	CMP	R2,R5
	BLT	postinitcolour		; Debugging - Why doesn't it work?
	BL	mode_colour
; FNcall Zap_ModeColour
	FNRTS	VS
postinitcolour
	ADD	R2,R2,#1
	CMP	R2,R4
	BCC	a$l
	FNRTS

;  FNJSR "R1-R5"
;  PUSH "R0"
;  MVN R0,#0
; FNcall Zap_ModeColourNum		; Read palette size
; PULL "R3"
; CMP R0,R3
; FNRTS "EQ"				; ???
;  PUSH "R3"
;  MOV R0,R4
;  ;FNcall Zap_ModeColourNum		; change palette size
;  PULL "R3"
;  MOV R2,#0				; colour number
; mode4_justa$l
;  TST R2,#7				; 8 colour boundry?
;  LDREQ R5,[R3],#4			; next bit of data
;  AND R0,R5,#&F			; wimp colour
;  ;FNcall Zap_ModeColour
;  FNRTS VS
;  MOV R5,R5,LSR#4			; next colour
;  ADD R2,R2,#1
;  CMP R2,R4
;  BCC mode4_justa$l
;  FNRTS

; mode4_DefaultColours			; Colour Numbers :
;  = &0C				; Comment Colour =&09 09
;  = &0E				; String colour  =&0A 10
;  = &0A				; Punctuation	 =&0B 11
;  = &0F				; Embedded {}	 =&0C 12
;  = &04				; Bs		 =&0D 13
;  = &02				; Misc Punct.	 =&0E 14
;  = &03				; Number colour  =&0F 15
;  = &04				; Error colour	 =&10 16
;  = &04				; GSTrans	 =&11 17
;  = &01				; Unknown	 =&12 18
;  = &0C				; Unknown	 =&13 19
;  = &0E				; Unknown	 =&14 20
;  = &01				; Unknown	 =&15 21
;  = &02				; Unknown	 =&16 22
;  = &03				; Unknown	 =&17 23
;  = &04				; Unknown	 =&18 24
;  = &01				; Unknown	 =&19 25
;  = &09				; Cond		 =&19 26
;  = &0B				; Unrecognised	 =&19 27
;  = &08				; FP		 =&19 28
;  = &08				; CP		 =&19 29
;  = &01				; LDM/STM	 =&19 30
;  = &0
;  = &0					; double zero termination !
;  ALIGN

mode4_cols
	=	"zap_m_codecols",0
	ALIGN

mode4_setwidth
; CMP R2,#0
; BNE mode0_setwidth
	FNJSR
; LDR R14,[R0]
	CMP	R0,#&FF			; 255 limit ?
	MOVGT	R0,#&FF
; STRCS R14,[R0]
	BL	mode0_setwidth
	ANDS	R0,R0,#&FF
	MOVEQ	R0,#1
	FNRTS

mode4_width
	FNJSR	"R1-R2"
	MOV	R0,#4
	STR	R0,[R8,#w_bpl]
	MOV	R0,#-1
	LDRB	R1,[R8,#w_format]	; mode number
	MOV	R2,#0
	BL	mode_data		; read the first word of mode data
	AND	R0,R0,#&FF
	CMP	R0,#1
	MOVLT	R0,#1			; width
	LDRB	R1,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R1,[R14,R1,LSL #2]!	; load in our mode word
	BIC	R1,R1,#255
	ORR	R1,R1,R0
	STR	R1,[R14]		; save in our mode word
	ADD	R0,R0,#18
	TST	R1,#1 << 28		; binary?
	ADDNE	R0,R0,#27
	FNRTS

	LOCAL

localmodeword
	&	0

local_temp4r6
	&	0
	&	0
	&	0
	&	0
	&	0
	&	0
	&	0
; & 0

; E R0 = offset (4 => -4...) / R7 = current address.
; X R0 -> to addr - offset (as an offset?)

getpreviousaddress
	FNJSR
	SUB	R14,R7,R0
	LDR	R0,[R9,#f_ptr]
	CMP	R14,R0
	MOVCC	R0,#0			; !???
	FNRTS	CC
	LDR	R1,[R9,#f_splito]	; offset of split start
	ADD	R1,R0,R1
	CMP	R14,R1			; R7...?
	MOVCC	R0,R14
	FNRTS	CC
	LDR	R1,[R9,#f_splite]	; offset of split end
	ADD	R1,R0,R1
	CMP	R14,R1
	MOVCS	R0,R14
	FNRTS	CS
	LDR	R1,[R9,#f_splits]	; size of split
	SUB	R14,R14,R1
	SUB	R5,R5,R1
	LDR	R1,[R9,#f_splito]	; offset of split start
	ADD	R10,R0,R1		; yuck code... (apparent buffer end...)
	MOV	R0,R14
	FNRTS

tizhexed
	FNJSR
	MOV	R3,#4
	MOV	R4,#0			; current instruction
hex2$l					; hex dump loop
	CMP	R7,R10
	BLCS	red_overflow
	FNRTS	VS
	LDRB	R0,[R7],#1
	ORR	R4,R4,R0
	MOV	R4,R4,ROR #8		; save byte in instruction
 ; BL hex2
	ADD	R6,R6,#2		; increment R6 like hex2...
	TST	R2,#1<<17
	SUBEQ	R6,R6,#4		; little endian so go back
	SUBS	R3,R3,#1
	BHI	hex2$l
	MOV	R0,R4			; instruction
	TST	R2,#1<<17
	BLNE	reverse_word		; big endian
	SUB	R1,R7,R5
	SUB	R1,R1,#4		; offset in file of instruction
	MOV	R4,R0			; save the instruction
	LDR	R2,[R8,#w_addr]
	FNRTS

;E R2 data
readandputdisasmdata
	LDR	R1,[R8,#w_format]
	TST	R1,#bit_windowwrap	; non-global...?
	MOVNE	PC,R14
	MOV	R1,R2,LSR #8
	BIC	R1,R1,#(&F << 20)	; options - need to update if these change
	ORR	R1,R1,#1<<23		; allow those lower-case letters!
	B	putdisasmdata

search_readandputdisasmdata
	LDR	R1,[R8,#w_format]
	TST	R1,#bit_windowwrap	; non-global...?
	MOVNE	PC,R14
	MOV	R1,R2,LSR #8
	BIC	R1,R1,#(&F << 20)	; options - need to update if these change
	B	putdisasmdata

carefully_readandputdisasmdata
	FNJSR
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_windowwrap
	MOVEQ	R1,R2,LSR #8
	BICEQ	R1,R1,#(&F << 20)	; options - need to update if these change
 ; *don't* allow those lower-case letters!?!?!?!
	BLEQ	putdisasmdata
	SUBS	R14,R14,R14
	FNRTS

carefully_readandrestoredisasm
	FNJSR
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_windowwrap
	BLEQ	restoredisasm
	SUBS	R14,R14,R14
	FNRTS

readandrestoredisasm
	LDR	R0,[R8,#w_format]
	TST	R0,#bit_windowwrap
	MOVNE	PC,R14
; fall through

restoredisasm
	FNJSR	"R0,R1"
	LDR	R1,local_disassemblerflags
	BL	putdisasmdata
	FNRTS

local_disassemblerflags
	DCD	0

; mode word values
 ; 0
 ; 1
 ; 2
 ; 4
 ; 8
 ; 16
 ; 32		; SWI names...
 ; 64		; &ampersand -> hex...
 ; 128		; # immediates
 ; 256		; logical...
 ; 512		; arithmetic...
 ; 1024		; cond complete.
 ; 2048		; second column reached...
 ; 4096		; asm condition (colouring)
 ; 8192		; asm condition (font)
 ; 16384 (14)	; FP?
 ; 32768 (15)	; CP
 ; 65536 (16)	; LDM/STM?
 ; (17)		; LDR/STR?
 ; (18)		; CP?
 ; (19)		; FP?
 ; (20)		; Undefined instruction
 ; (21)		; rolls...
 ; (22)		; Ins is unconditional... :)
mode4_redrawline
	FNJSR
	STR	R11,local_temp4r6 + 24	; save it...
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R2,R8,R2,LSL #2
	LDR	R2,[R2,#w_mode0]
	STR	R2,localmodeword
	MOV	R1,#0			; important r1=0?
	STR	R1,local_bgcol_please
	MOV	R2,#7
	MOV	R0,#9			; colour
	BL	colour_chars_both	; colour the ascii column
	MOV	R1,#7
	MOV	R2,#11
	LDR	R0,localmodeword
	TST	R0,#1 << 28
	ADDNE	R2,R2,#27
	MOV	R0,#10			; colour of hex/binary
	BL	colour_chars_both	; colour the hex dump column
	PUSH	"R5,R7,R10"		; save start of line
	MOV	R3,#4
ascii$l					; ascii characters loop
	CMP	R7,R10
	BLCS	red_overflow
	BVS	asciiblnk$l
	LDRB	R0,[R7],#1
	STRB	R0,[R6],#1
	SUBS	R3,R3,#1
	BHI	ascii$l
asciiend$l				; finished ascii field
	BL	colons
	PULL	"R5,R7,R10"		; get start of line
	LDR	R2,[R8,#w_format]	; format value
 ; fudge...
 ;MOV R0,#4
 ;BL getpreviousaddress			; as an offset...?
	SUB	R0,R7,#4
	LDR	R14,local_temp4r6 + 16	; recover previous attempt...
	TEQ	R0,R14
 ;BNE notprehex$l
 ;BEQ atprehex$l			; we've just done the previous instr...?
 ;MOV R0,#8
 ;BL getpreviousaddress			; as an offset...?
	SUBEQ	R0,R7,#8
	LDREQ	R14,local_temp4r6 + 20	; recover previous attempt...
	TEQEQ	R0,R14
	BEQ	atprehex$l		; we've just done the previous instr...?
notprehex$l
	ADR R0,local_temp4r6		; save it...
	STMIA R0,{R5-R7,R10}

	MOV	R0,#8
	BL	getpreviousaddress
	LDR	R11,[R9,#f_ptr]
	CMP	R0,R11
	MOVCS	R7,R0
	BLCS	tizhexed
 ;LDR R2,[R8,#w_addr]
 ;SUB R1,R7,R5
	ADD	R1,R1,R2		; user file address
	SWI	XDebugger_Disassemble	; discard results...
	ADR	R0,local_temp4r6
	LDMIA	R0,{R5-R7,R10}
	MOV	R0,#4
	BL	getpreviousaddress
	LDR	R11,[R9,#f_ptr]
	CMP	R0,R11
	MOVCS	R7,R0
	BLCS	tizhexed
 ;LDR R2,[R8,#w_addr]
 ;SUB R1,R7,R5
	ADD	R1,R1,R2		; user file address
	SWI	XDebugger_Disassemble	; discard results...
 ; end of fudge...
	ADR	R1,local_temp4r6
	LDMIA	R1,{R5-R7,R10}
atprehex$l
	MOV	R1,#0			;?
	LDR	R2,[R8,#w_format]	; format value
	MOV	R3,#4			; huh?
	MOV	R4,#0			; current instruction
 ; restore...
 ; LDR R0,local_temp4r6 + 16	; recover previous attempt...
	SUB	R0,R7,#4		; ?
	STR	R0,local_temp4r6 + 20	; recover previous attempt...
	STR	R7,local_temp4r6 + 16	; save it...
	LDR	R0,localmodeword
	TST	R0,#1 << 28		; binary mode
	BNE	insertbinarydata
	TST	R2,#1<<17
	ADDEQ	R6,R6,#6		; little endian
hex$l					; hex dump loop
	CMP	R7,R10
	BLCS	red_overflow
	BVS	just_exit_from_redraw	; overflow
	LDRB	R0,[R7],#1
	ORR	R4,R4,R0
	MOV	R4,R4,ROR #8		; save byte in instruction
	BL	hex2
	TST	R2,#1<<17
	SUBEQ	R6,R6,#4		; little endian so go back
	SUBS	R3,R3,#1
	BHI	hex$l
	TST	R2,#1<<17
	ADDEQ	R6,R6,#10		; finish hex dump field
backfrominsertbinarydata
	BL	colons			; now print instruction
	MOV	R0,R4			; instruction
	TST	R2,#1<<17
	BLNE	reverse_word		; big endian
	SUB	R1,R7,R5
	SUB	R1,R1,#4		; offset in file of instruction

	LDR	R11,[R9,#f_load]
	MOV	R11,R11,ASR #8
	CMP	R11,#-6			; module?
	BEQ	module$l		; it is a module
	CMP	R11,#-8			; absolute?
	BEQ	absolute$l		; it is an absolute
dis$l					; disassemble the instruction
	MOV	R4,R0			; save the instruction
	LDR	R2,[R8,#w_addr]
	ADD	R1,R1,R2		; user file address
	BL	mode4_clever_dis	; gerph
	ADRVS	R1,stored_blank_string2

	MOV	R2,#0			; standard foreground and flags

	AND	R0,R4,#&F<<28
	TEQ	R0,#&E<<28
	ORREQ	R2,R2,#1<<22		; No condition check needed...

	AND	R0,R4,#7<<25
	TEQ	R0,#5<<25
	ORREQ	R2,R2,#4		; Branch

	TEQ	R0,#4<<25
	BEQ	ldm$l			; STM or LDM

	AND	R0,R4,#&C << 24
	TEQ	R0,#4 << 24
	BEQ	ldr$l			; STR or LDR

	AND	R0,R4,#&F << 24
	TEQ	R0,#&C << 24
	TEQNE	R0,#&D << 24
	TEQNE	R0,#&E << 24
	BEQ	foundcopro$l		; copro

;pregotcol$l
	AND	R0,R4,#15<<24
	TEQ	R0,#15<<24
	ORREQ	R2,R2,#2
colouring_colour
 ; LDR R4,[R8,#w_txtw]		; offset to foreground mask
	LDRB	R3,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDRB	R3,[R14,R3,LSL #2]	; width of instructions
dis_loop_in_redraw
	LDRB	R0,[R1],#1		; load next character from R1 index.
	TEQ	R0,#0
	BEQ	pre_exit_from_redraw
	TST	R2,#1			; in a comment
	BNE	alreadyinacomment
	CMP	R0,#' '
	BEQ	tobfnumberreductionpossible
	TST	R2,#1<<20		; undefined ins
	BNE	dontcheckthese_minimal	; theundef
	TST	R2,#3<<12
	BNE	maybe_bgcondcolour

	LDR	R4,localmodeword	; flags...
	TST	R2,#2048		; second column not reached...
	BLEQ	secondcolnotreached2
notaconditionhere2
; TST R4,#1 << 31
 ;BNE notaconditionhere ; ???
	TST	R2,#1<<22		; second column not reached...
	BLEQ	tochkcondcode		; ????????????????????
; BL tochkcondcode
 ;BNE notaconditionhere
 ;TST R2,#2048				; second column not reached...
 ;BEQ secondcolnotreached
notaconditionhere
	TST	R4,#1 << 30		; flag says no conditions...
	BNE	backfromfoundaregister

	TST	R2,#2048		; second column not reached...
	BEQ	backfromfoundaregister	; secondcolnotreached2

	TST	R2,#&C2			; &... or #... or SWI(?)
	BNE	backfromfoundaregister
 ;TST R2,#1 << 20			; Undefined instruction
 ;BNE backfromfoundaregister
	CMP	R0,#'{'
	BCS	backfromfoundaregister

	BIC	R14,R0,#&20
	TST	R4,#1 << 9		; apcs?
	CMPNE	R14,#'A'			; was 'a'
	BCS	foundanAPCSregister	; hope this still works...???

	CMP	R14,#'R'
	BEQ	foundaregister
	CMP	R14,#'C'		; cp
	BEQ	foundaCPregister
	CMP	R14,#'F'		; fp
	BEQ	foundaFPregister
	CMP	R14,#'P'		; sp, ip
	BEQ	foundaPCpossibly

	CMP	R14,#'A'		; a1
	BEQ	foundanASpossibly
	CMP	R14,#'L'		; lr, sl
	BEQ	foundaLSpossibly

backfromfoundaregister
	MOV	R11,#2
	TEQ	R0,#';'			; comment?
	BEQ	foundanasmcommenthere

	CMP	R0,#'Z'
	BICGT	R2,R2,#96		; Registers and Hex...
	TEQ	R0,#','			; comma
	TEQNE	R0,#'-'			; hyphen
	BICEQ	R2,R2,#32		; Registers
	BICEQ	R2,R2,#3 << 14		; fp & cp registers
	TST	R4,#1 << 30
	BNE	dontcheckthese_minimal
	TEQ	R0,#'#'			; hyphen
	ORREQ	R2,R2,#128		; &ampersand -> hex...
	TST	R2,#&80			; in constant expression
	TSTEQ	R2,#32		; 2048	; in SWI name...?
	TEQEQ	R0,#'&'			; otherwide &address/hex no...
	ORREQ	R2,R2,#64		; &ampersand -> hex...
	BICEQ	R2,R2,#30		; &ampersand -> hex...????
	TEQ	R0,#','			; comma?
	BICEQ	R2,R2,#&C0		; end of immediate...
dontcheckthese_minimal
	TST	R2,#1 << 16		; LDM/STM?
	MOVNE	R11,#23
	TST	R2,#1 << 17		; LDR/STR?
	MOVNE	R11,#24
	TST	R2,#1 << 18		; FP instr
	MOVNE	R11,#30
	TST	R2,#1 << 19		; CP instr
	MOVNE	R11,#31
	TST	R2,#16			; SWI?
	MOVNE	R11,#15
	TST	R2,#8			; SWI?
	MOVNE	R11,#14
	TST	R2,#4			; SWI?
	MOVNE	R11,#13
	TST	R2,#2			; SWI?
	BNE	saswihere
;	MOV	R11,#12			; hope OK.
	TST	R2,#32			;
	MOVNE	R11,#19
	TST	R2,#64			; condition...? SWI?
	MOVNE	R11,#20
	TST	R2,#256
	MOVNE	R11,#22			; logical...
	TST	R2,#512
	MOVNE	R11,#22			; arithmetic...
	TST	R2,#1 << 21;1024
	MOVNE	R11,#22			; rolls...
	CMP	R11,#12
	TST	R2,#1 << 20		; undefined instructs
	MOVNE	R11,#27
	TST	R2,#1 << 14		; cp
	MOVNE	R11,#29
	TST	R2,#1 << 15		; fp
	MOVNE	R11,#28
	TST	R2,#128			; # immediates
	MOVNE	R11,#21

	TST	R4,#1 << 30		; minimal/unconditional...
	BNE	mode4_keepingitsimple	; ?????????????????????????????????
 ;TST R4,#1 << 31		; minimal...
 ;BNE bfnumberreductionpossible ; mode4_keepingitsimple

	BIC	R14,R0,#&20
	CMP	R14,#'A'
	RSBCSS	R14,R14,#'Z'
	BCS	bfnumberreductionpossible	; skip complications if possible...

	CMP	R0,#'['
	CMPNE	R0,#']'
	MOVEQ	R11,#16
	CMP	R0,#'{'
	CMPNE	R0,#'}'
	MOVEQ	R11,#17
	CMP	R0,#'#'
	CMPNE	R0,#'!'
	CMPNE	R0,#'^'
	CMPNE	R0,#','
	MOVEQ	R11,#18
mode4_keepingitsimple
	CMP	R0,#'@'
	CMPLE	R11,#2
	BLEQ	numberreductionpossible
	TST	R2,#2048		; after at least a space?
	BICEQ	R0,R0,#&20
bfnumberreductionpossible
	LDR	R4,[R8,#w_txtw]		; offset to foreground mask
	STRB	R11,[R6,R4]		; foreground colour
	ADD	R4,R4,R4
	STRB	R0,[R6],#1		; letter
	LDR	R0,[R8,#w_format]
	TST	R0,#1<<25		; free mouse/as BG colour?
	BNE	possiblyasbackground
	MOV	R11,#1
	SUB	R4,R4,#1
	STRB	R11,[R6,R4]		; background colour
	ADD	R4,R4,#1
	SUBS	R3,R3,#1		; number of chars...?
	BGT	dis_loop_in_redraw
pre_exit_from_redraw
just_exit_from_redraw
	LDR	R11,local_temp4r6 + 24	; save it...
	ADD	R11,R11,#1		; next log line
 ;STR R2,local_bgcol_please
	FNRTSS				; return no error

;theundef
; MOV R11,#27
; B bfnumberreductionpossible	; mode4_keepingitsimple

tobfnumberreductionpossible
	ORR	R2,R2,#2048		; second column reached...
	BIC	R2,R2,#&3<<12
	B	bfnumberreductionpossible	; mode4_keepingitsimple

numberreductionpossible
	LDR	R4,localmodeword
	TST	R4,#1 << 30		; minimal
	MOVNE	PC,R14
	MOV	R11,#&14
	CMP	R0,#'-'
	MOVEQ	R11,#&12
	MOV	PC,R14

; darrens_helpful_lower_case
;  BIC R0,R0,#&20
;  B asmcondfound

stored_blank_string2
	DCD	0
; ADD R11,R11,#1			; next log line
; PUSH "R0,R1,R6"
; LDR R6,local_temp4r6 + 20		; save it...
; MOV R1,#27
; MOV R0,#0
; ;LDR R1,[R8,#w_txtw]
;blankloop$l
; STRB R0,[R6,R1]
; SUBS R1,R1,#1
; BPL blankloop$l
; PULL "R0,R1,R6"
; FNRTSS				; return no error

asciiblnk$l				; blank non present ascii characters
	ADD	R6,R6,R3
	B	asciiend$l

; decode absolute header
; => r1 = file offset
; return using B dis$l
absolute$l
	CMP		r1,#(end_abs_stab - abs_stab) ; +20 for jump header
	BCS		dis$l		; definitely not in header
	CMP		r1,#20		; compare with start of data block
	BLT		dis$l		; is < header data, so we don't care
; check it is a valid AIF file
	PUSH	"R0"			; save the word
	MOV	R0,#16			; address of SWI "OS_Exit"
	BL	cln_readw		; get word
	EOR	r0,r0,#&EF000000	; clear top bits
	EORS	r0,r0,#&00000011	; clear SWI number
	PULL	"R0"			; word not now needed
	BNE	dis$l			; if not 0 now, it's invalid
	MOV     r0,r1                   ; put the offset in the right reg
        BL      mode4_aif_headerstring
        MOV     r1,r0                   ; return the string in R1
	MOV	R2,#&B			; use comment colour
	B	colouring_colour		; and put it in there


; decode module header
; => r1 = file offset
; return using B dis$l
module$l
        MOV     r11,r0                   ; hang on to instruction
        MOV     r0,r1                    ; r0 = offset
        BL      mode4_mod_headerstring   ; read the string
        TEQ     r0,#0                    ; did we decode it ?
        MOVEQ   r0,r11                   ; if not, restore instruction
        BEQ     dis$l                    ; if not, normal disassembly
        MOV     r1,r0                    ; string in r1
	MOV	R2,#&B			 ; use comment colour
	B	colouring_colour	 ; and colour it

; return a string for the module header
; => r0 = offset in file
; <= r0 = string pointer, or 0 if not known
mode4_mod_headerstring
	FNJSR	"R1-R3"
	CMP	R0,#(end_mod_stab - mod_stab) ;&2C
	MOV     r1,r0                   ; r1 = offset
	MOVCS   r0,#0                   ; if too big, it's not known
	FNRTS	CS			; definitely not in header
	MOV	R2,#0			; check valid loop
	PUSH	"R0"			; save the word
checkoff$l			        ; check it is a valid module offset
	MOV	R0,R2
	BL	cln_readw		; get word
	BIC	R0,R0,#1 << 31		; clear bit 31...
	BL	valid_off		; valid offset?
	PULL	"R0",CS
	MOVCS   r0,#0                   ; if too big, it's not known
	FNRTS	CS			; definitely not in header
	CMP	R2,R1
	ADDCC	R2,R2,#4
	BCC	checkoff$l
	PULL	"R0"			; word not now needed
	ADR	R0,mod_stab
	LDR	R14,[R0,R1]		; get string offset
	FNLDR	R0,env_modstart		; base for indirected offsets
	ADD	R1,R0,R14		; string address
	FNLDR	R2,wimp_data
	MOV	R3,#256
	BL	lookup_token
	FNLDR	R0,wimp_data,VC
	FNRTS				; return the string


ldm$l
	AND	R0,R4,#3<<23		; direction bits
	TST	R4,#1<<20
	BNE	load$l			; LDM
	ORR	R2,R2,#1 << 16
	TEQ	R0,#2<<23			; DB
	BNE	colouring_colour
	TST	R4,#1<<14
	ORRNE	R2,R2,#8
	B	colouring_colour

load$l
	ORR	R2,R2,#1 << 16
	TEQ	R0,#1<<23
	BNE	colouring_colour
	TST	R4,#1<<15
	ORRNE	R2,R2,#16
	B	colouring_colour

ldr$l
; TST R4,#&10			; ???
; BNE precolouring_colour		; ???
simplelsdr
	ORR	R2,R2,#1 << 17
	B	colouring_colour

foundcopro$l
	AND	R0,R4,#&F << 8
	TEQ	R0,#&1 << 8
	TEQNE	R0,#&2 << 8
	ORRNE	R2,R2,#1 << 19		; CP
	BNE	colouring_colour
	TEQ	R0,#&1 << 8
	BEQ	secondary_problem
	AND	R0,R4,#&F << 24
	TEQ	R0,#&E << 24
	ORREQ	R2,R2,#1 << 19		; CP
	ORRNE	R2,R2,#1 << 18		; FP
	B	colouring_colour

saswihere
	MOV	R11,#12
	TST	R2,#2048
	MOVNE	R11,#25
	B	mode4_keepingitsimple

foundaregister
	LDRB	R14,[R1]
	CMP	R14,#'0'
	RSBHSS	R14,R14,#'9'
	BLO	foundaROpossibly
	MOV	R2,#32
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#19
	B	mode4_keepingitsimple

foundanAPCSregister
	TEQ	R14,#'C'		; cp
	BEQ	foundaNAPCSCPreg
	TEQ	R14,#'F'		; fp
	BEQ	foundaNAPCSFPreg
	TEQ	R14,#'P'		; sp, ip
	BEQ	APCSstylep
notAPCSstylep
	MOV	R2,#32
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#19
	B	mode4_keepingitsimple

APCSstylep
	LDRB	R14,[R1,#-2]		; ???
	BIC	R14,R14,#&20
	TEQ	R14,#'C'
;	TEQNE	R14,#'F'
	BNE	notAPCSstylep
	MOV	R2,#1 << 14
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#29
	B	mode4_keepingitsimple

foundaNAPCSFPreg
	LDRB	R14,[R1]
	CMP	R14,#':'
	BCS	notAPCSstylep
	CMP	R14,#'0'
	BCC	notAPCSstylep
	MOV	R2,#1 << 15
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#28
	B	mode4_keepingitsimple

foundaNAPCSCPreg
	LDRB	R14,[R1,#-2]
	BIC	R14,R14,#&20
	TEQ	R14,#'P'
	BEQ	mode4_keepingitsimple
;	B	foundaCPregister
;	fall through...

foundaCPregister
	LDRB	R14,[R1,#-2]
	BIC	R14,R14,#&20
	TEQ	R14,#'P'		; for 'pc'...
	MOVEQ	R11,#19
	BEQ	mode4_keepingitsimple
	LDRB	R14,[R1]
	BIC	R14,R14,#&20
	TEQ	R14,#'P'
	LDREQB	R14,[R1,#1]
	BIC	R14,R14,#&20
	TEQ	R14,#'S'
	MOVEQ	R11,#19
	BEQ	mode4_keepingitsimple

	LDRB	R14,[R1]		; hope is OK...
	CMP	R14,#'0'
	RSBHSS	R14,R14,#'9'
	BLO	backfromfoundaregister
	MOV	R2,#1 << 14
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#29
	B	mode4_keepingitsimple

foundaFPregister
	LDRB R14,[R1]
	CMP R14,#'0'
	RSBHSS R14,R14,#'9'
	BLO backfromfoundaregister
	MOV	R2,#1 << 15
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#28
	B	mode4_keepingitsimple

foundaPCpossibly
	LDRB	R14,[R1]
	BIC	R14,R14,#&20
	TEQ	R14,#'C'
	BNE	backfromfoundaregister
	LDRB	R14,[R1,#-2]
	CMP	R14,#'{'
	CMPNE	R14,#'['
	CMPNE	R14,#'@'
	BGT	backfromfoundaregister
	MOV	R2,#32
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#19
	B	mode4_keepingitsimple

foundanASpossibly
	LDRB	R14,[R1]
	TEQ	R14,#'S'
	BNE	backfromfoundaregister
	LDRB	R14,[R1,#1]
	TEQ	R14,#'L'
	TEQNE	R14,#'R'
	BNE	backfromfoundaregister
	MOV	R2,#256
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#22
	B	mode4_keepingitsimple

foundaLSpossibly
	LDRB	R14,[R1]
	TEQ	R14,#'S'
	BNE	backfromfoundaregister
	LDRB	R14,[R1,#1]
	TEQ	R14,#'L'
	TEQNE	R14,#'R'
	BNE	backfromfoundaregister
	MOV	R2,#512
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#22
	B	mode4_keepingitsimple

foundaROpossibly
	LDRB	R14,[R1]
	TEQ	R14,#'R'
	BEQ	mode4_possiblyRRX
	TEQ	R14,#'O'
	BNE	backfromfoundaregister
	LDRB	R14,[R1,#1]
	TEQ	R14,#'L'
	TEQNE	R14,#'R'
	BNE	backfromfoundaregister
itsarolrorrrx
	MOV	R2,#1<<21 ;1024
	ORR	R2,R2,#2048		; second column reached...
	MOV	R11,#22
	B	mode4_keepingitsimple

mode4_possiblyRRX
	LDRB	R14,[R1,#1]
	TEQ	R14,#'X'
	BNE	backfromfoundaregister
	B	itsarolrorrrx

foundanasmcommenthere
	ORR	R2,R2,#1
	MOV	R11,#11
	LDR	R4,localmodeword
	TST	R4,#1 << 29
	BEQ	mode4_keepingitsimple
	LDR	R4,[R8,#w_txtw]		; offset to foreground mask
	ADD	R4,R4,R4
	MOV	R11,#0
asmruboutloop
	SUB	R6,R6,#1
	LDRB	R0,[R6]			; letter
	CMP	R0,#32
	STRLEB	R11,[R6,R4]		; foreground colour
	BLE	asmruboutloop
	B	pre_exit_from_redraw

;E R0=word R2=module offset R9=file
;X CC if word valid CS ow |

valid_off
	FNJSR
	CMP	R2,#&10
	BCC	code$l			; code offset
	CMP	R2,#&1C
	BCC	string$l			; string/table offset
	TEQ	R2,#&24
	BEQ	string$l			; string/table offset
	CMP	R2,#&20
	BCS	code$l			; code offset
	CMP	R0,#&01000000		; swi number
	FNRTS
code$l
	AND	R14,R0,#3			; word aligned?
	CMP	R14,#1
	FNRTS	CS			; not word aligned
; does CS need  ^^ to be set here ?
string$l
	LDR	R14,[R9,#f_len]
	CMP	R0,R14			; in file range?
	FNRTS

mod_stab
	DCD	starto$l
	DCD	inito$l
	DCD	fino$l
	DCD	serviceo$l
	DCD	titleo$l
	DCD	helpo$l
	DCD	commo$l
	DCD	swichunk$l
	DCD	swicode$l
	DCD	switable$l
	DCD	swideccode$l
	DCD	msgdeccode$l
end_mod_stab
starto$l	= "zap_d_starto",0
inito$l		= "zap_d_inito",0
fino$l		= "zap_d_fino",0
serviceo$l	= "zap_d_serviceo",0
titleo$l	= "zap_d_titleo",0
helpo$l		= "zap_d_helpo",0
commo$l		= "zap_d_commo",0
swichunk$l	= "zap_d_swichunk",0
swicode$l	= "zap_d_swicode",0
switable$l	= "zap_d_switable",0
swideccode$l	= "zap_d_swidecode",0
msgdeccode$l	= "zap_d_msgdecode",0
	ALIGN

stored_blank_string
	DCD	0

mode4_lineoff
	LDRB R1,[R8,#w_format]	; mode number
	ADD R0,R8,#w_mode0
	LDR R1,[R0,R1,LSL #2]
	MOV R0,#0
	TST R1,#1 << 28		; binary?
	AND R1,R1,#255			; bottom 8 bits
	ADD R1,R1,#18			; hex width
	ADDNE R1,R1,#27		; + bin width
	MOV PC,R14

mode4_linecol
	MOV	PC,R14			; must be at line start

mode4_plus
	FNJSR
	MOV	R0,R1
	MVN	R2,#1			;-2
	BL	follow_branch
	FNRTS

mode4_minus
	FNJSR
	BL	previous_mark
	MVN	R2,#1			; -2 for already moved
	FNRTS

;E R0=instruction word R1=(apparent) address
;X R0=(apparent) address to jump to / CS if none #

find_branch_addr
	STMFD	R13!,{R1-R2,R14}
	SWI	XDebugger_Disassemble
	ADRVS	R1,stored_blank_string
	MOVVS	R2,#1
 ;LDMVSFD R13!,{R1-R2,PC}
fi2
	LDRB	R0,[R1],#1
	TEQ	R0,#'&'
	BEQ	fi3
	CMP	R0,#&20
	BCS	fi2
	SUBS	R0,R0,#0			; sec
	LDMFD	R13!,{R1-R2,PC}
fi3
	MOV	R2,R1			; save first digit
	BL	hex_read
	SUB	R14,R1,R2
	TEQ	R14,#8			; was it 8 chars
	BNE	fi2			; if not then carry on
	ADDS	R0,R0,#0			; clc
	LDMFD	R13!,{R1-R2,PC}

;E R1=apparent address... R2 = 0ffset (4 or 8)
getpreviousinstrs
	FNJSR	"R1"
	SUBS	R1,R1,R2
	MOVS	R0,R1
	MOVMI	R0,#0
	BLPL	cln_readw			; get instruction in R0
	LDR	R2,[R8,#w_addr]		; base address
	ADD	R1,R2,R1
	SWI	XDebugger_Disassemble	; for the sake of ADRLs.
	ADRVS	R1,stored_blank_string
	MOVVS	R2,#1
	FNRTS

; decodes an offset into an AIF header description
; => r0= offset in the file
; <= r0= string to give it, or 0 if none
        LOCAL
mode4_aif_headerstring
	FNJSR	"R1-R3"
        CMP     r0,#&40                 ; is it < start of debugger ?
        BLO     topheader$l             ; if so, it's an explicit header
        MOV     r14,#-4*1               ; -1 string means 'unknown'
        MOVEQ   r14,#-4*2               ; if = start, it's the -2 string
        TEQ     r0,#&44                 ; is it start of zero-init ?
        MOVEQ   r14,#-4*3               ; if so, it's the -3 string
        TEQ     r0,#&7C                 ; is it end of zero-init ?
        MOVEQ   r14,#-4*4               ; if so, it's the -4 string
        MOV     r0,r14                  ; offset = r14
topheader$l
	ADR	R14,abs_stab	        ; take address of offset table
	LDR	R14,[R14,R0]		; get string offset
	FNLDR	R0,env_modstart		; base for indirected offsets
	ADD	R1,R0,R14		; string address
	FNLDR	R2,wimp_data
	MOV	R3,#256
	BL	lookup_token
	MOVVC	R0,R2
	FNLDR	R0,wimp_data,VC
	FNRTS

	DCD	zeroe$l
	DCD	zeros$l
	DCD	debug$l
	DCD	unknown$l
abs_stab
	DCD     decomp$l
        DCD     selfreloc$l
        DCD     zeroinit$l
        DCD     entry$l
        DCD     foolish$l
	DCD	abs_readonly$l
	DCD	abs_readwrite$l
	DCD	abs_debug$l
	DCD	abs_zeroinit$l
	DCD	abs_debugtype$l
	DCD	abs_base$l
	DCD	abs_workspace$l
	DCD	abs_addrmode$l
	DCD	abs_database$l
	DCD	abs_res1$l
	DCD	abs_res2$l
end_abs_stab
zeroe$l         = "zap_d_zeroe",0
zeros$l         = "zap_d_zeros",0
debug$l         = "zap_d_debug",0
unknown$l       = "zap_d_unknown",0
; before here are the 'special' -ve's
decomp$l        = "zap_d_decomp",0
selfreloc$l     = "zap_d_selfreloc",0
zeroinit$l      = "zap_d_zeroinit",0
entry$l         = "zap_d_entry",0
foolish$l       = "zap_d_foolish",0
abs_readonly$l	= "zap_d_abs_readonly",0
abs_readwrite$l	= "zap_d_abs_readwrite",0
abs_debug$l	= "zap_d_abs_debug",0
abs_zeroinit$l	= "zap_d_abs_zeroinit",0
abs_debugtype$l	= "zap_d_abs_debugtype",0
abs_base$l	= "zap_d_abs_base",0
abs_workspace$l	= "zap_d_abs_workspace",0
abs_addrmode$l	= "zap_d_abs_addrmode",0
abs_database$l	= "zap_d_abs_database",0
abs_res1$l	= "zap_d_abs_res1",0
abs_res2$l	= "zap_d_abs_res2",0
	ALIGN


 LOCAL

;E R0=file offset R8/R9 R10=caret
;X Branch at this offset followed #

follow_branch
	FNJSR	"R1-R3"
	STR	R14,local_temp4r6 + 16	; blat cache...
	BIC	R1,R0,#3			; offset of instruction
	STMFD	R13!,{R1}
	BL	getdisasmdata ; carefully_getdisasmdata ;
	STR	R0,local_disassemblerflags
	BL	carefully_readandputdisasmdata
	LDMFD	R13!,{R1}
 ; fudge
	MOV	R2,#8
	BL	getpreviousinstrs
	MOV	R2,#4
	BL	getpreviousinstrs
 ; end fudge
	MOVS	R0,R1
	BLPL	cln_readw			; get instruction in R0
	MOV	R3,R0			; save 'instruction'
	LDR	R2,[R8,#w_addr]		; base address
	ADD	R1,R2,R1
	BL	find_branch_addr
	BVS	exit$l
	BCC	branch$l			; R0=new address
 ; MOV R3,R0 ; tim's ???? fix ????
	BIC	R3,R3,#1 << 31		; clear bit 31...
	SUBS	R0,R3,R2			; file offset corresponding to this address
	BMI	exit$l			; off bottom of file (signed!)
	LDR	R14,[R9,#f_len]
	CMP	R0,R14
	BCS	exit$l			; off end of file
	MOV	R0,R3			; indirect (eg module header)
	SUB	R0,R0,R2			; find file offset
	BL	goto_offset
exit$l
	BL	carefully_readandrestoredisasm
	FNRTS
branch$l
 ;SWI &107
	SUB	R0,R0,R2			; find file offset
	BL	goto_offset
	B	exit$l

mode4_return
	FNJSR
	TEQ	R0,#0
	BNE	inmode2_return
inmode4_return
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R2,[R14,R2,LSL #2]
	STR	R2,localmodeword
	BL	getdisasmdata ; carefully_getdisasmdata VC
	STR	R0,local_disassemblerflags
	BL	loaddisasmwithcare		; if needed VC
	LDR	R2,localmodeword
 ;MOV R1,R2,LSR #8
 ;BIC R1,R1,#(&F << 20)		; options - need to update if these change
	BL	carefully_readandputdisasmdata

	ADR	R0,mo_s0			; command to execute
	ORR	R0,R0,#1 << 31		; don't learn
	BL	command_string
	BL	carefully_readandrestoredisasm
	FNRTS
mo_s0
	FNS	("ASSEMBLE")

mode4_start
	FNJSR	"R1"
	TEQ	R8,#0
	FNLDRB	R0,opt_format,EQ
	LDRNEB	R0,[R8,#w_format]	; mode number
	BL	restore_mode_word
	BL	loaddisasmwithcare	; load it if needed/possible.
	CMP	R8,#0
	FNRTS	EQ
	LDRB	R1,[R8,#w_format]	; mode number
	ADD	R14,R12,#opt_mode0
	LDR	R0,[R14,R1,LSL #2]
	ADD	R14,R8,#w_mode0
	STR	R0,[R14,R1,LSL #2]
	FNRTS

mode4_end
	TEQ	R8,#0
	FNLDRB	R0,opt_format,EQ
	LDRNEB	R0,[R8,#w_format]	; mode number
	B	save_mode_word

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search through a line (detokenise)			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R1=2 => R3=search file offset R4=direction
;  R1=3 => R1=detokenised str R2=offset/-ve R3=file off of line R10=len
;  R1=4 => As for 3 but R2=end of match offset
;X If R1=2 return vals as passed with R1=3
;  If R1=3 return R1=0 R2=file off of match R3=next offset
;  If R1=4 return R1=0 R2=file off of match end

mode4_search
	STR R14,local_temp4r6 + 16	; blat cache...
	TEQ R1,#3
	BEQ next$l			; find match offset and next line
	TEQ R1,#4
	BEQ end$l			; find end of match offset
	TEQ R1,#2
	MOVNE PC,R14
start$l					; get line to search through
	FNJSR
	PUSH	"R1-R10"		; hmm...
	LDRB	R2,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R2,[R14,R2,LSL #2]
  ; STR R2,localmodeword
	MOV	R3,R2
	BL	getdisasmdata
	STR	R0,local_disassemblerflags
	BL	search_readandputdisasmdata
	PULL	"R1-R10"

	CMP	R4,#0
	ADDPL	R3,R3,#3		; offset 1-3 means go to the next line
	BIC	R3,R3,#3		; file offset of 'line start'
	MOVS	R0,R3
	BLPL	cln_readw		; R0=instruction
	LDRVC	R1,[R8,#w_addr]		; address of first byte
	ADDVC	R1,R1,R3		; address to assume instruction came from
	BLVC	mode4_clever_search	; R1=buf R2=len (RET VS???)
	BVS	possibleproblem$l
;	FNRTS	VS			; !???
	MOV	R10,R2			; save the length
	CMP	R4,#0
	MOVPL	R2,#0			; offset in the detokenised line
	SUBMI	R2,R10,#1		; start at the line end

	BL	readandrestoredisasm	; preserves...?

; LDR R2,[R8,#w_mode4]
; STR R2,localmodeword
; BL carefully_getdisasmdata
; STR R0,local_disassemblerflags
; BL loaddisasmwithcare	; if needed
; LDR R2,localmodeword
; ;MOV R1,R2,LSR #8
; ;BIC R1,R1,#(&F << 20)		; options - need to update if these change
; BL carefully_readandputdisasmdata

	FNRTS

possibleproblem$l
	BL	readandrestoredisasm	; preserves...?
	ADDS	R14,R14,#0
	MOV	R1,#-1			; flag...????
	FNRTS

next$l
	MOV	R1,#0
	CMP	R2,#0
	MOVPL	R2,R3			; file offset of match (off in str ignored)
	ADD	R3,R3,R4,LSL #2		; jump a word in the correct direction
	MOV	PC,R14
end$l
	MOV	R1,#0
	ADD	R2,R3,#3
	MOV	PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Insert a character							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	LOCAL

; R4=w_flags R5=num typed R6=w_format R7=address of characters R8-R10=input

mode4_char
	FNJSR
	BL	minibuffer_wipe		; clear the minibuffer
a$l
	LDRB	R0,[R7],#1
	BL	minibuffer_writec
	FNRTS	VS
	SUBS	R5,R5,#1
	BGT	a$l			; fill up minibuffer
	LDR	R6,[R10,#c_off]		; offset of the instruction
	LDR	R5,[R8,#w_addr]		; address of offset 0
	BIC R6,R6,#3			; word align
	ADD	R0,R5,R6		; address instruction came from
	FNLDR	R1,wimp_block
	MOV	R2,#&100
	SWI	XOS_ConvertHex8		; start off with the address in hex
	FNRTS	VS
	FNLDR	R0,wimp_block
	BL	minibuffer_prompt
; FNcall Zap_MiniPrompt			; prompt = address + colon
	FNRTS	VS
	MOV	R1,#0
	MOV	R0,#0			; address to assume instruction came from
	SWI	XDebugger_Disassemble	; R1=buf R2=len
	ADRVSL	R1,stored_blank_string
	ADR	R0,assemble$l
	BL	find_key_command	; locate+load
	FNRTS	VS
	TEQ	R0,#0
	FNRTS	EQ			; not found
	MOV	R7,R0			; command address
	BL	minibuffer_start	; open the minibuffer
	FNRTS
assemble$l FNS ("ASSEMBLE")

local_bgcol_please
	DCD	0

tochkcondcode
	TST	R2,#&F<<10		; second column not reached...
	MOVNE	PC,R14
secondcolnotreached
	CMP	R0,#'a'
	BICCS	R0,R0,#&20
	BCS	asmcondfound

	TST	R4,#1 << 31
	MOVNE	PC,R14

	CMP	R0,#'V'
	BEQ	aCoranSV
	CMP	R0,#'C'
	BEQ	aCoranSC
	CMP	R0,#'P'
	BEQ	aPLUShere
	CMP	R0,#'M'
	BEQ	aMINUShere
	CMP	R0,#'L'
	BEQ	anLoranL
	CMP	R0,#'H'
	BEQ	anHoranH
	CMP	R0,#'G'
	BEQ	justalonelyTE
	CMP	R0,#'E'
	BEQ	justalonelyQ
	CMP	R0,#'N'
	BEQ	justalonelyEV
	MOV	PC,R14

secondcolnotreached2 ; can corrupt R11?
	CMP	R0,#'U'
	MOVNE	PC,R14
	LDRB	R11,[R1]
	CMP	R11,#'n'
	LDREQB	R11,[R1,#1]
	CMPEQ	R11,#'d'
	MOVNE	PC,R14
	ORR	R2,R2,#5 << 20		; undefined instructs
	ORR	R2,R2,#2048		; after gap...
	MOV	R11,#27
	B	bfnumberreductionpossible

aCoranSV
	LDRB	R14,[R1,#-2]
	CMP	R14,#'O'
	BEQ	notaconditionhere
	LDRB	R14,[R1,#-3]
	CMP	R14,#'B'
	BEQ	skipchk1$l
	LDRB	R14,[R1,#-4]
	CMP	R14,#'!'
	BLE	notaconditionhere
skipchk1$l
	LDRB	R14,[R1]
	CMP	R14,#'C'
	CMPNE	R14,#'S'
	BNE	notaconditionhere
asmcondfound
	TST	R4,#1 << 31
	MOVNE	PC,R14

	LDR	R14,[R8,#w_format]
	TST	R14,#1<<25		; cond colour as background?
	ORRNE	R2,R2,#1<<13
	STRNE	R2,local_bgcol_please
	BNE	notaconditionhere	; redundant
	ORR	R2,R2,#1<<12
	MOV	R11,#26
	B	mode4_keepingitsimple
;bgcondcolour
; LDR R14,local_bgcol_please
; CMP R14,#0
; BNE notaconditionhere
; MOV R11,#26
; STR R11,local_bgcol_please
; B notaconditionhere

aCoranSC
	LDRB	R14,[R1]
	CMP	R14,#'S'
	CMPNE	R14,#'C'
	BNE	notaconditionhere

	LDRB	R14,[R6,#-1] ; was 3
	CMP	R14,#'B'
	LDRNEB	R14,[R6,#-2] ; was 3
	CMPNE	R14,#'B'
	BEQ	skipchk3a$l ; if a B (as in BL...)
	LDRB	R14,[R6,#-1] ; was 3
	CMP	R14,#'A'
	LDREQB	R14,[R6,#-2] ; was 3
	CMPEQ	R14,#'!'
	BLE	notaconditionhere
	LDRB	R14,[R6,#-3] ; was 4
	CMP	R14,#'!'
	BLE	notaconditionhere
skipchk3a$l
	LDRB	R14,[R1,#-4]
	CMP	R14,#'A'
	BCS	asmcondfound
	LDRB	R14,[R1,#-3]
	CMP	R14,#'!'
	BCC	asmcondfound
	CMP	R14,#'B'
	BNE	notaconditionhere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'I'
	CMPNE	R14,#'C'
	BEQ	notaconditionhere
	B	asmcondfound

aPLUShere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'D'
	CMPNE	R14,#'M'
	BNE	straightfwdPLUS1
	LDRB	R14,[R1,#-3]
	CMP	R14,#'C'
	BEQ	notaconditionhere
straightfwdPLUS1
	LDRB	R14,[R1]
	CMP	R14,#'L'
	BEQ	asmcondfound
	B	notaconditionhere

aMINUShere
	LDRB	R14,[R1]
	CMP	R14,#'I'
	BNE	notaconditionhere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'R'
	CMPNE	R14,#'M'
	BEQ	asmcondfound
	CMP	R14,#'D'
	CMPNE	R14,#'T'
	BNE	asmcondfound		; dontchkanyfuthereSL
	LDRB	R14,[R1,#-3]
	CMP	R14,#'L'
	BEQ	notaconditionhere
	CMP	R14,#'S'
	BNE	asmcondfound
	LDRB	R14,[R1,#-4]
	CMP	R14,#'T'			; for TSTMI
	BEQ	asmcondfound
	B	notaconditionhere

anHoranH
	LDRB	R14,[R1]
	CMP	R14,#'S'
	CMPNE	R14,#'I'
	BEQ	asmcondfound
	B	notaconditionhere

anLoranL
; LDRB R14,[R1,#1]		; ???
; CMP R14,#'Q'
; BEQ notaconditionhere
;	LDRB	R14,[R1,#-2]
;	CMP	R14,#'@'			; for LOGGTP??
;	BLE	backfromfoundaregister;notaconditionhere
;	LDRB	R14,[R1,#-3]
;	CMP	R14,#'@'			; for LOGGTP??
;	BLE	backfromfoundaregister;notaconditionhere
;	LDRB	R14,[R1,#-1]
;	CMP	R14,#'@'			; for LOGGTP??
;	BLE	backfromfoundaregister;notaconditionhere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'U'			; for MULS...
	CMPNE	R14,#'F'			; for FLTGTP...
;	CMPNE	R14,#'@'			; for LOGGTP
	BEQ	backfromfoundaregister ; notaconditionhere
	LDRB	R14,[R1,#-3]
	CMP	R14,#'@'
	BLE	backfromfoundaregister; notaconditionhere		; FOR FLTGTP F5,R10 etc.
	CMP	R14,#'B'			; FOR BLLT...?
	BEQ	skipchk2$l
	LDRB	R14,[R1,#-4]
	CMP	R14,#'@'
	BLE	backfromfoundaregister ; notaconditionhere
; SWI &107
skipchk2$l
	LDRB	R14,[R1,#1]
	CMP	R14,#'G'		; LOG!!!
	BEQ	backfromfoundaregister ; notaconditionhere
	LDRB	R14,[R1]
	CMP	R14,#'S'
	CMPNE	R14,#'O'
	CMPNE	R14,#'E'
	BEQ	asmcondfound
	CMP	R14,#'T'
	BNE	backfromfoundaregister ; notaconditionhere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'F'			; for FTL<cond>
	BNE	asmcondfound
	LDRB	R14,[R1,#-3]
	CMP	R14,#'!'
	BCS	asmcondfound
	B	backfromfoundaregister ; notaconditionhere

justalonelyTE
	LDRB	R14,[R1]
	CMP	R14,#'T'
	CMPNE	R14,#'E'
	BEQ	asmcondfound
	B	notaconditionhere

justalonelyQ
	LDRB	R14,[R1]
	CMP	R14,#'Q'
	BNE	notaconditionhere
	LDRB	R14,[R1,#-2]
	CMP	R14,#'T'
	BNE	asmcondfound
	LDRB	R14,[R1,#-3]
	CMP	R14,#'S'
	BEQ	asmcondfound
	B	notaconditionhere

justalonelyEV
	LDRB	R14,[R1,#-2]
	CMP	R14,#'M'
	BNE	straightfwdCSV1
	LDRB	R14,[R1,#-3]
	CMP	R14,#'C'
	BEQ	notaconditionhere
straightfwdCSV1
	LDRB	R14,[R1,#-2]
	CMP	R14,#'V'
	BNE	straightfwdCSV2
	LDRB	R14,[R1,#-3]
	CMP	R14,#'M'
	BEQ	notaconditionhere
straightfwdCSV2
	LDRB	R14,[R1,#1]
	CMP	R14,#'Q'
	BEQ	notaconditionhere
	LDRB	R14,[R1]
	CMP	R14,#'E'
	CMPNE	R14,#'V'
	BEQ	asmcondfound
	B	notaconditionhere

;X R1=pointer to the menu

mode4_menu
	FNJSR	"R0"
; SWI &107
	MOV	R0,#14			; Code mode menu
	BL	read_menu_handle		; create the code mode menu
;  SUB R1,R1,#8
	FNRTS

redrawallcodemodewindows
	FNJSR	"R10"
	SWI	XHourglass_On
	ADR	R10,callallroutine$l
	BL	do_allwindow
	SWI	XHourglass_Off
	FNRTS
callallroutine$l
	FNJSR	"R0-R12"
	MOV	R0,#4
	BL	isthisaclonebase
	BLEQ	Updatewindow
	FNRTS

	LOCAL

redrawmostcodemodewindows	; 'global' ones anyway...
	FNJSR
	SWI	XHourglass_On
	CMP	R8,#0
	LDRNE	R0,[R8,#w_format]
	LDREQ	R0,[R12,#opt_format]
	TST	R0,#bit_windowwrap
	BLEQ	Updatewindow
	ADR	R10,callallroutine$l
	BL	do_allwindow
	SWI	XHourglass_Off
	FNRTS
callallroutine$l
	FNJSR	"R0-R12"
	MOV	R0,#4
	BL	isthisaclonebase
	FNRTS	NE
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_windowwrap	; ???
	BLNE	Updatewindow
	FNRTS

	DCD	&8017
Code_disasmtoggle		; global cases dealt with here...
	LDR	R6,[R0]		; gets word argument...
	CMP	R6,#&1C
	BCS	backtonormal$l
	FNJSR
	MOV	R0,#4
	BL	isthisaclonebase
r$l	MOVNE	R0,#2		; in case R2=15
	FNRTS	NE		; return if not (a clone of) Code mode
	CMP	R2,#15
	MOVLO	R14,R0
	TEQ	R0,R14		; menu - right mode?
	BNE	r$l
	CMP	R8,#0
	ADDEQ	R11,R12,#opt_mode0
	ADDNE	R11,R8,#w_mode0
	LDR	R0,[R11,R0,LSL #2]! ; mode word
	MOV	R7,R0
	CMP	R2,#15
	BEQ	but_tickquery2		; R2=15 indicates a 'tickquery'
	MOV	R5,R7,LSR #28
	BL	getdisasmdata
	MOV	R7,R0,LSL #8
	BIC	R7,R7,#(&F << 28)
	ORR	R7,R7,R5,LSL #28
	MOV	R5,#0
	AND	R1,R6,#&FF
	BL	mode4_execute
	MOV	R1,R6,LSR #8
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #16
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #24
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R7,LSR #8
	BIC	R7,R7,#(&F << 20)
	BL	putdisasmdata
	BL	redrawmostcodemodewindows
	FNRTS

specialcasestosdeal
	CMP	R6,#255
	BEQ	but_tickquery2
	CMP	R6,#254
	BEQ	but_tickquery3a
	CMP	R6,#253
	FNRTS	NE
	MOV	R0,#0		; clear nothing
	MOV	R1,#(1<<25)	; free click?
	BL	new_wind_format_set
	BIC	R0,R0,#2
	CMP	R2,#15
	FNRTS	EQ
	CMP	R8,#0
	BLNE	Updatewindow
	FNRTS

but_tickquery3a
	TEQ	R2,#15
	BEQ	but_tickquery3b
	TEQ	R8,#0
	LDRNEB	R0,[R8,#w_format]
	LDREQB	R0,[R12,#opt_format]
	CMP	R0,#4
	FNRTS	NE
	MOV	R0,#0		; clear nothing
	MOV	R1,#bit_windowwrap ; 1<<26	; toggle softwrap
	BL	new_wind_format_set
	BL	redrawmostcodemodewindows
	FNRTS

but_tickquery3b
	MOV	R0,#0		; clear nothing
	MOV	R1,#bit_windowwrap ; 1<<26	; toggle softwrap
	BL	new_wind_format_set
	FNRTS

getdisasmdata
	MOV	R0,#0
	MOV	R1,#0
	SWI	XDebugger_63
	SUBVS	R1,R1,R1	; 0 on error...
	MOV	PC,R14

putdisasmdata
	MVN	R0,#0
	SWI	XDebugger_63
	SUBS	R0,R0,R0			; clv.
	MOV	PC,R14

but_sortwwout
	FNJSR "R1-R12"
 ;FNcall Zap_GetWindOff
 ;FNcall Zap_ConvWindOff
 ;BL update_whole_window
 ;MOV	  R0,#4
 ;BL	  but_callmiscentrypt
 ;MOV	  R0,#5
 ;BL	  but_callmiscentrypt
 ;FNcall Zap_SaveWinStatus
 ;FNcall Zap_NewWinStatus
	BL	save_window_status
	BL	new_window_status		; update the window
	BL	Updatewindow
	FNRTS

	DCD	&8017
CmdCODEflagstoggle
	TEQ	R8,#0
	LDREQ	R11,[R12,#opt_format]
	LDRNE	R11,[R8,#w_format]
	TST	R11,#bit_windowwrap	; global?
	BNE	Code_disasmtoggle	; yes...
backtonormal$l
	FNJSR
	LDR	R6,[R0]		; gets word argument...
	MOV	R0,#4
	BL	isthisaclonebase
	MOVNE	R0,#2		; in case R2=15
	FNRTS	NE		; return if not (a clone of) Code mode
	CMP	R2,#15
	MOVLO	R14,R0
	TEQ	R0,R14		; menu - right mode?
	BNE	r$l
	TST	R6,#&80
	BNE	specialcasestosdeal
	TEQ	R8,#0
	ADDEQ	R11,R12,#opt_mode0
	ADDNE	R11,R8,#w_mode0
	LDR	R0,[R11,R0,LSL #2]!
	MOV	R7,R0
	CMP	R2,#15
	MOVEQ	R14,R6
	BEQ	but_tickquery		; R2=15 indicates a 'tickquery'
	MOV	R5,#0
	AND	R1,R6,#&FF
	BL	mode4_execute
	MOV	R1,R6,LSR #8
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #16
	AND	R1,R1,#&FF
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R1,R6,LSR #24
	TST	R1,#&80
	BLNE	mode4_execute
	MOV	R0,R7
	STR	R0,[R11]
	CMP	R8,#0
	BLNE	but_sortwwout		; window redraw if needed...
	FNRTS

but_tickquery
	AND	R2,R6,#&1F
	MOV	R3,#1
	MOV	R3,R3,LSL R2
	TST	R7,R3 ; r7?
	MOVNE	R0,#1
	MOVEQ	R0,#0
	FNRTSS

but_tickquery2
	CMP	R6,#255
	BEQ	skipd_codestf
	AND	R6,R6,#&1F
	CMP	R6,#&1C
	BCS	but_tickquery
	SUB	R6,R6,#8
	MOV	R7,#1
	MOV	R7,R7,LSL R6 ; ???
	MOV	R0,#0
	MOV	R1,#0
	SWI	XDebugger_63
	MOVVS	R7,#0
	TST	R0,R7
	MOVVC	R0,#0
	MOVVS	R0,#2
	ORRNE	R0,R0,#1
	FNRTSS
skipd_codestf
	MOV	R0,#0
	MOV	R1,#0
	SWI	XDebugger_63
	MOVVS	R0,#2
	MOVVC	R0,#0
	SUBS	R14,R14,R14
	ADDS	R0,R0,#0
	FNRTSS

mode4_execute
	AND	 R2,R1,#&1F
	MOV	 R3,#1
	MOV	 R3,R3,LSL R2
	MOV	 R2,#0
	MOV	 R4,#0
	MOV	 R1,R1,LSR #5
	AND	 R1,R1,#3
	CMP	 R1,#1
	MOVEQ	 R2,R3
	CMP	 R1,#2
	MOVEQ	 R4,R3
	BIC	 R7,R7,R2
	ORR	 R7,R7,R4
	EOR	 R7,R7,R3
	MOV	 PC,R14

insertbinarydata
	TST	R2,#1<<17
	ADDEQ	R6,R6,#27		; little endian
binaryloop$l
	CMP	R7,R10
	BLCS	red_overflow
	BVS	just_exit_from_redraw			; overflow
	LDRB	R0,[R7],#1
	ORR	R4,R4,R0
	MOV	R4,R4,ROR #8		; save byte in instruction
	BL	bin8
	MOV	R0,#32
	STRB	R0,[R6],#1
	TST	R2,#1<<17
	SUBEQ	R6,R6,#18		; little endian so go back
	SUBS	R3,R3,#1
	BHI	binaryloop$l
	SUB	R6,R6,#1
	TST	R2,#1<<17
	ADDEQ	R6,R6,#45		; finish hex dump field
	B	backfrominsertbinarydata

maybe_bgcondcolour		; corrupts R4.
	TST	R2,#1<<12
	BICNE	R2,R2,#1<<12
	MOVNE	R11,#26
	BNE	mode4_keepingitsimple
	TST	R2,#1<<10			; fontbgcol
	BICNE	R2,R2,#1<<13
	ORR	R2,R2,#1<<10		; fontbgcol ; 1<<21 ; cond complete.
	TST	R2,#2048			; after some spaces???
	BNE	notaconditionhere2
	BIC	R0,R0,#&20
	B	mode4_keepingitsimple

; LDR R4,local_bgcol_please
; TST R4,#&FF
; TST R2,#3 << 12
; MOVEQ PC,R14
 ;TST R4,#&80000000
 ;ORREQ R4,R4,#&80000000
 ;MOVNE R4,#&7F000000
 ;STR R4,local_bgcol_please
; MOV PC,R14

alreadyinacomment
	MOV	R11,#11
 ;LDR R4,localmodeword
 ;TST R4,#1 << 22
 ;BEQ mode4_keepingitsimple
 ;MOV R0,#32
	B	bfnumberreductionpossible ; mode4_keepingitsimple

possiblyasbackground
 ;STRB R14,[R6,R4]		; background colour
 ;LDR R14,local_bgcol_please
 ;TST R14,#&FF
	SUB	R4,R4,#1
	TST	R2,#1<<13			; cond bg font...
	MOVEQ	R14,#1			; bg.
	MOVNE	R14,#26			; possible colour
; SUB R4,R4,#1
	STRB	R14,[R6,R4]		; background colour
; ADD R4,R4,#1
	SUBS	R3,R3,#1
	BGT	dis_loop_in_redraw
	B	pre_exit_from_redraw

mode4_interrogate
	CMP	R0,#11
	BNE	couldbeokormaybenot
	LDR	R0,local_bgcol_please
	TST	R0,#3<<12 ; &40000000
	MOVNE	R0,#0
	MOVEQ	R0,#11
	MOV	PC,R14

couldbeokormaybenot
	CMP	R0,#14
	MOVEQ	R0,#1
	MOVEQ	PC,R14
	CMP	R0,#16
	BEQ	binarytest$l
	CMP	R0,#15
	BEQ	colourquery$l
	CMP	R0,#13 ; SAYT
	CMPNE	R0,#5 ; ConfineH
	CMPNE	R0,#6 ; ConfineV
	CMPNE	R0,#7 ; Free click
	CMPNE	R0,#8 ; Smart cursors
	CMPNE	R0,#12 ; Line Select
	CMPNE	R0,#23			; block editing?
	CMPNE	R0,#24			; auto-indent
	MOVEQ	R0,#0
	MOVEQ	PC,R14
	CMP	R0,#1
	CMPNE	R0,#2
	MVNEQ	R0,#0
	MOV	PC,R14

secondary_problem
;	TST	R4,#&00200000		; HMM...
;	ORRNE	R2,R2,#1 << 18		; FP...????????
;	BNE	colouring_colour

;	AND	R0,R4,#&F << 20
;	CMP	R0,#&0 << 20
;	CMPNE	R0,#&1 << 20
;	CMPNE	R0,#&6 << 20
;	CMPNE	R0,#&7 << 20
;	CMPNE	R0,#&8 << 20
;	CMPNE	R0,#&A << 20		; > C D E F
;	ORRLT	R2,R2,#1 << 18		; FP
;	BLT	colouring_colour		; dodgy criteria.

;	CMP	R0,#&C << 20
;	CMPNE	R0,#&D << 20		; > C D E F
;	ORREQ	R2,R2,#1 << 19		; CP
;	BEQ	colouring_colour

;	AND	R0,R4,#&0F << 24
;	CMP	R0,#&0D << 24		; &xDxxx1xx?
;	ORREQ	R2,R2,#1 << 19		; CP
;	BEQ	colouring_colour

	MOV	R0,R4,LSR#20
	AND	R0,R0,#&FF
	CMP	R0,#&C3
	CMPNE	R0,#&DC
	CMPNE	R0,#&DD
	CMPNE	R0,#&E0
	CMPNE	R0,#&E1
	CMPNE	R0,#&E2
	CMPNE	R0,#&E3
	CMPNE	R0,#&E4
	CMPNE	R0,#&E5
	ORREQ	R2,R2,#1 << 18		; FP
	BEQ	colouring_colour

	CMP	R0,#&ED			; better here???
	CMPNE	R0,#&EE			; better here???
	CMPNE	R0,#&EF			; better here???
	BEQ	stage4_problem

	CMP	R0,#&C0
	CMPNE	R0,#&C1
	CMPNE	R0,#&C4
	CMPNE	R0,#&C5
	CMPNE	R0,#&C9
	CMPNE	R0,#&CC
	ORREQ	R2,R2,#1 << 19		; CP
	BEQ	colouring_colour
; ...
;	CMP	R0,#&EB			; here...???

	CMP	R0,#&E6
	CMPNE	R0,#&E7
	CMPNE	R0,#&E8
	CMPNE	R0,#&E9			; different...
	CMPNE	R0,#&EA
	CMPNE	R0,#&EC
	BEQ	moreproblems$l
; ...
;	BEQ	idproblem$l

	AND	R0,R0,#&F0
	TEQ	R0,#&D0			; last...
	ORREQ	R2,R2,#1 << 18		; FP ...?
	BEQ	colouring_colour	; ???

	AND	R0,R4,#&F2 << 20	; was above...
	CMP	R0,#&C2 << 20		; &xC2xx1xx
	ORREQ	R2,R2,#1 << 18		; FP
	BEQ	colouring_colour

	AND	R0,R4,#&FF00
	TEQ	R0,#&F100
	BEQ	tertiaryproblems$l
	TEQ	R0,#&D100 ; ???
	BEQ	tertiaryproblems2$l

	AND	R0,R4,#&F1 << 20	; jusr swapped with above...
	CMP	R0,#&E0 << 20
	ORREQ	R2,R2,#1 << 19		; CP
	BEQ	colouring_colour

;	AND	R0,R4,#&F << 20
;	CMP	R0,#&F << 20
;	ANDEQ	R0,R4,#&E << 24
;	CMPEQ	R0,#&E << 24
;	ORRNE	R2,R2,#1 << 19		; CP ...?
;	BNE	colouring_colour

;	AND	R0,R4,#&F << 20
;	CMP	R0,#&F << 20
;	ANDEQ	R0,R4,#&E << 24
;	CMPEQ	R0,#&E << 24
;	ORRNE	R2,R2,#1 << 19		; CP ...?
;	BNE	colouring_colour

;	TEQ	R0,#&D << 24
;	ORREQ	R2,R2,#1 << 18		; FP
;	BEQ	colouring_colour
;	ORREQ	R2,R2,#1 << 18		; FP
;	ORR	R2,R2,#1 << 18		; FP
	ORR	R2,R2,#1 << 19		; CP ...?
	B	colouring_colour

stage4_problem
;	SWI &107
	TST	R4,#&10
	ORRNE	R2,R2,#1 << 19		; CP ...?
	BNE	colouring_colour

	TST	R4,#&8000
	ORRNE	R2,R2,#1 << 18		; FP
	ORREQ	R2,R2,#1 << 19		; CP ...?
;	BNE	colouring_colour

;	ORREQ	R2,R2,#1 << 19		; CP ...?
	B	colouring_colour

; was here - is it necessary...???
;	AND	R0,R4,#&FB00
;	TEQ	R0,#&1100
;;;	TEQNE	R0,#&5100
;	ORRNE	R2,R2,#1 << 18		; FP
;	ORREQ	R2,R2,#1 << 19		; CP ...?
;	B	colouring_colour

;idproblem$l
;;	SWI &107
;	AND	R0,R4,#&FF << 8
;	CMP	R0,#&F1 << 8
;	ORREQ	R2,R2,#1 << 18		; FP ...?
;	BEQ	colouring_colour		; ???
;
;	ORR	R2,R2,#1 << 19		; CP ...?
;	B	colouring_colour

moreproblems$l
	ANDS	R0,R4,#&10
	ORREQ	R2,R2,#1 << 18		; FP ...?
	BEQ	colouring_colour		; ???

	ORR	R2,R2,#1 << 19		; CP ...?
	B	colouring_colour

tertiaryproblems$l
	AND	R0,R4,#&FF << 20	; was above...
	CMP	R0,#&C8 << 20		; &xC2xx1xx
	ORRNE	R2,R2,#1 << 18		; FP ...?
	BNE	colouring_colour	; ???
	ORR	R2,R2,#1 << 19		; CP
	B	colouring_colour

tertiaryproblems2$l
	TST	R4,#&30
	ORREQ	R2,R2,#1 << 18		; FP ...?
	ORRNE	R2,R2,#1 << 19		; CP
	B	colouring_colour

binarytest$l
	FNJSR
	LDRB	R0,[R8,#w_format]	; mode number
	ADD	R14,R8,#w_mode0
	LDR	R0,[R14,R0,LSL #2]	; load in our mode word
	TST	R0,#1 << 28		; binary?
	MOVNE	R0,#2
	MOVEQ	R0,#16
	FNRTS

colourquery$l
	CMP	R1,#26
	MOVNE	PC,R14
	LDR	R0,[R8,#w_format]
	TST	R0,#1 << 25			; is it BG
	MOVNE	R0,#2			; bit 0 clear if it is...
	MOVEQ	R0,#15
	MOV	PC,R14

; e_help entry point, written by James (feel free to replace)
;
; \E r0 offset, r8/r9
; \X r0 = number of possibilities, r1 => block of pointers to possibilities
;  r2-r11 preserved
;
; Note: this can probably be written far better by someone else.
; In particular, it would be nice if branches could offer the symbolic
; function name as a possibility, if it exists. That's really Justin's
; area, though ...

buf$l EQU 50
mode4_help
	FNJSR "r2-r3"
	BIC r0,r0,#3 ; round down to a whole word
	MOV r2,r0 ; store for disassembly
	LDR r1,[r9,#f_splito]
	CMP r0,r1 ; is it past split?
	LDRGT r1,[r9,#f_splits]
	ADDGT r0,r0,r1 ; jump over split
	LDR r1,[r9,#f_ptr] ; start of buffer
	ADD r0,r0,r1 ; address
	LDR r0,[r0] ; get instruction word
	AND r1,r0,#(15:SHL:24) ; SWI identifying fragment
	CMP r1,#(15:SHL:24)
	BNE notswi$l

	BIC r2,r0,#(255:SHL:24) ; clear to SWI number
	MOV r0,#buf$l
	BL heap_claim
	FNRTS VS
	MOV r1,r0 ; buffer
	MOV r0,r2 ; SWI number
	MOV r2,#buf$l
	SWI XOS_SWINumberToString
	FNRTS VS

	MOV r0,#8
	BL heap_claim
	BVS fail$l

	STR r1,[r0,#0] ; first possibility
	MOV r1,r0 ; ready for return
	MOV r0,#4
	BL heap_claim
	BVS fail2$l

	STR r0,[r1,#4] ; second possibility
	LDR r2,swi$l
	STR r2,[r0] ; store "SWI\0"
	MOV r0,#2 ; two possibilities
	FNRTS

fail$l	MOV r2,r0 ; store error pointer
	MOV r0,r1 ; buffer to free
	BL heap_free
	MOV r0,r2 ; restore error pointer
	FNRTS

fail2$l MOV r2,r0 ; store error pointer
	LDR r0,[r1,#0] ; get SWI name buffer
	BL heap_free ; free it
	MOV r0,r1 ; get the other buffer
	BL heap_free ; free it
	MOV r0,r2 ; restore error pointer
	FNRTS

swi$l = "SWI", 0

; /E r0 = instruction word, r2 = file offset
notswi$l
	LDR r1,[r8,#w_addr] ; start address for file
	ADD r1,r1,r2 ; address the instruction "came from"
	BIC r0,r0,#(15:SHL:28) ; clear condition code
	ORR r0,r0,#(14:SHL:28) ; 'AL' (disassembled invisibly)
	SWI XDebugger_Disassemble		; naked???

	MOVVC r0,r2 ; length, including terminator
	BLVC heap_claim ; \X r0 => block
	FNRTS VS

	MOV r2,r1 ; source
	MOV r1,r0 ; destination
	MOV r3,r0 ; save it
	BL strcopy ; copy it, including terminator

	MOV r0,#4
	BL heap_claim
	BVS failnotswi$l

	STR r3,[r0] ; store pointer to disassembly
	MOV r1,r0 ; into position for return

	; this, of course, isn't enough. We now have to find the first
	; lwsp byte and replace it with a NUL, so that lookup will only
	; be on the opcode itself (plus flags. Arg.)
loop$l LDRB r2,[r3],#1
	CMP r2,#32
	BGT loop$l
	MOV r0,#0
	STRB r0,[r3,#-1]

	MOV r0,#1 ; one possibility
	FNRTS

failnotswi$l
	MOV r1,r0 ; store error pointer
	MOV r0,r3 ; get block pointer
	BL heap_free ; free it
	MOV r0,r1 ; restore error pointer
	FNRTS

	END

