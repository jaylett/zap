; Contains mode entry points for text mode.
; $Id: SoftWrap,fff,v 2.7 2005/02/23 13:28:34 christian Exp $

        GET     h.ZapHeader
        GET     h.Heap
        GET     h.ModeBits
        GET     h.Redraw
        GET     h.Cursors
        GET     h.Mode0

        IMPORT  clip_cache
        IMPORT  zephyr

        EXPORT  modesw_clnlog
        EXPORT  modesw_clnphy
        EXPORT  modesw_clnoff
        EXPORT  modesw_nextline
        EXPORT  modesw_prevline
        EXPORT  modesw_redrawline
        EXPORT  modesw_plus
        EXPORT  modesw_cplus
        EXPORT  modesw_linestart
        EXPORT  modesw_lineprev
        EXPORT  modesw_lineend
        EXPORT  modesw_linenext

;;;;;;;;;;;;;;;;;;;;; findnextphysl /////////////////////////

local_storageeugh
        DCD     0
local_storageeugh2
        DCD     0
local_zapwkspace
        DCD     0

;\\\\\\\\\\\\\\\\\\\\\\ findnextphysl ////////////////////////
; \E R0 = address of a start of a line
;    R12 = max length of line
;    R3 = buffer start
;    R4 = address of start of split
;    R5 = length of split
;    R6 = buffer end
;    R7 = end of line character
;    R8
; \X R0 = address of start of next line
;    CS if eol was forced by eol-character, CC else
;    VS if eot before eol

findnextphysl
        FNJSR   "R1,R2,R3,R8-R12"

        LDR     R10,[R8,#w_tabstops]
        PUSH    "R10"                   ;  keep tabstop list on stack, because
        LDRB    R10,[R8,#w_tabc]        ;  we lose R8 later

        PUSH    "R0-R1,R12"
        MOV     R0,#einterrogate_SoftWrapChars
        MOV     R11,#e_interrogate
        LDR     R12,local_zapwkspace
        BL      call_mode
        CMP     R0,#einterrogate_SoftWrapChars ;  didn't respond, so use defaults
        ADREQ   R0,dft_str_for_sw
        STR     R0,local_storageeugh
        PULL    "R0-R1,R12"

        LDR     R1,[R8,#w_format]
        AND     R1,R1,#format_TabDisplayFormat

        MOV     R8,R0
        MOV     R9,R0
        MOV     R11,#0

        TEQ     R0,R4
        ADDEQ   R0,R0,R5

        CMP     R0,R3
        MOVLT   R0,R3

        CMP     R0,R6
        BCS     fnpl_eot
fnpl_lp
        LDR     R3,local_storageeugh
        STR     R0,local_storageeugh2
        LDRB    R14,[R0],#1             ;  !EXCEPTION!!!?
        TEQ     R0,R4
        ADDEQ   R0,R0,R5
        CMP     R0,R6
        BCS     fnpl_eot
        TEQ     R14,R10                 ;  tabc
        BEQ     possibiltyofwraphere2
loop1$l
        LDRB    R2,[R3],#1
        CMP     R2,#0
        BEQ     swchar_dontdoathing
        CMP     R14,R2
        BNE     loop1$l
possibiltyofwraphere
        PUSH    "R14"
        LDRB    R14,[R0]
        TEQ     R14,#' '                ;  spaces
        MOVNE   R8,R0
dontchktherest
        PULL    "R14"
swchar_dontdoathing
        TEQ     R14,R7
        BEQ     fnpl_eolchar
        TEQ     R14,R10
                                        ; STRNE R0,local_addrofpreviousone
                                        ;  STRNE R14,local_arecenttab
        ADDNE   R11,R11,#1
        BLEQ    fnpl_tab
        CMP     R11,R12
        BLT     fnpl_lp                 ;  max r12 characters on the line
        LDRB    R14,[R0]
        TEQ     R14,R7
                                        ; PULL "R14"
        BEQ     fnpl_eolchar2

        TEQ     R8,R9
        MOVNE   R0,R8

        PULL    "R14"
        FNRTCC                          ;  this also clears V, so that's alright

dft_str_for_sw
        =       " -",0
        ALIGN


possibiltyofwraphere2
        LDR     R8,local_storageeugh2
        B       swchar_dontdoathing

fnpl_tab
        TEQ     R1,#0                   ;  tab mode = none?
        ADDEQ   R11,R11,#1
        LDRNE   R2,[R13]                ;  fetch w_tabstops from stack
        LDRNE   R2,[R2,R11,LSL #1]
        ADDNE   R11,R11,R2,LSR #16
        MOV     PC,R14

fnpl_eolchar
        PULL    "R14"                   ;  correct stack
        FNRTCS

fnpl_eolchar2
        LDRB    R14,[R0],#1
        TEQ     R0,R4
        ADDEQ   R0,R0,R5
        CMP     R0,R6
        BCS     fnpl_eot
        PULL    "R14"                   ;  correct stack
        FNRTCS

fnpl_eot
        MOV     R0,R6
        TEQ     R14,R7
        BEQ     fnpl_eolchar            ;  if last char of the file is ';n'
        PULL    "R14"                   ;  correct stack
        FNRTV                           ;  warning: now unpredictable C state


;;;;;;;;;;;;;;;;;;;;; compute_column ///////////////////////
; ;E r8/r9, r0,r1
; ;X r2
; Given r0,r1 file offsets; r0 -> an sol, compute the column number
; of r1 in r2. This is non-trivial due to tabulation

compute_column
        CMP     R1,R0
        MOVEQ   R2,#0
        MVNMI   R2,#0
        MOVLE   PC,R14
        FNJSR   "R0-R1,R3-R7,R11"
        LDR     R14,[R8,#w_format]
        TST     R14,#format_TabDisplayFormat

        SUBEQ   R2,R1,R0
        FNRTS   EQ

        LDR     R7,[R8,#w_tabstops]
        LDR     R3,[R9,#f_ptr]
        LDR     R4,[R9,#f_splito]
        ADD     R4,R4,R3
        LDR     R5,[R9,#f_splits]
        LDR     R6,[R9,#f_len]
        ADD     R6,R6,R3
        ADD     R6,R6,R5

        ADD     R0,R0,R3
        CMP     R0,R4
        ADDCS   R0,R0,R5
        ADD     R1,R1,R3
        CMP     R1,R4
        ADDCS   R1,R1,R5
        MOV     R2,#0
        LDRB    R11,[R8,#w_tabc]
cc_lp
        LDRB    R14,[R0],#1
        TEQ     R14,R11
                                        ; ORREQ R2,R2,#7
        LDREQ   R14,[R7,R2,LSL #1]
        ADDEQ   R2,R2,R14,LSR #16
        ADDNE   R2,R2,#1
        CMP     R0,R4                   ;  hop over the split
        ADDEQ   R0,R0,R5
        CMP     R0,R1
        BCC     cc_lp
        FNRTS

;;;;;;;;;;;;;;;;;;;;;;; mode_clnoff /////////////////////////

modesw_clnoff
        CMP     R0,#0
        MOVLE   R0,#0                   ;  doesn't help...
        FNJSR   "R10-R12"
        STR     R12,local_zapwkspace
        LDR     R14,[R9,#f_splito]
        CMP     R0,R14
        MOVLT   R10,R0
        LDRGE   R14,[R9,#f_splits]
        ADDGE   R10,R0,R14
        LDR     R14,[R9,#f_ptr]
        ADD     R10,R10,R14

        MOV     R12,#0
        LDR     R14,[R8,#w_coff]
        CMP     R0,R14
        ADRGE   R14,mclno_done
        BGE     mcl_forward
        CMP     R0,R14,LSR #1
        ADR     R14,mclno_done
        BGE     mcl_backward
        BLT     mcl_forward
mclno_done
        EOR     R0,R1,R0
        EOR     R1,R0,R1
        EOR     R0,R1,R0
        FNRTS

mcl_forward
; don't change stack structure without looking!
        FNJSR   "R3-R7,R10-R12"
        STR     R12,selfmod_reg
        MOVLT   R0,#0
        LDRGE   R0,[R8,#w_coff]
        MOVLT   R1,#0
        LDRGE   R1,[R8,#w_cline]
        MOVLT   R2,#0                   ;  NO!???
        LDRGE   R2,[R8,#w_clogl]

        LDR     R3,[R9,#f_ptr]
        LDR     R4,[R9,#f_splito]
        ADD     R4,R4,R3
        LDR     R5,[R9,#f_splits]
        LDR     R6,[R9,#f_len]
        ADD     R6,R6,R3
        ADD     R6,R6,R5
        LDR     R12,[R8,#w_bpl]
        LDRB    R7,[R8,#w_cr]

        ADD     R0,R0,R3
        CMP     R0,R4
        ADDCS   R0,R0,R5
        BL      selfmod_check
        BGE     mcl_done

mcl_fwd_from_bwd
mcl_fwd_lp
        PUSH    "R0-R2"                 ;  stack 'old' (r0,r1,r2)
        BL      findnextphysl
        BCS     mcl_noproblem
        BVS     mcl_eot_no_eol          ;  if at eot, and there isn't a ';n' at the end of the line
mcl_noproblem
        ADD     R1,R1,#1
        ADDCS   R2,R2,#1                ;  IF END OF LOG.LINE
        MRS     R11,CPSR                ;  preserve V
        BL      selfmod_check
        BGT     mcl_restore_done

        ADD     R13,R13,#12             ;  forget about the 'old' stuff, we're going on...
        BEQ     mcl_done                ;  if exactly at an sol, the 'new' coords apply, but...

        TST     R11,#Vbit
        BEQ     mcl_fwd_lp              ;  unless at eot...
        B       mcl_done

mcl_eot_no_eol
        STR     R0,mcl_reprint_service_0 ;  for mode_nextline, to correctly find eot
        STR     R1,mcl_reprint_service_1
        PULL    "R0-R2"
        CMP     R0,R4
        SUBCS   R0,R0,R5
        SUB     R0,R0,R3
        FNRTS

selfmod_reg
        DCD     0
mcl_reprint_service_0
        DCD     0
mcl_reprint_service_1
        DCD     0

mcl_restore_done
        PULL    "R0-R2"
mcl_done
        STR     R0,mcl_reprint_service_0 ;  for mode_nextline, to correctly find eot
        STR     R1,mcl_reprint_service_1 ;  ???? SW BUG ? :-/
        CMP     R0,R4
        SUBCS   R0,R0,R5
        SUB     R0,R0,R3
        FNRTS

mcl_backward
; don't change stack structure without looking!
        FNJSR   "R3-R7,R10-R12"
        STR     R12,selfmod_reg
        LDR     R0,[R8,#w_coff]
        LDR     R1,[R8,#w_cline]
        LDR     R2,[R8,#w_clogl]

        LDR     R3,[R9,#f_ptr]
        LDR     R4,[R9,#f_splito]
        ADD     R4,R4,R3
        LDR     R5,[R9,#f_splits]
        LDR     R6,[R9,#f_len]
        ADD     R6,R6,R3
        ADD     R6,R6,R5
        LDR     R12,[R8,#w_bpl]
        LDRB    R7,[R8,#w_cr]

        ADD     R0,R0,R3
        CMP     R0,R4
        ADDCS   R0,R0,R5

mcl_bfc_lp
        MOV     R11,R0

        BL      findsologl
        BVS     mcl_done                ;  stop if sot crossed
        PUSH    "R0,R14"                ;  preserve file address of start of curr. log. line
mcl_bfc_fwd_lp
        CMP     R0,R11
        BCS     mcl_bfc_fwd_elp         ;  forward to 'original file address',
        BL      findnextphysl           ;  .. counting lines
        SUB     R1,R1,#1                ;  DECREASE THE PHYS. LINE # FOR EACH line counted
        B       mcl_bfc_fwd_lp

mcl_bfc_fwd_elp
        ADDHI   R1,R1,#1                ;  if _exactly_ at an sol, don't do this
                                        ;  (ie when moved to
        PULL    "R0"
        BL      selfmod_check
        PULL    "R14"
        BLE     mcl_bwd_before          ;  only allowable jump to mcl_bwd_before
        MOV     R0,R14                  ;  MOVE LEFT ONE CHARACTER, OVER THE eol-char,
                                        ;  to enter previous...
        SUB     R2,R2,#1
        SUB     R1,R1,#1
        B       mcl_bfc_lp

selfmod_check
        FNJSR
        LDR     R14,selfmod_reg
        ADD     PC,PC,R14,LSL #3
        DCD     0
        CMP     R0,R10
        FNRTS
        CMP     R1,R10
        FNRTS
        CMP     R2,R10
        FNRTS
mcl_bwd_before
        BEQ     mcl_done                ;  from the cmp rxx,r10 at line 'yes!'

        B       mcl_fwd_from_bwd


;;;;;;;;;;;;;;;;;;;;;; findnextlogl ;;;;;;;;;;;;;;;;;;;;;;;;;

findnextlogl
        CMP     R0,R6
        RTV     CS
        CLV
        FNJSR
        CMP     R0,R6
        MOVCS   R0,R6
        BCS     fnll_return             ;  return eof if at eof
fnll_lp
        LDRB    R14,[R0],#1
        TEQ     R0,R4
        ADDEQ   R0,R0,R5                ;  skip split if appropriate
        CMP     R0,R6
        MOVCS   R0,R6
        BCS     fnll_return             ;  return eof if at eof
        TEQ     R14,R7
        BNE     fnll_lp                 ;  search for eol
fnll_return
        FNRTS

;;;;;;;;;;;;;;;;;;;;;;;; findsologl ;;;;;;;;;;;;;;;;;;;;;;;;;

findsologl
        CMP     R0,R3
        MOVLS   R0,R3
        RTV     LS
        CLV
        FNJSR   "R4"
        ADD     R4,R4,R5

fpll_lp
        TEQ     R0,R4
        SUBEQ   R0,R0,R5                ;  skip split if appropriate
        SUB     R0,R0,#1
        CMP     R0,R3
        LDRHSB  R14,[R0]                ;  dodgy check at -1 ?
        MOVLO   R14,R7
        TEQ     R14,R7
        BNE     fpll_lp                 ;  search for eol-character
        MOV     R14,R0
        ADD     R0,R0,#1
        TEQ     R0,R3
        MOVEQ   R14,R0
        SUB     R4,R4,R5
        TEQ     R0,R4
        ADDEQ   R0,R0,R5                ;  skip split forward, if nec.
fsll_return
        FNRTS


;;;;;;;;;;;;;;;;;;;;;;;;; mode_clnlog ///////////////////////

modesw_clnlog
        FNJSR   "R2,R10-R12"
        STR     R12,local_zapwkspace
        MOV     R10,R0
        MOV     R12,#2
        LDR     R14,[R8,#w_clogl]
        CMP     R10,R14
        ADRGE   R14,mclnl_done
        BGE     mcl_forward
        CMP     R10,R14,ASR #1
        ADR     R14,mclnl_done
        BGE     mcl_backward
        BLT     mcl_forward
mclnl_done
        FNRTS


;;;;;;;;;;;;;;;;;;;;;;; mode_clnphy /////////////////////////

modesw_clnphy
        FNJSR   "R2,R10-R12"
        STR     R12,local_zapwkspace
        MOV     R10,R0
        MOV     R12,#1
        LDR     R14,[R8,#w_cline]
        CMP     R10,R14
        ADRGE   R14,mclnp_done
        BGE     mcl_forward
        CMP     R10,R14,ASR #1
        ADR     R14,mclnp_done
        BGE     mcl_backward
        BLT     mcl_forward
mclnp_done
        MOV     R1,R2
        FNRTS


;;;;;;;;;;;;;;;;;;;;;;; mode_nextline //////////////////////////

modesw_nextline
        FNJSR   "R2-R7,R12"

        LDR     R3,[R9,#f_ptr]
        LDR     R4,[R9,#f_splito]
        ADD     R4,R4,R3
        LDR     R5,[R9,#f_splits]
        LDR     R6,[R9,#f_len]
        ADD     R6,R6,R3
        ADD     R6,R6,R5
        LDR     R12,[R8,#w_bpl]
        LDRB    R7,[R8,#w_cr]

        ADD     R0,R0,R3
        CMP     R0,R4
        ADDCS   R0,R0,R5
        BL      findnextlogl
        CMP     R0,R4
        SUBCS   R0,R0,R5
        SUBS    R0,R0,R3
        LDR     R12,[R13,#24]           ;  **** READING FROM STACK *****
        BL      modesw_clnoff
        LDR     R0,mcl_reprint_service_0 ;  ADDRESS OF FIRST SHIFTABLE LINE
        CMP     R0,R4
        SUBCS   R0,R0,R5
        SUB     R0,R0,R3                ;  R0 = OFFSET
        LDR     R1,mcl_reprint_service_1 ;  R1 = LINE # (MAY BE TOO HIGH, AT EOT)
        LDR     R14,[R9,#f_len]         ;  ????!
        FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;; mode_prevline ////////////////////////


modesw_prevline
        FNJSR   "R1-R7,R12"
        LDR     R14,[R9,#f_docom]
        CMP     R14,#0
        CMPNE   R14,#7                  ;  was 5
        FNRTS   CS                      ;  exit if r14=0 or r14>=7

        LDR     R3,[R9,#f_ptr]
        LDR     R4,[R9,#f_splito]
        ADD     R4,R4,R3
        LDR     R5,[R9,#f_splits]
        LDR     R6,[R9,#f_len]
        ADD     R6,R6,R3
        ADD     R6,R6,R5
        LDR     R12,[R8,#w_bpl]
        LDRB    R7,[R8,#w_cr]

        ADD     R0,R0,R3
        CMP     R0,R4
        ADDCS   R0,R0,R5

        BL      findsologl              ;  test GT!!!
        CMP     R0,R4
        SUBCS   R0,R0,R5
        SUB     R0,R0,R3

        LDR     R12,[R13,#28]           ;  ******** reading from stack ********
        PUSH    "R0"
        BL      clip_cache
        PULL    "R0"

        FNRTS


;;;;;;;;;;;;;;;;;;;;;;;; mode_linestart ////////////////////////

modesw_linestart
modesw_lineprev
        FNJSR   "R1-R7,R12"
        BL      mls_lowlevel
        CMP     R0,R4
        SUBHI   R0,R0,R5
        SUBS    R0,R0,R3
        MOVMI   R0,#0                   ; -)
        FNRTS

mls_lowlevel
        FNJSR
        LDR     R3,[R9,#f_ptr]
        LDR     R4,[R9,#f_splito]
        ADD     R4,R4,R3
        LDR     R5,[R9,#f_splits]
        LDR     R6,[R9,#f_len]
        ADD     R6,R6,R3
        ADD     R6,R6,R5
        LDR     R12,[R8,#w_bpl]
        LDRB    R7,[R8,#w_cr]

        ADD     R0,R0,R3
        CMP     R0,R4
        ADDCS   R0,R0,R5
        MOV     R1,R0
        MOV     R2,R0
        BL      findsologl
mls_lp
        CMP     R0,R1
        BGE     mls_stop
        ADDS    R2,R0,#0

        BL      findnextphysl
        BVC     mls_lp

mls_stop
        MOVNE   R0,R2                   ;  if the last line start found (in r0)
                                        ;  is too far, then use the
        FNRTS

;;;;;;;;;;;;;;;;;;;;;;;; mode_lineend //////////////////////////

modesw_lineend
        FNJSR   "R1-R7,R12"
        BL      mls_lowlevel
        BL      findnextphysl
        BCC     mln_letsdoit            ;  if a ';n' follows, then it's quite ok
        MOV     R12,#0
        MOVCS   R12,#1
        MOVVC   R12,#1                  ;  see mode_cplus for expl.
        CMP     R0,R4
        SUBHI   R0,R0,R5
        SUBS    R0,R0,R3
        SUBGT   R0,R0,R12
        FNRTS


;;;;;;;;;;;;;;;;;;;;;; mode_linenext ///////////////////////////

modesw_linenext
        FNJSR   "R1-R7,R12"
        BL      mls_lowlevel
        BL      findnextphysl

mln_letsdoit
        CMP     R0,R4
        SUBHI   R0,R0,R5
        SUB     R0,R0,R3
        FNRTS


;;;;;;;;;;;;;;;;;;;;;;; mode_plus //////////////////////////////
local_rtwo
        DCD     0

modesw_plus
        FNJSR   "R0,R3-R7,R11,R12"
        MOV     R1,R2
        BL      mode0_linecol
        MOV     R1,R0
        LDR     R0,[R13]
        LDR     R14,[R9,#f_len]
        MOV     R11,R0

        CMP     R1,R14
        FNRTS   GE                      ;  can't go beyond eot
        STR     R2,local_rtwo
        LDR     R3,[R9,#f_ptr]
        LDR     R4,[R9,#f_splito]
        ADD     R4,R4,R3
        LDR     R5,[R9,#f_splits]
        LDR     R6,[R9,#f_len]
        ADD     R6,R6,R3
        ADD     R6,R6,R5
        LDR     R12,[R8,#w_bpl]
        LDRB    R7,[R8,#w_cr]

        ADD     R0,R0,R3
        CMP     R0,R4
        ADDCS   R0,R0,R5
        BL      findnextphysl
        MRS     R12,CPSR
        CMP     R0,R4
        SUBCS   R0,R0,R5
        SUB     R14,R0,R3
        MOV     R0,R11
        MOV     R11,R14                 ;  r11 = offset of next pl.

        ADD     R1,R1,#1
        BL      compute_column
        TST     R12,#Cbit
        BNE     mp_doit
        TST     R12,#Vbit
        FNRTS   NE
        CMP     R1,R11
        MVNGT   R2,#0                   ;  return r2=-1 if onto next physical line
        FNRTS   GT

        LDR     R14,local_rtwo
        CMP     R14,R2
        MVNEQ   R2,#0                   ;  return r2=-1 if onto next physical line
        ADDEQ   R1,R1,#1
        FNRTS

mp_doit                                 ;  not interesting case (\n)
        CMP     R1,R11
        MVNGE   R2,#0                   ;  return r2=-1 if onto next physical line
        FNRTS


;///////////////////////////////////

modesw_cplus
        FNJSR   "R0,R3-R7,R12"

        LDR     R3,[R9,#f_ptr]
        LDR     R4,[R9,#f_splito]
        ADD     R4,R4,R3
        LDR     R5,[R9,#f_splits]
        LDR     R6,[R9,#f_len]
        ADD     R6,R6,R3
        ADD     R6,R6,R5
        LDR     R12,[R8,#w_bpl]
        LDRB    R7,[R8,#w_cr]

        ADD     R0,R0,R3
        CMP     R0,R4
        ADDCS   R0,R0,R5
        BL      findnextphysl
        MOV     R12,#0
        MOVCS   R12,#1                  ;  *not!?* end of physl line.
mcp_doit
        CMP     R0,R4
        SUBCS   R0,R0,R5
        SUB     R0,R0,R3
        SUBS    R1,R0,R12
        MOVMI   R1,#0                   ;  clever trick to make sure the last chr of the file

mcp_all
        FNPULL
        B       compute_column

local_r0
        DCD     0
        DCD     0


;;;;;;;;;;;;;;;;;;;;;; mode_redrawline /////////////////////////

sortoutsoftwrapredraw
call_mode_redrawline                    ;  call sw mode...
modesw_redrawline
        FNJSR   "R9"
        MOV     R0,R7
        PUSH    "R5-R7,R12"
        STR     R6,local_r0             ;  tt
        STR     R11,local_r0 + 4        ;  tt

        LDR     R3,[R9,#f_ptr]
        LDR     R4,[R9,#f_splito]
        ADD     R4,R4,R3
        LDR     R5,[R9,#f_splits]
        LDR     R6,[R9,#f_len]
        ADD     R6,R6,R3
        ADD     R6,R6,R5
        LDR     R12,[R8,#w_bpl]
        LDRB    R7,[R8,#w_cr]

        BL      findnextphysl
        LDR     R1,[R9,#f_splits]       ;  important for later...
        MOV     R2,R6                   ;  R9 is EOF pointer.
        PULL    "R5-R7,R12"

        ADDCS   R11,R11,#1
        PUSH    "R0"                    ;  start of next phys line
        PUSH    "R11"                   ;  start of next phys line
        BCC     mrl_nologline

        SUB     R0,R0,#1
        CMP     R0,R4
        BCC     mrl_nologline
        ADD     R4,R4,R1                ;  WAS R4
        CMP     R0,R4                   ;  WAS R4
        SUBLT   R0,R0,R1                ;  14

mrl_nologline
        MOV     R4,R0
        LDRB    R11,[R8,#w_tabc]

        LDR     R3,[R8,#w_txtw]
        ADD     R3,R6,R3,LSL #1
        CMP     R7,R4                   ;  TT
        BCS     mrl_cc_end              ;  nothing to do (only an eol-char or at eot)
        PUSH    "R12"                   ;  TT
        MOV     R12,#0                  ;  TT
mrl_copychars
        LDRB    R14,[R7],#1             ;  TT
        TEQ     R14,R11                 ;  TT
        ADDNE   R12,R12,#1              ;  TT
        ADDNE   R3,R3,#1
        ADDNE   R6,R6,#1
        BLEQ    mrl_tab                 ;  TT
dontdostoring
        TEQ     R7,R10                  ;  TT
        ADDEQ   R7,R7,R1                ;  TT
        ADDEQ   R5,R5,R1                ;  TT
        MOVEQ   R10,R2                  ;  ptr to eot
        CMP     R7,R4                   ;  TT
        BLT     mrl_copychars           ;  TT

        LDR     R11,local_r0            ;  TT ; to where, exactly?
        LDR     R14,[R8,#w_bpl]         ;  txtw] ; bpl] ; txtw]
        ADD     R11,R11,R14             ;  R11 was R4 (don't corrupt R4)
        MOV     R14,#' '                ;  TT ; scrubber
        MOV     R0,#0                   ;  TT ; background colour 1
        CMP     R6,R11                  ;  TT
        BCS     mrl_nospacestodo
mrl_copyspcs
        STRB    R14,[R6],#1             ;  TT ; scrub anything
        STRB    R0,[R3],#1              ;  TT ; scrub background colour
        CMP     R6,R11                  ;  TT
        BLE     mrl_copyspcs            ;  TT ; One more...
mrl_nospacestodo
                                        ; MOV R14,R12			; hmmm...
        PULL    "R12"
mrl_cc_end
        PULL    "R11"
        PULL    "R0"                    ;  last is dummy
        LDR     R2,local_r0 + 4         ;  TT
        CMP     R11,R2                  ;  R7,R2
        BEQ     mrl_nonewlogl           ;  was 'eq'
        ADD     R7,R7,#1                ;  if new logical line, skip the ';n'.
        TEQ     R7,R10
        ADDEQ   R7,R7,R1
        ADDEQ   R5,R5,R1
mrl_nonewlogl
        FNRTS



mrl_tab                                 ;  returns EQ if only 1 character to do.
        FNJSR   "R0,R4,R5,R7-R9"        ;  e R12 = initial offset set up...
        LDR     R14,[R8,#w_format]
        ANDS    R14,R14,#format_TabDisplayFormat
        BEQ     mrlt_none
        CMP     R14,#(tab_DisplayBar :SHL: tab_DisplayFormat_shift)
                                        ;  note that LineAndBar > Bar
        LDR     R5,[R8,#w_txtw]
        SUB     R5,R3,R5                ;  foreground...
        LDR     R14,[R8,#w_tabstops]
        LDR     R14,[R14,R12,LSL #1]
        ADD     R14,R12,R14,LSR #16
        MOV     R7,#32
        MOV     R8,#32
        MOV     R9,#32                  ;  default and spaces mode
        MOVHI   R7,#'-'                 ;  ']'
        MOVHI   R8,#'-'                 ;  ']'
        MOVHI   R9,R11                  ;  '--------->' mode
        MOVEQ   R7,R11                  ;  '->        ' mode
        SUB     R0,R14,R12              ;  r0 = number to do.
        MOV     R12,R14                 ;  R12 = final column.
        MOV     R14,#1
        MOV     R4,#8
        STRB    R7,[R6],#1
        STRB    R14,[R3],#1             ;  background
        STRB    R4,[R5],#1              ;  foreground
        SUBS    R0,R0,#1
        BEQ     mrlt_onlyone
mrlt_lpa
        STRB    R8,[R6],#1
        STRB    R14,[R3],#1             ;  foreground colour...
        STRB    R4,[R5],#1              ;  background colour...
        SUBS    R0,R0,#1
        BNE     mrlt_lpa
        STRB    R9,[R6,#-1]
mrlt_all
        MOVS    R14,#0
        FNRTS                           ;  looks like R12 is returned...

mrlt_onlyone
        TEQ     R9,R11
        STREQB  R9,[R6,#-1]
        MOVS    R14,#0
        FNRTS                           ;  flags too...

mrlt_none
        MOV     R14,R11
        STRB    R14,[R6],#1
        MOVS    R14,#-1
        FNRTS                           ;  R3,R6 updated.


        END
