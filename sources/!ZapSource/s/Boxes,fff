; Contains code for creating and dealing with clicks and key presses in
; specific template boxes.
; $Id: Boxes,fff,v 2.16 2002/11/12 13:10:30 christian Exp $

	GET	h.ZapHeader
	GET	h.Messages
	GET	h.Strings
	GET	h.CreateFile
	GET	h.CreateWind
	GET	h.Heap
	GET	h.KeyBits
	GET	h.Menus
	GET	h.StartCode
	GET	h.StartUp
	GET	h.Undo
	GET	h.ModeBits
	GET	h.MiniBuff
	GET	h.Cursors
	GET	h.Template
	GET	h.TMTVars
	GET	h.Search
	GET	h.Redraw
	GET	h.Commands
	GET	h.LineEditor
	GET	h.Execute

	IMPORT	err3
	IMPORT	help_string_1
	IMPORT	help_string_2
	IMPORT	process_command
	IMPORT	cln_readc
	EXPORT	template_list
	EXPORT	open_QuitBox
	EXPORT	open_UndoBox
	EXPORT	create_ColourBox
	EXPORT	get_MiniBuf
	EXPORT	get_SaveBox
	EXPORT	get_SaveSelBox
	EXPORT	get_LoadBox
	EXPORT	get_DyingBox
	EXPORT	get_SaveCBox
	EXPORT	get_SaveSCBox
	EXPORT	get_SaveOBox
	EXPORT	get_MacroBox
	EXPORT	get_NextBox
	EXPORT	dispatch_drag
	EXPORT	sub_save_filetype
	EXPORT	redraw_leaf_window
	EXPORT	update_all_save_boxes
	EXPORT	lc_SaveSel_newname
	EXPORT	cw_SaveSelBox
	EXPORT	get_mode_0Box
	EXPORT	cw_Goto_update_update
	EXPORT	ctrllist
	EXPORT	give_dbox_focus
	EXPORT	poll_word_pdriverchanged

	EXPORT	Countmatches
	EXPORT	Dzapbox
	EXPORT	Goto
	EXPORT	Infobox
	EXPORT	Mzapbox
	EXPORT	Printfile
	EXPORT	Quickprint
	EXPORT	Quit
	EXPORT	Replace
	EXPORT	Save
	EXPORT	Savesel
	EXPORT	Searchbuf
	EXPORT	Searchcur
	EXPORT	TotalSel
	EXPORT	WCSel
	EXPORT	WC
	EXPORT	Movebox
	EXPORT	Clonebox

; list template offsets $t=title $f=flags $c=create sub $i=interprate sub
; $ll=label

	MACRO
$la	FNtem $t,$f,$c,$i,$ll
$la	= "$t",0
	ALIGN
	DCD $f
	DCD $c
	DCD $i
	[ "$ll"<>""
$ll	* menu_num_off
	]
menu_num_off SETA menu_num_off + 1
	MEND

; find the address of template offset $b and put it in register $a
; the template list entries look something like:
;  00 - address of window defn
;  04 - flags (see below)
;  08 - window handle
;  0C - window off (?) - presumably temp space
;  10 - file off (?) - ditto
;  14 - create sub address
;  18 - exec sub address
;  1C - pointer to template name
; See s.Template

	MACRO
$la	FNind $a,$b,$cc
$la	LDR$cc $a,[R12,#tem_list]	; address of the template list
	ADD$cc $a,$a,#$b<<5		; 32 bytes each entry
	MEND

	MACRO
$la	FNindw $w,$a,$b,$cc
$la	LDR$cc $a,[R12,#tem_list]	; address of the template list
	LDR$cc $w,[$a,#$b<<5]!		; 32 bytes each entry; w = &defn
	MEND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; List of valid boxes and their routines		;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; template name,default flags,create offset,click offset,handle
; flags
; b0 open as part of a menu (I think - s.Template:close_leaf_window)
; b1-MZap?
; b2=Up/down cause update...?
; b3 = kill state
; b4 delete swap window on dying
; b5 delete when get a chance flag (don't delete?)
; b7 unorthodox cursor keys...
; b8 do give window the focus... /tab/u/d?
; b9 don't place caret in window bg
;    (but allow window's click handler to if it wants)
; b10 adjuct-clicks gain the caret.
; b11 interpret Tab/sTab as down/up
; b15 => window open, as best we can determine (sja, 1999-10-07)
;
; See the better documentation in s.Template

template_list
 GBLA menu_num_off
menu_num_off SETA 0
 FNtem "CloneBox",0,cw_CloneBox,lc_CloneBox,t_CloneBox
 FNtem "CloneCrBox",0,0,lc_CloneCrBox,t_CloneCrBox
 FNtem "ColourBox",&800,cw_ColourBox,lc_ColourBox,t_ColourBox
 FNtem "DyingBox",&904,cw_DyingBox,lc_DyingBox,t_DyingBox
 FNtem "DzapBox",&800,cw_DzapBox,lc_DzapBox,t_DzapBox
 FNtem "GotoBox",&84,cw_GotoBox,lc_GotoBox,t_GotoBox
 FNtem "InfoBox",0,cw_InfoBox,lc_InfoBox,t_InfoBox
 FNtem "LoadBox",&100,cw_LoadBox,lc_LoadBox,t_LoadBox ; was 0
 FNtem "MacroBox",&806,0,0,t_MacroBox
 FNtem "Main",6,0,0,t_mode_0Box
 FNtem "MiniBuf",&200,cw_MiniBuf,lc_MiniBuf,t_MiniBuf
 FNtem "MoveBox",&500,0,lc_MoveBox,t_MoveBox
 FNtem "MzapBox",&806,cw_MzapBox,lc_MzapBox,t_MzapBox
 FNtem "NextBox",&500,0,lc_NextBox,t_NextBox ; was 0,0 :?
 FNtem "PrintBox",&800,cw_PrintBox,lc_PrintBox,t_PrintBox
 FNtem "QuickBox",&800,cw_QuickBox,lc_QuickBox,t_QuickBox
 FNtem "QuitBox",&500,0,lc_QuitBox,t_QuitBox ; was &400
 FNtem "ReplaceBox",&884,cw_ReplaceBox,lc_ReplaceBox,t_ReplaceBox
 FNtem "SaveBox",&804,cw_SaveBox,lc_SaveBox,t_SaveBox
 FNtem "SaveCBox",&500,cw_SaveCBox,lc_SaveCBox,t_SaveCBox
 FNtem "SaveOBox",&500,cw_SaveOBox,lc_SaveOBox,t_SaveOBox
 FNtem "SaveSCBox",&500,cw_SaveSCBox,lc_SaveSCBox,t_SaveSCBox
 FNtem "SaveSelBox",&C04,cw_SaveSelBox,lc_SaveSelBox,t_SaveSelBox
 FNtem "SearchBox",&84,cw_SearchBox,lc_SearchBox,t_SearchBox
 FNtem "UndoBox",&500,0,lc_UndoBox,t_UndoBox
 FNtem "WCBox",0,cw_WCBox,lc_WCBox,t_WCBox
 DCD 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Entry/exit conditions					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Create window sub called (from leaf_create) with:
; ;E R6=window def R7=window index R8/R9=window or 0
; ;X Can corrupt R0-R11 #

; Interpret window sub called (from leaf click) with:
; ;E R2=xos R3=yos R4=mouse buttons R5=icon handle
;    R6=window def R7=window index R8/R9=window or 0
;    Return address on stack
; ;X Exit by calling c_ret (don't close) s_ret (do close the window).
;    Can corrupt R0-R11
;    Mouse buttons b0=adjust b1=menu b2=select *16=drag
;    Return in an icon is passed on by simulating adjust (b1 of R4)
;    Arrow key movement is passed on by setting b31 of R4
;    Control keys are passed on by R5=-key value
;     key values are 9 = Tab and 'A' = 'a' or ^A or 'A'. etc
;    Note that if VS, then it doesn't matter whether you use c_ret or s_ret

c_ret
 ADDVCS R0,R0,#0
;c_ret_error
 LDMFD R13!,{PC}		; clc and return
s_ret
 SUBVCS R0,R0,#0
 LDMFD R13!,{PC}		; sec and return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Info box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

cw_InfoBox
 FNJSR
 MOV R5,#4
 BL icon_getind			; R0=address of icon data
 MOV R2,R0			; dest
 LDR R1,ext1$l
 LDR R3,ext2$l
 SUB R3,R3,R1			; length
 FNLDR R0,env_modstart
 ADD R1,R1,R0			; source
 ADD R4,R2,R3
 SWI XZapRedraw_MoveBytes	; BL move_bytes
 MOV R0,#0
 STRB R0,[R4]
 FNRTS
ext1$l DCD help_string_1
ext2$l DCD help_string_2

lc_InfoBox
 TEQ R5,#9
 TEQNE R5,#10
 BEQ web$l
 TEQ R5,#3
 BNE c_ret
 BL show_authors
 B s_ret
web$l
 TEQ R5,#9
 ADREQ R0,www$l
 ADRNE R0,ftp$l
	PUSH "R0"
	SWI 256+4
	SWI 256+26
	SWI 2
	PULL "R0"
 ORR R0,R0,#command_DontLearn
 BL command_string ; just hope that there aren't any colons :-)
 ;CMP R0,R0 ; force VC
 B s_ret
www$l = "SendURLString (http://zap.tartarus.org/)",0
ftp$l = "SendURLString (ftp://zap.tartarus.org/)",0
 ALIGN

 DCD 7+c_CanCreateSubMenu
Infobox
 MOV R0,#t_InfoBox
 B open_leaf_com

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Save box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R7 = um, window number... R8(not strictly needed)/R9

 LOCAL

cw_DyingBox
cw_SaveBox
 TEQ R9,#0			; SJA (was R8)
 MOVEQ PC,R14			; file has been discarded (after save)
 FNJSR

 ; CMP R5,#&FF			; not in new type window.
 ; LDR R0,[R9,#f_load]		; new file type
 ; BL calc_ftype		; CS and R0=filetype/CC and load
 ; ; BCC
 ; FNLDR R1,wimp_flagbits
 ; ORR R0,R1,R0,LSL#4
 ; FNSTR R0,wimp_flagbits,NE

 ;FNLDR R0,wimp_flagbits
 ;TST R0,#1
 ;BNE selectionfn		; one way to get there...
 CMP R8,#0
 BLT selectionfn		; the other... (was LE...)
 LDR R0,[R9,#f_name]
; MOV R1,#&100			;-(
; BL heap_ensure			; make room for new name
; FNRTS VS			; copy in file length
; STR R0,[R9,#f_name]
 CMP R5,#&FF			; not in new type window.
 MOV R5,#0
 BLNE icon_bufferstr		; copy in filename
 MOV R5,#13
 BL icon_getind
 MOVVC R1,R0
 LDRVC R0,[R9,#f_len]
 MOVVC R2,#16
 SWIVC XOS_ConvertSpacedCardinal4
 BLVC cnvrtspcsinstr
 BL icon_redraw			; redraw if eg recreated by menu
 LDRVC R0,[R9,#f_len]
 MOVVC R5,#15
 BLVC icon_bufferhex
; FNRTS VS
; copy in file length
back_selectionfn
 FNRTS VS			; file length in hex

; MOV R5,#0
; BL icon_getind			; name
; BL str_len
; CMP R0,#11
; MOV R0,#8
; MOV R1,#8
; MOVCS R1,#0
; MOV R5,#0
; BL icon_alter

 LDR R0,[R9,#f_load]
 BL calc_ftype			; CS and R0=filetype/CC and load
 BCS typed$l			; file type
 ADR R0,load$l
 MOV R5,#8
 BL icon_buffertoken		; load
 ADR R0,exec$l
 MOV R5,#9
 BL icon_buffertoken		; exec
 MOV R5,#6			; take info from icon 6!?
 BL lc_read
 MOV R1,#&F000
; ORR R1,R1,#&F0000000
; AND R1,R0,R1			; writeable white background
 BL cols$l
 LDR R0,[R9,#f_load]
 MOV R5,#2
 BL icon_bufferhex		; load
 LDRVC R0,[R9,#f_exec]
 MOVVC R5,#1
 BLVC icon_bufferhex
 MOVVC R5,#6			; &FFF
 BLVC icon_clear
 MOVVC R5,#3
 BLVC icon_clear			; clear type icons
 MOVVC R5,#5
 BLVC icon_getind
 MOVVC R1,R0
 LDRVC R2,[R9,#f_load]
 LDRVC R3,[R9,#f_exec]
 MOVVC R0,#-1
 BLVC get_file_sprite		; and set sprite name
 BLVC icon_redraw
 FNRTS
typed$l
 MOV R4,R0			; save file type
 ADR R0,date$l
 MOV R5,#8
 BL icon_buffertoken		; date
 ADRVC R0,time$l
 MOVVC R5,#9
 BLVC icon_buffertoken		; time
 MOVVC R1,#&10000000		; never(?!) grey background
 BLVC cols$l
 MOVVC R5,#6
 BLVC icon_getind
 FNRTS VS
 MOV R1,R0
 MOV R2,#8
 MOV R0,R4
 CMP R0,#&1000
 SWICS XOS_ConvertHex6		; get hex of filetype
 SWICC XOS_ConvertHex4		; get hex of filetype
; FNRTS VS
 MOVVC R1,#'&'
 STRVCB R1,[R0]			; & at start of buffer
 BLVC icon_redraw
 MOVVC R5,#5
 BLVC icon_getind
 MOVVC R1,R0
 MOVVC R0,R4
 BLVC invisibleandsquashed
 BLVC get_file_sprite		; copy in sprite name
 BLVC icon_redraw
 MOVVC R5,#3
 BLVC icon_getind
 MOVVC R1,R0
 MOVVC R0,R4
 BLVC get_ftype			; set up file type name
 BLVC icon_redraw
 FNLDR R4,wimp_block,VC		; use for time
 LDRVC R0,[R9,#f_exec]
 STRVC R0,[R4,#20]!		; icon_redraw uses wimp_block
 LDRVC R0,[R9,#f_load]
 STRVC R0,[R4,#4]		; five byte time block
 MOVVC R5,#2
 BLVC icon_getind
 MOVVC R1,R0			; buffer
 MOVVC R2,#16
 ADRVC R3,dformat$l
 MOVVC R0,R4
 SWIVC XOS_ConvertDateAndTime
 BLVC icon_redraw
 MOVVC R5,#1
 BLVC icon_getind
 MOVVC R1,R0
 MOVVC R2,#16
 MOVVC R0,R4
 ADRVC R3,tformat$l
 SWIVC XOS_ConvertDateAndTime
 BLVC icon_redraw

; MOVVC R5,#0
; BLVC setup_icon_callback		; test...

 ;MOVVC R5,#0
 ;BLVC icon_redraw

 FNRTS
load$l = "zap_i_l",0
exec$l = "zap_i_x",0
date$l = "zap_i_d",0
time$l = "zap_i_t",0
dformat$l = "%dy-%m3-%ce%yr",0
tformat$l FNS ("%24:%mi:%se")
cols$l				; R1=mask set icon colours for icons 1,2
 FNJSR
 MOV R0,#&F0000000
 ORR R0,R0,#&0F000		; mask
 MOV R5,#2
 BL icon_alter
 MOVVC R0,#&F0000000
 ORRVC R0,R0,#&0F000
 MOVVC R5,#1
 BLVC icon_alter
 FNRTS

invisibleandsquashed		; this routine is currently redundant...
 CMP R0,#&FE000			; invisible
 MOVCC PC,R14
 CMP R0,#&FF000			; invisible
 MOVCS R0,R0,LSL #20
 MOVCS R0,R0,LSR #20
 MOVCS PC,R14
 CMP R0,#&FE000			; invisible
 MOVCS R0,#&F00
 ORRCS R0,R0,#&CA
 MOV PC,R14

 LOCAL

cnvrtspcsinstr
 FNJSR
a$l
 LDRB R14,[R0],#1
 TEQ R14,#&20
 MOVEQ R14,#','
 STREQB R14,[R0,#-1]		; replace spaces with commas
 CMP R14,#&20
 BCS a$l
 FNRTS

 LOCAL

selectionfn
 PUSH "R8"
 ;SWI &20107
 MOV R5,#0
 BL icon_getind
 MOV R1,R0
 LDRB R0,[R1]
 CMP R0,#&20
; BCS continue_selectionfn	; name already there
 ADRCC R2,cw_s0
 BLCC strcopy			; copy in default name
continue_selectionfn
 BLVC get_selection
 MOVVC R8,R2
 MOVVC R5,#13
 BLVC icon_getind
 MOVVC R1,R0
 MOVVC R0,R8
 MOVVC R2,#16
 SWIVC XOS_ConvertSpacedCardinal4	; copy in file length
; BVS beatarapidexit
 BLVC cnvrtspcsinstr
 MOVVC R0,R8
 MOVVC R5,#15
 BLVC icon_bufferhex		; file length in hex
beatarapidexit
 PULL "R8"
 B back_selectionfn

cw_s0
 FNS ("Selection")

 LOCAL

lc_SaveBox
 TEQ R9,#0			; SJA (was R8)
 BEQ c_ret			; file has been discarded (after save)
 BL converttoarrowiftab
 CMP R5,#&180
 BGE passonafnkeythencret
 ADR R0,keys$l
 BL key_to_click
 TST R4,#2
 BNE lc_Save_typemenu
 TEQ R5,#5
 BEQ lc_Save_dragsprite
 TEQ R5,#7
 BEQ lc_Dying_cancel
 TEQ R5,#10
 BEQ lc_Save_typemenu
 TEQ R5,#11
 BEQ lc_Save_newname
 TST R4,#1
 BEQ c_ret
 CMP R5,#1
 BEQ lc_Save_newexec
 BLO lc_Save_newname_ret ; 0
 CMP R5,#3
 BEQ lc_Save_newtypes
 BLO lc_Save_newload ; 2
 TEQ R5,#6
 BEQ lc_Save_newtypeh
 B c_ret
keys$l = 'M',11,0
 ALIGN

converttoarrowiftab
 SUB R0,R5,#&100
 TEQ R0,#&8A ; TAB
 TEQNE R0,#&9A ; sTAB
 MOVNE PC,R14
 TEQ R0,#&8A
 MOVEQ R5,#&8E
 MOVNE R5,#&8F
 ADD R5,R5,#&100
 ; fall through

passonafnkeythencret
 BL pass_on_a_fn_key
 B c_ret

 LOCAL

recreate_the_leaf_window
 FNJSR "R0-R9"
 CMP R8,#0
 MOVMI R0,#1
 MOVPL R0,#0
 FNSTR R0,wimp_flagbits		; *very* temporary
 LDR R0,[R7,#4]			; flags
 TST R0,#1
 FNRTS NE
 FNLDR R1,wimp_block
 LDR R0,[R7,#8]			; window handle
 STR R0,[R1]
 SWI XWimp_GetWindowState
 MVNVC R1,#0
 SWIVC XWimp_CreateMenu		; close the menu
 FNLDR R1,wimp_block,VC
 SWIVC XWimp_OpenWindow		; reopen the window
 FNRTS VS
 LDR R0,[R7,#4]
 ORR R0,R0,#1
 STR R0,[R7,#4]			; update flags to no longer window opened
 LDR R6,[R7]
 LDR R5,[R6,#84]		; number of icons
 SUBS R5,R5,#1			; last icon
 MOV R0,#1			; increase
 BL leaf_next_icon
 FNRTS

lc_SaveSel_typemenu
 MOV R8,#-1

lc_Dying_typemenu
lc_Save_typemenu
 BL recreate_the_leaf_window
 BVS c_ret
lc10
 MOV R0,#2			; second menu
 BL read_menu_handle		; create the file type menu
; BVS c_ret
; ADDVC R2,R2,#16		; adjust the x for window menus
; BNE a$l
; SUB R2,R2,#96			; adjust the x for main menu
; MOV R0,R1
; BL count_menu_size		; R0=menu height
; ADD R3,R0,#96			; y opening offset
;a$l
; BL open_menu
 BLVC create_menu			; open the file type menu
 B c_ret

lc_Save_typeupdate
 ; FNJSR
 BL modify_types_all_save
 BL update_all_save_boxes ; leaf_update
 B c_ret ;  FNRTS

; ADD R4,R6,#88+16
; LDR R2,[R4,#32]		; icon 1 flags
; LDR R3,[R4,#64]		; icon 2 flags
; BL leaf_update			; update the contents
; BVS c_ret
; LDR R0,[R4,#32]
; EOR R2,R2,R0
; LDR R0,[R4,#64]
; EOR R3,R3,R0
; MOV R0,#0
; MOV R1,R2
; MOV R5,#1
; BL icon_alter
; BVS c_ret
; MOV R0,#0
; MOV R1,R3
; MOV R5,#2
; BL icon_alter
; BVS c_ret
; MOV R5,#8
; BL icon_redraw
; BVS c_ret
; MOV R5,#9
; BL icon_redraw
; BVS c_ret
; BL leaf_update
; PUSH "R6,R7"
; LDR R6,[R7]			; window data
; BL conv_index_offs
; FNLDR R1,wimp_block
; ;MOV R0,#4			; icon number
; ;STR R0,[R1,#4]
; LDR R0,[R7,#8]			; window handle
; STR R0,[R1]
; ;SWI XWimp_GetWindowState
; ;MVN R0,#0
; ;STR R0,[R1]
; ;SWI XWimp_ForceRedraw		; redraw window
; BL redraw_request
; PULL "R6,R7"
; B c_ret

modify_types_all_save
 FNJSR
 BL get_SaveSelBox
 BL to_cw_SaveBox
 BL get_SaveBox
 BL to_cw_SaveBox
 BL get_DyingBox
 BL to_cw_SaveBox
 FNRTS

to_cw_SaveBox
 MOV R7,R1
 LDR R0,[R7,#8]			; window handle
 MOV R5,#&FF
 CMP R0,#0
 ;MOV R5,#&FF			; not in new type window.
 BLPL cw_SaveBox
 FNRTS

lc_Save_newname_ret
	TST	R4,#4			; ignore if (s)Tab
	BNE	c_ret
lc_Save_newname
 MOV R5,#11
 MOV R2,#&FF00
 BL slab_icon_in_temporarily
 MOV R5,#0
 BL icon_getind
 BLVC save_from_leaf
 BVS reporterr$l
 BL leaf_update
 B s_ret

reporterr$l
 MOV R11,R0
 BL leaf_update
;
 MOV R5,#11
 MOV R2,#&00
 BL slab_icon_in_temporarily
; SWI &107			; fires OK...
;
 MOV R0,R11
 FNRTV

lc_SaveSel_newexec
 MOV R8,#-1

lc_Dying_newexec
lc_Save_newexec
 MOV R5,#1
 BL lc_buffernum
 STRVC R0,[R9,#f_exec]
 BLVC update_all_save_boxes ; leaf_update
 B c_ret

lc_SaveSel_newload
 MOV R8,#-1

lc_Dying_newload
lc_Save_newload
 MOV R5,#2
 BL lc_buffernum
 STRVC R0,[R9,#f_load]
 BLVC update_all_save_boxes ; leaf_update
 B c_ret

lc_SaveSel_newtypes
 MOV R8,#-1

lc_Dying_newtypes
lc_Save_newtypes
 MOV R5,#3
 BL icon_getind
 LDRB R14,[R0]
 CMP R14,#&20
 BCC lc13			; null=switch to load/exec
 MOV R1,R0
 MOV R0,#31
 SWI XOS_FSControl
 BVS c_ret
 MOV R0,R2
lc_Save_newtype
 BL checkseeifFTEloaded
 MOV R0,R0,LSL#12		; FTE aware !!!!!!!!!!!!!!!
 MOV R2,R0,LSR#12		; get bottom 12 bits FTE aware !!!!!!!!!!
 MOVVS R2,R2,LSL#20
 MOVVS R2,R2,LSR#20
 CMP R2,#&1000
 EORCS R2,R2,#&000FF000
; MOV R0,R0,LSL#20
; MOV R2,R0,LSR#20		; get bottom 12 bits
 LDR R0,[R9,#f_load]
 BL calc_ftype
 BCC lc12			; not already typed
 LDRB R0,[R9,#f_load]
 CMP R2,#&1000
 ORR   R0,R0,#&F0000000
 ORRCC R0,R0,#&0FF00000
 ORR R2,R0,R2,LSL#8
 STR R2,[R9,#f_load]
 BL update_all_save_boxes ; leaf_update
 B c_ret
lc12
 CMP R2,#&1000			; FTE
 MOV	  R0,#&F0000000
 ORRCC R0,R0,#&0FF00000		; FTE
; MOV R0, #&FF000000
; ORR R0,R0,#&F00000
 ORR R0,R0,R2,LSL#8
 STR R0,[R9,#f_load]
 MOV R0,#0
 STR R0,[R9,#f_exec]
 B lc_Save_typeupdate
lc13
 MOV R0,#0
 STR R0,[R9,#f_load]
 STR R0,[R9,#f_exec]
 B lc_Save_typeupdate

lc_SaveSel_newtypeh
 MOV R8,#-1

lc_Dying_newtypeh
lc_Save_newtypeh
 MOV R5,#6
 BL icon_getind
 LDRB R14,[R0]
 CMP R14,#&20
 BCC lc13			; null=switch to load/exec
 MOV R5,#6
 BL lc_buffernum
 BVS c_ret
 B lc_Save_newtype

lc_SaveSel_dragsprite
lc_Dying_dragsprite
lc_Save_dragsprite
 TST R4,#&50			; if a drag mouse code then...
 MOVNE R0,R4,LSR#4
 FNSTR R0,wimp_menub,NE		; save button type
 BLNE initiate_drag
 B c_ret

drag_SaveBox
drag_DyingBox
 FNJSR
 BL conv_index_offs		; get R8/R9
 TEQ R9,#0			; SJA (was R8)
 BLNE drag_Box
 FNRTS

get_SaveBox
 FNind R1,t_SaveBox
 MOV PC,R14

; Menu entry to set savebox filetype off filetype menu

sub_save_filetype
 FNJSR				; R1=index=file type
 LDRB R2,[R9,#f_load]
 CMP R1,#&1000			; FTE
 ORR   R2,R2,#&F0000000
 ORRCC R2,R2,#&0FF00000		; FTE
; ORR R2,R2,#&FF000000
; ORR R2,R2,#&00F00000
 ORR R2,R2,R1,LSL#8
 STR R2,[R9,#f_load]
 FNind R7,t_SaveBox
 BL leaf_update
 FNRTS

 DCD 1+c_CanCreateSubMenu+c_MovesInputOrKeymap
Save
 MOV R0,#t_SaveBox	       ; save box
 B open_leaf_com
;
perform_an_update_here
 FNJSR "R6,R7"
 MOV R7,R1
 LDR R0,[R7,#8]			; window handle
 MOV R5,#&FF
 CMP R0,#0
 FNRTS MI
 BL leaf_update			; was BLPL - dunno what's wrong with this...
 LDR R6,[R7]			; window data
 BL conv_index_offs
 FNLDR R1,wimp_block,VC
 LDRVC R0,[R7,#8]		; window handle
 STRVC R0,[R1]
 BLVC redraw_request
 FNRTS

update_all_save_boxes
 FNJSR "R7"
 BL get_SaveSelBox
 BL perform_an_update_here
 BL get_SaveBox
 BL perform_an_update_here
 BL get_DyingBox
 BL perform_an_update_here
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Quit box					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lc_QuitBox
 ADR R0,keys$l
 BL key_to_click
 SUB R5,R5,#2
 CMP R5,#3
 ADDCC PC,PC,R5,LSL #2 ; WAS LO
 B c_ret
 B lc_Quit_quit
 B lc_Dying_cancel
 B lc_quit_tofront
keys$l = 'Q',2,'M',2,'C',3,'T',4,'F',4,0
 ALIGN

lc_Quit_quit
 FNLDR R0,opt_switches
 TST R0,#switch_QuitMeansShutdown
 BEQ lc_q1			; just quit this task
 FNLDR R1,wimp_block
 SWI XWimp_GetCaretPosition
 BVS c_ret
 MOV R0,#&1FC
 STR R0,[R1,#24]		; set up a keys pressed block
 MOV R0,#8
 FNLDR R2,wimp_quitsender
 SWI XWimp_SendMessage		; send the scF12
 BVS c_ret
lc_q1
 MOV R0,#0
 FNLDR R1,wimp_buffer
 SWI XWimp_Poll			; let message go/button pop up :-/
 BVS c_ret
 B main_quit			; finish

lc_quit_tofront
 ADR R10,lc_OpeningSubroutine2a
 BL do_allfiles
 B s_ret

 ;FNcall Zap_AllWindow
 ;BL lc_simulate_select_to_close ; Make sure replace dbox closes (TT).
 ;B s_ret

lc_OpeningSubroutine2a
 FNJSR
 LDR R0,[R9,#f_flags]
 TST R0,#flags_Modified ; MODIFIED
 FNRTS EQ
 MOV R0,#0
 STR R0,local_wcntr
 ADR R10,lc_OpeningSubroutine2
 BL do_eachwindow
 LDR R14,local_wcntr
 CMP R14,#0
 MOVEQ R8,#0
 BLEQ new_view
 FNRTS

local_wcntr
 DCD 0

lc_OpeningSubroutine2
 FNJSR
 MOVS R1,R8
 FNRTS LE			; ???
 MOV R0,#3
 BL open_a_window
 BL find_input
 BL put_caret
 MVN R14,#0
 STR R14,local_wcntr
 FNRTS

open_QuitBox
 FNJSR "R7-R9"
 FNind R7,t_QuitBox
 MOV R8,#0
 MOV R9,#0
 BL create_open_leaf
 FNRTS

 DCD 7+c_MovesInputOrKeymap
Quit
 FNJSR
 BL test_quit_ok
 BCC main_quit
 FNLDR R0,opt_switches
 BIC R0,R0,#switch_QuitMeansShutdown	; ensure only this task is quit
 FNSTR R0,opt_switches
 FNind R7,t_QuitBox
 BL create_open_leaf
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Dying box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; cw_DyingBox
; FNJSR
; MOV R8,#-1
; B cw_SaveBox
 ;FNind R7,t_DyingBox
 ;LDR R6,[R7]
 ;LDR R0,[R7,#8]
 ;MOV R1,#12
 ;MOV R2,#-1
 ;MOV R3,#-1
 ;MVN R4,#0
 ;MVN R5,#0
 ;SWI XWimp_SetCaretPosition
 ;FNRTS
; FNJSR
; MOV R0,#0
; STR R0,[R7,#4]			; zero flags
; LDR R0,[R9,#f_name]
; MOV R1,#0
; BL cw_bufferstr		; copy (as its address may change)
; FNRTS			; ?????????????????????

 LOCAL

lc_DyingBox
 TEQ R9,#0			; SJA (was R8)
 BEQ c_ret			; file has been discarded (after save)
; SWI &107			; gets here!
 SUB R14,R5,#&100
 CMP R14,#&8A
 CMPNE R14,#&8E
 CMPNE R14,#&8F
 BEQ lc_Dying_tab
 CMP R14,#&80
 BGE passonafnkeythencret
 ADR R0,keys$l
 BL key_to_click
 TST R4,#2
 BNE lc_Dying_typemenu
 TEQ R5,#5
 BEQ lc_Dying_dragsprite
 TEQ R5,#10
 BEQ lc_Dying_typemenu
 TEQ R5,#7 ; cancel
 BEQ lc_Dying_cancel
 TEQ R5,#11
 BEQ lc_Dying_newname
 TEQ R5,#12 ; discard file.
 BEQ lc_Dying_discard
 TEQ R5,#14 ; to save box???
 BEQ lc_Dying_save
 TEQ R5,#16
 BEQ lc_Dying_newnameOK
 TST R4,#1			; a mouse click...?
 BEQ c_ret
 CMP R5,#1
 BLO lc_Dying_newname_ret
 BEQ lc_Dying_newexec
 CMP R5,#3
 BLO lc_Dying_newload
 BEQ lc_Dying_newtypes
 TEQ R5,#6
 BEQ lc_Dying_newtypeh
 B c_ret
keys$l = 'S',16,'D',12,'C',7,'M',11,0
 ALIGN

 LOCAL

lc_Dying_cancel
 BL lc_simulate_select_to_close ; Make sure replace dbox closes (TT).
 B s_ret

lc_Dying_newnameOK
 PUSH "R7-R12"

 MOV R5,#11			; !??
 MOV R2,#&FF00
 BL slab_icon_in_temporarily
 MOVVC R5,#0
 BLVC icon_getind
 BLVC save_from_leaf		; save as normal...
 PULL "R7-R12"
 BVS soonto_c_ret
 MOV R5,#11			; !??
 MOV R2,#&00
 BL slab_icon_in_temporarily
; BVS c_ret
 CMP R0,#0
 BEQ lc_Dying_discard

 FNind R7,t_DyingBox
 LDR R0,[R7,#4]			; ???
 BIC R0,R0,#3<<3		; copy the discard afterwards bit
 STR R0,[R7,#4]

 B c_ret

soonto_c_ret
 MOV R11,R0
 MOV R5,#11			; !??
 MOV R2,#&00
 BL slab_icon_in_temporarily
 MOV R0,R11			; preserve error pointer...
 FNRTV

 ;BL leaf_update
 ;BL lc_simulate_select_to_close ; Make sure replace dbox closes (TT).
 ;B c_ret

lc_Dying_tab
 BL leaf_next_icon
 B c_ret

lc_Dying_newname_ret
	TST	R4,#4			; ignore if (s)Tab
	BNE	c_ret
lc_Dying_newname
 FNind R7,t_DyingBox
 LDR R0,[R7,#4]			; flags
 ;ORR R0,R0,#1<<3		; kill file afterwards
 ;TST R1,#1<<4
 ;BICEQ R0,R0,#1<<4
 ;ORRNE R0,R0,#1<<4		; copy the discard afterwards bit
 BIC R0,R0,#3<<3		; copy the discard afterwards bit
 STR R0,[R7,#4]

 MOV R5,#11
 MOV R2,#&FF00
 BL slab_icon_in_temporarily
in_Dying_newname
 MOV R5,#0
 BL icon_getind
 BL save_from_leaf
 BVS soonto_c_ret ; c_ret
 CMP R0,#0
 BEQ lc_Dying_discard

 FNind R7,t_DyingBox
 LDR R0,[R7,#4]
 BIC R0,R0,#3<<3		; copy the discard afterwards bit
 STR R0,[R7,#4]

 B c_ret

; other lc_Dying_* elsewhere

lc_Dying_save
 LDR R1,[R7,#4]			; get dying box flags
 FNind R7,t_SaveBox
 BL create_open_leaf
 BVS c_ret
 LDR R0,[R7,#4]			; flags
 ORR R0,R0,#1<<3		; kill file afterwards
 TST R1,#1<<4
 BICEQ R0,R0,#1<<4
 ORRNE R0,R0,#1<<4		; copy the discard afterwards bit
 STR R0,[R7,#4]
 B s_ret

lc_Dying_discard
 BL delete_swap_window		; swap window before deleting?
 BVS c_ret
; SWI &107			; DEBUG... GETS HERE...
 BL discard_file		; discard file
 B s_ret

get_DyingBox
 FNind R1,t_DyingBox
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Save sel box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

cw_SaveSelBox
 FNJSR "R8"
 MOV R8,#-1
 BL cw_SaveBox
 FNRTS

 LOCAL

lc_SaveSelBox
 TEQ R9,#0			; SJA (was R8)
 BEQ c_ret			; file has been discarded (after save)
 CMP R5,#&180
 BGE passonafnkeythencret
 ADR R0,keys$l
 BL key_to_click
 TST R4,#2
 BNE lc_SaveSel_typemenu
 TEQ R5,#5
 BEQ lc_SaveSel_dragsprite
 TEQ R5,#11
 BEQ lc_SaveSel_newname
 TEQ R5,#10
 BEQ lc_SaveSel_typemenu
 TEQ R5,#7 ; cancel
 BEQ lc_Dying_cancel
 TST R4,#1
 BEQ c_ret
 CMP R5,#1
 BLO lc_SaveSel_newname_ret
 BEQ lc_SaveSel_newexec
 CMP R5,#3
 BLO lc_SaveSel_newload
 BEQ lc_SaveSel_newtypes
 TEQ R5,#6
 BEQ lc_SaveSel_newtypeh
 B c_ret
keys$l = 'M',11,0
 ALIGN

 LOCAL

lc_SaveSel_newname_ret
	TST	R4,#4			; ignore if (s)Tab
	BNE	c_ret
lc_SaveSel_newname
 MOV R5,#11
 MOV R2,#&FF00
 BL slab_icon_in_temporarily
 MOV R5,#0
 BL icon_getind
 MOV R8,#-1			; save selection
 BL save_from_leaf
 BVS soonto_c_ret ; c_ret
 BL leaf_update
 B s_ret

; other lc_SaveSel_* elsewhere

drag_SaveSelBox
 FNJSR
 MOV R8,#0			; selection
 BL drag_Box
 FNRTS

get_SaveSelBox
 FNind R1,t_SaveSelBox
 MOV PC,R14

 DCD 7+c_CanCreateSubMenu+c_TickableMenuEntry+c_MovesInputOrKeymap
Savesel
 FNJSR
 MOV R4,R8
 MOV R3,R2
 BL shade_no_sel
 BCS savesel_nosel
 MOV R2,R3
 MOV R0,#t_SaveSelBox
 BL open_leaf_com
 ;SWI &107
 FNRTS

savesel_nosel
 TEQ R3,#15
 TEQNE R3,#16
 FNRTS EQ
 CMP R4,#0
 BEQ abeepandexit
 MOV R8,R4
 ADR R0,saveselnoselmessage
 MOV R1,#warn_UseMessageTrans
 BL warn_user
 FNRTS

abeepandexit
 BL Beep
 FNRTS

saveselnoselmessage
 FNS ("zap_NoSelToSave")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Goto box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

cw_GotoBox
 FNJSR

 FNLDR R14,opt_switches
 TST R14,#switch_ClearSearchWindow
 MOVNE R0,#0			; clear the buffer instead
 MOVNE R5,#11
 BLNE icon_bufferstr		; insert the string and update

 BLVC resethistorypositions
 BLVC find_caret_pos
 FNRTS VS
 TEQ R10,#0
 BNE caret$l			; a caret in this window
 LDR R3,[R8,#w_scrolly]
 PUSH "R6"
 BL ccd_yos_ypair
 TEQ R6,#0
 ADDNE R3,R3,#1			; R3=first wholly visible row
 PULL "R6"
 MOV R0,R3
 BL cln_phy
 MOVVC R2,R1
 MOVVC R4,R0			; R2=log R3=phy R4=off
 BVC update$l
 FNRTS
caret$l
 LDR R4,[R10,#c_off]
 MOV R0,R4
 BL cln_off
; FNRTS VS
 MOVVC R3,R0			; set up values
update$l
 BLVC to_cw_Goto_update		; reflect status
 BLVC cw_Goto_update2
 BLVC cw_Goto_update3
 FNRTS

 LOCAL

to_cw_Goto_update
 FNJSR
 FNindw R6,R7,t_GotoBox
 LDR R4,[R10,#c_off]
 MOV R0,R4
 BL cln_off
 MOVVC R3,R0			; set up values
 BLVC cw_Goto_update
 FNRTS

cw_Goto_update_update
 FNJSR "R0-R7,R10"
 MOV R10,R8
 FNindw R6,R7,t_GotoBox
 BL conv_index_offs
 BVS errorless$l
 CMP R8,R10			; comparing R8s.
 FNRTS NE

 FNLDR R10,car_cursor
 FNLDR R1,wimp_block
 LDR R0,[R7,#8]			; window handle
 STR R0,[R1]
 SWI XWimp_GetWindowState
 BVS errorless$l
 LDR R14,[R1,#32]
 TST R14,#&10000		; window open...?
 FNRTS EQ

 LDR R4,[R10,#c_off]
	LDR	R3,[R10,#c_line]
	MOV	R0,R3
	BL	cln_phy
	MOVVC	R2,R1
	BLVC	cw_Goto_update
errorless$l
 SUBS R14,R14,R14
 FNRTS

;E R2=log R3=phy R4=off R6/R7=leaf wind R8/R9=file /and/ R10...
;X New values written #

cw_Goto_update
 FNJSR "R1-R5"
 LDR R0,[R8,#w_stline]
 ADD R2,R2,R0
 ADD R3,R3,R0
 LDR R0,[R8,#w_addr]
 ADD R4,R4,R0
 MOV R0,R2
 MOV R5,#3
 LDR R14,local_scrapstore$l
 CMP R14,R0
 STRNE R0,local_scrapstore$l
 BLNE icon_buffernum
 FNRTS VS			; log line

 LDR R0,[R10,#c_col]
 LDR R14,[R8,#w_margin]
 SUB R0,R0,R14
 MOV R5,#4
 LDR R14,local_scrapstore$l + 4
 CMP R14,R0
 STRNE R0,local_scrapstore$l + 4
 BLNE icon_buffernum
 FNRTS VS			; log line
 MOV R0,R3
 MOV R5,#5
 LDR R14,local_scrapstore$l + 8
 CMP R14,R0
 STRNE R0,local_scrapstore$l + 8
 BLNE icon_buffernum
 FNRTS VS			; log line

 MOV R0,R4
 MOV R5,#6
 LDR R14,local_scrapstore$l + 12
 CMP R14,R0
 STRNE R0,local_scrapstore$l + 12
 BLNE icon_bufferhex
 FNRTS				; offset

local_scrapstore$l
 DCD -1
 DCD -1
 DCD -1
 DCD -1

cw_Goto_update2
 FNJSR "R1-R5"
 LDR R4,[R8,#w_format]
 TST R4,#&100
 MOVEQ R5,#7
 BEQ select$l			; logical
 TST R4,#&200
 MOVEQ R5,#9
 BEQ select$l			; address
 TST R4,#&800
 MOVEQ R5,#7
 MOVNE R5,#8
select$l
 BL icon_select			; select icon R5
 FNRTS

cw_Goto_update3			; put in an & if needed.
 FNJSR "R1-R5"
 MOV R5,#11			; icon with data
 BL icon_getind			; R0=address of search string
 LDRB R14,[R0]
 CMP R14,#'&'
 BEQ existingamp$l
 CMP R14,#32
 FNRTS CS
 LDR R14,[R8,#w_format]
 TST R14,#format_LinesBase
 MOVNE R14,#'&'
 STRNE R14,[R0]
 FNRTS

existingamp$l
 LDR R14,[R8,#w_format]
 TST R14,#format_LinesBase
 FNRTS NE
 LDRB R14,[R0,#1]
 CMP R14,#32
 MOVCC R14,#0
 STRCC R14,[R0]
 FNRTS

 LOCAL

lc_GotoBox
 SUB R14,R5,#&100
 CMP R14,#&9E ; pgup
 CMPNE R14,#&9F ; pgdown
 BEQ cursorkeyprocession_Goto
 TST R4,#&800 ; cursor keys...?
 BNE cursorkeyprocession_Goto2
 CMP R5,#&180
 BGE passonafnkeythencret
 AND R14,R4,#7
 CMP R14,#2
 BEQ lc_Goto_histmenu
 ADR R0,keys$l
 BL key_to_click
 BLMI slab_icon_in_temporarily
 TEQ R5,#12
 BEQ lc_Goto_newline
 SUB R0,R5,#7
 CMP R0,#3
 BCC lc_Goto_select		; select logical/physical/address
 TEQ R5,#10
 BEQ lc_Goto_histmenu
 TEQ R5,#13
 BEQ lc_Dying_cancel
 TST R4,#1
 BEQ c_ret
 TEQ R5,#11
 BEQ lc_Goto_newline		; adjust clicked on number
 TEQ R5,#99
 BEQ lc_Goto_clearhist
 TEQ R5,#98
 BEQ lc_SrchRep_CopySel
 B c_ret
keys$l = 'L',7,'P',8,'W',8,'C',8,'A',9,'Q',13,'K',99,'V',98,0
 ; New: W for 'Wrapped; C for Co-ord. V for copysel...
 ALIGN

lc_Goto_select
 BL icon_select
 B c_ret

lc_Goto_newline
 BL resethistorypositions
 BVS s_ret

 MOV R5,#11			; icon with data
 BL icon_getind			; R0=address of search string

 MOV R1,R0
 MOV R0,#lineed_buf_goto
 BL lineeditor_append		; add to history list.
 MOV R0,R1

 ;MOV R5,#11			; icon with data
 ;BL icon_getind
 LDRB R14,[R0]
 CMP R14,#&20
 BCC s_ret			; string empty so ignore
 BL chkforcommainstr
 BEQ commafound$l
maybenotdead$l
 BL lc_buffernum ; takes R1?	; get value in R0
 BVS c_ret
 MOV R4,R0			; save value
 MOV R0,#2
 BL lc_radioon			; get radioon icon in R0
 SUB R5,R0,#7			; save icon number
 MOV R0,R4			; value
 MOV R3,#0			; X co-ordinate
 CMP R5,#1
 BLO lc_Goto_newlog ; 7
 BEQ lc_Goto_newphy ; 8
 TEQ R5,#2
 BEQ lc_Goto_newoff ; 9
 B c_ret

commafound$l
 MOV R3,R0
 MOV R0,#2			; esg?
 BL lc_radioon			; get radioon icon in R0
 MOV R5,R0			; save icon number
 CMP R5,#8
 BNE maybenotdead$l
 MOV R0,R3
 MOVS R14,#0
 STRB R14,[R4,#-1]
 BL quickeval			; get value in R0
 BVS c_ret
 LDR R14,[R8,#w_bpl]
 CMP R0,R14
 MOVCC R3,R0
 SUBCS R3,R14,#1
 MOV R0,R4
 BL quickeval			; get value in R0
 BVS c_ret
 CMP R0,#0
 MOVLE R0,#1
 MOV R14,#','			; put it back again...
 STRB R14,[R4,#-1]
 ;MOV R4,R0			; save value
 ;MOV R0,R4			; value
 B lc_Goto_newphy

quickeval
 FNJSR
 FNLDR R1,wimp_block		; buffer
 MOV R2,#0			; buf len
 SWI XOS_EvaluateExpression
 FNRTS VS
 MOV R0,R2			; result
 TEQ R1,#0			; check integer returned
 BLNE err3
 FNRTS

lc_Goto_newlog
 LDR R14,[R8,#w_stline]
 SUB R0,R0,R14
 BL cln_log
 BVS c_ret
 B lc_Goto_off

lc_Goto_newphy
 LDR R14,[R8,#w_stline]
 SUB R0,R0,R14
 BL cln_phy
 BVS c_ret
 MOV R1,R3
 BL cln_linecol
 BVS c_ret
 FNLDR R10,car_cursor		; caret to move
 BL goto_offset
 LDR R14,[R8,#w_margin]
 ADD R14,R14,R3
 STR R14,[R10,#c_col]		; add in margin...
 BL plot_caret			; too many :(
 BLVC leaf_update
 B s_ret
; B lc_Goto_off

lc_Goto_newoff
 LDR R14,[R8,#w_addr]
 SUB R0,R0,R14
; B lc_Goto_off

lc_Goto_off
 FNLDR R10,car_cursor		; caret to move
 BL goto_offset
 BLVC leaf_update
 B s_ret

 DCD 1+c_CanCreateSubMenu+c_MovesInputOrKeymap
Goto
 FNJSR
 BL get_cursor_caret		; goto
 MOV R0,#t_GotoBox
 BL open_leaf_com
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cw_SearchBox
 FNJSR
 MOV R4,#0
 BL create_sar
 BL resethistorypositions
 BL checkseeiflineeditorloaded
 MOV R5,#18
 MOV R0,#1 << 22
 MOVVS R1,#1 << 22
 MOVVC R1,#0
 BL icon_alter
 FNRTS

;E R4=0 if search 1 if replace (for output/sel or global)
;  R6=data R7=wind of search or replace box
;X search field and icons updated #

create_sar
 FNJSR "R1,R5"
 FNLDR R0,fnd_string		; old search string
 MOV R5,#15
 FNLDR R14,opt_switches
 TST R14,#switch_ClearSearchWindow
 MOVNE R0,#0			; clear the buffer instead
 BL icon_bufferstr		; insert the string and update
 FNRTS VS
 FNLDR R1,opt_flags
 MOV R0,R1,LSR#12		; case sensitive bit
 MOV R5,#26
 BL icon_set
 MVN R0,R1,LSR#19
 MOV R5,#27
 BL icon_set			; replace macros
 FNLDR R1,opt_switches
 MOV R0,R1,LSR#search_RawSearch
 MOV R5,#25
 BL icon_set			; raw search
 MVN R0,R1,LSR#search_UseCommands
 MOV R5,#28
 BL icon_set			; use \commands
 MOV R0,R1,LSR#search_DirAndExtent_shift
 AND R0,R0,#3
 ADD R5,R0,#8			; icon of base option
 BL icon_select			; select forward/backward etc
 TEQ R4,#0
 MOVNE R1,R1,LSR#(search_GlobalReplace - search_ToBuffer)
				; move global replace to search to buffer
 MOV R0,R1,LSR#search_ToBuffer
 MOV R5,#12
 BL icon_set
 MOVVC R5,#3
 ADRVC R0,notknown$l
 BLVC icon_bufferstr		; insert the string and update
 FNRTS
notknown$l
 = "-",0
 ALIGN

 LOCAL

;E R4=mouse buttons
;  R5=icon/key click (acts on first 2 cols, show macros, Tab)
;X acted on (in both windows) if recognised. #

interpret_sar
 TST R4,#2
 MOVNE PC,R14			; return early on Menu clicks
 FNJSR "R1-R7"
 SUB R14,R5,#&100
 TEQ R14,#&AA			; ctab
 BEQ tab$l			; recall previous string
 CMP R5,#&180
 BGE passonafnkey
 ADR R0,keys$l
 BL key_to_click
; CMP R5,#5
; BLEQ sar_passkeyontowimp2	; pass key onto WIMP
 CMP R5,#251
 BGE sar_passkeyontowimp	; pass key onto WIMP
 TEQ R5,#14
 BEQ macros$l			; open macros box
 CMN R5,#'I'
 BEQ tab$l			; recall previous string
 TEQ R5,#25
 MOVEQ R0,#switch_SearchRawSearch
 BEQ switches$l
 TEQ R5,#26
 MOVEQ R0,#flags_SearchCaseSensitive
 BEQ opts$l
 TEQ R5,#1
 BEQ to_simple_Search_count
 TEQ R5,#27
 MVNEQ R0,#flags_NoSearchMacros
 BEQ opts$l
 TEQ R5,#28
 MVNEQ R0,#switch_SearchUseCommands
 BEQ switches$l
 SUB R0,R5,#8
 CMP R0,#4
 BCC start$l
 FNRTS				; not recognised
switches$l
 FNLDR R14,opt_switches
 TST R0,#1<<31			; works because this routine never has to flip (1:SHL:31)
 MVNNE R0,R0			; get mask
 EOR R14,R14,R0			; toggle state
 FNSTR R14,opt_switches
 MVNNE R14,R14			; toggle back
 TST R14,R0
 MOVEQ R2,#0
 MOVNE R2,#1
 B set$l
opts$l
 FNLDR R14,opt_flags
 TST R0,#1<<31
 MVNNE R0,R0			; get mask
 EOR R14,R14,R0			; toggle state
 FNSTR R14,opt_flags
 MVNNE R14,R14			; toggle back
 TST R14,R0
 MOVEQ R2,#0
 MOVNE R2,#1
 B set$l
start$l				; start from position selection
 FNLDR R14,opt_switches
 BIC R14,R14,#switch_SearchDirAndExtent
 ORR R14,R14,R0,LSL#search_DirAndExtent_shift
 FNSTR R14,opt_switches
 FNindw R6,R7,t_SearchBox
 BL icon_select
 FNindw R6,R7,t_ReplaceBox,VC
 BLVC icon_select
 FNRTS
set$l				; set according to bottom bit of R2
 FNindw R6,R7,t_SearchBox
 MOV R0,R2
 BL icon_set
 FNindw R6,R7,t_ReplaceBox,VC
 MOVVC R0,R2
 BLVC icon_set
 FNRTS
macros$l
 MOV R5,#14
 ;MOV R2,#&FF00
 BL slab_icon_in_temporarily
 ;PUSH "R6,R7"
 FNind R7,t_MacroBox
 BL create_open_leaf
 ;PULL "R6,R7"
 ;MOV R5,#14
 ;MOV R2,#&FF00
 ;BL slab_icon_in_temporarily
 FNRTS
tab$l
 MOV R0,#1			; pressing ctrl?
 BL test_forkey
 FNRTS CC
 BL resethistorypositions	; slightly overdoing things, but anyway
 FNLDR R1,wimp_block
 SWI XWimp_GetCaretPosition
 BVS c_ret
 LDR R5,[R1,#4]
 CMP R5,#15
 BNE tabrepl$l
 FNLDR R4,fnd_string		; old search string
 MOV R0,R4
 FNindw R6,R7,t_SearchBox	; (TT fix or tab bug search box)
 MOV R5,#15
 BL icon_bufferstr
 FNindw R6,R7,t_ReplaceBox	; (TT fix or tab bug replace box)
 MOV R5,#15
 MOV R0,R4
 BL icon_bufferstr
 MOV R5,#15
 BL icon_checkcaret		; (TT fix or tab bug)
 FNindw R6,R7,t_SearchBox	; (TT fix or tab bug search box)
 MOV R5,#15
 BL icon_checkcaret		; (TT fix or tab bug)
 FNRTS
tabrepl$l
 FNLDR R0,fnd_replace		; old search string
 MOV R5,#16
 FNindw R6,R7,t_ReplaceBox		; (TT fix or tab bug replace box)
 BL icon_bufferstr
 MOV R5,#16
 BL icon_checkcaret		; (TT fix or tab bug)
 FNRTS

; :CHR:&5C is a literal \ character.
; objasm calls this '\'
; armasm calls it '\\'
; as can probably cope with both, but this is easier.
keys$l = 'N',1,'R',25,'C',26,'M',27,:CHR:&5c,28,'S',8,'F',9,'B',10,'A',11,'E',14,183,248,184,249,185,250,'V',254,'Z',253,'X',252,'D',251,0
 ALIGN

 LOCAL

passonafnkey ; attempt fails...?
 BL pass_on_a_fn_key
 FNRTS

sar_passkeyontowimp		; For the benefit of '!Clipboard' users
 MOV R0,#'C'-&40
 CMP R5,#254			; who use cZ, cX, cC and cV to provide
 MOVEQ R0,#'V'-&40		; a writable icon clipboard.
 BEQ sar_justprocesskey		; cC may be generated by pressing cD.

 CMP R5,#253
 MOVEQ R0,#'Z'-&40
 BEQ sar_justprocesskey

 CMP R5,#252
 MOVEQ R0,#'X'-&40
; BEQ sar_justprocesskey

; CMP R5,#251
; MOVEQ R0,#'C'-&40
sar_justprocesskey
 SWI XWimp_ProcessKey
 FNRTS

;sar_passkeyontowimp2		; For the benefit of '!Clipboard' users
; FNJSR
; MOVEQ R0,#'C'-&40
; SWI XWimp_ProcessKey
; FNRTS

 DCD 1
Countmatches
 FNindw R6,R7,t_SearchBox
 B simple_Search_count

 ;FNJSR "R1-R7"
 ;PUSH "R0-R9"
 ; STMFD R13 !,{R1-R7}
 ;B simple_Search_count

to_simple_Search_count
 PUSH "R0-R9"
 MOV R5,#1
 MOV R2,#&FF00
 BL slab_icon_in_temporarily
 ;FNind R7,t_ReplaceBox

 CMP R8,#0
 MOVMI R0,#1
 MOVPL R0,#0
 FNSTR R0,wimp_flagbits		; *very* temporary
 LDR R0,[R7,#4]			; flags
 TST R0,#1
 BNE lcten$l
 FNLDR R1,wimp_block
 LDR R0,[R7,#8]			; window handle
 STR R0,[R1]
 SWI XWimp_GetWindowState ; Info
 BVS lcten$l			; find the window posn
 ;LDR R1,[R1,#(88+3*32+16)]	; flags on icon 3
 ;TST R1,#(&1F << 16)		; non-0 esg...
 ;BNE lcten$l
 MVN R1,#0
 SWI XWimp_CreateMenu		; close the menu
 BVS lcten$l
 FNLDR R1,wimp_block
 SWI XWimp_OpenWindow		; reopen the window
 BVS lcten$l
 LDR R0,[R7,#4]
 ORR R0,R0,#1
 STR R0,[R7,#4]			; update flags to no longer window opened
 LDR R6,[R7]
 LDR R5,[R6,#84]		; number of icons
 SUBS R5,R5,#1			; last icon
 MOV R0,#1			; increase
 BL leaf_next_icon
lcten$l

; FNLDR R1,wimp_block
; ADD R1,R1,#&60
; LDR R0,[R7,#8]			; window handle
; STR R0,[R1]
; SWI XWimp_GetWindowState
; MVN R1,#0
; SWI XWimp_CreateMenu		; close the menu
; FNLDR R1,wimp_block
; ADD R1,R1,#&60
; SWI XWimp_OpenWindow		; reopen the window
 PULL "R0-R9"
 BL simple_Search_count
 MOV R5,#1
 ;MOV R2,#&FF00
 BL slab_icon_in_temporarily
 FNRTS

 LOCAL

; localretflag$l
;  DCD 0

lc_SearchBox
 SUB R14,R5,#&100
 CMP R14,#&9E ; pgup
 CMPNE R14,#&9F ; pgdown
 BEQ cursorkeyprocession_Search
;  CMP R5,#&1D
;  MOVEQ R14,#&FA00
;  STR R14,localretflag$l

; CMP R5,#&9F ; pgdown
 ; ;BL sar_pguppgdown	; old tab
 ; SUB R14,R5,#&100
 ; CMP R14,#&9E
 ; CMPNE R14,#&9F
 ; BEQ cursorkeyprocession_Search
 ;CMP R14,#&8E
 ;CMPNE R14,#&8F
 ;TST R4,#&800
 ;BNE cursorkeyprocession_Search
 BL interpret_sar
 BVS c_ret
 TST R4,#&800 ; cursor keys...?
 BNE cursorkeyprocession_Search2
 ADR R0,keys$l
 BL key_to_click
 AND R14,R4,#7
 CMP R14,#2
 BEQ lc_Search_histmenu
 TEQ R5,#29
 BEQ lc_Dying_cancel
 TEQ R5,#12
 BEQ lc_Search_out
 TEQ R5,#15
 BEQ lc_maybe_Search_search		; user has pressed return (drag :-<)...?
 TEQ R5,#16
 BEQ lc_Search_search		; ok button
 TEQ R5,#18
 BEQ lc_Search_histmenu
 TEQ R5,#99
 BEQ lc_Search_clearhist_Search
 TEQ R5,#98
 BEQ lc_SrchRep_CopySel
 B c_ret
keys$l = 'W',12,'K',99,'P',98,0
 ALIGN

local_window_con
 DCD 0

lc_maybe_Search_search
 SWI XOS_Mouse
 CMP R2,#0
 BEQ lc_Search_search
 B c_ret

lc_Mini_histmenu
 ;BL recreate_the_leaf_window
 ;BVS c_ret
 FNLDR R0,mini_lineed
 STR R7,local_window_con
 BL hist_length_get
 MOV R4,R0
 FNLDR R0,mini_lineed
 MOV R1,#&7FFFFFFF
 BL lineeditor_setpos		; reset the recall position to end

 ADR R0,histnom$l
 ADR R1,histmake_m$l
 MOV R2,#0
 ADR R3,histclick_m$l
lc_build_menu
 ORR R1,R1,#1
 BL build_menu
lc_open_menu
 MOV R7,R0
 FNLDR R1,wimp_block
 SWI XWimp_GetPointerInfo
 LDMIA R1,{R2,R3}
; SUB R2,R2,#32
 MOV R1,R7
 BL open_menu
 B c_ret

lc_Goto_histmenu
 BL recreate_the_leaf_window
 BVS c_ret
 MOV R0,#lineed_buf_goto
 STR R7,local_window_con
 BL hist_length_get
 MOV R4,R0
 BL resethistorypositions

 ADR R0,histnom$l
 ADR R1,histmake_g$l
 MOV R2,#0
 ADR R3,histclick_g$l
 B lc_build_menu

lc_Replace_histmenu
 BL recreate_the_leaf_window
 BVS c_ret
 MOV R8,R4
 TST R8,#1
 MOVEQ R0,#lineed_buf_replace
 MOVNE R0,#lineed_buf_search
 STR R7,local_window_con
 BL hist_length_get
 MOV R4,R0
 BL resethistorypositions

 ADR R0,histnom$l
 TST R8,#1
 ADREQ R1,histmake_r$l
 ADRNE R1,histmake$l
 MOV R2,#0
 ADR R3,histclick_r$l
 B lc_build_menu

lc_choose_histmenu
 FNLDR R1,wimp_block
 SWI XWimp_GetCaretPosition
 LDR R14,[R1,#4]
 CMP R14,#16
; FNind R7,t_ReplaceBox
 BEQ lc_Replace_histmenu
; FNind R7,t_SearchBox

lc_Search_histmenu
 BL recreate_the_leaf_window
 BVS c_ret
 MOV R8,R4
 TST R8,#1
 MOVEQ R0,#lineed_buf_replace
 MOVNE R0,#lineed_buf_search
 STR R7,local_window_con
 BL hist_length_get
 MOV R4,R0
 BL resethistorypositions

 ADR R0,histnom$l
 TST R8,#1
 ADRNE R1,histmake_r$l
 ADREQ R1,histmake$l
 MOV R2,#0
 ADR R3,histclick$l
 B lc_build_menu

histnom$l FNS ("zap_m_hist")
histclick$l
 FNJSR "R1-R10"
 MOV R0,R10
 LDR R7,local_window_con
 LDR R6,[R7]			; (TT fix or tab bug)
 MOV R5,#15
 BL icon_bufferstr
 MOV R5,#15
 BL icon_checkcaret		; (TT fix or tab bug)
 FNRTS

histclick_r$l
 FNJSR "R1-R10"
 MOV R0,R10
 LDR R7,local_window_con
 LDR R6,[R7]			; (TT fix or tab bug)
 MOV R5,#16
 BL icon_bufferstr
 MOV R5,#16
 BL icon_checkcaret		; (TT fix or tab bug)
 FNRTS

histclick_g$l
 FNJSR "R1-R10"
 MOV R0,R10
 LDR R7,local_window_con
 LDR R6,[R7]			; (TT fix or tab bug)
 MOV R5,#11
 BL icon_bufferstr
 MOV R5,#11
 BL icon_checkcaret		; (TT fix or tab bug)
 FNRTS

histclick_m$l
 FNJSR "R1-R10"
 ADR R0,ctrlu$l
 BL minibuffer_write
 MOV R0,R10
 BL minibuffer_write
 BL minibuffer_update
 FNRTS
ctrlu$l
 DCD 21

histmake$l
 FNJSR "R1-R10"
 MOV R10,R0
 MOV R0,#lineed_buf_search
ortho_hist_clk
 MOV R1,#&80000000 ; wrap
 BL retrieve_from_le
 CMP R0,#0
 MOVEQ R0,#-1
 FNRTS EQ
 MOV R1,R10
 MOV R2,R0
 BL strcopy
 MOV R0,R10
 FNRTS

histmake_r$l
 FNJSR "R1-R10"
 MOV R10,R0
 MOV R0,#lineed_buf_replace
 B ortho_hist_clk

histmake_g$l
 FNJSR "R1-R10"
 MOV R10,R0
 MOV R0,#lineed_buf_goto
 B ortho_hist_clk

histmake_m$l
 FNJSR "R1-R10"
 MOV R10,R0
 FNLDR R0,mini_lineed
 B ortho_hist_clk

hist_length_get ; X returns length in R0
 FNJSR "R1-R9"
 MOV R7,R0
 BL resethistorypositions
 MOV R9,#5
loop$l
 BL getlength$l
 BNE loop$l
 ADD R0,R9,#1
 FNRTS

getlength$l
 FNJSR
 MOV R0,R7
 MOV R1,#&80000000 ; wrap
 BL retrieve_from_le
 CMP R0,#0
 MOVEQ R0,#-1
 FNRTS EQ
 BL str_len
 CMP R0,R9
 MOVCS R9,R0
 MVN R14,#0 ; NE
 FNRTS

lc_Search_clearhist_Search
 MOV R0,#lineed_buf_search
 BL lineeditor_kill
 B c_ret

lc_Search_clearhist_Replace
 FNLDR R1,wimp_block
 SWI XWimp_GetCaretPosition
 BVS c_ret
 LDR R5,[R1,#4]
 CMP R5,#15
 MOVEQ R0,#lineed_buf_search
 MOVNE R0,#lineed_buf_replace
 BL lineeditor_kill
 B c_ret

lc_Goto_clearhist
 MOV R0,#lineed_buf_goto
 BL lineeditor_kill
 B c_ret

cursorkeyprocession_Goto
 MOV R5,#15
 CMP R14,#&9F ; pgup
 MOVEQ R1,#&80000001		; up (!wrapped)
 MOVNE R1,#&80000002		; down (!wrapped)
 B lc_Goto_recall_mb

cursorkeyprocession_Goto2
 CMP R10,#1
 MOVEQ R1,#&80000001		; up (!wrapped)
 MOVNE R1,#&80000002		; down (!wrapped)
 B lc_Goto_recall_mb

cursorkeyprocession_Search
 MOV R5,#15
 CMP R14,#&9F ; pgup
 MOVEQ R1,#&80000001		; up (!wrapped)
 MOVNE R1,#&80000002		; down (!wrapped)
 B lc_Search_recall_mb

cursorkeyprocession_Search2
 CMP R10,#1
 MOVEQ R1,#&80000001		; up (!wrapped)
 MOVNE R1,#&80000002		; down (!wrapped)
 B lc_Search_recall_mb

cursorkeyprocession_Replace
 FNLDR R1,wimp_block
 SWI XWimp_GetCaretPosition
 BVS c_ret
 LDR R5,[R1,#4]			; get icon number...
 CMP R14,#&9F ; pgup
 MOVEQ R1,#&80000001		; up (!wrapped)
 MOVNE R1,#&80000002		; down (!wrapped)
 B lc_Replace_recall_mb

 LOCAL

lc_Search_out
 FNLDR R14,opt_switches
 EOR R14,R14,#switch_SearchToBuffer	; new value
 FNSTR R14,opt_switches
 MOV R0,R14,LSR#search_ToBuffer
 BL icon_set
 B c_ret

lc_Goto_recall_mb
 MOV R3,R1			; direction...
 MOV R0,#lineed_buf_goto
 BL retrieve_from_le
 CMP R0,#0
 BEQ c_ret
 MOV R5,#11
 FNindw R6,R7,t_GotoBox		; (TT fix or tab bug search box)
 BL cmpstr0withictxt
 MOVEQ R1,R3
 MOVEQ R0,#lineed_buf_goto
 BLEQ retrieve_from_le
 CMP R0,#0
 BEQ c_ret
 FNindw R6,R7,t_GotoBox		; (TT fix or tab bug search box)
 BL icon_bufferstr
 BL icon_checkcaret		; (TT fix or tab bug)
 B c_ret

lc_Search_recall_mb		; E R1=direction code, R5=icon number R6/R7
 MOV R3,R1			; direction...
 MOV R0,#lineed_buf_search
 BL retrieve_from_le
 CMP R0,#0
 BEQ c_ret
 MOV R5,#15
 FNindw R6,R7,t_SearchBox	; (TT fix or tab bug search box)
 BL cmpstr0withictxt
 MOVEQ R1,R3
 MOVEQ R0,#lineed_buf_search
 BLEQ retrieve_from_le
 CMP R0,#0
 BEQ c_ret
 ;FNind R7,t_ReplaceBox		; (TT fix or tab bug replace box)
 ;LDR R6,[R7]			; (TT fix or tab bug)
 ;BL icon_bufferstr
 ;MOV R5,#15
 ;BL icon_checkcaret		; (TT fix or tab bug)
 FNindw R6,R7,t_SearchBox	; (TT fix or tab bug search box)
 BL icon_bufferstr
 BL icon_checkcaret		; (TT fix or tab bug)
 B c_ret

lc_Replace_recall_mb		; E R1=direction code, R5=icon number R6/R7
 MOV R3,R1			; direction...
 BL to_retrieve_from_le
 CMP R0,#0
 BEQ c_ret
 FNindw R6,R7,t_ReplaceBox	; (TT fix or tab bug Replace box)
 BL cmpstr0withictxt
 MOVEQ R1,R3
 BLEQ to_retrieve_from_le
 CMP R0,#0
 BEQ c_ret
 FNindw R6,R7,t_ReplaceBox	; (TT fix or tab bug Replace box)
 BL icon_bufferstr
 BL icon_checkcaret		; (TT fix or tab bug)
 B c_ret

to_retrieve_from_le
 CMP R5,#15
 MOVEQ R0,#lineed_buf_search
 MOVNE R0,#lineed_buf_replace
 B retrieve_from_le

;isiniconfifteen
; FNJSR
; FNLDR R1,wimp_block
; SWI XWimp_GetCaretPosition
; LDR R
; FNRTS

cmpstr0withictxt ; R5 = icon with str - R0 = other string R6,R7
 FNJSR "R0-R2,R6"
 ADD R6,R6,#88
 ADD R6,R6,R5,LSL#5		; icon address
 LDR R1,[R6,#20]		; buffer address
 MOV R2,R0
 BL strcmp
 FNRTS ; EQ nor NE

retrieve_from_le ; E R1 = direction. R0=buffernum R5= icon...
 FNJSR "R10"
 CMP R0,#0			; no line editor buffer...
 FNRTS EQ
 MOV R10,R0
 BL lineeditor_setpos
 MOV R0,R10
 BL getahistcharactr
 FNRTS

 LOCAL
getahistcharactr ; E R0 ; X R0 = ptr to entry / 0
 FNJSR
 FNLDR R1,wimp_buffer
 MOV R2,#255
 BL lineeditor_retrieve
 BVS err$l
 BEQ err$l
 FNLDR R0,wimp_buffer
 LDRB R14,[R0]
 CMP R14,#31
 MOVLES R0,#0
 FNRTS
err$l
	SUBS	R0,R0,R0
	FNRTS

resethistorypositions
 FNJSR
 MOV R0,#lineed_buf_search
 BL lineeditor_reset		; reset the recall position to end
 MOV R0,#lineed_buf_replace
 BL lineeditor_reset		; reset the recall position to end
 MOV R0,#lineed_buf_goto
 BL lineeditor_reset		; reset the recall position to end
 FNRTS

lc_Search_search
 BL resethistorypositions
 BVS s_ret

 MOV R5,#15
 BL icon_getind			; R0=address of search string

 MOV R1,R0
 MOV R0,#lineed_buf_search
 BL lineeditor_append		; add to history list.
 MOV R0,R1

 MOV R1,#1
 MOV R2,#0
 FNLDR R3,opt_switches
 TST R3,#switch_SearchToBuffer
 ADREQ R7,Searchcur
 ADRNE R7,Searchbuf
 MOV R10,#0
 BL process_command
 B s_ret

 LOCAL
lc_SrchRep_CopySel		; paste selection into icon
 BL get_selection
 BCS c_ret
 MOVS R3,R2
 BEQ c_ret
 LDR R4,[R9,#f_ptr]
 LDR R5,[R9,#f_len]
 LDR R6,[R9,#f_splito]
 LDR R7,[R9,#f_splits]
 CMP R1,R6
 ADDHI R4,R4,R7
; MOV R3,R2
 MOV R11,R1
 PUSH "R9,R10"
 LDRB R9,[R8,#w_cr]
 LDRB R10,[R8,#w_tabc]
loop$l
; SUBS R3,R3,#1
; BMI c_ret
 TEQ R11,R6
 ADDEQ R4,R4,R7
 LDRB R14,[R4,R11]
 TEQ R14,R9
 BEQ cr$l
 TEQ R14,R10
 BEQ tab$l
 TEQ R14,#127
 BEQ del$l
normal$l
 CMP R14,#31
 BLS ctrl$l
 TEQ R14,#'\'
 TEQNE R14,#'`'
 BEQ tick$l
 TST R14,#128
 MOVNE R0,#138
 MOVNE R1,#0
 MOVNE R2,#0
 SWINE XOS_Byte
insert$l
 MOVVC R0,#138
 MOVVC R1,#0
 MOVVC R2,R14
 SWIVC XOS_Byte
 BVS error$l
next$l
 ADD R11,R11,#1
 SUBS R3,R3,#1
 BNE loop$l
error$l
 LDMFD R13!,{R9,R10}
 B c_ret
ctrl$l
 FNLDR R0,opt_switches
 TST R0,#switch_SearchUseCommands
 MOVNE R14,#32
 BNE insert$l
 MOV R0,#138
 MOV R1,#0
 MOV R2,#'\'
 SWI XOS_Byte
 BVS error$l
 ADR R2,ctrllist$l
 MOV R14,R14,LSL #1
 MOV R0,#138
 MOV R1,#0
 LDRB R2,[R14,R2]!
 SWI XOS_Byte
 BVS error$l
 LDRB R14,[R14,#1]
 TEQ R14,#0
 BEQ next$l
 B insert$l
ctrllist$l
 = '0',0, '1',0, '2',0, '3',0, '4',0, '5',0, '6',0, 'a',0
 = 'b',0, '9',0, "10",  'v',0, 'f',0, 'r',0, "14",  "15"
 = "16",  "17",  "18",  "19",  "20",  "21",  "22",  "23"
 = "24",  "25",  "26",  "27",  "28",  "29",  "30",  "31"
cr$l
 FNLDR R0,opt_switches
 TST R0,#switch_SearchRawSearch
 MOVEQ R3,#1
 TST R0,#switch_SearchUseCommands
 BNE normal$l
 MOV R14,#'n'
 B cr_tab$l
tab$l
 FNLDR R0,opt_switches
 TST R0,#switch_SearchUseCommands
 BNE normal$l
 MOV R14,#'t'
cr_tab$l
 MOV R0,#138
 MOV R1,#0
 MOV R2,#'\'
 SWI XOS_Byte
 B insert$l
del$l
 FNLDR R0,opt_switches
 TST R0,#switch_SearchUseCommands
 MOVNE R14,#32
 BNE insert$l
 MOV R0,#138
 MOV R1,#0
 MOV R2,#'\'
 SWI XOS_Byte
 MOVVC R14,#'?'
 B insert$l
tick$l
 FNLDR R0,opt_switches
 TST R0,#switch_SearchUseCommands
 MOVEQ R0,#138
 MOVEQ R1,#0
 MOVEQ R2,#'`'
 SWIEQ XOS_Byte
 B insert$l

; X R2->ctrl chars list (byte pairs)

ctrllist
 ADR R2,ctrllist ; wtf?
 MOV PC,R14

startofsrccntoffs
 DCD 0

; FNJSR
; ADR R10,safe_simple_Search_count
; BL do_longop
; FNRTS
;
;safe_simple_Search_count
simple_Search_count
 FNJSR "R0-R7,R10,R11"
 BL long_op_on
 MOV R5,#15
 BL icon_getind			; R0=address of search string
 BL new_search_string		; set this string as the current one
 BVS lastexitsearchcount$l
 MOV R11,#0
 TEQ R0,#0
 BEQ displaythecountresult$l
 MOV R2,#0
 BL default_search		; read the default search values
 BVS lastexitsearchcount$l
 STR R3,startofsrccntoffs
 MOV R11,#0			; counter...
 ;STR R11,atasetflag$l		; this file only so far...
 MOV R10,R0			; search string
 STR R9,startofsrccntoffs
 ORR R5,R5,#zsearch_DontBeep	; don't beep if match found...
loopsearchcount$l
 BL reportonprogresscount
 ;TST R5,#(1 << 27)		; loop around windows...
 ; BL checkforfinalwindow
 ; BNE displaythecountresult$l
 MOV R1,#3			; output type from search...
 MOV R4,#1
 MOV R0,R10
 BL search_data			; perform search
 BVS lastexitsearchcount$l
 ;CMP R0,#0
 ;ADDPL R11,R11,#1
 ;ADDPL R3,R0,#1 ; R4
 ;BPL loopsearchcount$l
 MOV R11,R0
displaythecountresult$l
 BL rptcounttousr
 BL icon_redraw
 BL icon_getflags		; get flags data...
 TST R0,#&1F << 16		; ESG
 BNE lastexitsearchcount$l
 ; here
 MOV R2,#0
 MOV R5,R11
 MOV R11,#1
; BL toWCOutput
lastexitsearchcount$l
 BL long_op_off
 FNRTS				; care - from a long time ago...!

pass_on_a_fn_key
 FNJSR "R8-R11"
 MOV R11,R5
 BL close_leaf_window
 MOV R6,#0
 FNLDR R10,car_cursor
 LDR R0,[R10,#c_wind]
 BL conv_wind_off
 MOV R0,R11
 MOVS R5,R0			; wimp key number
 FNLDR R1,key_modifiers
 BL convert_key			; convert R0 to zap key number
 BL process_a_key
 FNRTS

; checkforfinalwindow
;  LDR R0,startofsrccntoffs
;  CMP R9,R0
;  BNE setaflag$l
;  LDR R0,atasetflag$l
;  CMP R0,#0
;  MOV PC,R14
;
; setaflag$l
;  SWI &107
;  STR R14,atasetflag$l
;  CMP R14,R14
;  MOV PC,R14
;
; atasetflag$l
;  DCD 0

;E R11 = count
rptcounttousr
 FNJSR
 MOV R5,#3
 BL icon_getind			; where the result goes...
 MOV R1,R0
 MOV R0,R11
 MOV R2,#12
 SWI XOS_ConvertSpacedCardinal4
 BVS lastexitsearchcount$l
 BL cnvrtspcsinstr
 FNRTS

reportonprogresscount
 FNJSR "R2,R3"
 CMP R4,#0
 BMI negativedirection$l
 LDR R1,[R9,#f_len]
 MOV R0,R3
 LDR R2,startofsrccntoffs
 SUB R0,R0,R2
 SUB R1,R1,R2
 BL long_op_display
 FNRTS

negativedirection$l
 MOV R0,R3
 LDR R1,startofsrccntoffs
 BL long_op_display
 FNRTS

 LOCAL

 DCD 1+c_Param_String+c_PreMinibuffer+c_MinibufferKill+c_CanCreateSubMenu+c_MovesInputOrKeymap
Searchcur
 FNJSR
 TEQ R2,#0
 BEQ search$l
 BL clearglobal$l
 MOV R0,#t_SearchBox
 BL open_leaf_com
 FNRTS
search$l			; actually search for the string
 BL new_search_string		; set this string as the current one
 FNRTS VS
 TEQ R0,#0
 FNRTS EQ			; string was null so do nothing
 ;MOV R4,#0
 ;MOV R6,R0
 ;FNind R7,t_SearchBox
 ;BL create_sar
 BL clearglobal$l
 BL default_search		; read the default search values
 BLVC search_data		; perform search
 FNRTS

clearglobal$l
 FNLDR R0,opt_switches
 BIC R0,R0,#switch_SearchToBuffer
 FNSTR R0,opt_switches
 MOV PC,R14

 LOCAL

 DCD 1+c_Param_String+c_PreMinibuffer+c_MinibufferKill+c_CanCreateSubMenu+c_MovesInputOrKeymap
Searchbuf
 FNJSR
 TEQ R2,#0
 BEQ search$l
 BL setglobal$l
 MOV R0,#t_SearchBox
 BL open_leaf_com
 FNRTS
search$l
 BL new_search_string		; set this string as the current one
 FNRTS VS
 TEQ R0,#0
 FNRTS EQ			; string was null so do nothing
 BL setglobal$l
 BL default_search		; read the default search values
 BLVC search_data		; perform search
 FNRTS

setglobal$l
 FNLDR R0,opt_switches
 ORR R0,R0,#switch_SearchToBuffer
 FNSTR R0,opt_switches
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macro box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

get_MacroBox
 FNind R7,t_MacroBox
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Main box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

get_mode_0Box
 FNind R7,t_mode_0Box
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Replace box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cw_ReplaceBox
 FNJSR
 FNLDR R0,fnd_replace
 MOV R5,#16
 BL icon_bufferstr
 MOVVC R4,#1
 BLVC create_sar
 FNRTS VS
 ;LDR R0,[R7,#4]			; dubious flags
 ;BIC R0,R0,#&3F
 ;ORR R0,R0,#6
 ;STR R0,[R7,#4]			; dubious flags
 BL checkseeiflineeditorloaded
 MOV R5,#18
 MOV R0,#1 << 22
 MOVVS R1,#1 << 22
 MOVVC R1,#0
 BL icon_alter
 BL checkseeiflineeditorloaded
 MOV R5,#19
 MOV R0,#1 << 22
 MOVVS R1,#1 << 22
 MOVVC R1,#0
 BL icon_alter
 FNRTS

 LOCAL

lc_ReplaceBox
 ;BL sar_pguppgdown		; old tab
 SUB R14,R5,#&100
; CMP R14,#&8A
; CMPNE R14,#&9A
;; CMPNE R14,#&AA		; ctab
; CMPNE R14,#&BA
; ;CMPNE R14,#&9E ; pgup
; ;CMPNE R14,#&9F ; pgdown
; CMNNE R5,#'I'			; tab???
; BEQ replshifttab$l
 CMP R14,#&9E ; pgup
 CMPNE R14,#&9F ; pgdown
 BEQ cursorkeyprocession_Replace
 ;BEQ c_ret
 CMP R14,#&AA
 CMPNE R14,#&7F
 BGT passonafnkeythencret
 ;TST R4,#&800
 ;RSBNE R10,R10,#0
 ;BNE cursorkeyprocession_Replace
 BL interpret_sar		; toggle the case sensitive state etc
 BVS c_ret
 TST R4,#&800 ; cursor keys...?
 BNE replshifttab$l
 ADR R0,keys$l
 BL key_to_click
 ;BLMI slab_icon_in_temporarily
 AND R14,R4,#7
 CMP R14,#2
 BEQ lc_choose_histmenu ; lc_Search_histmenu
 TEQ R5,#12			; Icon 12
 BEQ lc_Replace_global
 TEQ R5,#17			; Replace button
 BEQ lc_Replace_replace
 TEQ R5,#18
 BEQ lc_Search_histmenu ; lc_Replace_histmenu
 TEQ R5,#19
 BEQ lc_Replace_histmenu
 TEQ R5,#20
 BEQ lc_Replace_copyfields
 TEQ R5,#29
 BEQ lc_Dying_cancel
 TEQ R5,#99
 BEQ lc_Search_clearhist_Replace
 TEQ R5,#98
 BEQ lc_SrchRep_CopySel
 ;TEQ R5,#1
 ;BEQ to_simple_Replace_count
 TST R4,#1
 BEQ c_ret
 TEQ R5,#16			; return pressed in replace with box
 BEQ lc_Replace_replace_ret
 B c_ret
keys$l = 'G',12,'K',99,'T',20,'P',98,0
 ALIGN

replshifttab$l
 FNLDR R1,wimp_block
 SWI XWimp_GetCaretPosition
 LDR R14,[R1,#4]
 CMP R14,#15
 MOVNE R0,#1
 MOVEQ R0,#-1
 BL leaf_next_icon		; move
 ;BVS c_ret
 ;LDR R3,[R7,#4]		; restore flags
 ;TST R3,#1<<2
 ;BLEQ leaf_update		; update leaf window contents
 B c_ret

;to_simple_Replace_count
; BL simple_Search_count
; B c_ret
; ;FNRTS

lc_Replace_global
 FNLDR R14,opt_switches
 EOR R14,R14,#switch_SearchGlobalReplace
 FNSTR R14,opt_switches
 MOV R0,R14,LSR#search_GlobalReplace
 BL icon_set
 B c_ret

lc_Replace_copyfields
 TST R4,#1
 BNE oww$l
 MOV R5,#15
 BL icon_getind			; R0=address of search string
 MOV R5,#16
 BL icon_bufferstr
 MOV R5,#16
 BL icon_checkcaret		; (TT fix or tab bug)
 B c_ret
oww$l
 MOV R5,#16
 BL icon_getind			; R0=address of search string
 MOV R5,#15
 BL icon_bufferstr
 MOV R5,#15
 BL icon_checkcaret		; (TT fix or tab bug)
 B c_ret

lc_Replace_replace_ret
	TST	R4,#4			; ignore if (s)Tab
	BNE	c_ret
lc_Replace_replace
 BL resethistorypositions
 BVS s_ret

 MOV R5,#15
 BL icon_getind			; R0=address of search string

 MOV R1,R0
 MOV R0,#lineed_buf_search
 BL lineeditor_append		; add to history list.
 MOV R0,R1

 MOV R5,#16
 BL icon_getind			; R0=address of search string

 MOV R1,R0
 MOV R0,#lineed_buf_replace
 BL lineeditor_append		; add to history list.
 MOV R0,R1

 MOV R5,#15
 BL icon_getind			; R0=address of search string
 BLVC new_search_string
 BVS c_ret
 TEQ R0,#0
 BEQ s_ret			; string was null so abort
 MOV R5,#16
 BL icon_getind			; R0=address of replace string
 BLVC new_replace_string
 BVS c_ret

 BL get_NextBox			; next box
 LDR R0,[R7,#8]			; window handle
 CMN R0,#1
 BEQ noneedtokill$l		; already dead
 LDR R0,[R7,#4]			; flags
 BIC R0,R0,#1<<5		; don't delete at any time now
 STR R0,[R7,#4]
 ADD R1,R7,#8
 SWI XWimp_DeleteWindow
 BVS s_ret			; delete the window
 MOV R14,#-1
 STR R14,[R7,#8]		; window handle
noneedtokill$l

 ; BL close_leaf_window		; next box ; doesn't work

 BL default_replace		; set up R1,R3,R4,R5
 BLVC replace_data		; perform replace (or start in sel case)
 B s_ret

 DCD 1+c_CanCreateSubMenu+c_MovesInputOrKeymap
Replace
 MOV R0,#t_ReplaceBox
 B open_leaf_com

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Next box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

; cw_NextBox
;  FNJSR
;  ;MOV R14,#-1
;  ;STR R14,[R6,#24]
;  ;LDR R14,[R6,#28]
;  ;ORR R14,R14,#1<<20 ; hopeful input focus...
;  ;STR R14,[R6,#28]
;  ;;BL create_open_leaf
;  ;SWI &107
;  ;BL close_leaf_window
;  ;LDR R0,[R7,#4]			; dubious flags
;  ;BIC R0,R0,#&3F
;  ;ORR R0,R0,#6
;  ;STR R0,[R7,#4]			; dubious flags
;  FNRTS

lc_NextBox
; B c_ret ; DEBUG !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

 CMP R5,#&180
 BGE passonafnkeythencret
; BL give_dbox_focus
 ADR R0,keys$l
 BL key_to_click
 ; BPL nokeypered			; ???
 CMP R5,#9
 BCS c_ret
 CMP R5,#2
 BLCS slab_icon_in_temporarily
nokeypered
; CMP R5,#9 ; MAX.
 ADD PC,PC,R5,LSL #2 ; WAS LO
 B c_ret
 B lc_Next_Replace
 B lc_Next_Skip
 B lc_Next_Last
 B lc_Next_cancel
 B lc_Next_Undo
 B lc_Next_Redo
 B lc_Next_toend
 B lc_Next_insel
 B lc_Next_tofront
keys$l = 'R',0,'M',0,'S',1,'L',2,'C',3,'Q',3,'U',4,'D',5,'T',6,'A',6,'E',6,'I',7,'F',8,'Y',0,'N',1,'!',6,0

 ALIGN

lc_Next_tofront
 FNLDR R10,car_selection	; get the selected area (to replace)
 LDR R0,[R10,#c_wind]
 CMP R0,#0
 BMI c_ret			; was s_ret (closes???)
 BL conv_wind_off		; get R8/R9
 MOVS R1,R8
 FNRTS LE			; ???
 MOV R0,#3
 BL open_a_window
; BL find_input
; BL put_caret
 LDRVC R0,[R7,#8]			; window handle

 ;FNLDR R7,tem_list,VC		; address of the template list
 ;LDRVC R7,[R7,#t_MoveBox*32+8]	; 32 bytes each entry
 FNLDR R1,wimp_block,VC
 STRVC R0,[R1]
 SWIVC XWimp_GetWindowState
 MVNVC R0,#0
 STRVC R0,[R1,#w_infront]
 SWIVC XWimp_OpenWindow
 B c_ret

give_dbox_focus
 FNJSR "R1-R5"
 LDR R0,[R7,#8]			; window handle
 MVN R1,#0
 MOV R2,#0
 MOV R3,#0
 MOV R4,#1<<25			; invisible
 MVN R5,#0
 SWI XWimp_SetCaretPosition
 FNRTS

lc_Next_Replace
 FNLDR R10,car_selection	; get the selected area (to replace)
 LDR R0,[R10,#c_wind]
 CMP R0,#0
 BMI s_ret
 BL conv_wind_off		; get R8/R9
 LDR R0,[R10,#c_off]		; offset of match start
 MOV R3,R0			; save
 LDR R1,[R10,#c_owidth]		; offset of match end
 BL replace_string		; R1=new end offset of replace string
 BLVC replace_skip
 B c_ret

lc_Next_Skip
 FNLDR R10,car_selection
 LDR R0,[R10,#c_wind]
 CMP R0,#0
 BMI s_ret
 BL conv_wind_off		; get R8/R9
 LDR R3,[R10,#c_off]		; offset of match start
 LDR R1,[R10,#c_owidth]		; offset of match end
 BL replace_skip
 B c_ret

lc_Next_Undo
 LDR R14,[R9,#f_flags]
 ORR R14,R14,#flags_UnlinkCursor
 STR R14,[R9,#f_flags]		; unlink input
 MOV R0,#1			; undo 1 step...
 MOV R1,#0			; fast undo
 BL undo_command
 LDR R14,[R9,#f_flags]		; save error pointer in R0
 BIC R14,R14,#flags_UnlinkCursor
 STR R14,[R9,#f_flags]		; relink caret
 B c_ret

lc_Next_Redo
 LDR R14,[R9,#f_flags]
 ORR R14,R14,#flags_UnlinkCursor
 STR R14,[R9,#f_flags]		; unlink input
 MOV R0,#1			; redo 1 step...
 MOV R1,#0			; fast undo???
 BL redo_command
 LDR R14,[R9,#f_flags]		; save error pointer in R0
 BIC R14,R14,#flags_UnlinkCursor
 STR R14,[R9,#f_flags]		; relink caret
 B c_ret

;E R3=offset of start of match R1=offset of end of match
;  R8/R9=current window
;X Search and replace restarted after this match
;  (which may have been replaced)

replace_skip
 FNJSR "R1-R5"
 PUSH "R1,R3,R8-R9"
 BL default_replace		; set up R1,R3-R5 default values
 PULL "R1,R3,R8-R9"		; restore the window currently on
 CMP R4,#0
 SUBPL R3,R1,#1			; next offset to start from
 MOV R1,#0			; still doing selective replace
 BL replace_data
 FNRTS

lc_Next_toend
 FNLDR R10,car_selection
 LDR R0,[R10,#c_wind]
 CMP R0,#0
 BMI s_ret
 BL conv_wind_off		; get R8/R9
 LDR R0,[R9,#f_flags]
 ANDS R0,R0,#&110
 BNE lc_Next_Replace
 ;B lc_Next_Replace
 BL default_replace		; set up search flags and direction
 ;FNLDR R10,car_selection
 ;LDR R0,[R10,#c_wind]
 ;CMP R0,#0
 ;BMI s_ret
 ;BL conv_wind_off		; get R8/R9
 MOV R1,#1			; global replace now
 LDR R3,[R10,#c_off]		; start of the match
 SUB R3,R3,R4			; move back/(fwd?) one
 BL clear_selection
 BVS c_ret
 BL replace_data		; global replace from here
 B lc_Dying_cancel

lc_Next_insel
 FNLDR R10,car_selection
 LDR R0,[R10,#c_wind]
 CMP R0,#0
 BMI warn1$l
 BL conv_wind_off		; get R8/R9
 LDR R0,[R9,#f_flags]
 ANDS R0,R0,#&110
 BNE lc_Next_Replace
 BL default_replace		; set up search flags and direction
 MOV R1,#2			; global replace now
 BL set_up_cur_pos_at_sel
; LDR R3,[R10,#c_off]		; start of the match
 BL replace_data		; global replace from here
; BL lc_simulate_select_to_close ; Make sure replace dbox closes (TT).
 B s_ret			; finished

set_up_cur_pos_at_sel
 FNJSR "R1,R2,R8,R9,R10"
 BL get_selection
 CMP R4,#0
 MOVPL R3,R1
 ADDMI R3,R1,R2
 SUB R3,R3,R4			; move back/(fwd?) one
; MOV R0,R3
; FNLDR R10,car_cursor
; BL goto_file_offset
 FNRTS

warn1$l
 BL Beep
 B c_ret			; finished?

lc_Next_Last			; Entire routine by Tim Tyler
 FNLDR R10,car_selection	; get the selected area (to replace)
 LDR R0,[R10,#c_wind]		;
 CMP R0,#0			;
 BMI s_ret			;
 BL conv_wind_off		; get R8/R9
 LDR R0,[R10,#c_off]		; offset of match start
 MOV R3,R0			; save
 LDR R1,[R10,#c_owidth]		; offset of match end
 BL replace_string		; R1=new end offset of replace string
; fall through

lc_Next_cancel
 BL clear_selection
 B lc_Dying_cancel

lc_simulate_select_to_close
 FNLDR R0,wimp_menub		; get button status
 BIC R0,R0,#1			; adjust click now closes dbox...
 FNSTR R0,wimp_menub		; by simulating a select-click...
 MOV PC,R14

get_NextBox
 FNind R7,t_NextBox
 MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Dzap box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cw_DzapBox
 FNJSR
 LDR R0,[R7,#4]			; current flags
 ORR R0,R0,#2			; down increase
 BIC R0,R0,#4			; redraw
 STR R0,[R7,#4]			; flags
 BLVC cw_Dzap_getregs		; set up registers
 BLVC cw_Dzap_fsinfo		; fill in filing system info 0,1,9,10
 BLVC cw_Dzap_sht		; fill in rest sector/head/track
 BLVC cw_Dzap_bigdisk
 FNRTS

;X R10=wimp_dzap R11=0 if dzap data not valid. Otherwise
;  R11=bytes per sector(B) R4=num of heads(H) R3=sectors per track(S) |

cw_Dzap_getregs
 FNJSR
 FNLDR R10,wimp_dzap
 LDR R11,[R10,#&28]
 CMP R11,#1
 FNRTS LO
 LDREQB R11,[R10,#&40]		; log2 sector size
 MOVHI R11,#0
 MOV R0,#1
 MOV R11,R0,LSL R11		; bytes per sector
 LDRB R4,[R10,#&42]		; heads
 LDRB R3,[R10,#&41]		; sectors per track
 FNRTS

 LOCAL

; fills in fs name, number of floppies, number of HD's and current drive

cw_Dzap_fsinfo
 FNJSR
 MOV R5,#0
 BL icon_getind
 MOV R1,R0
 MOV R2,R10
 BL strcopy			; filing system name
 LDR R0,[R10,#&2C]		; number floppies
 CMP R0,#4
 BHI invalid$l			; *can* have four floppy drives!
 MOV R5,#9
 BL icon_buffernum
 LDRVC R0,[R10,#&30]		; number HDS
 MOVVC R5,#10
 BLVC icon_buffernum
 FNRTS VS
 LDR R0,[R10,#&20]		; current drive
 CMP R0,#8
 MOVCS R0,#0
 MOV R5,#1
 BL icon_buffernum
 FNRTS
invalid$l
 ADR R0,icons$l
 BL icons_clear
 FNRTS
icons$l = 9,10,1,&FF
 ALIGN

 LOCAL

;E R4=number of heads R3=sectors per track R11=bytes per sector
;  fill in sector/head/track etc

cw_Dzap_sht
 FNJSR
 TEQ R11,#0
 BEQ invalid$l
 FNLDR R0,wimp_dzap ; hmm...
 LDR R0,[R0,#&28]
 TEQ R0,#2
 LDREQB R0,[R10,#&40]		; log2 sector size
 MOVEQ R11,R11,LSL R0
 MOV R0,R11
 MOV R5,#13
 BL icon_buffernum		; byt per sect
 MOVVC R0,R3
 MOVVC R5,#16
 BLVC icon_buffernum		; sects per track
 MOVVC R0,R4
 MOVVC R5,#18
 BLVC icon_buffernum		; heads
 MOVVC R5,#24
 BLVC icon_getind
 FNRTS VS
 FNLDR R14,wimp_dzap ; hmm...
 LDR R0,[R10,#&28]
 TEQ R0,#2
 BNE smalldisk$l
 PUSH "R4"
 LDR R4,[R10,#&50]		; disk size (low)
 LDR R0,[R10,#&64]		; disk size (high)
 BL icon_bufferhex16
 LDMFD R13!,{R4}
 B donesize$l
smalldisk$l
 LDR R0,[R10,#&50]		; disk size
 BL icon_bufferhex
donesize$l
 MUL R0,R11,R3			; bytes per track (one head)
 MUL R1,R0,R4			; bytes per track (all heads)
 LDR R0,[R10,#&50]		; disc size
 SWI XZapRedraw_Divide ; BL div_mod	; R0=number of tracks
 MOVVC R5,#21
 BLVC icon_buffernum		; number of tracks
 LDRVC R4,[R10,#&24]		; current disc address
 MOVVC R0,R4
 MOVVC R5,#5
 BLVC icon_bufferhex		; current addr
 MOVVC R0,R4			; disc address
 BLVC conv_addr_sht		; convert to sht R0-R3
 MOVVC R0,R1
 MOVVC R5,#2
 BLVC icon_buffernum		; current sector
 MOVVC R0,R2
 MOVVC R5,#3
 BLVC icon_buffernum		; current head
 MOVVC R0,R3
 MOVVC R5,#4
 BLVC icon_buffernum		; current track
 MOVVC R5,#27
 BLVC icon_getind
 FNRTS VS
 MOVVC R1,R0			; dest icon 27
 ADDVC R2,R10,#&56		; source
 MOVVC R3,#12			; dest buffer size
 MOVVC R4,#&20			; space terminates
 BLVC strmove			; copy in disc name
 BLVC icon_redraw			; update
 FNRTS
invalid$l
 ADR R0,icons$l
 BL icons_clear
 FNRTS
icons$l = 13,16,18,21,24,27,2,3,4,5,&FF
 ALIGN

; displays icon: 'disk address' or 'sector address'

cw_Dzap_bigdisk
 FNJSR
 LDR R1,[R6,#84]		; no. of icons
 CMP R1,#33
 FNRTS LT		; do nothing if no icon 33 (sector addr)
 FNLDR R1,wimp_dzap
 LDR R1,[R1,#&28]
 TEQ R1,#2
 MOV R0,#1
 MOVEQ R1,#0
 MOVNE R1,#1
 PUSH "R1"
 MOV R5,#25
 BL icon_alter
 MOV R0,#1
 LDMFD R13!,{R1}
 EOR R1,R1,#1
 MOV R5,#33
 FNPULL
 B icon_alter


 LOCAL

lc_DzapBox
 ADR R0,keys$l
 BL key_to_click
 BLMI slab_icon_in_temporarily
 TEQ R5,#28
 BEQ lc_Dzap_readsect
 TEQ R5,#29
 BEQ lc_Dzap_readtrk
 TEQ R5,#30
 BEQ lc_Dzap_readdisc
 TEQ R5,#31
 BEQ s_ret			; quit
 TST R4,#1
 BEQ c_ret			; enter not clicked
 CMP R5,#1
 BLO lc_Dzap_newname ; 0
 BEQ lc_Dzap_newdrive
 CMP R5,#5 ; 2,3,4
 BLO lc_Dzap_newsht
 BEQ lc_Dzap_newaddr
 B c_ret
keys$l = 'S',28,'T',29,'D',30,'Q',31,'C',31,0
 ALIGN

lc_Dzap_newname
 FNLDR R11,wimp_dzap
 MOV R5,#0
 BL icon_getind
 MOV R1,R11
 MOV R2,R0
 BL strcopy			; copy in new name
 MOV R0,#0
 STR R0,[R11,#&28]		; disc record not valid
 MVN R0,#0
 STR R0,[R11,#&2C]		; drives not valid
 MOV R10,#2
 BL call_filecore		; do _Drives
 BVS c_ret
 STR R0,[R11,#&20]
 STR R1,[R11,#&2C]
 STR R2,[R11,#&30]		; save number of drives
 B lc_Dzap_getrecord

lc_Dzap_newdrive
 FNLDR R11,wimp_dzap
 LDR R0,[R11,#&2C]
 CMP R0,#0
 BMI c_ret			; ignore if no valid filesys
 MOV R0,#0
 STR R0,[R11,#&28]		; no valid disc record
 MOV R5,#1
 BL lc_buffernum
 BVS c_ret
 CMP R0,#8
 MOVCS R0,#0
 STR R0,[R11,#&20]		; new current drive
; B lc_Dzap_getrecord
; fall through...

lc_Dzap_getrecord
 FNLDR R0,wimp_data		; NB WB used by call_filecore
 LDR R1,[R11,#&20]		; current drive
 ADD R1,R1,#'0'
 STRB R1,[R0]
 MOV R1,#0
 STRB R1,[R0,#1]		; get disc specifier at R0
 ADD R1,R11,#&40		; pointer to block
 MOV R10,#5
 BL call_filecore		; do _DescribeDisc
 BVS c_ret
 LDR R0,[R11,#&64]
 CMP R0,#0
 LDREQ R0,[R11,#&50]
 CMPEQ R0,#&20000000 ; 512MB
 MOVHI R0,#2			; big disk
 MOVLS R0,#1			; small disk
 STR R0,[R11,#&28]		; disc record valid
 BL cw_Dzap_bigdisk
 B c_ret

lc_Dzap_newsht
 BL cw_Dzap_getregs
 TEQ R11,#0
 BEQ c_ret			; no valid disc record
 MOV R5,#4
 BL lc_buffernum
 BVS c_ret
 MOV R2,R0			; save track number
 MOV R5,#3
 BL lc_buffernum
 BVS c_ret
 MLA R2,R4,R2,R0		; total num trkheads
 MOV R5,#2
 BL lc_buffernum
 BVS c_ret
 MLA R2,R3,R2,R0		; total num sectors
 MUL R0,R2,R11			; address
 STR R0,[R10,#&24]
 B c_ret

lc_Dzap_newaddr
 BL cw_Dzap_getregs
 TEQ R11,#0
 BEQ c_ret			; no valid disc record
 MOV R5,#5
 BL lc_buffernum
 BVS c_ret
 STR R0,[R10,#&24]
 B c_ret

lc_Dzap_readsect
 FNLDR R11,wimp_dzap
 LDR R0,[R11,#&24]
 BL conv_addr_sht
 MOV R0,#0
 BL conv_sht_addr
 MOV R4,R0			; start address
 ADD R1,R1,#1			; next sector
 MOV R0,#0
 BL conv_sht_addr
 MOV R5,R0			; end address
 B lc_Dzap_read

lc_Dzap_readtrk
 FNLDR R11,wimp_dzap
 LDR R0,[R11,#&24]
 BL conv_addr_sht
 MOV R0,#0
 MOV R1,#0
 BL conv_sht_addr
 MOV R4,R0			; start address
 ADD R2,R2,#1			; next head
 MOV R0,#0
 BL conv_sht_addr
 MOV R5,R0			; end address
 B lc_Dzap_read

lc_Dzap_readdisc
 FNLDR R11,wimp_dzap
 LDR R0,[R11,#&28]
 TEQ R0,#0
 BEQ c_ret			; no good
 MOV R4,#0
 LDR R5,[R11,#&50]		; disc size
; B lc_Dzap_read

lc_Dzap_read
 CMP R4,#0
 BMI c_ret			; no good
 MOV R0,R4
 BL conv_addr_str		; set up file name
 BVS c_ret
 SUB R0,R5,R4			; length of file
;
 FNLDR R1,wimp_dzap
 LDR R2,[R1,#&28]
 TEQ R2,#2
 LDREQB R2,[R1,#&40]
 MOVEQ R0,R0,LSL R2
 MOV R5,R0
;
 FNLDR R1,wimp_block		; filename
 MOV R2,#0			; load addr (was R4; isn't, due to big disks)
 MOV R3,#0			; exec address
 BL create_file_block
 MOVVC R0,#1
 STRVC R0,[R9,#f_cmode]		; dzap from this address
 STRVC R4,[R9,#f_source]
 LDRVC R0,[R9,#f_ptr]		; buffer
 MOVVC R1,R4			; start address
 MOVVC R2,R5			; length
; SUBVC R2,R5,R4		; length
 BLVC read_disc			; read in data
 BLVC create_window_block
 BLVC create_window_caret
 FNind R7,t_MoveBox,VC
 BLVC create_open_leaf
 B c_ret

 DCD 7+c_CanCreateSubMenu+c_MovesInputOrKeymap
Dzapbox
 MOV R0,#t_DzapBox
 B open_leaf_com

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Print box					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

cw_PrintBox
	MOV	R11,#0		; update all
cw_PrintBox_main
 FNJSR
 FNLDR	R10,wimp_print
 CMP	R8,#0			; new code...!
 BEQ	someuserbits$l		; new code...!
 LDR	R0,[R8,#w_width]	; width in chars
 BL	pnt_fit_pages
 FNRTS	VS
 LDR	R0,[R8,#w_height]	; total number of lines
 LDR	R2,[R10,#print_lines_per_column]
 LDR	R1,[R10,#print_columns_per_page]
 MUL	R1,R2,R1		; lines per page
 SWI	XZapRedraw_Divide
 TEQ	R2,#0
 ADDNE	R0,R0,#1		; last page not empty
 STR	R0,[R10,#print_total_num_pages]

 LDR R0,[R10,#print_lines_per_column]
 MOV R5,#11
 BL icon_buffernum
 LDRVC R0,[R10,#print_total_num_pages]
 MOVVC R5,#13
 BLVC icon_buffernum
 FNRTS VS
 TEQ R11,#0
 BNE no_userbits$l		; R11!=0 - don't alter editable bits
someuserbits$l
 LDR R0,[R10,#print_columns_per_page]
 MOV R5,#5
 BL icon_buffernum
 LDRVC R0,[R10,#print_start_page]
 ADDVC R0,R0,#1
 MOVVC R5,#1
 BLVC icon_buffernum
 LDRVC R0,[R10,#print_stop_page]
 MOVVC R5,#0
 BLVC icon_buffernum
 FNRTS VS
 FNLDR R11,opt_flags
 TST R11,#flags_FancyPrintSideways
 MOVEQ R5,#7
 MOVNE R5,#8
 BL icon_select
 MVNVC R0,R11,LSR#16
 MOVVC R5,#6
 BLVC icon_set
 FNRTS VS
no_userbits$l
 PUSH "R6,R7"
 SWI XPDriver_Info
 LDMFD R13!,{R6,R7}
 MOVVS R3,#0
 ADRVS R0,nodriver$l
 BLVS lookup_token_R0
 MOVVS R4,R0
 MOV R0,#1<<22
 MOVVC R1,#0
 MOVVS R1,#1<<22
 MOV R2,#0
 MOV R5,#9
 ;BVS nonamesoquit$l
 BL icon_alter
 FNRTS VS
 LDR R0,[R6,#88+2*32+16]
 TST R0,#256
 MOVNE R0,R4
 MOVNE R5,#15			; name icon...
 BLNE icon_bufferstr
 FNRTS VS
 LDR R0,[R6,#88+3*32+16]
 TST R0,#&F000
 MOVNE R0,R3
 MOVNE R5,#14			; colour icon...
 BLNE icon_set
 FNRTS
;nonamesoquit$l
; BL icon_alter
; FNRTS

nodriver$l = "zap_i_nopdriver",0
	ALIGN

poll_word_pdriverchanged
	FNJSR
	MOV	R8,#0			; new code...!
	FNindw	R6,R7,t_PrintBox
	MOV	R11,#1
	BL	cw_PrintBox_main
	FNRTS	VC
	ADDS	R0,R0,#4		; also CLV...
	MOV	R1,#0
	BL	warn_user
	FNRTS

	LOCAL

lc_PrintBox
 CMP R5,#&180
 BGE passonafnkeythencret
 ADR R0,keys$l
 BL key_to_click
 ;BLMI slab_icon_in_temporarily
 TEQ R5,#9
 BEQ lc_Print_print
 TEQ R5,#7
 TEQNE R5,#8
 BEQ lc_Print_up
 TEQ R5,#6
 BEQ lc_Print_title
 TEQ R5,#10
 BEQ lc_Dying_cancel
 TEQ R5,#14
 BEQ lc_Print_colour
 TST R4,#1
 BEQ c_ret
 TEQ R5,#5
 BEQ lc_Print_newpps
 CMP R5,#1
 BEQ lc_Print_newstart
 BLO lc_Print_newend
 B c_ret
keys$l = 'V',7,'S',8,'A',6,'F',14,'C',10,'Q',10,0
 ALIGN

lc_Print_title
 FNLDR R1,opt_flags
 EOR R1,R1,#flags_FancyPrintNoTitle
 FNSTR R1,opt_flags
 MVN R0,R1,LSR#16
 BL icon_set
 BLVC cw_PrintBox_main
 B c_ret

lc_Print_colour
 MOV R0,#0
 MOV R1,#1<<21
 BL icon_alter
 B c_ret

lc_Print_up
 FNLDR R1,opt_flags
 TEQ R5,#8
 BICNE R1,R1,#flags_FancyPrintSideways
 ORREQ R1,R1,#flags_FancyPrintSideways
 FNSTR R1,opt_flags
 BL icon_select
 MOVVC R11,#1
 BLVC cw_PrintBox_main
 B c_ret

lc_Print_newpps
 BL lc_buffernum
 BVS c_ret
 FNLDR R10,wimp_print
 CMP R0,#1
 MOVLT R0,#1
 STR R0,[R10,#print_columns_per_page]
 B c_ret

lc_Print_newstart
 BL lc_buffernum
; BVS c_ret
 FNLDR R10,wimp_print,VC
 SUBVC R0,R0,#1
 STRVC R0,[R10,#print_start_page]
 B c_ret

lc_Print_newend
	MOV	R5,#0
	BL	lc_buffernum
	BVS	c_ret
	FNLDR	R10,wimp_print
	STR	R0,[R10,#print_stop_page]
	TST	R4,#4			; return if (s)Tab
	BNE	c_ret
lc_Print_print
	SWI	XPDriver_Info
	BVS	s_ret
	FNind	R7,t_PrintBox
	LDR	R0,[R7,#8]
	FNLDR	R1,wimp_block
	MOV	R14,#14			; colour icon...
	STMIA	R1,{R0,R14}
	SWI	XWimp_GetIconState
	LDRVC	R0,[R1,#24]
	MOVVS	R0,#0
	AND	R0,R0,#1<<21
	BL	print_file
	B	s_ret

	DCD	1+c_CanCreateSubMenu+c_MovesInputOrKeymap
Printfile
	FNJSR
	BL	pnt_get_pagesize
	FNLDR	R10,wimp_print,VC
	MOVVC	R0,#0
	STRVC	R0,[R10,#print_start_page]
	MOVVC	R0,#&10000
	STRVC	R0,[R10,#print_stop_page]
	MOVVC	R0,#t_PrintBox
	BLVC	open_leaf_com
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Quick box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cw_QuickBox
 FNJSR
 FNLDR R10,wimp_print
 LDR R2,[R8,#w_stline]
 LDR R0,[R10,#print_start_line]
 ADD R0,R0,R2			; first line
 MOV R5,#1
 BL icon_buffernum
 LDRVC R0,[R10,#print_stop_line]
 ADDVC R0,R0,R2
 SUBVC R0,R0,#1			; last line (inc)
 MOVVC R5,#0
 BLVC icon_buffernum
 FNLDR R11,opt_flags,VC
 MVNVC R0,R11,LSR#18		; quick title flag
 MOVVC R5,#4
 BLVC icon_set
 FNRTS

 LOCAL
lc_QuickBox
 CMP R5,#&180
 BGE passonafnkeythencret
 TEQ R5,#5
 BEQ lc_Quick_print
 TEQ R5,#3
 CMNNE R5,#'Q'	; Quit
 CMNNE R5,#'C'	; Quit
 BEQ lc_Dying_cancel
 TEQ R5,#4
 CMNNE R5,#'A'	; pAge...?
 CMNNE R5,#'W'	; With
 CMNNE R5,#'P'	; Page
 CMNNE R5,#'H'	; Header
 BEQ lc_Quick_title
 TST R4,#1
 BEQ c_ret			; no adjust (which represents Return in an icon)
 CMP R5,#1
 BEQ lc_Quick_newstart
 BLO lc_Quick_newend ; R5=0
 B c_ret

lc_Quick_title
 FNLDR R1,opt_flags
 EOR R1,R1,#flags_QuickPrintNoTitle
 FNSTR R1,opt_flags
 MVN R0,R1,LSR#18
 MOV R5,#4
 BL icon_set
 B c_ret

lc_Quick_newstart
 BL newstart$l
 B c_ret

newstart$l
 FNJSR
 MOV R5,#1
 BL lc_buffernum
 FNLDR R10,wimp_print,VC
 LDRVC R2,[R8,#w_stline]
 SUBVC R0,R0,R2
 STRVC R0,[R10,#print_start_line]
 FNRTS

newend$l
 FNJSR
 MOV R5,#0
 BL lc_buffernum
 FNLDR R10,wimp_print,VC
 LDRVC R2,[R8,#w_stline]
 SUBVC R0,R0,R2
 ADDVC R0,R0,#1
 STRVC R0,[R10,#print_stop_line]
 FNRTS

lc_Quick_newend
 BL newend$l
 BVS c_ret
 TST R4,#4
 BNE c_ret
 B doprint$l

lc_Quick_print
 BL newstart$l
 BLVC newend$l
 BVS c_ret
doprint$l
 MOV R5,#5
 MOV R2,#&FF00
 BL slab_icon_in_temporarily
 BL quick_print
 MOV R5,#5
 MOV R2,#&FF00
 BL slab_icon_in_temporarily
 B s_ret

 DCD 1+c_CanCreateSubMenu+c_MovesInputOrKeymap
Quickprint
 FNJSR
 FNLDR R10,wimp_print
 MOV R0,#0
 STR R0,[R10,#print_start_line]
 LDR R0,[R8,#w_height]
 STR R0,[R10,#print_stop_line]
 MOV R0,#t_QuickBox
 BL open_leaf_com
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Mzap box					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

cw_MzapBox
 FNJSR
 FNLDR R10,wimp_mzap
 LDR R0,[R10]			; task handle
 TEQ R0,#0
 BNE setup$l			; already set up
 FNLDR R0,wimp_task		; set up for zap
 STR R0,[R10]
 FNLDR R0,env_top
 SUB R0,R0,#&8000
 LDR R14,zap$l
 STMIB R10,{R0,R14}
setup$l
 MOV R0,#&8000
 MOV R5,#0
 BL icon_bufferhex
 LDRVC R0,[R10,#4]
 ADDVC R0,R0,#&8000
 MOVVC R5,#1
 BLVC icon_bufferhex
 FNRTS VS
 MOV R5,#2
 BL icon_getind
 MOV R1,R0
 ADD R2,R10,#8
 MOV R3,#16
 MOV R4,#&1F
 BL strmove
 BL icon_redraw
 FNRTS
zap$l FNS |zap$|

lc_MzapBox
 TEQ R5,#7
 BEQ lc_Mzap_read
 TEQ R5,#8
 BEQ lc_Mzap_dragsprite
 TST R4,#1
 BEQ c_ret
 TEQ R5,#1
 BNE c_ret

	TST	R4,#4			; ignore if (s)Tab
	BNE	c_ret
lc_Mzap_read
 MOV R5,#0
 BL lc_buffernum
; BVS c_ret
 MOVVC R2,R0			; start address
 MOVVC R5,#1
 BLVC lc_buffernum
 BVS c_ret
 MOV R4,R0			; end address
 CMP R2,R4
 BEQ s_ret			; nothing to read
 BHI endbeforestart$l

 LDR R0,[R6,#140]		; addr of string for icon 1.
 LDRB R1,[R0]
 CMP R1,#'+'
 ADDEQ R4,R4,R2			; for &8000 "+&400"

 MOV R3,#&8000			; exec address
 FNLDR R10,wimp_mzap
 ADD R1,R10,#8			; task name
 SUB R0,R4,R2			; length
 BL create_file_block
; BVS c_ret
 LDRVC R0,[R9,#f_ptr]		; buffer
 MOVVC R1,R2			; start address
 MOVVC R2,R4			; end address
 BLVC read_memory
 BLVC create_window_block
 BLVC create_window_caret
 B s_ret
endbeforestart$l
	BL	Beep		; warn user
	B	c_ret		; don't close dbox

lc_Mzap_dragsprite
 TST R4,#&50			; drag mouse code? (NE if so)
 MOVNE R0,R4,LSR#4
 FNSTR R0,wimp_menub,NE		; save button status
 BLNE initiate_drag		; pick up at process_leaf_drag
 B c_ret			; which calls drag_MzapBox

 LOCAL

; R7=window index and sprite dragged onto this box WB

drag_MzapBox
	FNJSR
	FNLDR	R1,wimp_block
	SWI	XWimp_GetPointerInfo	; window handle #12 icon #16
	FNRTS	VS
	LDR	R0,[R1,#12]		; window handle
	BL	convert_wind_handle	; is it one of my text windows?
	BCC	text$l
	MOV	R0,#1<<30		; send code 19
	LDR	R2,[R1,#12]		; window
	MOV	R3,#20			; message length
	LDR	R4,[R1,#16]		; icon
	BL	message_send
	FNRTS	VS
a$l					; got the task handle in R0
	STR	R0,[R1,#20]		; task handle of TW dropped on
	LDR	R0,d$l
	MOV	R2,#0			; broadcast
	MOV	R3,#24			; length
	ADR	R5,task_nameis
	BL	message_send
	FNRTS
d$l	DCD	&400C6+(&9<<28)		; msg TaskNameRq + want any replies
text$l
	BL	conv_wind_off		; set R8/R9 for this window

	MOV	R0,#einterrogate_ModeType
	MOV	R11,#e_interrogate
	LDRB	R10,[R8,#w_format]	; mode number
	BL	call_given_mode
	TEQ	R0,#modetype_TaskWindow	; is this a taskwindow?
	FNLDR	R0,wimp_task,NE		; Zap's task handle
	BNE	a$l
	LDR	R0,[R9,#f_source]		; info block
	LDR	R0,[R0]			; task handle of child task
	B	a$l

	LOCAL

; message TaskNameRq has been replied to

task_nameis
	FNJSR
	LDR	R0,d$l
	TEQ	R2,R0
	FNRTS	NE
	FNLDR	R10,wimp_mzap
	LDR	R0,[R1,#20]		; task handle
	LDR	R14,[R1,#24]		; slot size
	STMIA	R10,{R0,R14}
	ADD	R2,R1,#28			; source
	ADD	R1,R10,#8			; dest
	MOV	R3,#24			; len
	MOV	R4,#&1F
	BL	strmove			; copy in task name
	FNind	R7,t_MzapBox
	BL	leaf_update			; update the box on screen
	FNRTS
d$l	DCD &400C7			; TaskNameIs

	DCD	7+c_CanCreateSubMenu+c_MovesInputOrKeymap
Mzapbox
	MOV	R0,#t_MzapBox
	B	open_leaf_com

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Undo box					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

lc_UndoBox
	TEQ	R5,#3
	CMNNE	R5,#'C'
	BEQ	s_ret
	TEQ	R5,#2
	CMNNE	R5,#'T'
	BNE	c_ret
	BL	turn_off_undo
	B	s_ret

;E R8/R9=window
;X Undo box opened

open_UndoBox
	FNJSR	R7
	FNind	R7,t_UndoBox
	BL	create_open_leaf
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Load box						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cw_LoadBox
	TEQ	R9,#0			; SJA (was R8)
	MOVEQ	PC,R14			; file discarded (after save)
 FNJSR
	LDR	R0,[R9,#f_name]
	; MOV R1,#&100			;-(
	; BL heap_ensure		; make room for new name
	; STRVC R0,[R9,#f_name]
	MOVVC	R1,#1
	BLVC	cw_bufferstr		; copy (as its address may change)
	FNRTS

;E	R4=mouse buttons R5=icon num R6=window data R7=index R8/R9
;X CS if window should be closed (unless adjust pressed)

lc_LoadBox
	TEQ	R5,#3
	CMNNE	R5,#'E'
	BEQ	lc_Load_dual
	TEQ	R5,#4
	CMNNE	R5,#'O'
	BEQ	lc_Load_overwrite
	TEQ	R5,#5
	CMNNE	R5,#'C'
	CMNNE	R5,#'Q'			; (TT)
	BEQ	lc_Dying_cancel
	TEQ	R5,#6			; (TT)
	CMNNE	R5,#'F'			; (TT)
	CMNNE	R5,#'T'			; (TT)
	BEQ	lc_Load_BringtoFront	; (TT)
	B	c_ret

lc_Load_BringtoFront
	ADR	R10,lc_OpeningSubroutine
	BL	do_eachwindow
	B	lc_Dying_cancel

lc_Load_overwrite
	BL	discard_file
	BVS	c_ret			; So R8/R9 no longer valid
lc_Load_dual
	MOV	R5,#1			; icon with file name
	BL	icon_getind		; find address in R0=fname
	BL	install_new_file	;
	B	lc_Dying_cancel

get_LoadBox
	FNind	R7,t_LoadBox
	MOV	PC,R14

lc_OpeningSubroutine
	FNJSR
	MOV	R0,#3
; MOV R1,R8
	BL	open_a_window
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SaveOBox						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cw_SaveOBox
	TEQ	R9,#0			; SJA (was R8)
	MOVEQ	PC,R14			; file has been discarded (after save
	FNJSR
	LDR	R0,[R9,#f_proposed_name]
	CMP	R0,#0
	LDREQ	R0,[R9,#f_name]
	; MOV R1,#&100			;-(
	; BL heap_ensure		; make room for new name
	; STRVC R0,[R9,#f_name]
	MOVVC	R1,#0
	BLVC	cw_bufferstr		; copy (as its address may change)
	FNRTS

lc_SaveOBox
	TEQ	R5,#3
	CMNNE	R5,#'O'
	BEQ	lc_SaveO_overwrite
	TEQ	R5,#5
	CMNNE	R5,#'C'
	BEQ	lc_Dying_cancel
	B	c_ret

lc_SaveO_overwrite
	MOV	R0,#0
	BL	save_file_buffer
	B	s_ret

get_SaveOBox
	FNind	R7,t_SaveOBox
	MOV	PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SaveCBox						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cw_SaveCBox ; E R6 => window defn yielding filename R9, FILE...
	TEQ	R9,#0
	MOVEQ	PC,R14		; file has been discarded (after save)
	FNJSR
	LDR	R0,[R9,#f_proposed_name]
	CMP	R0,#0
	LDREQ	R0,[R9,#f_name]
	MOVVC	R1,#0
	BLVC	cw_bufferstr	; copy :-( as its address may change)
	FNRTS

lc_SaveCBox
	TEQ	R5,#3
	CMNNE	R5,#'S'
	BEQ	lc_SaveC_overwrite
	TEQ	R5,#5
	CMNNE	R5,#'C'
	BEQ	lc_Dying_cancel
	B	c_ret

lc_SaveC_overwrite
	BL	save_file_date
	B	s_ret

get_SaveCBox
	FNind	R7,t_SaveCBox
	MOV	PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SaveSCBox						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

cw_SaveSCBox ; E R6 => window defn
	FNJSR
	FNLDR	R0,wimp_data
	LDR	R0,[R0,#&88]	; somewhere... eeeeeek - the undo buffer?
	MOV	R1,#0
	BL	cw_bufferstr	; copy (as its address may change)
	FNRTS

lc_SaveSCBox
	TEQ	R5,#3
	CMNNE	R5,#'S'
	BEQ	lc_SaveSC_overwrite
	TEQ	R5,#5
	CMNNE	R5,#'C'
	BEQ	lc_Dying_cancel
	B	c_ret

lc_SaveSC_overwrite
	BL	get_SaveSCBox
	MOV	R5,#0
	BL	icon_getind			; R0=address of icon data
	BL	simply_save_selection
	B	s_ret

	LOCAL

get_SaveSCBox
	FNind	R7,t_SaveSCBox
	MOV	PC,R14

	DCD	1 + c_CanCreateSubMenu + c_TickableMenuEntry	; No R10, but opens a window + shade.
TotalSel
	FNJSR
	MOV	R7,R2			; Remember R2.
	MOV	R4,R8
	MOV	R5,R9
	BL	shade_no_sel		; ...?
	BCS	WCError
	BL	findtotal$l
	FNRTVC	VS			; don't report an error, just stop ...
;	MOV	R5,#&100		; the value...
	MOV	R2,R7
;	MOV	R7,#16 ; don't close menu...?!?!?
	MOV	R11,#2
	B	WCOutput		; this wants R14 stacked for it ...

; \X VS if user pressed escape
findtotal$l
	FNJSR	"R7,R11" ;R1=sel off R2=sel len R8/R9=sel
	BL	long_op_on		; hourglass, enable escape
	SUB	R6,R1,#1
	ADD	R7,R1,R2
	MOV	R5,#0			; returned total...
start$l
	MOV	R3,#&37			; maxlen
	MOV	R11,#0			; not-in-number
	FNLDR	R4,wimp_block		; Where to write string.
;	LDR R2,[R9,#f_len]		; len
totalloop$l
	SWI	XOS_ReadEscapeState	; does the user want to break out? - on error, ignore
	BCS	stop$l
	ADDS	R6,R6,#1		; clv here!
	CMP	R6,R7
	BCS	exit$l
	MOV	R0,R6
	BL	cln_readc
;	TEQ R11,#0
	CMP	R0,#33
;	CMPCS	R11,#1
	BCC	dontjustcontinue$l
	TEQ	R0,#'#'
	TEQNE	R0,#','
	TEQNE	R0,#'''
	TEQNE	R0,#'"'
	TEQNE	R0,#'{'
	TEQNE	R0,#'['
	BEQ	dontjustcontinue$l
	MOV	R11,#1
	STRB	R0,[R4],#1
	SUBS	R3,R3,#1
	BPL	totalloop$l
	; error of overflow...
	BEQ	evaluateit$l
dontjustcontinue$l
	CMP	R11,#1
;	BEQ	evaluateit$l
	BNE	start$l
	; fall through...
evaluateit$l
;	MOV	R0,#13
;	STRB	R0,[R4],#1
	MOV	R14,#0
	STRB	R14,[R4],#1
	FNLDR	R0,wimp_block		; Where to write string.
nofullstops$l
	LDRB	R1,[R4],#-1
	CMP	R1,#'.'
	STREQB	R14,[R4,#1]
	CMP	R4,R0
	BGT	nofullstops$l

	ADD	R1,R0,#&40
	MOV	R2,#&40
	SWI	XOS_EvaluateExpression
	MOVVS	R2,#0
	CMP	R1,#0
	MOVNE	R2,#0
	ADD	R5,R5,R2		; hopefully...
	B	start$l
exit$l	BL	long_op_off		; hourglass off, disable escape
	FNRTS				; exit
stop$l	BL	long_op_off
	FNRTV				; exit, setting V

	DCD	1 + c_CanCreateSubMenu + c_TickableMenuEntry	; No R10, but opens a window + shade.
WCSel
	FNJSR
	MOV	R7,R2			; Remember R2.
	MOV	R4,R8
	MOV	R5,R9
	BL	shade_no_sel
	BCS	WCError
	;CMPCS	 R7,#16
	;LDMEQFD	R13!,{PC}

	; MOV	R1,#7			; car_selection (caret block ptr).
	; FNcall	Zap_ReadVar		; get caret block ptr in R0.
	; LDR	R1,[R0,#c_off]	; _FILE_ offset of selection start.
	; LDR	R2,[R0,#c_owidth]	; _FILE_ offset of selection end.
	; CMP	R1,R2
	; BEQ	WCError
	; SWI	XOS_WriteI+7
	ADD	R2,R1,R2
	LDR	R3,[R9,#f_splito]
	LDR	R4,[R9,#f_ptr]
	LDR	R5,[R9,#f_splits]
	ADD	R6,R3,R4		; R6 = split addr

	CMP	R1,R3			; is start in bottom or top half?
	ADDCS	R1,R1,R5		; if top, skip split.
	ADD	R1,R1,R4		; convert to absolute addr.

	CMP	R2,R3			; is end in bottom or top half?
	ADDCS	R2,R2,R5		; if top, skip split.
	ADD	R2,R2,R4		; convert to absolute addr.

	B	WC_Primitive

	DCD	1 + c_CanCreateSubMenu		; No R10, but opens a window.
WC
	FNJSR
	; BL get2_WCBox ; set up r0.
	; BL open_leaf_com
	;
	; LDMFD	R13!,{PC}

	MOV	R7,R2			; Remember R2.

	LDR	R1,[R9,#f_ptr]		; Address of start of file.
	LDR	R3,[R9,#f_bufl]		; Size of file (including split).
	ADD	R2,R1,R3		; Address of end of file.
	LDR	R6,[R9,#f_splito]	; Split offset.
	ADD	R6,R6,R1		; Address of split.

	LDR	R3,[R9,#f_len]		; Size of file (without split).
	TEQ	R3,#0			; Empty file?
	MOVEQ	R11,#0			; write "0 words" not "0 s" :-) - sja
	BEQ	WCOutput		; Yup.
	; FALLTHROUGH
WC_Primitive
	; \E	R1 = start addr
	;	R2 = end addr
	;	R6 = split addr

	MOV	R4,#0			; 0 => out of word, 1 => in word
	MOV	R5,#0			; Word count.
	MOV	R11,#0			; words flag...
loop$l ; Word count loop.

	; Mind the gap!
	CMP	R1,R6			; Are we at the split?
	LDREQ	R0,[R9,#f_splits]	; Jump it!
	ADDEQ	R1,R1,R0

	; Are we finished?
	CMP	R1,R2
	BGE	WCOutput

	; Get the next character in the file.
	LDRB	R0,[R1],#1

	; Is it an end of word marker?
	CMP	R0,#' '

	; R0 <= 32 -- end of word.
	MOVLE	R4,#0			; Out of word.
	BLE	loop$l

	; R0 > 32 -- not end of word.
	CMP	R4,#0			; Out of word?
	MOVEQ	R4,#1			; Not any more -- in word.
	ADDEQ	R5,R5,#1		; Increment word count.

	B	loop$l

WCnoselmessage
	FNS	("zap_NoSelToAnalyse")

WCError
	MOV	R8,R4
	MOV	R9,R5
	CMP	R7,#15;CMPCS
	ADRLO	R0,WCnoselmessage
	MOVLO	R1,#warn_UseMessageTrans
	BLLO	warn_user
	FNRTS

;E R2 = input to command eg 16 R5 = number to be displayed R11=type
; R7 = 16...?
; R11 =	0
;	1 - matches
;	2 - total
toWCOutput
	FNJSR
WCOutput
	; Convert word count to string.
	MOV	R0,R5			; Number to convert (word count).
;	FNLDR	R1,wimp_block		; Where to write string.
;	ADD	R1,R1,#60		; um, where exactly...?
	ADR	R1,WCString
	MOV	R2,#16			; Size of buffer.
	SWI	XOS_ConvertSpacedCardinal4
	FNRTS	VS		; Return on error.
	BL	cnvrtspcsinstr
	FNRTS	VS		; Return on error.
	; Catenate " word".
	CMP	R11,#2
	MOVLO	R0,#' '
	MOVHS	R0,#0
	STRB	R0,[R1],#1

	ADD	R3,R2,#WCString_End-WCString-16
	MOV	R2,R1
	CMP	R11,#1
	ADRLO	R14,back$l
	BLO	words$l
	BLEQ	matches$l
back$l	BL	lookup_token

	; If Zap just wants a window handle, return.
	; If not, close the menu now ...
	CMP	R7,#16
	BEQ	dontclose$l
	MOV	R1,#-1
	SWI	XWimp_CreateMenu
	FNRTS	VS
	; This isn't necessary, because we call Wimp_CreateMenu below
	; which will do this job for us if necessary. However doing this
	; now fails if the last menu was this window - because we've
	; already deleted this window, and a bug in the wimp blows up
	; when it tries to close a deleted window (I think it's just
	; failing to track the delete window through the menu phase.)
	; - sja

dontclose$l
	MOV	R0,#t_WCBox
	MOV	R2,#16
	BL	open_leaf_com ; returns handle in R0...

	BL	adjusttitledata

	CMP	R7,#16
	FNRTS	EQ

	MOV R7,R0

	; what about adjust clicks on a menu entry...?
	MOV R0,#4
	FNSTR R0,wimp_menub		; get button state
	; that's what...

	; Open the window at the pointer.
	SWI	XOS_Mouse		; Where is the pointer?
	SUB	R2,R0,#150
	ADD	R3,R1,#50
	MOV	R1,R7
	SWI	XWimp_CreateMenu
	; Return.
	FNRTS

words$l
	TEQ	R5,#1
	ADREQ	R1,wordone_text$l
	ADRNE	R1,wordmany_text$l
	MOV	PC,R14

matches$l
	TEQ	R5,#1
	ADREQ	R1,matchone_text$l
	ADRNE	R1,matchmany_text$l
	MOV	PC,R14

wordone_text$l		= "zap_wc_word",0
wordmany_text$l		= "zap_wc_words",0
matchone_text$l		= "zap_wc_match",0
matchmany_text$l	= "zap_wc_matches",0
	ALIGN

adjusttitledata
	FNJSR	"R0,R1,R2"
	FNLDR	R1,wimp_block		; Where to write string.
	ADD	R1,R1,#80
	STR	R0,[R1]
	SWI	XWimp_GetWindowInfo
	LDR	R1,[R1,#76]		; inditected title bar text pointer
	CMP	R11,#1
	ADRLT	R0,wordcounttb
	ADREQ	R0,matchcounttb
	ADRGT	R0,totalcounttb
	BL	lookup_token_R0
	MOV	R2,R0
	BL	strcopy
	FNRTS

WCString
	=	10,"Help! I'm trapped!",10
WCString_End

wordcounttb
	=	"zap_i_wc",0

matchcounttb
	=	"zap_i_mc",0

totalcounttb
	=	"zap_i_tc",0
	ALIGN

cw_WCBox
;	FNLDR	R0,wimp_block		; Where to write string.
;	ADD	R0,R0,#60
	ADR	R0,WCString
	STR	R0,[R6,#(88+20)]
	MOV	PC,R14

lc_WCBox			; hmm.
	B	c_ret

;get_WCBox
; FNind R0,t_WCBox
; MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Mini buffer						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

cw_MiniBuf
	FNJSR
	FNLDR	R0,opt_flags
	TST	R0,#flags_PopupMinibuffer
	LDR	R0,[R6,#28]		; get window flags
	BICEQ	R0,R0,#1<<26		; remove title if popup
	ORREQ	R0,R0,#1<<5		; it is a pane if popup
	ORRNE	R0,R0,#1<<26		; add title if permanent
	BICNE	R0,R0,#1<<5		; not a pane if permanent
	STR	R0,[R6,#28]
	FNRTS

lc_MiniBuf
	;MOV	R1,R7
	;BL	get_MiniBuf
	;TEQ	R1,R7
	;BNE	c_ret	; minibuffer...?
	TST	R4,#5
	BNE	lc_Mini_select
	TST	R4,#2
	BNE	lc_Mini_histmenu
	TST	R4,#&50
	BNE	lc_Mini_drag
	B	lc_Mini_select
	;SWI	&107
	;B	c_ret

lc_Mini_drag
	FNLDR	R1,wimp_block
	LDR	R0,[R7,#8]
	STR	R0,[R1]			; window handle
	SWI	XWimp_GetWindowState
	BVS	c_ret
	LDR	R0,[R1,#w_maxx]		; max x
	SUB	R0,R0,R2
	CMP	R0,#32			; near right hand edge?
	MOVLE	R0,#2			; drag window size
	MOVGT	R0,#1			; drag window posn
	STMIB	R1,{R0,R2}
	STR	R2,[R1,#16]		; min/max x
	STR	R3,[R1,#12]
	STR	R3,[R1,#20]		; min/max y
	SWI	XWimp_DragBox
	B	c_ret

lc_Mini_select
	MOV	R5,R2
	MOV	R0,#129
	MOV	R1,#255
	MOV	R2,#255
	SWI	XOS_Byte
	BVS	c_ret
	BCS	leave_caret$l
	FNLDR	R1,wimp_block
	LDR	R0,[R7,#8]
	STR	R0,[R1]			; window handle
	SWI	XWimp_GetWindowState
	BVS	c_ret
	LDR	R3,[R1,#4]		; left edge
	LDR	R1,[R1,#20]		; x scroll offset
	SUB	R2,R5,R3
	ADD	R2,R2,R1		; calculate xpos
	BL	checkfortextop
	MOVLT	R5,R2,LSR #4		; system font - use xpos/16
	BLT	sysfont$l
	SUB	R3,R2,#8		; adjust for left margin
	ADD	R2,R3,R3,LSL #3
	ADD	R2,R2,R3,LSL #4		; xpos*25
	MOV	R2,R2,LSL #4		; xpos*400 (ie. millipoints)
	MOV	R3,#0
	FNLDR	R1,mini_ptr
	SWI	XFont_FindCaret
	BVS	c_ret
sysfont$l
	FNLDR	R1,mini_mark
	FNLDR	R2,mini_len
	CMP	R5,R1
	MOVLO	R5,R1
	CMP	R5,R2
	MOVHI	R5,R2
	FNSTR	R5,mini_off
leave_caret$l
	BL	minibuffer_setcaret		; gain input focus
	B	c_ret

get_MiniBuf
	FNind	R7,t_MiniBuf
	MOV	PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Colour box					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R6/R7=colour box (can corrupt all) (colour number in flags b16+)

cw_ColourBox
	FNJSR
	LDR	R2,[R7,#4]
	MOV	R2,R2,ASR#16		; zap colour number (sign saved)
	CMP	R2,#-1
	STR	R2,local_colournum
	FNLDR	R0,opt_minibac,LT
	FNLDR	R0,opt_minifor,EQ
	BLE	a$l
	MOV	R0,#-1
	TEQ	R8,#0
	FNLDRB	R1,opt_format,EQ
	LDRNEB	R1,[R8,#w_format]	; mode
	BL	mode_colour		; read palette entry
	FNRTS	VS
a$l
	FNSTR	R0,tem_colour		; current pal. entry of palette box
	BL	colour_3percent
	BL	select_style_icons
	FNRTS

local_colournum
	DCD	0

select_style_icons
	FNJSR	"R11"
	LDR	R6,[R7]
	FNLDR	R11,tem_colour	; current palette entry of palette box
	AND	R11,R11,#&E9		; current style mask.
	MOV	R5,#46
	TEQ	R11,#&00
	MOVEQ	R0,#1
	MOVNE	R0,#0
	BL	icon_set
	MOV	R5,#47
	TST	R11,#&20
	MOVNE	R0,#1
	MOVEQ	R0,#0
	BL	icon_set
	MOV	R5,#48
	TST	R11,#&40
	MOVNE	R0,#1
	MOVEQ	R0,#0
	BL	icon_set
	MOV	R5,#49
	TST	R11,#&80
	MOVNE	R0,#1
	MOVEQ	R0,#0
	BL	icon_set
	MOV	R5,#50
	TST	R11,#&1
	MOVNE	R0,#1
	MOVEQ	R0,#0
	BL	icon_set
	MOV	R5,#51
	TST	R11,#&8
	MOVNE	R0,#1
	MOVEQ	R0,#0
	BL	icon_set
	LDR	R14,local_colournum
	CMP	R14,#9
	BCS	tst_for_maybe_noss
	CMP	R14,#0
	CMPNE	R14,#1
	CMPNE	R14,#3
	CMPNE	R14,#4
	CMPNE	R14,#5
	CMPNE	R14,#6
; MOVS R14,#-1			; ALWAYS ALWAYS ALWAYS ALWAYS ALWAYS ALWAYS
no_tst_for_maybe_noss
 ;BLNE tst_for_maybe_noss
	LDR	R3,[R7]			; window data
	MOVNE	R14,#&4000
	MOVEQ	R14,#&40
	STR	R14,[R3,#12]
	MOVNE	R1,#0
	MOVEQ	R1,#(1<<22)
	MOV	R5,#46
	MOV	R0,#(1<<22)
	BL	icon_alter
	MOV	R5,#47
	MOV	R0,#(1<<22)
	BL	icon_alter
	MOV	R5,#48
	MOV	R0,#(1<<22)
	BL	icon_alter
	MOV	R5,#49
	MOV	R0,#(1<<22)
	BL	icon_alter
	MOV	R5,#50
	MOV	R0,#(1<<22)
	BL	icon_alter
	MOV	R5,#51
	MOV	R0,#(1<<22)
	BL	icon_alter
	FNRTS

;E R14 = colour number...
tst_for_maybe_noss
	CMP	R14,#-1
	MOVLES	R14,#0
	BEQ	no_tst_for_maybe_noss	; return EQ ; noness$l
	PUSH	"R2,R9-R11"
	; LDR R14,[R7,#4]
	; MOV R14,R14,ASR#16		; zap colour number (sign saved)
	MOV	R0,#15
	; LDR R1,local_colournum
	MOV	R1,R14
	MOV	R11,#e_interrogate
	CMP	R8,#0
	; BEQ someness$l
	LDRNEB	R10,[R8,#w_format]		; mode number
	FNLDRB	R10,opt_format,EQ
	BL	call_given_mode
	; MOV R0,#0 ; !!!!!!!!!!!!!!!!!!!!!!!!!!
	TST	R0,#2
	; BEQ noness$l
someness$l
	PULL	"R2,R9-R11"
	; MOVS R14,#-1			; return NE
	B	no_tst_for_maybe_noss
;noness$l
; PULL "R2,R9-R11"
; MOVS R14,#0				; return EQ
; B no_tst_for_maybe_noss

;E R0=24 bit palette entry R6/R7=colour box
;X Percentage values updated from this

colour_3percent
	FNJSR	"R1,R5"
	MOV	R1,R0,LSR#8
	AND	R0,R1,#&FF
	MOV	R5,#19			; red
	BL	colour_percent
	MOVVC	R1,R1,LSR#8
	ANDVC	R0,R1,#&FF
	MOVVC	R5,#20			; green
	BLVC	colour_percent
	MOVVC	R0,R1,LSR#8
	MOVVC	R5,#21			; blue
	BLVC	colour_percent
	FNRTS

;E R4=mouse buttons R5=icon num R6=window data R7=index R8/R9
;X CS if window should be closed (unless adjust pressed)

lc_ColourBox
	CMP	R5,#7
	BLE	c_ret			; ignore clicks on the dummy icons
	SUB	R0,R5,#27		; icons 27-34=wimp colours 0-7
	CMP	R0,#8
	MOVCC	R5,R0			; map 27-34 to 0-7 (unsigned)
	CMP	R5,#&10
	BCC	ColourBox_wimp
	CMP	R5,#46
	RSBHSS	R14,R5,#51
	BLHS	setitifsimple$l
	TEQ	R5,#25
	BEQ	ColourBox_set
	CMP	R5,#46
	RSBHSS	R14,R5,#51
	BHS	ColourBox_setfonts
	TEQ	R5,#16
	TEQNE	R5,#17
	TEQNE	R5,#18
	BEQ	ColourBox_bar		; click/drag on one of the bars
	SUB	R0,R5,#35
	CMP	R0,#6
	BCC	ColourBox_adjust	; click on an up/down adjust icon
	TST	R4,#1+(1<<31)
	BEQ	c_ret			; no return/move
	SUB	R0,R5,#19
	CMP	R0,#3
	BLO	ColourBox_enter
	B	c_ret

setitifsimple$l
	FNJSR
	TEQ	R5,#46
	BLEQ	clearothers$l
	BL	icon_getflags		; get flags data...
	AND	R0,R0,#&1F << 16	; ESG
	TEQ	R0,#(1 << 16)
	FNRTS	EQ			; ???
	FNLDR	R0,tem_colour
	TEQ	R5,#47
	MOVEQ	R11,#&20
	TEQ	R5,#48
	MOVEQ	R11,#&40
	TEQ	R5,#49
	MOVEQ	R11,#&80
	TEQ	R5,#50
	MOVEQ	R11,#&1
	TEQ	R5,#51
	MOVEQ	R11,#&8

	TST	R0,R11
	MOVEQ	R0,#1
	MOVNE	R0,#0
	BL	icon_set		; select it no matter what...???
; SWI &107
	FNRTS

clearothers$l
	FNJSR	"R5"
	MOV	R5,#47
	MOV	R0,#0
	BL	icon_set		; de-select it no matter what...
	MOV	R5,#48
	MOV	R0,#0
	BL	icon_set		; de-select it no matter what...
	MOV	R5,#49
	MOV	R0,#0
	BL	icon_set		; de-select it no matter what...
	MOV	R5,#50
	MOV	R0,#0
	BL	icon_set		; de-select it no matter what...
	MOV	R5,#51
	MOV	R0,#0
	BL	icon_set		; de-select it no matter what...
	FNRTS

; R0=0-5 for the adjust number R4=adjust button state
; colour inc/decremented

ColourBox_adjust
	TST	R4,#1
	EORNE	R0,R0,#1		; reverse the direction
	FNLDR	R2,tem_colour		; current colour state
	MOV	R14,R0,LSR#1		; 0-2 for colour number
	ADD	R5,R14,#16		; icon number of corresponding bar
	CMP	R5,#17
	MOVLT	R2,R2,LSR#8
	MOVEQ	R2,R2,LSR#16
	MOVGT	R2,R2,LSR#24
	AND	R2,R2,#&FF
	TST	R0,#1
	SUBEQ	R2,R2,#1
	ADDNE	R2,R2,#1			; new colour
	CMP	R2,#0
	MOVLE	R2,#0
	CMP	R2,#&FF
	MOVGT	R2,#&FF			; round
	MOV	R0,R2
	BL	colourbox_newvalue
	B	c_ret

 LOCAL

ColourBox_bar				; started dragging one of the bars?
	TST	R4,#&50
	BEQ	click$l
	ADR	R2,sub$l		; drag bar sub
	MOV	R3,R5			; icon number as parameter
	MOV	R4,#1			; call all the time
	BL	icon_drag
	B	c_ret
click$l
	MOV	R11,R5
	BL	sub$l			; update bar position
	B	c_ret
sub$l
	FNJSR	"R1-R7"
	FNindw	R6,R7,t_ColourBox	; window
	MOV	R5,R11			; icon handle was data
	FNLDR	R1,wimp_block
	SWI	XWimp_GetPointerInfo
	LDMVCIA	R1,{R2,R3}		; x and y
	BLVC	icon_get_coord		; convert R2/R3 to icon relative
	FNRTS	VS
	ADD	R0,R6,#88+8		; icon data + 8
	LDR	R1,[R0,R5,LSL #5]!	; + icon num
	LDR	R0,[R0,#-8]
	SUB	R1,R1,R0		; icon width
	MOV	R0,R2,LSL#8		; offset *256
	SWI	XZapRedraw_Divide	; BL div_mod
	BL	colourbox_newvalue
	FNRTS

 LOCAL

ColourBox_enter
	BL	icon_getind		; R0=string to sort out
	MOV	R1,#0			; clear buffer
a$l
	ADD	R1,R1,R1,LSL#2
	MOV	R1,R1,LSL#1		; *10
	LDRB	R14,[R0],#1
	CMP	R14,#&20
	BCC	e$l
	BEQ	a$l
	TEQ	R14,#'.'
	BEQ	d$l
	SUB	R14,R14,#'0'
	CMP	R14,#10
	ADDCC	R1,R1,R14
	BCC	a$l
	B	e$l
d$l					; after decimal point
	LDRB	R14,[R0],#1
	SUB	R14,R14,#'0'
	CMP	R14,#10
	ADDCC	R1,R1,R14
e$l					; R1=value %*10 = thousandths
	MOV	R0,R1,LSL#8		; mult by 256
	MOV	R1,#1004
	SWI	XZapRedraw_Divide	; BL div_mod
	CMP	R2,#504
	ADDCS	R0,R0,#1		; round up
	SUB	R5,R5,#3
	BL	colourbox_newvalue
	FNRTS	VS
	TEQ	R5,#18			; not the last icon
	BNE	c_ret
	TST	R4,#1
	BNE	ColourBox_set		; was a return
	B	c_ret

 LOCAL

;E R0=proportion (0-approx &FF)
;  R5=icon of bar that's been dragged or altered R6=window R7=colourbox
;X tem_colour and icons updated #

colourbox_newvalue
	FNJSR	"R1-R3,R5"
	CMP	R0,#&FF			; round
	MOVCS	R0,#&FF			; the colour value
	MOV	R3,R0			; save
	ADD	R1,R0,R0,LSL#8
	ADD	R1,R1,R1,LSL#16		; quadrouple up
	CMP	R5,#17
	MOVLT	R14,#&0000FF00
	MOVEQ	R14,#&00FF0000
	MOVGT	R14,#&FF000000		; get mask
	FNLDR	R2,tem_colour
	AND	R1,R1,R14
	AND	R0,R2,R14		; old colour
	TEQ	R0,R1
	FNRTS	EQ			; no change (don't update - flicker)
	BIC	R2,R2,R14
	ORR	R2,R2,R1
	FNSTR	R2,tem_colour		; written new colour
	BL	icon_update		; update the bar
	MOVVC	R0,R3
	ADDVC	R5,R5,#3
	BLVC	colour_percent		; update the written icon contents
	BLVC	icon_update
	BLVC	icon_checkcaret
	MOVVC	R5,#26
	BLVC	icon_update		; and the colour square
	FNRTS

ColourBox_wimp				; set wimp colour
	FNSTR	R5,tem_colour		; set the colour
	MOV	R0,#1
	ADD	R1,R12,#red_flags
	ADD	R2,R12,#tem_colour
	MOV	R3,R2
	MOV	R4,#1
	SWI	XZapRedraw_CreatePalette; convert to a wimp colour
	; BVS c_ret
	FNLDR	R0,tem_colour,VC
	BICVC	R0,R0,#&FF
	ORRVC	R0,R0,#&10		; base style
	FNSTR	R0,tem_colour,VC
	BLVC	set_colourbox
	B	c_ret

	LOCAL

ColourBox_setfonts
	MOV	R14,#0
	STR	R14,[R8,#w_txtn]
	BL	set_colourbox
	; BLVC update$l
	B	c_ret			; gently...

;update$l
; FNJSR "R1-R12"
; FNLDR R1,wimp_block
; LDR R14,[R8,#w_handle]
; STR R14,[R1]
; SWI XWimp_GetWindowState
;; BLVC redraw_window
; FNRTS

; MOVVC R2,#0
; LDRVC R3,[R8,#w_height]
; BLVC update_cache
; ; update_window ; update_whole_window
; BLVC create_redraw_data	; create new style redraw data
; FNRTS VS
; MOVVC R4,R0			; largest character used
; BLVC invert_carets		; add in the caret data
; BLVC redraw_area		; display on screen area
; FNRTS

ColourBox_set			; make current colour the chosen one
	BL	set_colourbox
	B	s_ret

set_colourbox			; make tem_colour the chosen one + update
	FNJSR
	LDR	R6,[R7]			; window data
	MOV	R2,#0
	MOV	R5,#47
	BL	lc_read
	TST	R0,#(1<<21)
	ORRNE	R2,R2,#&20
	MOV	R5,#48
	BL	lc_read
	TST	R0,#(1<<21)
	ORRNE	R2,R2,#&40
	MOV	R5,#49
	BL	lc_read
	TST	R0,#(1<<21)
	ORRNE	R2,R2,#&80
 ;FNLDR R0,tem_colour			; new colour
	MOV	R5,#50
	BL	lc_read
	TST	R0,#(1<<21)
	ORRNE	R2,R2,#&1
	MOV	R5,#51
	BL	lc_read
	TST	R0,#(1<<21)
	ORRNE	R2,R2,#&8
	FNLDR	R0,tem_colour		; new colour
	BIC	R0,R0,#&E9		; ensure low bits of byte 0 are clear
	ORR	R0,R0,R2		; add in style information...
	LDR	R2,[R7,#4]		; flags
	MOV	R2,R2,ASR#16		; colour number
	CMP	R2,#0
	BMI	mini$l			; minibuffer
	TEQ	R8,#0
	FNLDR	R4,opt_format,EQ
	LDRNE	R4,[R8,#w_format]	; format word
	AND	R1,R4,#&FF			; mode
	CMP	R2,#9
	BGE	a$l			; just this mode
	TST	R4,#format_ColoursSetsGivenMode
	MOVEQ	R1,#-1			; do all modes
a$l
	BL	mode_colour_all		; set the colour(s)
	FNRTS	VS
	TEQ	R8,#0
	BEQ	end$l			; done it
	BL	create_palette		; update the window palette
	 ; BLVC setup_fontmc
	BL	blat_cache_of_this_window
	BLVC	update_whole_window
	BVC	end$l
	FNRTS

mini$l
	CMP	R2,#-1
	FNSTR	R0,opt_minibac,LT
	FNSTR	R0,opt_minifor,EQ
	BL	minibuffer_update	; redraw
	FNRTS	VS
end$l				; changed the colour (now update the box)
	BL	leaf_update
	MOVVC	R5,#16
	BLVC	icon_update
	MOVVC	R5,#17
	BLVC	icon_update
	MOVVC	R5,#18
	BLVC	icon_update
	MOVVC	R5,#26
	BLVC	icon_update
	FNRTS

;E R0=colour number to create it on (as a menu window)
;    -2=minibuffer background -1=minibuffer foreground +ve=window colour num
;  R8/R9=window acting on or 0 for iconbar menu
;X R0=window handle of the colour box (not opened yet)

create_ColourBox
	FNJSR	"R1,R7"
	MOV	R0,R0,LSL#16		; flags contain colour num << 16
	ORR	R0,R0,#6		; arrow direction, don't redraw
	FNind	R7,t_ColourBox
	STR	R0,[R7,#4]		; write the flags
	MOV	R1,#0			; opened off a menu
	BL	create_leaf_window
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Move box (dzap)				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

lc_MoveBox
	ADR	R0,keys$l
	BL	key_to_click
	BPL	nokeypered$l
	CMP	R5,#3
	BLCS	slab_icon_in_temporarily
nokeypered$l
	SUB	R5,R5,#3
	CMP	R5,#8
	ADR	R14,c_ret$l
	MOVLO	R1,#1
	MOVLO	R2,#0
	ADDLO	PC,PC,R5,LSL #2
c_ret$l
	B	c_ret
	B	Lastcylinder
	B	Nextcylinder
	B	Lasttrack
	B	Nexttrack
	B	Lastsector
	B	Nextsector
	B	lc_MoveBox_tofront
	B	s_ret			; close it...
lc_MoveBox_tofront
	FNJSR
	BL	Tofront
	FNLDR	R7,tem_list,VC		; address of the template list
	LDRVC	R7,[R7,#t_MoveBox*32+8]	; 32 bytes each entry
	FNLDR	R1,wimp_block,VC
	STRVC	R7,[R1]
	SWIVC	XWimp_GetWindowState
	MVNVC	R0,#0
	STRVC	R0,[R1,#w_infront]
	SWIVC	XWimp_OpenWindow
	FNRTS		;
keys$l = 'X',3,'C',4,'R',5,'T',6,'A',7,'S',8,0
	ALIGN

	DCD	1+c_CanCreateSubMenu+c_MovesInputOrKeymap+c_TickableMenuEntry
Movebox
	TEQ	R2,#15
	BEQ	disknav_tick
	LDR	R0,[R9,#f_cmode]
	TEQ	R0,#1			; is it a dzap created file?
	MOVNE	PC,R14
	MOV	R0,#t_MoveBox
	B	open_leaf_com

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clone box					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	DCD	7+c_CanCreateSubMenu+c_MovesInputOrKeymap
Clonebox
	MOV	R8,#0
	MOV	R9,#0
	MOV	R0,#t_CloneBox
	B	open_leaf_com

lc_CloneBox
	CMP	R5,#&180
	BGE	passonafnkeythencret
	TST	R4,#2
	MOVNE	R5,#4
	SUB	R5,R5,#4
	CMP	R5,#5
	ADDLO	PC,PC,R5,LSL #2
	B	c_ret
	B	lc_CloneBox_menu
	B	lc_CloneBox_create
	B	lc_CloneBox_delete
	B	lc_CloneBox_hide
	B	lc_Dying_cancel

	LOCAL

lc_CloneBox_menu
	BL	recreate_the_leaf_window
	BVS	c_ret
	ADR	R0,clone$l
	ADR	R1,build$l
	MOV	R2,#0
	ADR	R3,click$l
	MOV	R4,#16
	FNLDR	R8,ext_clones
	B	lc_build_menu
clone$l	FNS	("zap_m_clone")
build$l	FNJSR	"R1-R2,R5"
	MOV	R5,R0
	LDR	R2,[R8],#4
	TEQ	R2,#0
	MOVEQ	R0,#-1
	FNRTS	EQ			; reached the end of the list
	MOV	R1,R5			; buffer for string
	BL	strcopy			; copy it in
	LDR	R0,[R8,#-4]		; index -> mode name
	FNRTS
click$l	MOV	R1,R10
	B	CloneBox_show

lc_CloneBox_create
	FNind	R7,t_CloneCrBox
	BL	create_open_leaf
	LDRVC	R0,[R7,#8]		; window handle
	MOVVC	R1,#2
	MOVVC	R2,#0
	MOVVC	R3,#0
	MVNVC	R4,#0
	MVNVC	R5,#0
	SWIVC	XWimp_SetCaretPosition
	B	c_ret

lc_CloneBox_delete
	MOV	R5,#2
	BL	icon_getind
	MOV	R1,R0
	MOV	R2,#0
	BL	remove_clone_mode_entry
	BLVC	CloneBox_findaclone
	B	c_ret

lc_CloneBox_hide
	MOV	R5,#2
	BL	icon_getind
	MOV	R5,R0
	MOV	R1,R0
	MOV	R2,#1
	BL	remove_clone_mode_entry
	MOVVC	R0,R5
	BLVC	CloneBox_shade
	B	c_ret

	LOCAL

cw_CloneBox
	FNJSR
	MOV	R5,#2			; clone name icon
	BL	icon_getind
	BL	test_mode_name
	TEQ	R0,#0
	BMI	findaclone$l
	MOV	R2,R0
	BL	CloneBox_isthisaclone
	FNPULL	NE			; OK, we have a clone...
	LDRNE	R0,[R1,#e_title*2]
	BNE	CloneBox_shade
findaclone$l
	FNPULL
;fall through to CloneBox_findaclone

	LOCAL

CloneBox_findaclone
	FNJSR
	MOV	R2,#-1
loop$l	ADD	R2,R2,#1
	CMP	R2,#max_mode		; tried all mode numbers?
	BHS	no$l
	MOV	R0,R2
	BL	CloneBox_isthisaclone
	BEQ	loop$l			; no - try next mode number
	LDR	R1,[R1,#2*e_title]	; get mode name
	FNPULL
	B	CloneBox_show
no$l	FNLDR	R1,ext_clones
	LDR	R1,[R1]
	FNPULL
; fall through to CloneBox_show

	LOCAL

;E R0->mode name
CloneBox_show
	FNJSR	"R2,R6,R7"
	FNindw	R6,R7,t_CloneBox	; window
	BL	find_clone_mode_entry
	MOV	R4,R1
	MOV	R5,#3
	BL	icon_bufferstr
	MOVVC	R0,R1
	MOVVC	R5,#2
	BLVC	icon_bufferstr
	FNRTS	VS
	MOV	R0,R4
	BL	test_mode_name
	TEQ	R0,#0
	MOVMI	R0,R4
	BMI	shade$l
	BL	read_mode
	LDR	R0,[R1,#2*e_title]
shade$l	BL	CloneBox_shade
	FNRTS

;E R0->mode name, or null
;X icons (un)shaded appropriately
CloneBox_shade
	MOVS	R1,R0
	FNJSR	"R1"
	MOV	R0,#1<<22
	MOVEQ	R1,#1<<22
	MOVNE	R1,#0
	MOV	R5,#4
	BL	icon_alter	; menu icon
	MOVVC	R0,#1<<22
	MOVVC	R5,#6
	BLVC	icon_alter	; 'delete' icon
	FNRTS	VS
	LDR	R0,[R13]
	TEQ	R0,#0
	BLNE	test_mode_name
	CMP	R0,#0
	MOV	R0,#1<<22
	MOVLE	R1,#1<<22	; OK since mode 0 (Text) is never a clone
	MOVGT	R1,#0
	MOV	R5,#7
	BL	icon_alter	; 'hide' icon
	FNRTS	VS
	LDR	R0,[R13]
	TEQ	R0,#0
	FNRTS	NE
	MOV	R5,#2
	BL	icon_clear	; clone name
	MOVVC	R5,#3
	BLVC	icon_clear	; clone base name
	FNRTS

;E R0=R2=mode
;X R1=0 or -> linked table; NE if mode is a clone (R0=base)
CloneBox_isthisaclone
	FNJSR
	BL	read_mode
	TEQ	R0,#0
	LDRNE	R0,[R1,#d_clonebasemode]
	TEQNE	R0,R2
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clone creation box				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

lc_CloneCrBox
	CMP	R5,#&180
	BGE	passonafnkeythencret
	TST	R4,#2
	MOVNE	R5,#4
	ADR	R0,keys$l
	BL	key_to_click
	SUB	R5,R5,#4
	CMP	R5,#3
	ADDLO	PC,PC,R5,LSL #2
	B	c_ret
	B	lc_CloneCrBox_menu
	B	lc_Dying_cancel
	B	lc_CloneCrBox_create
keys$l	=	13,6,0
	ALIGN

	LOCAL

lc_CloneCrBox_menu
	ADR	R0,title$l
	ADR	R1,build$l
	MOV	R2,#0
	ADR	R3,click$l
	MOV	R4,#16
	MOV	R8,#0
	MOV	R9,#0
	B	lc_build_menu
title$l	FNS	("zap_m_mode")
build$l	FNJSR	"R1-R2,R5"
	MOV	R10,R0			; save buffer address
	ADD	PC,PC,R9,LSL #2
	FNRTS
	B	mode$l
	B	clone$l
	B	unloaded$l
mode$l	CMP	R8,#max_mode
	ADDEQ	R9,R9,#1
	FNLDR	R8,ext_clones,EQ	; list of clone modes
	BEQ	clone$l
	MOV	R0,R8
	BL	read_mode
	ADD	R8,R8,#1
	TEQ	R0,#0
	LDRNE	R0,[R1,#2*e_mode]
	TSTNE	R0,#emode_MayBeCloned
	BEQ	mode$l
	LDR	R0,[R1,#d_clonebasemode]
	ADD	R0,R0,#1
	TEQ	R0,R8
	BNE	mode$l
	LDR	R2,[R1,#2*e_title]	; mode name
	MOV	R1,R10
	MOV	R10,R2
	BL	strcopy
	MOV	R0,R10			; index -> mode name
	FNRTS
clone$l	LDR	R2,[R8],#4
	TEQ	R2,#0
	ADDEQ	R9,R9,#1
	FNLDR	R8,ext_modes,EQ		; list of external modes
	BEQ	unloaded$l
	LDRB	R1,[R6,#11]
	EOR	R1,R1,#15		; set to blue
	STRB	R1,[R6,#11]
	MOV	R1,R10
	BL	strcopy
	LDR	R0,[R8,#-4]		; index -> mode name
	FNRTS
loaded$l
	MOV	R0,R8
	BL	str_len
	ADD	R8,R8,R0
	ADD	R8,R8,#12
	BIC	R8,R8,#3
unloaded$l
	LDR	R14,[R8]
	TEQ	R14,#0
	MOVEQ	R0,#-1
	FNRTS	EQ			; reached the end of the list
	MOV	R0,R8
	BL	test_mode_name
	TEQ	R0,#0
	BPL	loaded$l
	MOV	R0,R8
	BL	str_len
	ADD	R11,R8,R0
	ADD	R11,R11,#12		; skip terminator, flags & offset
	BIC	R11,R11,#3		; align
	LDR	R0,[R11,#-8]
	TST	R0,#1<<31
	BNE	loaded$l		; if flags unspecified, don't list
	TST	R0,#emode_MayBeCloned
	BEQ	loaded$l		; if not cloneable, don't list
	LDRB	R1,[R6,#11]
	BIC	R1,R1,#2		; set menu entry to grey-5
	STRB	R1,[R6,#11]
	MOV	R1,R10
	MOV	R2,R8
	BL	strcopy
	MOV	R0,R8			; index -> mode name
	MOV	R8,R11			; point at next name
	FNRTS
click$l	MOV	R0,R10
	MOV	R5,#3
	FNindw	R6,R7,t_CloneCrBox	; window
	B	icon_bufferstr

lc_CloneCrBox_create
	FNLDR	R1,wimp_buffer
	MOV	R5,#2
	BL	icon_getind
	MOV	R2,R0
	BL	strcopy
	MOV	R0,#32
	STRB	R0,[R1,#-1]
	MOV	R5,#3
	BL	icon_getind
	MOV	R2,R0
	BL	strcopy
	FNLDR	R0,wimp_buffer
	MOV	R2,#0
	BL	CloneCreate
	BVS	c_ret
	MOV	R5,#2
	BL	icon_getind
	BL	CloneBox_show
	B	s_ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; End of boxes list					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R7=window index (called from process_leaf_drag)
;X Can corrupt R0-R11

dispatch_drag
	FNind	R0,t_SaveBox
	TEQ	R0,R7
	BEQ	drag_SaveBox
	FNind	R0,t_DyingBox
	TEQ	R0,R7
	BEQ	drag_DyingBox
	FNind	R0,t_SaveSelBox
	TEQ	R0,R7
	BEQ	drag_SaveSelBox
	FNind	R0,t_MzapBox
	TEQ	R0,R7
	BEQ	drag_MzapBox
	MOV	PC,R14

 LOCAL

; is there a ','? zeroize it and ret ptr in R4 if so.

chkforcommainstr ; EQ if a comma found... R4= location of next.
	FNJSR	"R0"
loop$l
	LDRB	R14,[R0],#1
	CMP	R14,#32
	FNRTS	CC
	CMP	R14,#','
	BNE	loop$l
	MOV	R4,R0
	;MOVS	R14,#0
	;STRB	R14,[R0,#-1]
	;MOVS	R14,#0
	FNRTS

	LOCAL

;E R1=window block (as given by wimp) R7=window index of the leaf window
;X draw the area #

redraw_leaf_window
	FNind	R0,t_MiniBuf
	TEQ	R0,R7
	BEQ	redraw_minibuffer
	FNind	R0,t_ColourBox
	TEQ	R0,R7
	BEQ	redraw_ColourBox
	MOV	PC,R14

;E
;X icon slabbed in, redrwn, and slabbed out.

slab_icon_in_temporarily
	FNJSR	"R0-R7"
	PUSH	"R2,R5,R6,R7"
	MOV	R2,#0
	BL	icon_select
	MOV	R0,#19
	SWI	XOS_Byte
	PULL	"R2,R5,R6,R7"
	MOV	R0,#1 << 21
	MOV	R1,#0
	BL	icon_alter
	FNRTS

	END
