; Minibuffer code + filename completion + interactive help
; $Id: MiniBuff,fff,v 2.14 2002/11/16 17:30:18 christian Exp $

 GET h.ZapHeader
 GET h.Messages
 GET h.CreateFile
 GET h.Heap
 GET h.Strings
 GET h.Template
 GET h.CreateWind
 GET h.Cursors
 GET h.Commands
 GET h.Execute
 GET h.StartCode
 GET h.Boxes
 GET h.KeyBits
 GET h.LineEditor
 GET h.ModeBits

 IMPORT call_back
 IMPORT convert_key
 IMPORT process_a_key
 IMPORT get_MiniBuf
 IMPORT check_object_type
 IMPORT message_reply
 IMPORT menu_get_help
 IMPORT menu_decode
 IMPORT mode_name
 IMPORT test_forkey
 IMPORT command_primative	; not *my* spelling (DS)
 IMPORT show_key

 EXPORT warn_user
 EXPORT warn_user_token
 EXPORT minibuffer_open
 EXPORT minibuffer_ensure
 EXPORT minibuffer_ensure_open
 EXPORT minibuffer_start
 EXPORT minibuffer_writec
 EXPORT minibuffer_write
 EXPORT minibuffer_write_token
 EXPORT minibuffer_prompt
 EXPORT minibuffer_prompt_token
 EXPORT minibuffer_prompt_and_history
 EXPORT minibuffer_prompt_token_and_history
 EXPORT minibuffer_update
 EXPORT minibuffer_show
 EXPORT minibuffer_setcaret
 EXPORT minibuffer_ensurecaret
 EXPORT minibuffer_command
 EXPORT minibuffer_clear
 EXPORT minibuffer_wipe
 EXPORT minibuffer_close
 EXPORT minibuffer_eval
 EXPORT minibuffer_key
 EXPORT reopen_minibuffer
 EXPORT redraw_minibuffer
 EXPORT process_minibuffer_key
 EXPORT init_mini
 EXPORT help_help
 EXPORT find_command_help
 EXPORT display_help
 EXPORT checkfortextop

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Filename completion code				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=filename
;X R0=number of matches found R1=leaf offset
;  WD contains a list of possibilites WB WD #

; (Need more space for wildcarded name & buffer)
; (SparkFS, for example, can cope with filenames up to 47 chars)
; (raFS can probably cope with more...!)

; I think that only the most insane people have pathnames over 200 bytes.
; In any case WIMP limit is about 240,
; you only need 20 bytes + leafname for the r2 buffer
; you aren't going to get strlen(r1) + strlen(r2) + 2 over 200 very often,
; which will be when this code beeps. (I get beep in various directories
; with things > 12 characters.

 FNAME find_completions
find_completions
 FNJSR "R2-R11"
 MOV R10,R0			; save filename
 BL find_leaf_name
 FNRTS VS
 SUBS R11,R0,R10		; offset of leaf part
 FNLDR R9,wimp_block		; place to put search strings
 MOVEQ R1,#'@'
 STREQ R1,[R9]
 BEQ gotdir$l
 MOV R1,R10
 MOV R2,R9
 MOV R3,R11
 SWI XZapRedraw_MoveBytes	; copy the directory name
 ADD R1,R9,R11			; end of name
 CMP R11,#0
 BLE fi22
 LDRB R0,[R1,#-1]		; get last char of string
 TEQ R0,#'.'			; remove any dots
 SUBEQ R1,R1,#1
fi22
 MOV R0,#0
 STRB R0,[R1]			; complete directory name
gotdir$l
 FNLDR R1,wimp_print		; free...?
; ADD R1,R9,#&C0
 ADD R2,R10,R11
sc$l
 LDRB R0,[R2],#1
 CMP R0,#'"'
 CMPNE R0,#32
 STRHIB R0,[R1],#1
 BHI sc$l			; copy leaf name to WB+&C0/wimp_print
 MOV R0,#'*'
 STRB R0,[R1],#1
 MOV R0,#0
 STRB R0,[R1]			; complete wildcarded name
 FNLDR R7,wimp_data		; buffer for matches
 MOV R4,#0			; first item
 MOV R5,#&40			; buffer length...? (was &20)
 FNLDR R6,wimp_print
; ADD R6,R9,#&C0		; wildcarded name
; ADD R2,R7,#&E0		; was old place to read data entry
 ADD R2,R6,#&40			; place to read data entry
 MOV R8,#0			; number found
fi23
 MOV R0,#10
 MOV R1,R9
 MOV R3,#1			; read a match
 SWI XOS_GBPB
 MOVVS R8,#0			; found none
 BVS fi24			; can't find the directory!
 CMP R4,#0
 BMI fi24			; run out of objects
 CMP R3,#0
 BLE fi23			; didn't match - try next one
 ADD R8,R8,#1			; found a matching object
 PUSH "R2"
 ADD R2,R2,#20			; object name
 MOV R1,R7
 BL strcpy
 PULL "R2"
 LDR R0,[R2,#16]		; object type
 TST R0,#2			; directory?
 MOVNE R0,#'.'
 STRNEB R0,[R1],#1
 MOV R0,#0
 STRB R0,[R1],#1
 MOV R7,R1			; new buffer pointer
 B fi23
fi24
 ADDS R0,R8,#0			; number of matches + clv
 MOV R1,R11			; leaf name offset
 FNRTS

 LOCAL

;X filename in minibuffer completed #
 FNAME complete_filename
complete_filename
 FNJSR "R1-R4"
 FNLDR R0,mini_ptr
 FNLDR R1,mini_off
back$l
 SUBS R1,R1,#1			; find start of partial name
 BMI noback$l
 LDRB R2,[R0,R1]
 CMP R2,#'"'
 CMPNE R2,#32
 BHI back$l
noback$l
 ADD R1,R1,#1
 ADD R0,R0,R1			; filename pointer
 MOV R2,R0			; start of file name
 BL find_completions
 FNRTS VS
 MOV R3,R0			; save number of matches
 ADD R0,R2,R1			; find leaf part
 SUB R1,R0,#1
sl$l				; find length
 LDRB R14,[R1,#1]!
 CMP R14,#'"'
 CMPNE R14,#32
 BHI sl$l
 SUB R1,R1,R0			; length
 FNLDR R0,mini_ptr
 FNLDR R4,mini_off
 FNLDR R14,mini_len
fwd$l
 TEQ R4,R14			; find end of partial name...
 LDRNEB R2,[R0,R4]
 MOVEQ R2,#0
 CMP R2,#'"'
 CMPNE R2,#32
 ADDHI R4,R4,#1
 BHI fwd$l
 FNSTR R4,mini_off		; ...and put the cursor there
 FNLDR R2,wimp_data		; list of matches
 MOV R0,R3			; number of matches
 BL perform_completion
 FNRTS

perform_completion
 FNJSR
 BL add_completions
 FNRTS VS
 TEQ R0,#1
 BLNE Beep			; completion not found
 FNRTS

;E R0=number of matches found (of form "<string>*")
;  R1=length of leaf part (ie length of "<string>")
;  R2=address of buffer containing list of matches
;X R0=0 if no matches found R0=1 if unique match found
;  R0=2 if characters added R0=3 if match found but can extend
;  R0=4 if several possible extensions no chars added WB WD #
 FNAME add_completions
add_completions
 FNJSR "R1-R11"
 CMP R0,#0			; any matches found?
 FNRTS LE
 MOV R3,R1			; save length of leaf part
 MOV R8,R2			; save buffer address
 MOV R7,#0			; flags (b0=ok so far b1=added let)
 MOV R2,R0			; save number of matches
ad20
 MOV R4,R2			; count through matches
 MOV R5,R8			; list of matches
 LDRB R9,[R5,R3]		; character to try for
 SUB R6,R9,#'a'
 CMP R6,#26
 ADDCS R6,R6,#'a'
 ADDCC R6,R6,#'A'
 BIC R7,R7,#1			; match ok so far
ad21
 LDRB R0,[R5,R3]!		; move to next char
 CMP R0,#&20
 BCC ad23			; found an exact match
 SUB R14,R0,#'a'
 CMP R14,#26
 ADDCS R14,R14,#'a'
 ADDCC R14,R14,#'A'
 TEQ R6,R14
 ORRNE R7,R7,#1			; cannot match any more chars
 ADD R5,R5,#1
ad22
 LDRB R0,[R5],#1
 CMP R0,#&20
 BCS ad22
 SUBS R4,R4,#1			; onto next match?
 BGT ad21
 TST R7,#1
 BNE ad24			; didn't find letter or exact match
 ADD R3,R3,#1			; letter matched
 PUSH "R9"
 MOV R0,R13			; matched char
 BL minibuffer_write		; add the char
 ADD R13,R13,#4
 ORRVC R7,R7,#2			; we have added some letters
 BVC ad20
 FNRTS
ad23
 TEQ R2,#1
 MOVEQ R0,#1			; found unique match
 MOVNE R0,#3			; found match but can extend
 FNRTS
ad24
 TST R7,#2
 MOVEQ R0,#2			; some chars added
 MOVNE R0,#4			; couldn't add any (open buf!)
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Warning code						    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=message R1=delay or 0 for default +flags R8/R9
;  b31 => don't beep  b30 => no prefix  b29 => R0->token
 FNAME warn_user_token
warn_user_token
 ORR R1,R1,#warn_UseMessageTrans
warn_user
 FNJSR "R1-R2,R10"
 SYSLOGF "warn_user %0s", LOG_WARNING
 MOV R10,R0			; save address of message
 TST R1,#warn_DontBeep
 BLEQ Beep
 ;SWIEQ &107			; beep when opening warning window
 BLVC minibuffer_clear
 FNRTS VS
 TST R1,#warn_NoPrefix
 ADREQ R0,s$l
 BLEQ minibuffer_write_token
 FNRTS VS
 MOV R0,R10
 TST R1,#warn_UseMessageTrans
 BNE wt$l
 BL minibuffer_write
 B wn$l
wt$l
 BL minibuffer_write_token
wn$l
 BLVC minibuffer_ensure_open
 FNRTS VS
 MOV R0,#1
 STR R0,local_callbackflag
 FNLDR R0,opt_switches
 ORR R0,R0,#switch_MinibufferCloseable
 FNSTR R0,opt_switches
 BICS R1,R1,#&FF000000
 MOVEQ R1,#110			; 1s default to wait
 RSB R1,R1,#0			; negate
 ADR R2,sub$l
 SWI XOS_ReadMonotonicTime
 STR R0,local_callbacktime
 MOV R3,R0
 BL call_back
 BL restore_carets		; input not lost any more...
 FNRTS
s$l FNS ("zap_warning")
sub$l
 LDR R0,local_callbacktime
 TEQ R0,R11
 MOVNE PC,R14
 FNJSR
 MOV R0,#0
 STR R0,local_callbackflag
 FNLDR R0,opt_switches
 TST R0,#switch_MinibufferCloseable
; [ LOGGING = SYSLOG
; FNRTS EQ
; BL minibuffer_close
; SYSLOG "warn_user closed minibuffer", LOG_WARNING
; |
 BLNE minibuffer_close
; ]
 FNRTS

local_callbackflag & 0
local_callbacktime & 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Minibuffer Code					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R8/R9=window to popup on / 0 to open at default coords
;X Minibuffer window created and opened, input focus not gained #
 FNAME minibuffer_open
minibuffer_open
 FNJSR "R1-R7"
 BL get_MiniBuf
 MOV R1,#1			; not created by menu
 BL create_leaf_window		; create the window
 FNRTS VS
 BL open_mini_window
 LDR R14,local_callbacktime
 EOR R14,R14,#1<<31
 STR R14,local_callbacktime
 MOV R14,#0
 STR R14,local_callbackflag
 FNRTS

;X ensures minibuffer open / closed accoriding to opt_flags #
 FNAME minibuffer_ensure
minibuffer_ensure
 FNLDR R0,opt_flags
 MOV R0,R0,LSR#23
 ANDS R0,R0,#3
 MOVEQ PC,R14
 FNJSR "R7-R9"
 BL get_MiniBuf
 TEQ R0,#2
 BEQ mi1
 MOV R8,#0
 MOV R9,#0
 BL minibuffer_open
 FNRTS
mi1
 BL close_leaf_window
 FNRTS

;E R8/R9
;X Minibuffer is visable on screen
 FNAME minibuffer_ensure_open
minibuffer_ensure_open
 FNJSR "R7"
 BL get_wind_off		; R0=associated window
 FNLDR R14,mini_wind		; old window
 FNSTR R0,mini_wind		; new window
 BL get_MiniBuf
 TEQ R0,R14
 BEQ mi16			; same window so check if open
 FNLDR R0,opt_flags
 TST R0,#1<<23
 BEQ mi17			; popup so popup in new window
mi16
 LDR R0,[R7,#8]			; window handle
 CMN R0,#1
 BEQ mi17			; window not open
 LDR R0,[R7,#4]
 TST R0,#1<<5
 BEQ mi11			; already open
mi17
 BL minibuffer_open		; open the window
 FNRTS
mi11
 BL minibuffer_update		; so just update the contents
 FNRTS

;E R7=command number to assosiate to minibuffer contents R8/R9
;X Minibuffer created if closed / refreshed ow
;  Caret placed, line editor position reset #
 FNAME minibuffer_start
minibuffer_start
 FNJSR "R7"
 FNLDR R0,opt_switches
 BIC R0,R0,#switch_MinibufferCloseable
 FNSTR R0,opt_switches
 FNSTR R7,mini_command
 BL minibuffer_ensure_open
 BLVC get_MiniBuf
 BLVC minibuffer_setcaret	; put caret in minibuffer
 FNLDR R0,opt_switches,VC
 ORRVC R0,R0,#switch_MinibufferStatus	; save what's in buffer on a recall
 FNSTR R0,opt_switches,VC
 FNLDR R0,lineed_currentbuf,VC	; handle
 FNSTR R0,mini_lineed,VC	; make current for minibuffer
 BLVC lineeditor_reset		; reset minibuffer pointer
 FNRTS

 LOCAL

;E R0=character to write to the minibuffer
;X Single character written (screen not updated) #
 FNAME minibuffer_writec
minibuffer_writec
 FNJSR
 AND R14,R0,#&FF
 ADR R0,d$l
 STR R14,[R0]			; write whole word (with zeros)
 BL minibuffer_write
 FNRTS
d$l DCD 0

;E R0=pointer to 0 terminated string
;X String written to minibuffer with codes

;  0=terminator
;  1=move to mark
;  2=8=move cursor back
;  4=delete next char
;  5=jump to end
;  6=9=move cursor forward
;  11=clear from cursor
;  12=clear buffer
;  14=clear history (cK, oddly enough)
;  16=paste selection (cP)
;  21=clear from mark (cU)
;  23=paste to cursor (cW)
;  28=set mark
;  29=delete right to whitespace
;  30=move left to whitespace/'.'
;  31=move right to whitespace/'.'
;  127=delete char 32-126/128-255 insert char
;  all others ignored. Screen not updated #
 FNAME minibuffer_write
minibuffer_write
 FNJSR "R1-R8"
 ;SWI &107
 FNLDR R14,key_flags
 TST R14,#2			; are we in an execute strokes loop
 FNRTS NE
mi_resume$l
 FNLDR R4,mini_ptr		; buffer address
 FNLDR R5,mini_bufl		; length of buffer
 FNLDR R6,mini_len		; length of valid text
 FNLDR R7,mini_off		; cursor offset
 MOV R8,R0			; input string
mi4
 LDRB R0,[R8],#1
 CMP R0,#&20
 BCC mi7			; codes 0-&1F
 TEQ R0,#127
 BEQ mi6			; delete back
 CMP R6,R5
 BGE mi4			; can't insert - buffer full
 ADD R1,R4,R7
 ADD R2,R1,#1
 SUB R3,R6,R7
 SWI XZapRedraw_MoveBytes ; BL move_bytes
 LDRB R0,[R8,#-1]
 STRB R0,[R4,R7]		; insert the char
 ADD R7,R7,#1
 ADD R6,R6,#1
 B mi4
mi6
 FNLDR R0,mini_mark
 CMP R7,R0
 BLE mi4			; none to delete
 ADD R1,R4,R7
 SUB R2,R1,#1
 SUB R3,R6,R7
 SWI XZapRedraw_MoveBytes ; BL move_bytes
 SUB R7,R7,#1
 SUB R6,R6,#1
 B mi4
mi7
 ADD PC,PC,R0,LSL #2
 & 0
 B mi5		;  0 ; terminator
 B mi_cLeft	;  1
 B mi8		;  2 ; left
 B mi4		;  3 ; unused
 B mi10		;  4 ; delete right
 B mi_cRight	;  5
 B mi9		;  6 ; right
 B mi4		;  7 ; unused
 B mi8		;  8 ; left
 B mi9		;  9 ; right
 B mi4		; 10 ; unused
 B mi_cCopy	; 11
 B mi_clearbuf	; 12
 B mi4		; 13 ; unused
 B mi_histkill	; 14
 B mi4		; 15 ; unused
 B mi_paste	; 16
 B mi4		; 17 ; unused
 B mi4		; 18 ; unused
 B mi4		; 19 ; unused
 B mi4		; 20 ; unused
 B mi_cU	; 21
 B mi4		; 22 ; unused
 B mi_pastefrom	; 23 ; unused
 B mi4		; 24 ; unused
 B mi4		; 25 ; unused
 B mi4		; 26 ; unused
 B mi4		; 27 ; unused
 B mi_setmark	; 28
 B mi_sCopy	; 29
 B mi_sLeft	; 30
 B mi_sRight	; 31
mi_cLeft
 FNLDR R7,mini_mark
 B mi4
mi_cRight
 MOV R7,R6
 B mi4
mi_cCopy
 MOV R6,R7
 B mi4
mi_clearbuf
 MOV R7,#0
 MOV R6,#0
 FNSTR R7,mini_mark
 B mi4
mi_cU
 FNLDR R7,mini_mark
 MOV R6,R7
 B mi4
mi_setmark
 FNSTR R7,mini_mark
 B mi4
mi_histkill
 FNLDR R0,mini_lineed
 BL lineeditor_kill
; SWI &107 ; ??????????????????????????????????
 B mi4
mi_pastefrom
 FNLDR R10,car_cursor
 LDR R1,[R10,#c_off]
 FNLDR R3,mini_ptr
 FNLDR R2,mini_len
 FNLDR R0,mini_mark
 ADD R3,R3,R0
 SUB R2,R2,R0
 MOV R0,#&11
 BL command_primative		; hmm, 'primitive'...
 BVC mi4
 B mi5
mi_sCopy
 CMP R7,R6
 BGE mi4			; no char to delete
 MOV R2,R7
mi_sCopy$l
 LDRB R1,[R4,R2]
 ADD R2,R2,#1
 TEQ R2,R6
 TEQNE R1,#32
 BNE mi_sCopy$l
 SUBS R0,R2,R7
 ADDNE R2,R4,R7
 ADDNE R1,R2,R0
 SUBNE R6,R6,R0
 SUBNES R3,R6,R7
 SWINE XZapRedraw_MoveBytes ; BLNE move_bytes
 B mi4
mi_sLeft
 FNLDR R0,mini_mark
 TEQ R7,R0
 BEQ mi4			; no chars to left
mi_sLeft1$l
 SUB R7,R7,#1
 LDRB R1,[R4,R7]
 TEQ R7,R0
 MOVEQ R1,#0
 TEQ R1,#' '
 TEQNE R1,#'.'
 BEQ mi_sLeft1$l
mi_sLeft2$l
 SUB R7,R7,#1
 LDRB R1,[R4,R7]
 TEQ R7,R0
 TEQNE R1,#' '
 TEQNE R1,#'.'
 BNE mi_sLeft2$l
 TEQ R1,#' '
 TEQNE R1,#'.'
 ADDEQ R7,R7,#1
 B mi4
mi_sRight
 TEQ R7,R6
 BEQ mi4			; no chars to right
mi_sRight1$l
 ADD R7,R7,#1
 LDRB R1,[R4,R7]
 TEQ R7,R6
 TEQNE R1,#' '
 TEQNE R1,#'.'
 BNE mi_sRight1$l
 TEQ R7,R6
 BEQ mi4
mi_sRight2$l
 ADD R7,R7,#1
 LDRB R1,[R4,R7]
 TEQ R7,R6
 MOVEQ R1,#0
 TEQ R1,#' '
 TEQNE R1,#'.'
 BEQ mi_sRight2$l
 B mi4
mi8
 SUB R7,R7,#1
 FNLDR R0,mini_mark
 CMP R7,R0
 MOVLE R7,R0
 B mi4
mi9
 ADD R7,R7,#1
 CMP R7,R6
 MOVGE R7,R6
 B mi4
mi10
 CMP R7,R6
 BGE mi4			; no char to delete
 ADD R2,R4,R7
 ADD R1,R2,#1
 SUB R6,R6,#1
 SUB R3,R6,R7
 SWI XZapRedraw_MoveBytes ; BL move_bytes
 B mi4
mi5
 FNSTR R6,mini_len		; length of valid text
 FNSTR R7,mini_off		; cursor offset
 MOV R1,#0
 STRB R1,[R4,R6]		; add terminator
 MOVVC R0,#0
 FNRTS
mi_paste
 MOV R3,R8
 BL get_selection
 MOVCS R8,R3			; bugfix...?
 BCS mi4
 FNSTR R6,mini_len		; length of valid text
 FNSTR R7,mini_off		; cursor offset
 MOV R0,#0
 STRB R0,[R4,R6]		; add terminator
 LDR R4,[R9,#f_ptr]
 LDR R5,[R9,#f_len]
 LDR R6,[R9,#f_splito]
 LDR R7,[R9,#f_splits]
 CMP R1,R6
 ADDHI R4,R4,R7
mi_paste$l
 SUBS R2,R2,#1
 MOVMI R0,R3
 BMI mi_resume$l
 TEQ R1,R6
 ADDEQ R4,R4,R7
 LDRB R0,[R4,R1]
 CMP R0,#127
 CMPNE R0,#31
 MOVLS R0,#32
 BL minibuffer_writec
 ADD R1,R1,#1
 B mi_paste$l

;E R0=pointer to token (GSTransed) R4-R7=parameters
;X String written to minibuffer with codes as for minibuffer_write
 FNAME minibuffer_write_token
minibuffer_write_token
	FNJSR	"R1-R7"
	MOV	R1,R0
	MOV	R4,R0
	SUB	R13,R13,#256
	MOV	R2,R13
	MOV	R3,#256
	BL	lookup_token_gs
	MOVVC	R0,R2
	MOVVS	R0,R4
	BL	minibuffer_write
	ADD	R13,R13,#256
	FNRTS

;E R0=pointer to string of text only
;X Text replaces the text before mark, updating all offsets #
;  ": " appended if necessary (unless b31 set)
 FNAME minibuffer_prompt
minibuffer_prompt
 FNJSR "R1-R7"
 FNLDR R14,key_flags
 TST R14,#2			; are we in an execute strokes loop
 FNRTS NE
 AND R7,R0,#1<<31
 BIC R0,R0,#1<<31
 MOV R4,R0			; save string
 BL str_len			; find length
 MOV R5,R0			; save length
 ADD R0,R4,R5
 LDRB R14,[R0,#-1]
 TEQ R14,#' '
 LDREQB R14,[R0,#-2]
 TEQEQ R14,#':'			; ends in ": "?
 TSTEQ R7,#1<<31
 SUBEQ R5,R5,#2			; ...ignore
 FNLDR R0,mini_mark		; mark offset
 SUB R6,R5,R0			; signed change
 FNLDR R3,mini_len
 TST R7,#1<<31
 ADDEQ R6,R6,#2			; allow for ": "
 ADD R2,R3,R6			; new length (after insert)
 FNLDR R1,mini_bufl
 CMP R2,R1			; will it fit?
 FNRTS GE
 FNSTR R2,mini_len		; update length
 ADD R2,R0,R6
 FNSTR R2,mini_mark		; update mark
 FNLDR R2,mini_off
 ADDS R2,R2,R6
 MOVLE R2,#0
 FNSTR R2,mini_off		; update cursor offset
 FNLDR R1,mini_ptr
 ADD R1,R1,R0			; source
 ADD R2,R1,R6			; dest
 SUB R3,R3,R0			; amount
 ADD R3,R3,#1			; move the terminating 0 as well
 SWI XZapRedraw_MoveBytes ; BL move_bytes
 MOV R1,R4
 FNLDR R2,mini_ptr
 MOV R3,R5
 SWI XZapRedraw_MoveBytes ; BL move_bytes
 TST R7,#1<<31
 FNLDR R1,mini_ptr,EQ
 MOVEQ R0,#':'
 STREQB R0,[R1,R5]!
 MOVEQ R0,#' '
 STREQB R0,[R1,#1]		; append ": " to prompt
 FNRTS

;E R0=pointer to token R4-R7=parameters
;X Text replaces the text before mark, updating all offsets #
	FNAME	minibuffer_prompt_token
minibuffer_prompt_token
	FNJSR	"R1-R7,R11"
	AND	R11,R0,#1<<31
	BIC	R0,R0,R11
	MOV	R1,R0
	MOV	R4,R0
	SUB	R13,R13,#256
	MOV	R2,R13
	MOV	R3,#256
	BL	lookup_token
	ORRVC	R0,R2,R11
	ORRVS	R0,R4,R11
	BL	minibuffer_prompt
	ADD	R13,R13,#256
	FNRTS

;E R0=pointer to text R4-R7=parameters R1=history buffer
;X Text replaces the text before mark, updating all offsets;
;  buffer selected #
	FNAME	minibuffer_prompt_and_history
minibuffer_prompt_and_history
	FNJSR
	BL	minibuffer_prompt
	MOVVC	R0,R1
	BLVC	lineeditor_select
	FNRTS

;E R0=pointer to token R4-R7=parameters R1=history buffer
;X Text replaces the text before mark, updating all offsets
;  buffer selected #
	FNAME	minibuffer_prompt_token_and_history
minibuffer_prompt_token_and_history
	FNJSR
	BL	minibuffer_prompt_token
	MOVVC	R0,R1
	BLVC	lineeditor_select
	FNRTS

;X Minibuffer updated on screen (if open) with scroll offsets
;  set to ensure cursor in view etc WB #
 FNAME minibuffer_update
minibuffer_update
 FNJSR "R1-R7"
 BL get_MiniBuf
 LDR R4,[R7,#8]			; window handle
 CMP R4,#0			; window existing?
 FNRTS MI
 LDR R0,[R7,#4]
 TST R0,#1<<5			; window open?
 FNRTS NE
 FNLDR R1,wimp_block
 STR R4,[R1]			; window handle
 LDR R6,[R7]			; actual window block
 ADD R6,R6,#40			; work area
 LDMIA R6,{R0,R2,R3,R14}	; load
 STMIB R1,{R0,R2,R3,R14}	; save
 BL update_leaf_window		; send this block to be updated
 FNRTS VS
 SWI XWimp_GetCaretPosition
 FNRTS VS
 LDR R0,[R1]
 TEQ R0,R4			; is the caret in here?
 BLEQ minibuffer_setcaret
 FNRTS

;X If minibuffer non empty then update

minibuffer_show
 FNLDR R0,mini_len
 TEQ R0,#0
 MOVLE PC,R14
   B minibuffer_update

  ;E R7=minibuffer
  ;X minibuffer caret set WB #

 LOCAL

 FNAME minibuffer_setcaret
minibuffer_setcaret
 FNJSR "R1-R6"
 BL minibuffer_ensurecaret
 FNRTS VS
 LDR R0,[R7,#8]			; window handle
 CMP R0,#0
 FNRTS LE
 LDR R6,[R7]			; window data
 FNLDR R5,mini_off		; index into string
 BL checkfortextop
 LDRLT R2,[R6,#40]		; work min x
 ADDLT R2,R2,#8			; left hand indent
 ADDLT R2,R2,R5,LSL#4		; 16 os per character
 BLGE font$l
 MVN R1,#0			; no icon! (or wimp handles keys)
 LDR R3,[R6,#44]		; ymin of work area
 LDR R4,[R6,#52]		; ymax of work area
 SUB R4,R4,R3			; height of caret
 MOV R5,#0			; no string index
 SWI XWimp_SetCaretPosition
 FNRTS
font$l
 MOV R0,#1
 FNLDR R1,mini_ptr
 MOV R2,R5
 SWI XWimp_TextOp		; get substring width
 ADDVC R2,R0,#8			; left hand indent
 LDRVC R0,[R7,#8]
 MOVVC PC,R14
 FNRTS

;E R7=minibuffer
;X Ensures caret is visible WB #
 FNAME minibuffer_ensurecaret
minibuffer_ensurecaret
 FNJSR "R1"
 FNLDR R1,wimp_block
 LDR R0,[R7,#8]			; window flags
 CMP R0,#0
 FNRTS LE
 STR R0,[R1]
 SWI XWimp_GetWindowState	; get window state block
 FNRTS VS
 BL show_mini_caret
 FNRTS VS
 SWINE XWimp_OpenWindow
 FNRTS

;E R1=minibuffer open block
;X EQ if caret visible NE if scroll offsets changed |

 LOCAL

 FNAME show_mini_caret
show_mini_caret
 FNJSR "R2-R7"
 BL checkfortextop
 MOVLT R2,#8			; indent
 FNLDR R3,mini_off,LT
 FNLDR R4,mini_len,LT
 ADDLT R3,R2,R3,LSL#4		; cursor posn
 ADDLT R4,R2,R4,LSL#4		; end of text posn
 ADDLT R4,R4,R2			; add right margin
 BLGE font$l
 LDR R2,[R1,#w_maxx]
 LDR R0,[R1,#w_minx]
 LDR R5,[R1,#w_scrollx]
 SUB R2,R2,R0			; width of visible area
 CMP R4,R2
 MOVLS R0,#0
 BLS short$l
 SUB R14,R4,R2			; rightmost allowable scroll offset
 MOV R0,R5
 CMP R2,#128
 MOVGE R6,#64
 MOVLT R6,R2,LSR #1
 BIC R6,R6,#1
 ADD R7,R5,R2
 SUB R7,R7,R6
 ADD R5,R5,R6
 CMP R3,R5
 BGE ge$l
 SUB R0,R3,R6
 FNLDR R4,mini_off
 FNLDR R5,mini_mark
 TEQ R4,R5
 MOVEQ R0,#0
ge$l
 CMP R3,R7
 ADDGT R0,R3,R6
 SUBGT R0,R0,R2
 TEQ R0,#0
 MOVMI R0,#0
 CMP R0,R14
 MOVHI R0,R14
short$l
 STR R0,[R1,#w_scrollx]
 FNRTS

font$l
 FNJSR "R1"
 MOV R0,#1
 FNLDR R1,mini_ptr
 FNLDR R2,mini_off
 SWI XWimp_TextOp		; get substring width
 ADDVC R3,R0,#8
 MOVVC R0,#1
 FNLDR R1,mini_ptr,VC
 FNLDR R2,mini_len,VC
 SWIVC XWimp_TextOp		; get whole string width
 ADDVC R4,R0,#16
 FNRTS VC
 LDR R1,[R13],#8
 FNRTS

;E R2=type
;X Command associated to minibuffer called with
;   R0=minibuffer after mark
;   R1=1
;   R2 altered to contain 'string' type
;  Returns R0 from command/0 if no command #
 FNAME minibuffer_command
minibuffer_command
 FNJSR "R1,R2,R7-R10"
 BL get_input_caret
 BCS mi12			; no input caret
 FNLDR R7,mini_command		; minibuffer command
 CMP R7,#0
 BLE mi12			; none
 BL reclaim_caret		; reclaim caret for the duration
 FNLDR R0,mini_ptr
 FNLDR R1,mini_mark
 ADD R0,R0,R1			; minibuffer after mark
 MOV R1,#1			; only one time
 ORR R2,R2,#3<<24
 BL process_command
 BLVC declaim_caret
 FNRTS
mi12
 MOV R0,#0
 FNRTS

;X Clears minibuffer contents and command before new instr #
 FNAME minibuffer_clear
minibuffer_clear
 FNJSR
 MOV R0,#0
 FNSTR R0,mini_len
 FNSTR R0,mini_off
 FNSTR R0,mini_mark
 FNSTR R0,mini_command
 FNLDR R14,mini_ptr
 STRB R0,[R14]			; clear minibuffer
 FNRTS

;X If minibuffer open and not clear then cleared #
;  (called before a command executed)
 FNAME minibuffer_wipe
minibuffer_wipe
 FNJSR "R7"
 FNLDR R0,mini_len
 CMP R0,#0
 FNRTS LE		; minibuffer already empty
 BL get_MiniBuf
 LDR R0,[R7,#8]
 CMP R0,#0
 FNRTS MI		; none to clear
 BL minibuffer_clear		; zero the pointers
 FNRTS VS
 BL minibuffer_update		; update on screen
 FNRTS

;X Minibuffer close if popup / input lost ow.
 FNAME minibuffer_close
minibuffer_close
 FNJSR "R7"
 BL get_MiniBuf
 LDR R0,[R7,#8]
 CMP R0,#0			; any window to consider?
 FNRTS MI
 MOV R0,#&70 ; escape
 BL test_forkey
 BCS escapedfromthebuffer
 LDR R0,local_callbackflag
 CMP R0,#0
 FNRTS NE
escapedfromthebuffer
 FNLDR R0,opt_flags
 TST R0,#1<<23
 BEQ mi13			; popup
 BL minibuffer_update		; clear it
 FNRTS VS
 ;BL restore_carets
 FNRTS
mi13
 BL close_leaf_window		; close it
 ;BL restore_carets		; input not lost any more...
 FNRTS

;E R0=string (usually minibuffer string)
;X R0=number stored in string/CS if none WB
 FNAME minibuffer_eval
minibuffer_eval
 FNJSR "R1-R2"
 FNLDR R1,wimp_block
 MOV R2,#0
 SWI XOS_EvaluateExpression
 BVS mi15
 TEQ R1,#0
 BNE mi15			; not an integer
 ADDS R0,R2,#0			; result and clear C
 FNRTS
mi15
 SUBS R0,R0,#0			; set C and clear V
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Minibuffer key handling				     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=key R7=minibuffer
;X Minibuffer key processed (never close the window) #
 FNAME process_minibuffer_key
process_minibuffer_key
 FNJSR
 ;SWI &107
 MOV R5,R0			; save wimp key (incase pass on)
 MOV R3,#0			; no key to act on yet
 FNLDR R1,key_modifiers
 BL convert_key			; find my key code
 FNLDR R4,mini_command		; find command associated
 CMP R4,#0
 BLE close$l			; none!
 LDR R4,[R4,#-4]		; flags word
 TST R4,#1<<8		; does it want to know the key?
 BEQ a$l			; no
 ADD R2,R0,#&8000		; key + &8000
 BL minibuffer_command		; R0=new key / -1
 FNRTS VS
a$l
 MOV R3,R0			; save key to be acted on
 CMP R0,#&8000
 BGE exec$l			; finish minibuffer
 TEQ R0,#7
 TEQNE R0,#&1B
 BEQ close$l			; cancel/escape
 SUB R14,R0,#&100
 TEQ R14,#&66			; keypad enter
 TEQNE R14,#&76			; + shift
 TEQNE R0,#&1D			; return
 TEQNE R14,#&1D			; + shift
 BEQ exec$l
 TEQ R0,#&8000001D
 MOVEQ R3,#&1D
 BEQ exec_nosave$l
 BL minibuffer_key		; take the key action
 FNRTS VS
 TST R4,#1<<7
 BEQ b$l			; don't inform command
 FNLDR R14,opt_flags
 ORR R14,R14,#1<<25		; ignore input transfers
 FNSTR R14,opt_flags
 MOV R2,#7
 BL minibuffer_command		; tell command the new string
 FNLDR R14,opt_flags
 BIC R14,R14,#1<<25		; consider input gains again
 FNSTR R14,opt_flags
 FNRTS VS
b$l
 BL minibuffer_update		; update minibuffer on screen
 FNRTS				; wait for next key press
exec$l				; execute the command
 BL minibuffer_addline		; Save BEFORE command clears it, eg. COMMAND
 FNRTS VS
exec_nosave$l
 MOV R2,#1			; return pressed
 BL minibuffer_command		; tell the command the string
 FNRTS VS			; R0=returned value
 TST R4,#1<<11
 BEQ close$l			; always close the minibuffer
 TEQ R0,#0
 FNRTS NE			; don't close it if R0=1 on exit
close$l
 BL minibuffer_close		; close the minibuffer
 FNRTS VS
 CMP R3,#&8000
 FNRTS LT			; no key to 'execute'
 BL get_input_caret		; get R8-R10
 FNRTS CS
 SUB R0,R3,#&8000
 BL process_a_key		; do the key (R5=wimp key number)
 FNRTS

;X Current contents of minibuffer appended to the history buffer,
;  Buffer pointer set to this line.
;  b15 of opt_switches flag cleared (MinibufferStatus)
 FNAME minibuffer_addline
minibuffer_addline
 FNJSR "R1"
 FNLDR R0,mini_lineed
 MOV R1,#&7FFFFFFF
 BL lineeditor_setpos		; reset the recall position to end
 FNLDR R0,mini_ptr,VC
 FNLDR R1,mini_mark,VC
 ADDVC R1,R0,R1			; line to append
 FNLDR R0,mini_lineed,VC
 BLVC lineeditor_append		; add line to history
 FNLDR R0,opt_switches,VC
 BICVC R0,R0,#switch_MinibufferStatus
 FNSTR R0,opt_switches,VC
 FNRTS

 LOCAL

;E R0=zap key/-1 of typed key R4=command flags R5=wimp key
;X key action taken via minibuffer_write (no scn update) KB #
 FNAME minibuffer_key
minibuffer_key
 FNJSR "R1"
 ;SWI &107
 CMP R0,#0
 FNRTS MI			; nothing to do
 CMP R0,#&1C0
 BCS digits$l			; f10-f12 or keypad digits
 CMP R0,#&180
 BCS fn$l			; function keys
 CMP R0,#&100
 BCS mine$l			; my special keys
 CMP R0,#&20
 BCS send$l			; send character
 TEQ R0,#&1C
 MOVEQ R0,#127
 ;BEQ send$l			; backspace key = delete
 TEQ R0,#11			; cK?
 MOVEQ R0,#14			; delete history.
 ;TEQNE R0,#14
 ;TEQNE R0,#16
 ;TEQNE R0,#21
 ;TEQNE R0,#23
 B send$l			; send ctrl K,P,U,W
 ;B passon$l			; pass on others
digits$l			; keypad digits etc
 AND R1,R0,#&F
 CMP R1,#10
 BCS passon$l			; f10-f12
 ADD R0,R1,#'0'
 B send$l
fn$l
 SUB R1,R0,#&100		; get bottom byte
 TEQ R1,#&8C
 MOVEQ R0,#8
 BEQ send$l			; left
 TEQ R1,#&8D
 MOVEQ R0,#9
 BEQ send$l			; right
 TEQ R1,#&8E
 TEQNE R1,#&9E
 TEQNE R1,#&AE			; downs
 TEQNE R1,#&8F
 TEQNE R1,#&9F
 TEQNE R1,#&AF			; ups
 BEQ arrow$l
 TEQ R1,#&9C
 MOVEQ R0,#30
 BEQ send$l			; sleft
 TEQ R1,#&AC
 MOVEQ R0,#1
 BEQ send$l			; cleft
 TEQ R1,#&9D
 MOVEQ R0,#31
 BEQ send$l			; sright
 TEQ R1,#&AD
 MOVEQ R0,#5
 BEQ send$l			; cright
 TEQ R1,#&8B
 TEQNE R1,#127
 MOVEQ R0,#4
 BEQ send$l			; copy/sdel
 TEQ R1,#&8A
 BEQ tab$l			; tab
 TEQ R1,#&9B
 MOVEQ R0,#29
 BEQ send$l			; sCopy
 TEQ R1,#&AB
 MOVEQ R0,#11
 BEQ send$l			; cCopy
 B passon$l			; pass on the rest
mine$l
 TEQ R0,#&120			; shift space
 MOVEQ R0,#&20
 BEQ send$l
 CMP R0,#&160
 FNRTS CC			; ignore
 AND R1,R0,#&0F
 CMP R1,#8
 FNRTS CS
 ADR R0,data$l
 LDRB R0,[R0,R1]
 B send$l			; keypad punctuation key
data$l = 0,"/*#-+",13,"."
 ALIGN
send$l				; R0=character to write
 FNLDR R14,opt_switches
 ORR R14,R14,#switch_MinibufferStatus	; the line has been changed
 FNSTR R14,opt_switches
 BL minibuffer_writec
 FNRTS
passon$l
 MOV R0,R5			; wimp key value
 SWI XWimp_ProcessKey		; pass on
 FNRTS
tab$l
 TST R4,#1<<9			; filename expansion?
 FNRTS EQ
 BL complete_filename		; complete the name
 FNRTS
arrow$l				; R1=bottom byte of key number
 FNLDR R0,opt_switches
 TST R0,#switch_MinibufferStatus
 BLNE minibuffer_addline	; the line has been changed so save
 FNRTS VS
 TEQ R1,#&8E
 TEQNE R1,#&9E
 MOVEQ R1,#&80000002		; down
 TEQ R1,#&AE
 MOVEQ R1,#&7FFFFFFF		; to end
 TEQ R1,#&8F
 TEQNE R1,#&9F
 MOVEQ R1,#&80000001		; up
 TEQ R1,#&AF
 MOVEQ R1,#0			; to start
 FNLDR R0,mini_lineed
 BL lineeditor_setpos
 BLVC recall$l
 FNRTS
recall$l			; recall a line from the history buffer
 FNJSR "R1-R3"
 FNLDR R0,mini_ptr
 FNLDR R3,mini_mark
 FNLDR R2,mini_bufl
 SUB R2,R2,R3			; length left in buffer
 ADD R1,R0,R3			; start of buffer after mark
 FNLDR R0,mini_lineed		; handle
 BL lineeditor_retrieve		; get the line
 FNRTS VS
 FNRTS EQ
 MOV R0,R1
 BL str_len
 ADD R0,R0,R3			; total length of recalled string
 FNSTR R0,mini_len
 FNSTR R0,mini_off		; put cursor at end
 FNRTS

;E R7=window index, R8/R9 or 0 to open at default coords
;X leaf window opened at minibuffer posn WB #
 FNAME open_mini_window
open_mini_window
 FNJSR "R1-R9"
 LDR R6,[R7]			; window data
 BL conv_index_offs
 FNLDR R1,wimp_block
 LDR R0,[R7,#8]			; window handle
 STR R0,[R1]
 TEQ R8,#0			; does a related window exist
 BNE mi2			; yes
 LDMIA R6,{R0,R2,R3,R4}
 STMIB R1,{R0,R2,R3,R4}		; copy coords
 MVN R0,#0
 STR R0,[R1,#w_infront]		; create open block
 B mi3
mi2
 BL update_wind_state		; get current window posn in R8
 FNRTS VS
 LDR R0,[R8,#w_minx]		; left edge of window
 LDR R2,[R6]
 LDR R3,[R6,#8]
 SUB R3,R3,R2			; width of minibuffer
 LDR R2,[R8,#w_maxx]
 SUB R2,R2,R0			; width of window
 FNLDR R14,opt_switches		; if auto-width is set for the minibuffer
 TST R14,#switch_MinibufferAutoWidth
 MOVNE R3,R2			; then the minibuffer width when opened is the window width
 BNE post$l
 CMP R3,R2			; otherwise ...
 MOVGE R3,R2			; min of the two
post$l
 STR R0,[R1,#w_minx]
 ADD R0,R0,R3
 STR R0,[R1,#w_maxx]		; set up x coords of window
 FNLDR R14,scn_magy
 MOV R0,#1
 MOV R14,R0,LSL R14		; os pixels per raster line
 LDR R0,[R8,#w_miny]		; bottom of window (above bar)
 SUB R0,R0,R14			; skip line at window bottom
 LDR R2,[R6,#4]			; maybe 1 os in high res modes
 LDR R3,[R6,#12]
 SUB R3,R3,R2			; height
 STR R0,[R1,#w_maxy]
 SUB R0,R0,R3
 STR R0,[R1,#w_miny]
 LDR R0,[R8,#w_infront]		; window infront of main window
 STR R0,[R1,#w_infront]		; create open block
mi3
 MOV R0,#0
 STR R0,[R1,#w_scrollx]
 STR R0,[R1,#w_scrolly]
 SWI XWimp_OpenWindow		; open window
 FNRTS

;E R1=proposed new open block R8
;X Minibuffer opened first at new posn if need be #
 FNAME reopen_minibuffer
reopen_minibuffer
 FNJSR R7
 BL get_MiniBuf
 LDR R14,[R7,#8]		; minibuffer window handle
 CMP R14,#0
 FNRTS LE			; non mini buffer
 LDR R14,[R7,#4]
 TST R14,#1<<5
 FNRTS NE			; minibuffer closed
 LDR R14,[R7,#12]		; associated window
 CMP R14,#0
 FNRTS MI			; none
 FNLDR R0,wind_list
 ADD R0,R0,R14,LSL#w_shift	; window block
 TEQ R0,R8			; same window?
 BLEQ reflect_minibuffer
 FNRTS

;E R1=proposed open block R8=window (minibuf must be open)
;X Reopen minibuffer at same relative offset to R8 window #
;NB R1=R8 on most calls and may be wimp_block (eg Toggle)!
 FNAME reflect_minibuffer
reflect_minibuffer
 FNJSR "R1-R7"
 MOV R2,R1			; save new open block
 FNLDR R1,mini_openblk		; workspace open block
 BL calculate_open_block	; find change R3-R6
 FNRTS VS
 BL get_MiniBuf
 LDR R0,[R7,#8]			; minibuffer handle
 STR R0,[R1]
 SWI XWimp_GetWindowState	; find its current posn
 FNRTS VS
 LDR R0,[R1,#w_minx]		; mini lhs
 LDR R14,[R1,#w_maxx]
 SUB R14,R14,R0			; mini width
 ADD R0,R0,R3			; new lhs
 STR R0,[R1,#w_minx]
 ADDS R14,R14,R4		; new width
 MOVLE R14,#0			; min width is zero
 ADD R14,R0,R14			; new xmax
 STR R14,[R1,#w_maxx]		; done x coords
 LDR R3,[R1,#w_miny]		; current y min
 LDR R4,[R1,#w_maxy]
 SUB R4,R4,R3			; height of minibuffer
 SUB R5,R5,R6			; change in miny
 ADD R3,R3,R5			; change current y min
 ADD R4,R3,R4			; new maxy
 STR R3,[R1,#w_miny]
 STR R4,[R1,#w_maxy]		; change the y vals
 LDR R0,[R2,#w_infront]
 STR R0,[R1,#w_infront]		; its the minibuffer on top
 LDR R0,[R1]			; minibuffer handle
 STR R0,[R2,#w_infront]		; put main window behind
 BL show_mini_caret		; change scroll offsets
 FNRTS VS
 SWI XWimp_OpenWindow		; open the window
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Minibuffer redraw on screen				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=window block (as given by wimp) R7=window index of minibuffer
;X draw the area #
 FNAME redraw_minibuffer
redraw_minibuffer
 FNJSR "R1-R11"
 MOV R11,R1			; save the window block
 FNLDR R0,opt_minibac
 MOV R3,#&80			; background
 MOV R4,#0			; action
 SWI XColourTrans_SetGCOL
 MOV R1,R11
 BL find_leaf_area		; (R2,R3)=top left R5=num chars
 FNRTS VS			; R4=char offset
 MOV R6,R2			; save x coord
 MOV R0,#4
 LDR R1,[R11,#36]		; max x
 LDR R2,[R11,#32]		; min y
 SWI XOS_Plot			; move to bottom right
 MOVVC R0,#103
 LDRVC R1,[R11,#28]		; min x
 LDRVC R2,[R11,#40]		; max y
 SWIVC XOS_Plot			; Clear background
 FNRTS VS
 BL checkfortextop
 BGE font$l
 MOV R0,#4
 MOV R1,R6
 MOV R2,R3
 SWI XOS_Plot			; move to top left
 FNLDR R0,opt_minifor,VC
 MOVVC R3,#0			; foreground
 MOVVC R11,R4
 MOVVC R4,#0			; action
 SWIVC XColourTrans_SetGCOL
 FNRTS VS
 FNLDR R0,mini_ptr		; minibuffer start
 ADD R0,R0,R11			; first char we're interested in
 MOVS R1,R5			; num of chars
 SWINE XOS_WriteN		; write the chars to screen
 FNRTS				; go home!
font$l
 MOV R0,#0
 FNLDR R1,opt_minifor
 FNLDR R2,opt_minibac
 SWI XWimp_TextOp
 MOVVC R0,#8
 SWIVC XWimp_ReadSysInfo
 FNRTS VS
 TEQ R0,#0
 MOV R0,#&40000002
 FNLDR R1,mini_ptr
 MOV R4,R6
 SUBEQ R5,R3,#24
 SUBNE R5,R3,#20
 MVN R2,#0
 MVN R3,#0
 SWI XWimp_TextOp
 FNRTS

;E R1=wimp redraw block
;X R2/R3=top left R4=char offset R5=num chars to draw (clipped) #
 FNAME find_leaf_area
find_leaf_area
 FNJSR
 LDR R0,[R1,#4]
 LDR R14,[R1,#20]
 SUB R2,R0,R14			; x coord of work area 0
 ADD R2,R2,#8			; margin
 LDR R0,[R1,#28]
 SUBS R4,R0,R2			; work area lhs
 MOVMI R4,#0
 LDR R0,[R1,#36]
 SUBS R5,R0,R2			; work area rhs
 MOVMI R5,#0
 BL checkfortextop
 MOVGE R4,#0
 MOVGE R5,#16384		; arbitrary value for when using Wimp_TextOp
 MOVLT R4,R4,LSR#4		; first char
 ADDLT R5,R5,#15
 MOVLT R5,R5,LSR#4		; last char (exclusive)
 FNLDR R0,mini_len
 CMP R5,R0
 MOVGT R5,R0			; clip to number available
 SUBS R5,R5,R4
 MOVMI R5,#0			; number to draw
 ADD R2,R2,R4,LSL#4		; left hand edge
 LDR R0,[R1,#16]
 LDR R14,[R1,#24]
 SUB R3,R0,R14			; y coord of work area 0
 SUB R3,R3,#8			; move down 2 pixs
 FNRTS

;E Templates & keys loaded
;X Minibuffer vars initialised and buffer opened if opts #
 FNAME init_mini
init_mini
 FNJSR "R6-R7"
 BL get_MiniBuf
 FNLDR R0,mini_bufl
 CMP R0,#8
 MOVLE R0,#8
 FNSTR R0,mini_bufl		; ensure sensible length
 ADD R0,R0,#1			; room for terminator
 BL heap_claim
 FNRTS VS
 FNSTR R0,mini_ptr		; minibuffer address
 MOV R0,#0
 FNSTR R0,mini_len
 FNSTR R0,mini_off
 FNSTR R0,mini_mark
 FNSTR R0,mini_command
 BL minibuffer_ensure
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; !Help support						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

; R1=message block for Help_Help message
; corrupts all WB etc
 FNAME help_help
help_help
 FNJSR
 MOV R11,R1			; save message block
 LDR R0,[R11,#32]		; window handle
 CMP R0,#-2
 BEQ iconbar$l			; iconbar icon
 BL convert_wind_handle
 BCC text$l			; zap text window
 BL convert_leaf_wind_handle
 BCC leaf$l			; leaf window handle
 MOV R0,#1			; report tree
 FNLDR R1,wimp_data		; buffer for menu tree
 LDR R3,[R11,#36]		; icon handle
 LDR R2,[R11,#32]		; window handle (probably a menu)
 SWI XWimp_GetMenuState		; tree in buffer same as Wimp_Poll 9
 FNRTVC VS			; don't give an error (eg Risc Os 2)
 LDR R0,[R1]
 CMP R0,#0
 BPL menu$l			; was in a menu
 MOV R0,#17
 MOV R1,R11
 BL wimp_passon			; not a recognised window
 FNRTS
iconbar$l
 ADR R0,icon$l
wind$l				; R0=label for window or icon info
 MOV R3,#0
 BL find_help
 FNRTS VS
 TEQ R0,#0
 FNRTS EQ			; none
 MOV R0,R1
 MOV R1,#0			; don't want to treat some chrs specially
 BL send_help			; ouput the para
 FNRTS
icon$l FNS ("zap.icon")
text$l				; it's a Zap text window
 BL conv_wind_off		; set up R8/R9
 FNLDR R1,wimp_block		; put label in here
 ADR R2,mode$l
 BL strcpy
 LDRB R0,[R8,#w_format]		; mode number
 BL mode_name			; R2=mode name
 FNRTS VS
 BL strcopy
 FNLDR R0,wimp_block
 B wind$l			; mode_<name>
mode$l FNS ("mode_")
leaf$l
 MOV R7,R0			; save window index
 FNLDR R1,wimp_block
 ADR R2,leafw$l
 BL strcpy
 LDR R2,[R7,#28]		; template name
 BL strcopy
 FNLDR R0,wimp_block
 B wind$l
leafw$l FNS ("window.")
menu$l				; menu stuff R1=menu tree
 MOV R9,R11			; save orginial wimp message
 MOV R11,R1			; menu tree
 FNLDR R1,wimp_menuptr		; address of current menu
 BL menu_get_help
 FNRTS VS
 TEQ R0,#0
 FNRTS EQ
gotmenu$l
 MOVVC R11,R9			; message to reply to
 BLVC send_help
 FNRTS

 LOCAL

;E R0=pointer to command name or label
;  R1=command argument (if R2 valid)
;  R2=command flags (or 0 if no argument given,-1 if not a command)
;  R3=parameter type (only valid if command takes a parameter)
;     b24 = don't process special characters
;     b30 = c-var
;     b31 = is a function
;X wimp_data contains the help text for the command
;  R0=length of help data / 0 if no help data found
 FNAME find_command_help
find_command_help
 FNJSR "R1-R7,R10-R11"
 FNLDR R6,wimp_data		; buffer start
 MOV R7,#0			; current buffer offset
 MOV R5,R1			; save command argument
 MOV R4,R2			; save command flags
 MOV R11,R3
 MOV R10,R0			; keep comand name
 BL find_help
 FNRTS VS
 TEQ R0,#0
 FNRTS EQ			; command wasn't found
 MOV R2,R0			; command name
 MOV R3,R1			; para start
 CMP R4,#-1
 BEQ para$l			; not a command so insert the paragraph
 TST R11,#1<<31			; function?
 ADRNE R0,fn$l
 BNE token_ready$l
 TST R11,#1:SHL:30		; c-var?
 ADREQ R0,com$l
 ADRNE R0,var$l
token_ready$l
 BL lookup_token_R0
 BL str$l
 BLVC insert$l
 FNRTS VS
 MOV R4,R4,LSR#3
 ANDS R4,R4,#7			; command type
 BL key$l			; add attached key (CHEL)
 FNRTS VS			; oops
 MOVS R4,R4
 BEQ para$l			; no argument
 ADR R0,arg$l
 BL lookup_token_R0
 BL str$l
 FNRTS VS
 CMP R4,#3
 BLT byte$l
 BEQ string$l
 ADR R0,block$l
 BL lookup_token_R0
 BL str$l
 FNRTS VS
done$l				; argument done
 SUB R3,R3,#1			; include extra return
para$l				; do main para
 MOV R2,R3
 MOV R0,R2
 BL next_para
 MOV R3,R0
 BL insert$l
 MOVVC R0,R7
 FNRTS
com$l	= "zap_h_cmd",0
fn$l	= "zap_h_fn",0
var$l	= "zap_h_var",0
arg$l	= "zap_h_arg",0
block$l = "zap_h_db",0
bra$l	FNS (" (' ')")		; aligns...
byte$l
 TST R11,#8
 BNE intexpr$l
 ADD R1,R6,R7
 MOV R0,#'&'
 STRB R0,[R1],#1
 MOV R0,R5			; argument
 MOV R2,#15
 TEQ R4,#2
 BEQ word$l
 SWI XOS_ConvertHex2
 FNRTS VS
 ADR R2,bra$l
 BL strcpy
 STRB R5,[R1,#-3]
 SUB R7,R1,R6
 B done$l
word$l
 TST R11,#8
 BNE intexpr$l
 SWI XOS_ConvertHex8
 SUBVC R7,R1,R6
 BVC done$l
 FNRTS
intexpr$l
 MOV R0,#'#'
expr$l
 STRB R0,[R6,R7]
 ADD R7,R7,#1
 MOV R0,#'('
 STRB R0,[R6,R7]
 ADD R7,R7,#1
 MOV R0,R5
 BL str$l
 MOVVC R0,#')'
 STRVCB R0,[R6,R7]
 ADDVC R7,R7,#1
 BVC done$l
 FNRTS
string$l
 TST R11,#8
 MOVNE R0,#'$'
 BNE expr$l
 CMP R5,#0
 BLE done$l
 MOV R0,#'"'
 STRB R0,[R6,R7]
 ADD R7,R7,#1
 MOV R0,R5
 BL str$l
 MOVVC R0,#'"'
 STRVCB R0,[R6,R7]
 ADDVC R7,R7,#1
 BVC done$l
 FNRTS
str$l				; insert zero terminates string in R0
 FNJSR "R1-R3"
 MOV R2,R0
 BL str_len
 ADD R3,R2,R0
 BL insert$l
 FNRTS
insert$l			; insert text between R2 and R3
 FNJSR "R1-R4"
 SUB R3,R3,R2			; text length
 MOV R0,R6
 ADD R1,R7,R3
 ADD R1,R1,#16			; ensure an extra 16 chars for byte$l etc
 BL heap_ensure
 FNRTS VS
 FNSTR R0,wimp_data
 MOV R6,R0
 ADD R1,R6,R7
 ADD R7,R7,R3
 MOV R14,#0
 MOV R4,#1			; 0=ignore
insertloop$l
 SUBS R3,R3,#1
 FNRTS MI
 LDRB R0,[R2],#1
 TST R11,#1<<24			; process special chars?
 BNE store$l			; ... no
 TEQ R0,#1			; ^A, ^Z: output following text
 TEQNE R0,#26
 MOVEQ R4,#1
 SUBEQ R7,R7,#1
 BEQ insertloop$l
 TEQ R0,#8			; ^H: don't output following text
 MOVEQ R4,#0
 SUBEQ R7,R7,#1
 BEQ insertloop$l
 TEQ R0,#13			; CR => LF if preceded by an LF
 TEQEQ R14,#10
 MOVEQ R0,#10
 TEQ R0,#13			; CR => space otherwise
 MOVEQ R0,#32
store$l
 TEQ R4,#0
 STRNEB R0,[R1],#1		; only store if not ignoring :-)
 MOVNE R14,R0			; previous character
 SUBEQ R7,R7,#1
 B insertloop$l
key$l
	TST	R11,#3<<30		; return early if not a command
	MOVNE	PC,R14
	TEQ	R4,#0
	MOVMI	PC,R14
	FNJSR	"R1-R4,R11"		; add key shortcut to help
	MOV	R0,R6
	ADD	R1,R7,#12		; big enough
	BL	heap_ensure
	FNRTS	VS			; nope
	MOV	R6,R0
	MOV	R0,R10			; restore name
	BL	look_key_command	; get address
	TEQ	R0,#0
	FNRTS	EQ			; not found
	PUSH	"R7"			; keep text pointer
	MOV	R7,R0			; get address
	MOV	R0,R5			; get argument data
	MOV	R11,R4			; argument type
	BL	find_key_w_currentmap	; get key number
	CMP	R0,#-1			; none?
	MOVEQ	R0,R5
	MOVEQ	R11,#-1			; try first match
	BLEQ	find_key_w_currentmap	; get key number
	CMP	R0,#-1			; still none?
	BNE	foundkey$l
	MOV	R0,R10
	BL	look_key_command	; set up wimp_block
	TST	R0,#1
	BNE	foundcmdname$l
	PUSH	"R4,R5"
	FNLDR	R4,ext_comms
	FNLDR	R5,wimp_block
	BL	search_command_table	; try the External info
	MOV	R0,R4
	PULL	"R4,R5"
	MOVCS	R0,#-1
	BCS	foundkey$l		; we haven't really
foundcmdname$l
	ORR	R7,R0,#1
	MOV	R0,R5			; get argument data
	MOV	R11,R4			; argument type
	BL	find_key_w_currentmap	; get key number
	CMP	R0,#-1			; none?
	MOVEQ	R0,R5
	MOVEQ	R11,#-1			; try first match
	BLEQ	find_key_w_currentmap	; get key number
foundkey$l
	PULL	"R7"
	CMP	R0,#-1			; none?
	FNRTS	EQ
	ADD	R1,R6,R7
	SUB	R1,R1,#2
	MOV	R2,#12			; max length inc terminator
	BL	show_key		; add string preserves r1
	ADD	R1,R1,#2		; keep pointer
	ADD	R2,R1,#1		; allow for bracket
	ADD	R3,R1,#10		; and end
keyloop1$l
	LDRB	R0,[R1],#1		; find beginning of key
	CMP	R0,#32
	BLS	keyloop1$l
	SUB	R1,R1,#1		; point to first char
	SUB	R3,R3,R1		; length of key
	MOV	R4,#'('
	STRB	R4,[R2,#-1]
	ADD	R4,R2,R3		; after key
	SWI	XZapRedraw_MoveBytes	; copy back
	MOV	R0,#')'
	STRB	R0,[R4,#-1]
	MOV	R0,#10
	STRB	R0,[R4],#1
	SUB	R7,R4,R6
	FNRTS

 LOCAL

;E R0=length of data in wimp_data / 0 if none
;X File opened.
 FNAME display_help
display_help
 FNJSR "R1-R5,R8-R9"
 CMP R0,#0
 BLE nohelp$l
 MOV R5,R0			; save length
 LDR R0,text$l
 BL calc_load			; R2/R3=load/exec
 MOV R0,R5
 ADR R1,help$l			; name
 BL create_file_block		; set up R9
 FNRTS VS
 LDR R0,[R9,#f_flags]
 ORR R0,R0,#flags_ReadOnly
 STR R0,[R9,#f_flags]
 FNLDR R1,wimp_data
 LDR R2,[R9,#f_ptr]
 MOV R3,R5
 SWI XZapRedraw_MoveBytes ; BL move_bytes
 BLVC create_window_block
	MOVVC R0,#0
	BLVC new_mode		; HACK: Tim's modes don't like softwrap?
 LDRVC R14,[R8,#w_format]
 ORRVC R14,R14,#format_SoftWrap
 STRVC R14,[R8,#w_format]
 FNRTS
help$l = "Help",0
nohelpmsg$l = "zap_NoHelpText",0
 ALIGN
text$l DCD &FFF
nohelp$l
 ADR R0,nohelpmsg$l
 MOV R1,#7<<29
 BL warn_user
 FNRTS


 LOCAL

;E R0=pointer to label to get help data about
;X R0=pointer to label match in the helpdata file / 0 if not found
;  R1=pointer to paragraph following the label #
 FNAME find_help
find_help
 FNJSR "R2,R11"
 AND R11,R3,#3<<30
 MOV R1,R0			; save search label
 BL load_help
 FNRTS VS
 FNLDR R2,wimp_helpdata		; file
a$l
 LDRB R0,[R2]
 TEQ R0,#0			; end of file?
 FNRTS EQ
 TST R11,#1:SHL:30		; c-var
 BEQ not_var$l
 TEQ R0,#35			; '#'
 ADDEQ R2,R2,#1			; skip it
 BLEQ strcmpstr			; case sensitive, R1,R2 saved
 BNE b$l
 LDRB R0,[R0]			; character after string
 CMP R0,#&20
 BLE found$l			; found label
 B b$l
not_var$l
 TST R11,#1:SHL:31		; function
 BEQ n$l			; neither function nor c-var
 TEQ R0,#64			; '@'
 BNE b$l			; couldn't find it here
 ADD R2,R2,#1			; skip it
n$l
 BL strCMPstr			; not case sensitive R1,R2 saved
 BNE b$l
 LDRB R0,[R0]			; character after string
 CMP R0,#&20
 BLE found$l			; found label
b$l
 MOV R0,R2
 BL next_para
 MOV R2,R0
 B a$l
found$l
 MOV R1,R2			; label
c$l
 LDRB R0,[R1],#1
 TEQ R0,#0			; file end?
 FNRTS EQ
 TEQ R0,#&0A
 BNE c$l			; get to start of next line in R1
 MOV R0,R2			; start of label
 FNRTS

 LOCAL

;E R0=pointer to text paragraph to send
;  R1=non-0 if < and | to be treated as literals
;  R11=HelpRequest message to reply to
;X Text copied into the message block from #20 and message replied to.
;  Only copies up to the first |Z or until the buffer is full.
 FNAME send_help
send_help
 FNJSR "R1-R4"
 MOV R1,R0			; start of text
 MOV R2,#0			; 'previous' character
 MOV R3,#20			; current offset in help message
 MOV R4,#1			; no ignore
char$l
 LDRB R0,[R1],#1
 TEQ R0,#10
 TEQEQ R2,#10			; end marker: \n\n
 SUBEQ R3,R3,#2
 TEQNE R0,#0			; end marker: ^@
 BEQ end$l
 TEQ R0,#1			; ^A or ^H: stop ignoring
 TEQNE R0,#8
 MOVEQ R4,#1
 BEQ char$l
 TEQ R0,#26			; ^Z: ignore until end, ^A or ^H
 MOVEQ R4,#0
 TEQNE R4,#0			; short-circuit if in ignore mode
 BEQ char$l
 TEQ R0,#32
 TEQEQ R2,#32			; reduce multiple spaces
 BEQ char$l
 MOV R14,R0
 TEQ R0,#13			; translate CR to LF (then back again later)
 MOVEQ R0,#10
 TEQEQ R2,#10			; but ignore it if it's preceded by an LF
 MOV R2,R14			; remember (untranslated) for next time
 BEQ char$l
 TEQ R0,#10
 BLEQ trail$l			; remove trailing spaces & convert to CR
 CMP R0,#31
 ORRLO R0,R0,#64		; handle ctrl chars
 BLLO pipe$l
 TEQ R0,#'<'			; handle other 'special' chars
 TEQNE R0,#'|'
 BLEQ pipe$l
 STRB R0,[R11,R3]
 ADD R3,R3,#1
 TEQ R3,#255			; run out of room?
 BNE char$l			; ... no
end$l
 MOV R0,#0
 STRB R0,[R11,R3]		; end of text
 ADD R3,R3,#1
 TST R3,#3
 BNE end$l
 STR R3,[R11]			; new message length
 LDR R0,reply$l
 MOV R1,R11
 BL message_reply
 FNRTS
pipe$l
 FNJSR
 LDR R14,[R13,#4]		; stacked R1 ('|' control)
 TEQ R14,#0
 FNRTS NE
 CMP R3,#254
 FNPULL HS
 BHS end$l			; run out of room
 MOV R14,#'|'
 STRB R14,[R11,R3]
 ADD R3,R3,#1
 FNRTS
reply$l DCD &503		; HelpReply
trail$l				; strip trailing spaces
	TEQ	R3,#20
	MOVEQ	R0,#13
	MOVEQ	PC,R14
	SUB	R3,R3,#1
	LDRB	R0,[R11,R3]
	TEQ	R0,#32
	BEQ	trail$l
	ADD	R3,R3,#1
	MOV	R0,#13
	MOV	PC,R14

 LOCAL

;E R0=pointer in a zero terminated file (line end = &0A)
;X R0=start of next para/pointer to terminating char |
 FNAME next_para
next_para
 FNJSR
a$l
 LDRB R14,[R0],#1
 TEQ R14,#0
 SUBEQ R0,R0,#1
 FNRTS EQ			; file end
 TEQ R14,#&0A
 BNE a$l			; still in text
 LDRB R14,[R0]
 TEQ R14,#&0A
 BNE a$l			; make sure at para start
 ADD R0,R0,#1
 FNRTS

 LOCAL

;X Ensure helpdata file loaded #
 FNAME load_help
load_help
 FNLDR R0,wimp_helpdata
 CMP R0,#0
 MOVGT PC,R14			; already loaded
 FNJSR "R1-R5"
 MOV R0,#5
 ADR R1,help$l
 SWI XOS_File			; find info
 BLVC check_object_type
 ADDVC R0,R4,#1			; file+terminator
 BLVC heap_claim
 FNSTR R0,wimp_helpdata,VC		; help file
 MOVVC R2,R0
 MOVVC R0,#0
 STRVCB R0,[R2,R4]		; add terminating 0
 MOVVC R0,#255
 ADRVC R1,help$l
 MOVVC R3,#0
 SWIVC XOS_File			; load the file
 FNRTS
help$l FNS ("<Zap$HelpData>")


; in #
; out - Wimp_TextOp available? LT=no, GE=yes

checkfortextop
	FNJSR
	FNLDR	R14,opt_switches
	TST	R14,#switch_MinibufferAntialiased
	FNLDR	R14,wimp_realver,NE
	MOVEQ	R14,#0
	SUB	R14,R14,#320
	CMP	R14,#17
	FNRTS

 END
