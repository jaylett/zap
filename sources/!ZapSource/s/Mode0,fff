;test string: \\\aaa+++aaa\\\aaa\\\+++aaa+++\\\aaa
; Contains mode entry points for text mode.
; $Id: Mode0,fff,v 1.1.2.7 1999/04/13 00:44:04 ds Exp $

	GET	h.ZapHeader
	GET	h.Commands
	GET	h.AlterTxt
	GET	h.StartCode
	GET	h.Heap
	GET	h.ModeBits
	GET	h.Redraw
	GET	h.Cursors
	GET	h.Template
	GET	h.Mode1
	GET	h.SoftWrap
	GET	h.TMTVars

	IMPORT	get_SaveBox
	IMPORT	discard_file
	IMPORT	conv_wind_off
	IMPORT	test_shiftctrl
	IMPORT	find_leaf_name
	IMPORT	strcpy
	IMPORT	strcopy
	IMPORT	warn_user
	IMPORT	save_text
	IMPORT	zephyr

	EXPORT	mode_table_0
	EXPORT	mode0_author
	EXPORT	cln_FORWARD
	EXPORT	mode0_splus
	EXPORT	mode0_init
	EXPORT	mode0_copy
	EXPORT	mode0_click
	EXPORT	mode0_linestart
	EXPORT	mode0_linecol
	EXPORT	mode0_autoplus
	EXPORT	mode0_setwidth
	EXPORT	mode0_prevline
	EXPORT	modes_copy
	EXPORT	returnword
	EXPORT	next_line_number
	EXPORT	offset_line_number
	EXPORT	physical_line_number
	EXPORT	logical_line_number
	EXPORT	char_del_dispatch

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Default modes added and their blocks			      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mode_table_0
	DCD	mode_table_0
	DCD	mode0_title
	DCD	mode0_author
	DCD	0
	DCD	0 :OR: emode_MayBeCloned
	DCD	mode0_init
	DCD	0
	DCD	mode0_table_end-mode_table_0

	DCD	Null			; postload
	DCD	Null
	DCD	Null
	DCD	modes_start
	DCD	modes_end
	DCD	mode0_width
	DCD	mode0_linecol
	DCD	mode0_lineoff
	DCD	mode0_clnlog
	DCD	mode0_clnphy
	DCD	mode0_clnoff
	DCD	mode0_nextline
	DCD	mode0_minus
	DCD	mode0_plus
	DCD	mode0_sminus
	DCD	mode0_splus
	DCD	mode0_cminus
	DCD	mode0_cplus
	DCD	mode0_redrawline
	DCD	mode0_redrawlnum
	DCD	mode0_char
	DCD	mode0_delete
	DCD	mode0_tab
	DCD	mode0_return
	DCD	Null			; renumber
	DCD	mode0_saveandrun	; save and run
	DCD	mode0_linestart
	DCD	mode0_lineend
	DCD	mode0_linenext
	DCD	mode0_lineprev
	DCD	mode0_copy
	DCD	mode0_joinline
	DCD	mode0_splitline
	DCD	Null			; align caret
	DCD	mode0_command
	DCD	mode0_compile		; compile
	DCD	mode0_formattext
	DCD	Null			; run
	DCD	Null			; run and quit (e_compile)
	DCD	Null			; e_basic
	DCD	Null			; e_search
	DCD	replace_area
	DCD	mode0_selection
	DCD	mode0_click
	DCD	Null			; messages
	DCD	mode0_setwidth
	DCD	Null			; list fns
	DCD	mode0_prevline
	DCD	Null			; Open window
	DCD	mode0_interrogate	; interrogate
	DCD	mode0_returnword	; returnword
	DCD	mode0_help		; help
mode0_table_end

mode0_author
 = "Dominic Symes, Tim Tyler, Daniel Wagenaar and James Aylett",0
 ALIGN

mode0_title  FNS ("Text")

mode0_init
 TEQ R1,#3			; killing an ext edit / OLE file?
 BEQ free_exteditole
 TEQ R1,#4
 BEQ save_exteditole
 TEQ R1,#0			; quitting ?
 MOVEQ R0,#-1			; don't kill this module!!
 MOV PC,R14

 LOCAL

free_exteditole
 LDR R0,[R9,#f_cmode]
 TEQ R0,#0			; check it's owned by text mode
 MOVNE PC,R14
 FNJSR "R1-R10"
 LDR R10,[R9,#f_source]		; the data block
 LDR R0,[R10,#ee_ee]
 CMP R0,#1
 BLO free_extedit		; R0=0 -> EE file
 FNRTS HI			; not an OLE file
 ; do OLE here
 FNLDR R1,wimp_block		; somewhere for the message
 MOV R14,#0
 LDR R0,[R10,#ole_session]
 STR R14,[R1,#20]
 STR R0,[R1,#24]		; session number
 LDR R0,oleclosesession$l
 LDR R2,[R10,#ole_taskhandle]
 MOV R3,#28			; length of message
 BL message_send		; close session
 MOVVC R0,R10			; get block pointer
 BLVC heap_free
 FNRTS
oleclosesession$l
 DCD &80E23

free_extedit
; STMFD R13!,{R1-R10,R14}
; LDR R0,[R9,#f_cmode]
; TEQ R0,#0			; check its an ext edit file
; LDMNEFD R13!,{R1-R10,PC}
; LDR R10,[R9,#f_source]		; the data block
 FNLDR R1,wimp_block
 MOV R0,#0
 STR R0,[R1,#20]
 LDR R0,[R10,#ee_jobhandle]	; now #4
 STR R0,[R1,#24]		; job handle
 LDR R0,fr_d0			; message number
 LDR R2,[R10,#ee_taskhandle]	; task handle
 MOV R3,#28			; length
 BL message_send		; abort session
 MOVVC R0,R10
 BLVC heap_free			; free the data block
 FNRTS
fr_d0
 DCD &45D83			; abort

 LOCAL

save_exteditole
;save_extedit
 FNJSR "R1-R11"			; hardwired later!...
 LDR R10,[R9,#f_source]		; info block
 LDR R2,[R10,#ee_ee]
 CMP R2,#0
 BEQ save_extedit		; EE file
 CMP R2,#1
 FNRTS NE			; not an OLE file
 ; do OLE here
 FNLDR R1,wimp_block		; unlike EE, OLE actually saves the temp file
 LDR R2,[R10,#ole_taskhandle]	; ?
 MOV R14,#0			; TT
 STR R14,[R1,#20]		; TT
 LDR R3,[R10,#ole_session]
 STR R3,[R1,#24]
; MOV R3,#0			; session number		; TT
 STR R14,[R1,#12]		; your_ref (new message)	; TT
 ADD R0,R1,#28			; session name starts here
 LDR R8,[R9,#f_name]		; from
 ADD R7,R1,#255			; limit (with space for a trailing NUL)
saveloop$l
 LDRB R9,[R8],#1
 STRB R9,[R0],#1
 CMP R0,R7
 BNE saveloop$l
 MOV R9,#0
 STRB R9,[R0],#1
 ; Note that the following bit probably isn't necessary, but I could
 ; never get the correct method:
 ; ADD R3,R1,#28
 ; ORR R3,R3,#(1:SHL:31)
 ; which should make Zap calculate it automatically from the start
 ; of the string, to work properly.
 SUB R3,R0,R1			; bytes in message
 ADD R3,R3,#3
 BIC R3,R3,#3			; whole words
 LDR R0,olefilechanged$l
; MOV R5,#0
 BL message_send
 FNRTS
olefilechanged$l
 DCD &80E1E
 FNRTS

save_extedit
 MOV R2,#0			; use file name
 LDR R3,[R10,#ee_jobhandle]	; job handle  ; was R1????
 LDR R4,[R10,#ee_taskhandle]	; task handle ; was R1????
; LDR R3,[R1]			; job handle
; LDR R4,[R1,#4]			; task handle
 MOV R10,#1			; ext edit
 ADR R7,sub$l			; routine to call when finished
 MOV R11,R9			; file pointer (routine data)
 BL send_data_save
; FNRTS VS			; not an OLE file
 LDMFD R13!,{R1-R11,R14}	; hardwired...
 MOVVC R1,#-1			; stop the normal save!
 MOVVC R0,#-1			; data not safe yet
 MOV PC,R14

sub$l
 FNJSR "R9"
 MOV R9,R11
 LDR R0,[R9,#f_source]
 LDR R0,[R0,#ee_flags]		; external edit flags
 TST R0,#1			; continue?
 MOVEQ R0,#-1
 STREQ R0,[R9,#f_cmode]		; no longer an external edit file
 BLEQ discard_file
 FNRTS

 LOCAL

mode0_width
 FNJSR "R1-R2"
 MOV R0,#-1
 LDRB R1,[R8,#w_format]		; mode number
 MOV R2,#0
 BL mode_data			; read mode word
 MOV R1,R0,LSL#16
 MOV R1,R1,LSR#16		; get bottom 16 bits
 LDR R0,[R8,#w_flags]
 TST R0,#1<<6			; no auto width so...
 MOVEQ R0,R1			; text width (not auto width)
 BEQ width$l			; normal, not auto width
 LDR R0,[R8,#w_format]
 TST R0,#1<<27			; softwrap, so...
 MOVNE R0,R1			; text width (not auto width)
 BNE width$l			; normal, not auto width
 FNLDR R0,wimp_maxaw
 ;PUSH	  "R0"
 ;MOV	  R0,R7
 ;BL	 update_w_bpl
 ;PULL	 "R0"
 STR R0,[R8,#w_bpl]		; max line width (used in cln_count)
 BL cln_count			; R0=max logical line length
 FNRTS VS
 TEQ R0,#0
 MOVEQ R0,R1			; default width if file null
 FNLDR R1,wimp_minaw
 CMP R0,R1
 MOVLT R0,R1
 FNLDR R1,wimp_maxaw
 CMP R0,R1
 MOVGT R0,R1			; clip width to desired bounds
width$l				; b0-b15 of R0 is the width
 CMP R0,#5
 MOVLE R0,#5			; ensure width at least 5
 ;BL	 update_w_bpl
 STR R0,[R8,#w_bpl]		; save as byte (line) width
 FNRTS

mode0_setwidth
 STMFD R13!,{R1-R3,R14}
 MOV R3,R0			; save mode width
 MVN R0,#0			; read
 TEQ R8,#0
 FNLDRB R1,opt_format,EQ
 LDRNEB R1,[R8,#w_format]	; mode number
 MOV R2,#0
 BL mode_data			; read mode width word
 CMP R3,#0			; if negative, then...
 BMI ms10			; just reading the width
 MOV R0,R0,LSR#16		; clear bottom 16 bits
 MOV R3,R3,LSL#16
 MOV R3,R3,LSR#16		; new mode width
 CMP R3,#1
 MOVLE R3,#1			; clip below
 ADD R0,R3,R0,LSL#16		; new mode word
 TEQ R8,#0
 FNLDRB R1,opt_format,EQ
 LDRNEB R1,[R8,#w_format]	; mode number
 MOV R2,#0
 BL mode_data			; write the word
 LDMFD R13!,{R1-R3,PC}
ms10
 MOV R0,R0,LSL#16
 MOV R0,R0,LSR#16		; isolate the mode width
 LDMFD R13!,{R1-R3,PC}

call_redrawlnum
 BL modesw_redrawlnum
 LDMFD R13!,{PC}

mode0_redrawlnum
 STMFD R13!,{R14}
 LDR R14,[R8,#w_format]
 ANDS R14,R14,#bit_softwrap
 BNE call_redrawlnum
 LDMFD R13!,{R14}

 FNJSR
 SUBS R0,R7,#1			; file off of char before start of line
 BMI mo1
 BL cln_readc			; get char
 LDRB R1,[R8,#w_cr]
 TEQ R0,R1
 BEQ mo1			; match so we are at line start
 SUBS R0,R0,#0			; sec
 FNRTS
mo1
 ADDS R0,R0,#0			; clc
 FNRTS

mode0_redrawline
 FNJSR "R12"
 AND R0,R4,#&3<<12		; get tab type
 ORR R11,R11,R0,LSL#18		; store in top two bits of R11
 MOV  R1,#0			; col offset
 LDRB R2,[R8,#w_cr]		; get return code
 LDR  R3,[R8,#w_bpl]		; length of line
 LDRB R4,[R8,#w_tabc]		; get tab code
 ORR R2,R2,R4,LSL #24
 LDR R4,[R8,#w_txtw]		; width of cache as line width
 ADD R12,R6,R4			; colour fg mask buffer...
 ADD R4,R12,R4			; colour bg mask buffer...
red_c0_l1
 CMP R7,R10
 BLCS red_overflow		; off buffer section
 BVS red_c0_6			; hit file end
 LDRB R0,[R7],#1		; get next char
 AND R14,R2,#&FF
 TEQ R0,R14			; is it a cr
 BEQ red_c0_6			; end of this line
 TEQ R0,R2,LSR #24		; is it a tab
 BEQ red_c0_1
red_c0_3
 STRB R0,[R6,R1]		; write character
 MOV R0,#1			; bg coloured...
 STRB R0,[R4,R1]
 ADD R1,R1,#1			; update column count
red_c0_4
 CMP R1,R3			; are we at end of line
 BCC red_c0_l1			; next if not
 CMP R7,R10
 BLCS red_overflow		; off buffer section
 BVS red_c0_6			; off end of file
 LDRB R0,[R7]
 AND R14,R2,#&FF
 TEQ R0,R14
 ADDEQ R7,R7,#1			; skip return if follows
 BEQ red_c0_6
 LDR R1,[R8,#w_bpl]		; length remember margin!!!
 B red_c0_8
red_c0_1
 MOV R0,#9			; an arrow
 MOVS R14,R11,LSR #30
 BEQ red_c0_3			; no tab
 TEQ R14,#2
 STREQB R0,[R6,R1]		; arrow at start
 MOVEQ R14,#1			; control character coloured...(ha, opti)
 STREQB R14,[R4,R1]
 MOVS R14,R11,LSR #30		; code not needed...?
 TEQ R14,#3
 BNE red_c0_9
 ;ADDNE R1,R1,#8
 ;BICNE R1,R1,#7
 ;BNE red_c0_4			; done tab
red_c0_5
 MOV R14,#45 ; 29		; '-' - NOT ']' :|
 STRB R14,[R6,R1]		; store tab bit...
 MOV R14,#8			; FG control character coloured...
 STRB R14,[R12,R1]
 MOV R14,#1			; BG colour...(ha, opti)
 STRB R14,[R4,R1]
 LDR R14,[R8,#w_bpl]
 ADD R1,R1,#1
 CMP R1,R14
 BEQ toolong$l
 TST R1,#7
 BNE red_c0_5
 SUB R14,R1,#1
 STRB R0,[R6,R14]
 ;MOV R0,#8			; control character coloured...
 ;STRB R0,[R12,R14]		; code not needed...?
 ;LDR R14,[R8,#w_bpl]
 ;SUBS R14,R14,#3
 ;CMP R1,R14
 ;STREQB R0,[R6,R1]		; tab I of -> character at eol...
 MOV R0,#1			; control character coloured...(ha, opti)
 STRB R0,[R4,R1]
 B red_c0_4

toolong$l
 SUB R14,R1,#1
 STRB R0,[R6,R14]		; tab I of -> character at eol...
 MOV R0,#1			; control character coloured...(ha, opti)
 STRB R0,[R4,R14]
 B red_c0_4

red_c0_6
 ADDS R11,R11,#1		; new logical line & clv
red_c0_8
 BIC R11,R11,#3<<30		; clear tab status
; LDR R3,[R8,#w_txtw]		; width of cache as line width
; ADD R6,R6,R3,LSL#1		; background colour mask
; MOV R0,#1			; second background colour
;red_c0_7
; SUBS R1,R1,#1			; reduce column
; LDMLTFD R13!,{PC}		; finish
; STRB R0,[R6,R1]		; second background colour
; B red_c0_7
 FNRTS

red_c0_9
 ;MOV R14,#' ' ; 29		; '-' - NOT ']' :|
 ;STRB R14,[R6,R1]		; store tab bit...
 ;MOV R14,#8			; control character coloured...
 ;STRB R14,[R12,R1]
 MOV R14,#1			; control character coloured...(ha, opti)
 STRB R14,[R4,R1]
 ADD R1,R1,#1
 TST R1,#7
 BNE red_c0_9
 ;SUB R14,R1,#1
 ;STRB R0,[R6,R14]
 ;MOV R0,#8			; control character coloured...
 ;STRB R0,[R12,R14]		; code not needed...?
 ;MOV R0,#1			; control character coloured...(ha, opti)
 ;STRB R0,[R4,R1]		; ???
 B red_c0_4

 LOCAL

; ***************************************************************
; *		Calculation of line number routines		*
; ***************************************************************

; veneers:

; if calling these from within Zap and you know that the base mode
; is Text mode, then it's probably best to write code which avoids
; calling 'call_given_base_mode' and place it somewhere nearby.

next_line_number
 FNJSR "R11"
 MOV R11,#e_nextline
 BL call_mode
; post-processing...
 FNRTS

offset_line_number
 FNJSR "R11"
 MOV R11,#e_clnoff
 BL call_mode
; post-processing...
 FNRTS

physical_line_number
 FNJSR "R11"
; pre-processing...?
 MOV R11,#e_clnphy
 BL call_mode
 FNRTS

logical_line_number
 FNJSR "R11"
 MOV R11,#e_clnlog
 BL call_mode
; post-processing...
 FNRTS

; subs:

call_mode_clnphy		; call sw mode...
	BL	modesw_clnphy ;  call_mode_clnphy
	LDMFD	R13 !,{PC}

mode0_clnphy
	STMFD	R13 !,{R14}
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	BNE	call_mode_clnphy

 STMFD R13!,{R2-R11}
 MOV R2,R9			; file block
 LDR R3,[R8,#w_bpl]
 LDR R4,[R8,#w_tabc]
 LDR R5,[R8,#w_cr]
 LDR R6,[R8,#w_clogl]
 LDR R7,[R8,#w_cline]
 LDR R9,[R8,#w_coff]
 MOV R10,R0			; search phy line
 CMP R10,R7,LSR#1
 MOVLS R6,#0
 MOVLS R7,#0
 MOVLS R9,#0			; base offsets
cln_phy_2
 CMP R10,R7
 BCC cln_phy_backward
 BEQ cln_phy_end
cln_phy_1
 BL cln_FORWARD
 BVS cln_phy_end
 CMP R10,R7
 BHI cln_phy_1
 BCC cln_phy_vs
cln_phy_end
 MOV R0,R9
 MOV R1,R6
 LDMFD R13!,{R2-R11,PC}^	; returns with no error
cln_phy_backward
 BL cln_BACKWARD
 BVC cln_phy_2
cln_phy_vs
 BLVC err$l
 LDMFD R13!,{R2-R11,PC}		; return with error
err$l ERRlit "Internal error: cln_phy"

 LOCAL

call_mode_clnlog		; call sw mode...
	BL	modesw_clnlog ; call_mode_clnlog
	LDMFD	R13 !,{PC}

mode0_clnlog
	STMFD	R13 !,{R14}
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	BNE	call_mode_clnlog

 STMFD R13!,{R2-R11}
 MOV R2,R9			; file block
 LDR R3,[R8,#w_bpl]
 LDR R4,[R8,#w_tabc]
 LDR R5,[R8,#w_cr]
 LDR R6,[R8,#w_clogl]
 LDR R7,[R8,#w_cline]
 LDR R9,[R8,#w_coff]
 MOV R10,R0			; search log line
 CMP R10,R6,LSR#1
 MOVLS R6,#0
 MOVLS R7,#0
 MOVLS R9,#0			; base offsets
 TEQ R10,#0
 BEQ cln_log_end		; case when search line is 0
cln_log_2
 CMP R10,R6
 BLS cln_log_backward		; may be in the line
cln_log_1
 BL cln_FORWARD
 BVS cln_log_end
 CMP R10,R6
 BHI cln_log_1
 BCC cln_log_vs
cln_log_end
 MOV R0,R9
 MOV R1,R7
 LDMFD R13!,{R2-R11,PC}^	; returns with no error
cln_log_backward
 BL cln_BACKWARD
 BVC cln_log_2
cln_log_vs
 BLVC err$l
 LDMFD R13!,{R2-R11,PC}		; return with error
err$l ERRlit "Internal error: cln_log"


call_mode_clnoff		; call sw mode...
	BL	modesw_clnoff
	LDMFD	R13 !,{PC}

mode0_clnoff
	STMFD	R13 !,{R14}
; STMFD R13!,{R0}
; BL zephyr
; LDMFD R13!,{R0}
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	BNE	call_mode_clnoff	; TEST TEST TEST TEST

 STMFD R13!,{R3-R11}
 LDR R1,[R9,#f_len]
 TEQ R1,#0			; null length file special case
 BEQ cln_off_0
 CMP R0,R1
 MOVCC R10,R0
 MOVCS R10,R1			; search offset in file or on end
 MOV R2,R9			; file block
 LDR R3,[R8,#w_bpl]
 LDR R4,[R8,#w_tabc]
 LDR R5,[R8,#w_cr]
 LDR R6,[R8,#w_clogl]
 LDR R7,[R8,#w_cline]
 LDR R9,[R8,#w_coff]
 CMP R10,R9,LSR#1		; if offset nearer start of file
 MOVLS R6,#0
 MOVLS R7,#0
 MOVLS R9,#0			; base offsets
cln_off_2
 CMP R10,R9
 BCC cln_off_backward		; was/still is CC
 BEQ cln_off_end
 ADR R11,cln_off_blk		; temp data store
cln_off_1
 STMIA R11,{R6,R7,R9}		; save start of line
 BL cln_FORWARD
 BVS cln_off_3			; off end of file
 CMP R10,R9
 BEQ cln_off_end		; match
 BHI cln_off_1			; still further on
 LDMIA R11,{R6,R7,R9}		; get previous line vals
cln_off_end
; SWI &107
 MOV R0,R7			; phy line
 MOV R1,R9			; start offset of line
 MOV R2,R6			; log line
 LDMFD R13!,{R3-R11,PC}^	; returns with no error
cln_off_backward
 BL cln_BACKWARD
 BVC cln_off_2
 LDMFD R13!,{R3-R11,PC}		; return with error
cln_off_blk
 DCD 0
 DCD 0
 DCD 0				; small data block
cln_off_3
 LDMIA R11,{R6,R7,R9}		; get previous line vals
 B cln_off_end

cln_off_0
 MOV R0,#0
 MOV R1,#0
 MOV R2,#0
 LDMFD R13!,{R3-R11,PC}		; null file

;;;; middle level forward/backward subs & split buffer handling ;;;;

;E R2=fileblk R3=line len R4=tab mask R5=ret mask R6=log ln R7=phy ln
;  R9=file off of start of phy line
;X Vals updated to the start of the next physical line. R8=len of this
;  phy line (exc 0A). It returns VS if the end of the buffer lies on
;  this line. Saves R10-R11.

cln_FORWARD
 STMFD R13!,{R10-R11,R14}
 MOV R8,#0			; current column offset
 LDR R10,[R2,#f_ptr]
 LDR R11,[R2,#f_splito]
 CMP R9,R11
 ADD R9,R10,R9
 BCS cln_FO_1
 ADD R11,R10,R11
 BL cln_forward			; first half of buffer
 SUBVC R9,R9,R10
 LDMVCFD R13!,{R10-R11,PC}
cln_FO_1
 LDR R0,[R2,#f_bufl]
 ADD R11,R10,R0
 LDR R0,[R2,#f_splits]
 ADD R10,R10,R0			; aparant start of second half
 ADD R9,R9,R0
 BL cln_forward			; second half of buffer
 SUB R9,R9,R10			; file offset
 LDMVCFD R13!,{R10-R11,PC}
 CMP R8,R3			; is the last line full
; ADDCS R7,R7,#1			; if so inc phy line (but not log line)
 LDMFD R13!,{R10-R11,R14}	; and return
 ;MOVCS PC,R14			; return VC if could do this line
 ORRS PC,R14,#Vbit

 LOCAL

;E R2=fileblk R3=line len R4=tab mask R5=ret mask R6=log ln R7=phy ln
;  R9=file off of start of phy line
;X vals updated to _A_ previous phy line, VS if error R10-R11 saved

cln_BACKWARD
 STMFD R13!,{R10-R11,R14}
 MOV R11,R9			; save current start of phy line
 STMFD R13!,{R6,R7}		; save line counts
 LDR R8,[R2,#f_ptr]		; start of first half
 LDR R7,[R2,#f_splito]		; len of first half
 CMP R9,R7
 ADD R9,R8,R9			; address in first half
 BLS cln_BA_1			; in first half
 LDR R6,[R2,#f_splits]		; split gap size
 ADD R10,R8,R7			; end of first half
 ADD R10,R10,R6			; start of second half
 ADD R9,R9,R6			; address in second half
 BL cln_backward		; second half of buffer
 SUB R9,R9,R6			; address in first half
 BVC cln_BA_2			; at start of a log line
cln_BA_1
 MOV R10,R8			; start of first half
 BL cln_backward		; first half of buffer
cln_BA_2
 SUBS R9,R9,R8			; file offset of phy line (&clv)
 MOV R10,R9			; save new offset
 MOV R7,#0
 MOV R6,#0			; zero line counts
cln_BA_3
 BL cln_FORWARD			; move forward one phy line
 BVS cln_BA_vs
 CMP R9,R11
 BLT cln_BA_3			; not reached start pos yet
 BHI cln_BA_vs			; no match = error
 MOV R9,R10			; new offset
 LDMFD R13!,{R0,R1}		; origional line vals
 SUB R6,R0,R6
 SUB R7,R1,R7			; new line vals
 LDMFD R13!,{R10-R11,PC}
cln_BA_vs
 LDMFD R13!,{R0,R1}		; restore stack
 BL err$l			; internal error
 LDMFD R13!,{R10-R11,PC}	; ret with error
err$l ERRlit "Internal error: cln_BACKWARD"

;;;;;;;;;;;;;;;; low level forward/backward subs ;;;;;;;;;;;;;;;;;;;

;E R3=line len R4=tab mask R5=ret mask R6=log ln R7=phy ln R8=cur offset
;  in phy line R9=curr address in buffer R11=end of section
;X All values moved to start of the next physical line in the section.
;  R2 & R10-R11 saved. Note that if it reaches the end of the section
;  before it is certain that it has reached the next phy line the returns
;  VS. Otherwise returns VC.

cln_forward
 FNJSR
cln_fo_l
 ;SUB R14,R11,#4		; PLAIN WRONG.
 CMP R9,R11			; was R11 (fix of bug mentioned below...?)
 BCS cln_fo_vs			; end of section reached
 AND R14,R9,#3
 BIC R9,R9,#3
 LDR R0,[R9],#4			; this instruction has caused an abort...
				; ...on one occasion in TW mode... :(
 EOR R1,R0,R4			; tab mask
 EOR R0,R0,R5			; return mask
 SUB R8,R8,R14			; compensate for branching into code
 ADD R14,R14,R14,LSL#1		; times 3
 ADD PC,PC,R14,LSL#2		; branch into code
 DCD 0
cln_fo_a
 TST   R0,#&000000FF
 TSTNE R1,#&000000FF
 BEQ   cln_fo_0			; do first char
 TST   R0,#&0000FF00
 TSTNE R1,#&0000FF00
 BEQ   cln_fo_1			; do second char
 TST   R0,#&00FF0000
 TSTNE R1,#&00FF0000
 BEQ   cln_fo_2			; do third char
 TST   R0,#&FF000000
 TSTNE R1,#&FF000000
 BEQ   cln_fo_3			; do fourth char
 ADD R8,R8,#4			; new offset
 CMP R9,R11
 BCS cln_fo_v			; overflow and compensate
 CMP R8,R3			; off end of line?
 LDRLS R0,[R9],#4
 EORLS R1,R0,R4			; tab
 EORLS R0,R0,R5			; ret
 BLS cln_fo_a			; loop if not off end of line
cln_fo_nl
 SUB R0,R8,R3			; find overflow
 SUB R9,R9,R0			; start of phy line
 ADD R7,R7,#1			; inc phy line
 FNRTS
cln_fo_v
 SUB R0,R9,R11			; size of overflow
 SUB R8,R8,R0			; subtract the chars
 MOV R9,R11			; new nextchar
 CMP R8,R3
 BHI cln_fo_nl			; we've gone onto a newline
cln_fo_vs
 FNRTV				; overflown buffer before next phy line
cln_fo_0
 SUB R9,R9,#4
 B cln_fo_m
cln_fo_1
 ADD R8,R8,#1
 MOV R0,R0,LSR#8
 SUB R9,R9,#3
 B cln_fo_m
cln_fo_2
 ADD R8,R8,#2
 MOV R0,R0,LSR#16
 SUB R9,R9,#2
 B cln_fo_m
cln_fo_3
 ADD R8,R8,#3
 MOV R0,R0,LSR#24
 SUB R9,R9,#1
cln_fo_m
 CMP R9,R11
 BCS cln_fo_v			; overflowed buffer
 TST R0,#&FF			; char valid
 BNE cln_fo_tab			; not a return (thus a tab)
 CMP R8,R3
 BHI cln_fo_nl			; already on next line
 ADD R9,R9,#1			; include this char
 ADD R7,R7,#1
 ADD R6,R6,#1			; next phy & log line
 FNRTS
cln_fo_tab
 CMP R8,R3
 BCS cln_fo_nl			; gone to next phy line if R8>=R3
 ADD R9,R9,#1			; include this tab
 ADD R8,R8,#8
 BIC R8,R8,#7			; effect tab
 CMP R8,R3
 MOVCS R8,R3			; align to edge
 B cln_fo_l			; do next character

;E R5=ret mask R9=addr in buffer R10=start of section
;X VS if overflowed section before prev log line }
;  VC if reached prev logical line (in R9)	 } R1-R4,R6-R8,R11 saved

cln_backward
 CMP R9,R10			; start of buf
 BLS cln_ba_vs
 SUB R9,R9,#1			; skip 0A/a char (if already at start)
cln_ba_2
 CMP R9,R10
 BLS cln_ba_vs			; start of buf
 TST R9,#3
 BEQ cln_ba_a			; word aligned
 LDRB R0,[R9,#-1]!
 TEQ R0,R5,LSR#24
 BNE cln_ba_2
 ADD R9,R9,#1			; start of log line
 MOV PC,R14			; ret
cln_ba_a
 LDR R0,[R9,#-4]!		; word aligned R9
 EOR R0,R0,R5			; ret mask
 TST   R0,#&FF000000
 TSTNE R0,#&00FF0000
 TSTNE R0,#&0000FF00
 TSTNE R0,#&000000FF
 BEQ cln_ba_m			; match found
 CMP R9,R10
 BHI cln_ba_a			; still some chars left
cln_ba_vs
 MOV R9,R10
 ORRS PC,R14,#Vbit	      ; return start of buffer error
cln_ba_m
 TST   R0,#&FF000000
 ADDEQ R9,R9,#1
 TSTNE R0,#&00FF0000
 ADDEQ R9,R9,#1
 TSTNE R0,#&0000FF00
 ADDEQ R9,R9,#1			; R9 points to the 0A
 CMP R9,R10
 BCC cln_ba_vs			; off start of buffer
 ADD R9,R9,#1			; start of next line
 MOV PC,R14

 LOCAL

; call_mode_lineoff		; sw only.
;  FNJSR "R2-R10"
;  LDRB R5,[R8,#w_cr]
;  LDRB R4,[R8,#w_tabc]
;  MOV R6,#0			; current column
;  MOV R7,R0			; current offset
;  MOV R10,R1			; file offset to stop at
;  CMP R10,R7
;  BLS end2$l			; already passed it
; loop2$l
;  MOV R0,R7
;  BL cln_readc
;  TEQ R0,R5
;  BEQ end2$l
;  TEQ R0,R4
;  ADDEQ R6,R6,#8
;  BICEQ R6,R6,#7
;  ADDNE R6,R6,#1
;  ADD R7,R7,#1
;  CMP R10,R7
;  BHI loop2$l
; end2$l
;  SWI &107
;  MOV R0,R6
;  MOV R1,#1			; caret width
;  FNRTS

;E R0=offset of physical line start R1=file offset R8/R9
;X R0=column offset (exc margin) R1=caret width

mode0_lineoff
; STMFD	  R13 !,{R14}
; LDR	  R14,[R8,#w_format]
; ANDS	  R14,R14,#bit_softwrap
; BNE	  call_mode_lineoff
; LDMFD	  R13 !,{R14}

default_mode0_lineoff
 FNJSR "R2-R10"
 LDRB R5,[R8,#w_cr]
 LDRB R4,[R8,#w_tabc]
 LDR R8,[R9,#f_len]		; R8 mashed!
 MOV R6,#0			; current column
 MOV R7,R0			; current offset
 MOV R10,R1			; file offset to stop at
 CMP R10,R7
 BLS end$l			; already passed it
loop$l
 CMP R7,R8			; eof?
 BCS end$l
 MOV R0,R7
 BL cln_readc
 TEQ R0,R5
 BEQ end$l
 TEQ R0,R4
 ADDEQ R6,R6,#8
 BICEQ R6,R6,#7
 ADDNE R6,R6,#1
 ADD R7,R7,#1
 CMP R10,R7
 BHI loop$l
end$l
 MOV R0,R6
 MOV R1,#1			; caret width
 FNRTS

call_mode_linecol		; *don't* call sw mode...
 ; \E r0 = sophysl offset
 ;    r1 = column #
 ;    r8-r10
 ; \X r0 = offset corresp. to column #
;.mode_linecol
; stmfd r13!,{r14}
; bl mode_clever_linecol
; ldmfd r13!,{pc}^
; .mode_clever_linecol
 ; main routine for mode_linecol
 ; \X CS if at eol, CC if not
 ;    OTHER FLAGS CORRUPT, INCL. V!!!
 STMFD r13!,{r0-r11}
 LDR R11,[r8,#w_info]		; sufficient.
 ORR R14,R11,#bit_strongsw	; clear is not relevant here...!
 STR R14,[r8,#w_info]
 BL mode0_lineend
 STR R11,[r8,#w_info]
 MOV r3,r0
 ; r3 = lineend offset
 LDMFD r13!,{r0}
 BL default_mode0_linecol
 ;SWI &107
 CMP r0,r3
 MOVCS r0,r3
 LDMFD r13!,{r1-r11}
 LDMFD R13 !,{PC}^

mode0_linecol
 STMFD	 R13 !,{R14}
 LDR	 R14,[R8,#w_format]
 ANDS	 R14,R14,#bit_softwrap
 BNE	 call_mode_linecol
 LDMFD	 R13 !,{R14}
default_mode0_linecol

 STMFD R13!,{R1-R10,R14}
 LDRB R5,[R8,#w_cr]
 LDRB R4,[R8,#w_tabc]
 LDR R3,[R9,#f_len]
 MOV R6,#0
 MOV R7,R0
 ADDS R10,R1,#0
 BLE cln_lc_2			; at start of line
cln_lc_1
 CMP R7,R3
 BCS cln_lc_2			; off end of file
 MOV R0,R7
 BL cln_readc
 TEQ R0,R5
 BEQ cln_lc_2
 TEQ R0,R4
 ADDEQ R6,R6,#8
 BICEQ R6,R6,#7
 ADDNE R6,R6,#1
 ADD R7,R7,#1
 CMP R10,R6
 BHI cln_lc_1
 SUBCC R7,R7,#1
cln_lc_2
 MOV R0,R7
 CMP R0,R3
 MOVCS R0,R3
 LDMFD R13!,{R1-R10,PC}

;E R0=line off R1=caret off R2=caret col R8/R9
;X R1/R2 new posn after / R2=-1 and R1=new file offset #

call_mode_plus
 STMFD R13!,{R0,R1,R7,R14}
 LDR R14,[R8,#w_format]
 ANDS R14,R14,#bit_confinehorizontal
 BNE assw_normal
 MOV R7,R1			; save caret offset
 LDR R1,[R9,#f_len]
 CMP R7,R1
 BCS assw_normal		; off end of file so *stop* if needed
 MOV R0,R7
 BL cln_readc			; get char currently on
 LDRB R1,[R8,#w_cr]
 TEQ R0,R1
 BEQ tocln_p1			; a return
assw_normal
 LDMFD R13!,{R0,R1,R7,R14}
 BL modesw_plus
 LDMFD	 R13 !,{PC}

;tomodesw_plus
; BL modesw_plus
; LDMFD R13 !,{R7,PC}

tocln_p1
 LDMFD R13!,{R0,R1,R7,R14}
 LDMFD R13!,{R14}
 B mode0_normalplus

mode0_plus
 STMFD	 R13 !,{R14}
 LDR	 R14,[R8,#w_format]
 ANDS	 R14,R14,#bit_softwrap
 BNE	 call_mode_plus
 LDMFD	 R13 !,{R14}
mode0_normalplus
 STMFD R13!,{R7,R14}
 MOV R7,R1			; save caret offset
 LDR R14,[R8,#w_format]
 ANDS R14,R14,#bit_confinehorizontal
 BNE cln_p2			; confined.
 FNLDR R14,car_mode
 CMP R14,#3
 BEQ cln_p2
 LDR R1,[R9,#f_len]
 CMP R7,R1
 BCS cln_p3			; off end of file so *stop* if needed
 MOV R0,R7
 BL cln_readc			; get char currently on
 LDRB R1,[R8,#w_cr]
 TEQ R0,R1
 BEQ cln_p1			; a return
 LDRB R1,[R8,#w_tabc]
 TEQ R0,R1
 ADDEQ R2,R2,#8
 BICEQ R2,R2,#7
 ADDNE R2,R2,#1			; new column offset
 ADD R7,R7,#1			; new offset
 LDR R1,[R9,#f_len]
 CMP R7,R1
 LDMCSFD R13!,{R7,PC}		; at end of file (so return f_len)
 MOV R0,R7
 BL cln_readc
 LDRB R1,[R8,#w_cr]
 TEQ R0,R1
 MOVEQ R1,R7
 LDMEQFD R13!,{R7,PC}
 LDR R1,[R8,#w_bpl]
 CMP R2,R1
 SUBCS R7,R7,#1			; compensate for the no return
 BCS cln_p2			; next line
 MOV R1,R7			; new offset
 LDMFD R13!,{R7,PC}

cln_p1
 ADD R2,R2,#1			; next column
 LDR R1,[R8,#w_bpl]
 CMP R2,R1
 MOVCC R1,R7
 LDMCCFD R13!,{R7,PC}
; fall through...

cln_p2
 ADD R1,R7,#1			; offset
 MVN R2,#0
 LDMFD R13!,{R7,PC}

cln_p3
 ADD R2,R2,#1			; next column
 LDR R1,[R8,#w_bpl]
 CMP R2,R1
 MOVCC R1,R7
 LDMCCFD R13!,{R7,PC}
; fall through...

cln_p4
 SUB R2,R2,#1			; TT
 SUB R1,R7,#0			; TT
 LDMFD R13!,{R7,PC}

 LOCAL

;E R0=line off R1=caret off R2=caret col R8/R9
;X R1/R2 new posn after / R2=-1 R1=new offset #

mode0_minus
 FNJSR "R3-R10"
 LDRB R5,[R8,#w_cr]
 LDRB R4,[R8,#w_tabc]
 MOV R3,R1			; current file offset
 MOV R6,#0			; current col
 MOV R7,R0			; current address in line
 ADDS R10,R2,#0			; search column
 BLE prev$l			; at start of line already
 LDR R2,[R9,#f_len]		; end of file
loop$l
 CMP R7,R2
 BCS back$l			; cursor is off the end of the file
 MOV R0,R7
 BL cln_readc
 TEQ R0,R5
 BEQ back$l			; a return
 MOV R14,R6			; temp save of previous column
 TEQ R0,R4
 ADDEQ R6,R6,#8
 BICEQ R6,R6,#7
 ADDNE R6,R6,#1
 ADD R7,R7,#1			; next column
 CMP R10,R6
 BGT loop$l
 SUB R1,R7,#1			; new offset of caret
 MOV R2,R14			; new col of caret
 FNRTS
prev$l
 SUB R1,R7,#1
 MOV R2,#-1
 FNRTS				; move to end of previous line
back$l
 MOV R1,R7			; point to the return
 SUB R2,R10,#1			; and move back one column
 FNRTS

 LOCAL

;E R0=phy line start R1=cur off R2=cur col R8-R10
;X R1,R2=new posn / R2<0 for specials #

mode0_splus
 PUSH "R2"
 LDR R2,[R8,#w_format]		; w_format
 TST R2,#1 << 25
 PULL "R2"
 BNE splus_smart
 FNJSR "R3-R7"
 MOV R7,R1			; save offset
 LDR R6,[R9,#f_len]		; length of file
 LDRB R5,[R8,#w_cr]
 LDRB R4,[R8,#w_tabc]
 MOV R3,#-1			; have met a white space flag
 MOV R2,#-1			; returns offset
loop$l
 CMP R7,R6
 MOVCS R1,R6			; end of file
 FNRTS CS
 MOV R0,R7
 BL cln_readc
 TEQ R0,#' '
 TEQNE R0,R4
 TEQNE R0,R5
 MOVEQ R3,#1			; reached a white space
 ADD R7,R7,#1			; next char
 BEQ loop$l			; a white space character
 MOVS R3,R3
 BMI loop$l			; no white spaces yet!
 SUB R1,R7,#1
 FNRTS

 LOCAL

; as for mode0_splus

mode0_sminus
 PUSH "R2"
 LDR R2,[R8,#w_format]		; w_format
 TST R2,#1 << 25
 PULL "R2"
 BNE sminus_smart
 FNJSR "R3-R7"
 MOV R7,R1			; save offset
 LDRB R5,[R8,#w_cr]
 LDRB R4,[R8,#w_tabc]
 MOV R3,#-1			; have met a white space flag
 MOV R2,#-1			; returns offset
loop$l
 CMP R7,#0
 MOVLE R1,#0			; start of file
 FNRTS LE
 SUB R0,R7,#1
 BL cln_readc
 TEQ R0,#' '
 TEQNE R0,R4
 TEQNE R0,R5
 MOVEQ R3,#1			; reached a white space
 SUB R7,R7,#1			; this char
 BEQ loop$l			; a white space character
 MOVS R3,R3
 BMI loop$l			; no white spaces yet!
 ADD R1,R7,#1
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Wordwrap/Line format						  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

mode0_formattext
 FNJSR
 BL start_operation		; concatonate
 LDR R0,[R10,#c_loff]
line$l
 BL format_line
 BVS err$l
 TEQ R1,#1			; reached para end?
 BNE line$l
 STR R0,[R10,#c_off]		; new caret offset
 BL stop_operation		; print result
 BLVC reflect_caret
 BLVC make_cursor_visible
 FNRTS
err$l
 BL stop_operation
 FNRTS

 LOCAL

;E R0=file offset to take for line start R8-R9
;X R0=file offset of next line after (uses command_primative) #
;  R1=0 if nothing done/1 if reached para end/2 if moved stuff
; (Algorithm: If line stops short of end then sees if it can join on a bit
; of the next line - if so then joins on the whole of the next line and
; loops back to the start. If line goes over end then splits it and returns).

format_line
 FNJSR "R2-R11"
 MOV R7,R0			; save file offset
 LDR R6,[R9,#f_len]
 LDRB R5,[R8,#w_cr]
 LDRB R4,[R8,#w_tabc]
 CMP R7,R6
 BCS fileend$l			; reached file end
 MOV R3,#0			; current column
 LDR R2,[R8,#w_wrapwidth]	; format width
 MOV R10,#0			; last valid split offset (none currently)
 MOV R11,#0			; done nothing flag
search$l			; search for somewhere to split at
 CMP R7,R6
 BCS lineend$l ; fileend$l	; reached file end
; BCS fileend$l			; reached file end
 MOV R0,R7
 BL cln_readc			; get next character
 ADD R7,R7,#1			; update offset
 TEQ R0,R5
 BEQ lineend$l			; reached line end
 TEQ R0,R4
 ADDNE R3,R3,#1
 ADDEQ R3,R3,#8
 BICEQ R3,R3,#7			; update column
 TEQ R0,#&20
 TEQNE R0,R4
 SUBEQ R10,R7,#1		; update last valid split posn
 BEQ search$l			; and loop ignoring overflow
 CMP R3,R2			; have we overflowed line end
 BLE search$l			; (not overflow)
 CMP R10,#0
; BLE para$l			; nowhere to split so give up
 BLE search$l			; nowhere to split - keep going anyway because it's rude not to
 MOV R0,#3			; replace
 MOV R1,R10			; file offset
 MOV R2,#1			; number of bytes
 ADD R3,R12,#tmp_formline	; data to replace with
 STRB R5,[R3]
 BL command_primative		; (this sub may be called in exec_command)
 ADDVC R0,R10,#1			; next line
 MOVVC R1,#2			; done stuff
 FNRTS
lineend$l
 TEQ R3,#0
 BEQ end$l			; this line was blank so skip
 MOV R10,R7			; start of next line
join$l				; get bit to join on
; CMP R10,R6
; BHS fileend$l			; off end of file
 SUBS R0,R10,R7			; number of bytes planning to add (exc ret)
 BLE check$l			; don't test adding null text
 ADD R0,R0,R3			; total length of old line (exc extra space)
 CMP R0,R2
 BCS end$l			; no split posn close enough to join
check$l				; check for a split posn
 CMP R10,R6			; at EOF?
 MOVHS R0,R5			; ...if so, pretend it's a CR
 MOVLO R0,R10
 BLLO cln_readc			; otherwise, get next char
 TEQ R0,#&20
 TEQNE R0,R5
 TEQNE R0,R4
 ADDNE R10,R10,#1
 BNE join$l			; not reached a split posn yet
 SUBS R0,R10,R7			; offset in line
 BLE para$l			; if at start of line then at new para
 ADD R1,R3,R0
 ADD R1,R1,#1			; col we would reach if joined
 CMP R1,R2
 BHI end$l			; no good don't bother to join
 MOV R3,R1			; update col
 PUSH "R2-R3"
 MOV R0,#3			; replace
 SUB R1,R7,#1			; file offset
 MOV R2,#1			; number of bytes
 ADD R3,R12,#tmp_formline	; data to replace with
 MOV R14,#&20
 STRB R14,[R3]
 BL command_primative		; (this sub may be called in exec_command)
 PULL "R2-R3"
 SUBVC R0,R7,#1			; last valid spilt posn
 MOVVC R7,R10			; update offset
 MOVVC R10,R0			; update last valid posn
 MOVVC R11,#2			; done something
 BVC search$l			; continue with line
 FNRTS
end$l
 MOV R0,R7			; next line
 MOV R1,R11			; return what I've done
 FNRTS
fileend$l
 MOV R0,R6			; file end
 MOV R1,#1
 FNRTS
para$l				; start of a new paragraph
 MOV R0,R7
 MOV R1,#1
 FNRTS

mode0_command
 FNJSR
 BL adjust_ins_pt_if_needed
 BLEQ changeposn$l
 LDR R14,[R8,#w_flags]
 TST R14,#(1<<13)		; wordwrap?
 BNE co23			; wordwrap
 BL command_primative		; do the original command
 FNRTS
co23
 BL start_operation
 BL command_primative
 BLVS stop_operation
 FNRTS VS
 STMFD R13!,{R1-R3}
 ADD R3,R1,R2			; last altered offset
 MOV R0,R1			; first file offset
 BL mode0_linestart		; start of the logical line
 BVS co22
 LDR R2,[R9,#f_flags]
 ORR R14,R2,#1<<14		; unlink input
 STR R14,[R9,#f_flags]
co21
 BL format_line
 BVS co22
 TEQ R1,#1
 BEQ co22			; reached para end
 CMP R0,R3
 BCC co21			; haven't yet reached change end
 TEQ R1,#0
 BNE co21			; has done something so continue
co22
 LDR R14,[R9,#f_flags]
 AND R2,R2,#1<<14
 BIC R14,R14,#1<<14
 ORR R14,R14,R2
 STR R14,[R9,#f_flags]		; restore linked state
 BL stop_operation
 LDMFD R13!,{R1-R3,PC}

;X NE if insert as normal.  EQ if changes needed...
adjust_ins_pt_if_needed
 FNJSR "R0,R1,R2,R3,R10"
 LDR R14,[R8,#w_info]
 TST R14,#1<<6
 BEQ exitclear$l		; not a full line
 AND R14,R0,#7			; get basic command number
 TEQ R14,#1			; insert
 BNE exitclear$l		; not a full line
 CMP R2,#3
 BLT exitclear$l		; not a full line
 ;LDR R14,[R9,#f_len]		; at last char...?
 ;CMP R1,R14
 ;BCS exitclear$l		; if so then insert a line
 MOV R1,#0
 LDRB R0,[R8,#w_cr]
loop1$l
 SUB R2,R2,#1
 LDRB R14,[R3,R2]		; last character
 CMP R14,#33
 ORRCS R1,R1,#1<<31		; flag for 'sensible character used'.
 TEQ R14,R0
 ORREQ R1,R1,#1<<30		; flag for CR hit
 ;BEQ co2			; is a return so enter line
 CMP R2,#0
 BGT loop1$l
 TST R1,#1<<30
 BNE co2
exitclear$l
 MOVS R14,#-1			; NE if not.
 FNRTS
co2
 TST R1,#1<<31
 BEQ exitclear$l
 MOVS R14,#0			; EQ if as full line...
 FNRTS

changeposn$l
 FNJSR "R0,R10,R11"
 MOV R0,R1
 MOV R11,#e_lineprev
 BL call_mode
 MOV R1,R0
 FNRTS

 LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Move to line start/end					  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

call_mode_lineend		; call sw mode...
 LDMFD	R13 !,{R14}
 B	modesw_lineend

mode0_lineend
 STMFD	R13 !,{R14}
 LDR	R14,[R8,#w_format]
 TST	R14,#bit_softwrap
 BEQ	asnormal$l
 LDR	R14,[R8,#w_info]
 TST	R14,#bit_strongsw
 BNE	call_mode_lineend
asnormal$l
 STMFD	R13!,{R1-R2}
 MOV	R1,R0
 BL	mode0_cplus
 MOV	R0,R1
 LDMFD	R13!,{R1-R2,PC}

 LOCAL

call_mode_lineprev		; call sw mode...
 LDMFD	R13 !,{R14}
 B	modesw_lineprev
; LDMFD	  R13 !,{PC}

mode0_lineprev
 STMFD R13 !,{R14}
 LDR R14,[R8,#w_format];
 ANDS R14,R14,#bit_softwrap
 BEQ basemode_linestart

 ;;;!!!
; B basemode_linestart

 LDR R14,[R8,#w_info]
 TST R14,#bit_strongsw
 BNE call_mode_lineprev
 B basemode_linestart

call_mode_linestart		; call sw mode...
 LDMFD R13 !,{R14}
 B modesw_linestart ;  call_mode_linestart
; LDMFD R13 !,{PC}

 LOCAL

mode0_linestart
 STMFD R13 !,{R14}
 LDR R14,[R8,#w_format];
 TST R14,#bit_softwrap
 BEQ basemode_linestart
 LDR R14,[R8,#w_info]
 TST R14,#bit_strongsw
 BNE call_mode_linestart
basemode_linestart
 STMFD R13!,{R1-R2}
 MOV R1,R0
 BL mode0_cminus
 MOV R0,R1
 LDMFD R13!,{R1-R2,PC}

 LOCAL

call_mode_linenext		; call sw mode...
 LDMFD R13 !,{R14}
 B modesw_linenext ; call_mode_linenext

mode0_linenext
 STMFD R13!,{R14}
 LDR R14,[R8,#w_format];
 TST R14,#bit_softwrap
 BEQ asnormal$l
 LDR R14,[R8,#w_info]
 TST R14,#bit_strongsw
 BNE call_mode_linenext
asnormal$l
 STMFD R13!,{R1-R2}
 MOV R1,R0
 BL mode0_cplus
 ADD R0,R1,#1
 LDR R1,[R9,#f_len]
 CMP R0,R1
 MOVCS R0,R1
 LDMFD R13!,{R1-R2,PC}

 LOCAL

mode0_cplus
 STMFD R13 !,{R14}
 LDR R14,[R8,#w_format];
 TST R14,#bit_softwrap
 BEQ asnormal$l
 LDR R14,[R8,#w_info]
 TST R14,#bit_strongsw
 BNE modesw_cplus
asnormal$l
 STMFD R13!,{R3-R7}
 LDRB R5,[R8,#w_cr]
 LDR R6,[R9,#f_len]
 MOV R7,R1			; save offset
 MVN R2,#0			; returning offset
cln_l1
 CMP R7,R6
 MOVCS R1,R6			; end of file
 LDMCSFD R13!,{R3-R7,PC}
 MOV R0,R7
 BL cln_readc
 TEQ R0,R5
 ADD R7,R7,#1
 BNE cln_l1
 SUB R1,R7,#1			; end of line
 LDMFD R13!,{R3-R7,PC}

 LOCAL

call_mode_cminus
 MOV R2,#0
 MOV R1,R0
 LDMFD R13!,{PC}

mode0_cminus
 STMFD R13!,{R14}
 LDR R14,[R8,#w_format];
 ANDS R14,R14,#bit_softwrap
 BEQ asnormal$l
 LDR R14,[R8,#w_info]
 TST R14,#bit_strongsw
 BNE call_mode_cminus
asnormal$l
 STMFD R13!,{R3-R7}
; LDMFD R13!,{R14}
; STMFD R13!,{R3-R7,R14}
 LDRB R5,[R8,#w_cr]
 MOV R7,R1			; save offset
 MVN R2,#0			; returning offset
cln_l2
 CMP R7,#0
 MOVLE R1,#0			; start of file
 LDMLEFD R13!,{R3-R7,PC}
 SUB R0,R7,#1
 BL cln_readc
 TEQ R0,R5
 SUB R7,R7,#1
 BNE cln_l2
 ADD R1,R7,#1
 LDMFD R13!,{R3-R7,PC}

;E R0=offset R8/R9
;X R0=start of word |

mode0_wordminus_whole
 STMFD R13!,{R1-R7,R14}
 LDR R6,[R9,#f_len]
 LDRB R5,[R8,#w_cr]
 LDRB R4,[R8,#w_tabc]
 MOV R7,R0
 CMP R7,R6
 MOVCS R0,R6
 LDMCSFD R13!,{R1-R7,PC}
wo1a
 CMP R7,#0
 MOVLE R0,#0
 LDMLEFD R13!,{R1-R7,PC}
 SUB R0,R7,#1
 BL cln_readc
 TEQ   R0,R5
 TEQNE R0,R4
 TEQNE R0,#&20 ; just spaces; simple.
 SUBNE R7,R7,#1
 BNE wo1a
 MOV R0,R7
 LDMFD R13!,{R1-R7,PC}

;E R0=offset R8/R9
;X R0=start of word |

mode0_wordplus_whole
 STMFD R13!,{R1-R7,R14}
 LDR R6,[R9,#f_len]
 LDRB R5,[R8,#w_cr]
 LDRB R4,[R8,#w_tabc]
 MOV R7,R0
 CMP R7,R6
 MOVCS R0,R6
 LDMCSFD R13!,{R1-R7,PC}
wo1b
 CMP R7,R6
 MOVCS R0,R6
 LDMCSFD R13!,{R1-R7,PC}
 MOV R0,R7
 BL cln_readc
 TEQ   R0,R5
 TEQNE R0,R4
 TEQNE R0,#&20 ; just spaces; simple.
 ADDNE R7,R7,#1
 BNE wo1b
 MOV R0,R7
 LDMFD R13!,{R1-R7,PC}

;E R0=offset R8/R9
;X R0=start of word |

mode0_wordminus
 STMFD R13!,{R1-R7,R14}
 LDR R6,[R9,#f_len]
 LDRB R5,[R8,#w_cr]
 LDRB R4,[R8,#w_tabc]
 MOV R7,R0
 CMP R7,R6
 MOVCS R0,R6
 LDMCSFD R13!,{R1-R7,PC}
 MVN R3,#0
 BL ask_mode_about_this_word
wo1
 MOV R0,R7
 BL cln_readc
 CMP R0,R5
 BLEQ getnextoneback ; endoflinewordcr
 BL CursorPriority2 ; result in R2
 MOV R2,R0
woon1a
 CMP R7,#0
 MOVLE R0,#0
 LDMLEFD R13!,{R1-R7,PC}
 SUB R0,R7,#1
 BL cln_readc
 CMP R0,R5
 BEQ endoflinewnoncr ; endoflinewordcr
 BL CursorPriority2
 CMP R0,R2
 ADDEQ R7,R7,R3
 BEQ woon1a
 STMFD R13!,{R1,R8-R11}	; stack
 MOV R0,#19
 MOV R11,#e_interrogate
 SUB R1,R7,#1
 BL call_mode
 LDMFD R13!,{R1,R8-R11}	; unstack
 CMP R0,#19
 ADDNE R7,R7,R3
 BNE woon1a
 B endoflinewnoncr

;E R0=offset R8/R9
;X R0=end of word |

mode0_wordplus
 STMFD R13!,{R1-R7,R14}
 LDRB R5,[R8,#w_cr]
 LDRB R4,[R8,#w_tabc]
 LDR R6,[R9,#f_len]
 MOV R3,#1
 MOV R7,R0
 BL ask_mode_about_this_word
wo2
 MOV R0,R7
 CMP R0,R6
 MOVCS R0,R6
 LDMCSFD R13!,{R1-R7,PC}	; new beyond eof check...
 BL cln_readc
 CMP R0,R5
 BEQ endoflinewnoncr ; endoflinewordcr
 BL CursorPriority2 ; result in R2
 MOV R2,R0
 ADD R7,R7,R3
woon1
 CMP R7,R6
 MOVCS R0,R6
 LDMCSFD R13!,{R1-R7,PC}
 MOV R0,R7
 BL cln_readc
 CMP R0,R5
 BEQ endoflinewnoncr ; endoflinewordcr
 BL CursorPriority2
 CMP R0,R2
 ADDEQ R7,R7,R3
 BEQ woon1
 STMFD R13!,{R1,R8-R11}	; stack
 MOV R0,#19
 MOV R11,#e_interrogate
 MOV R1,R7
 BL call_mode
 LDMFD R13!,{R1,R8-R11}	; unstack
 CMP R0,#19
 ADDNE R7,R7,R3
 BNE woon1

endoflinewnoncr
 MOV R0,R7
 LDMFD R13!,{R1-R7,PC}

endoflinewordcr
 ADD R0,R7,#1
 LDMFD R13!,{R1-R7,PC}

;E R0=offset R8/R9
;X paragraph start |

mode0_parastart
 STMFD R13!,{R1,R14}
pa2
 CMP R0,#0
 MOVLE R0,#0
 LDMLEFD R13!,{R1,PC}
 BL mode0_linestart
 MOV R1,R0
 BL mode0_wordplus
 CMP R0,R1
 SUBGT R0,R1,#1			; end of previous line
 BGT pa2
 MOV R0,R1
 BL mode0_lineend		; are we at end of this line
 TEQ R0,R1
 ADDEQ R0,R1,#1			; null line
 MOVNE R0,R1			; line not null
 LDMFD R13!,{R1,PC}

call_mode_nextline		; call sw mode...
 BL	modesw_nextline	; call_mode_nextline
 LDMFD	R13!,{PC}

mode0_nextline
 STMFD	R13!,{R14}
 LDR	R14,[R8,#w_format];
 ANDS	R14,R14,#bit_softwrap
 BNE	call_mode_nextline
 STMFD	R13!,{R2-R11}
 MOV	R10,R0
 MOV	R2,R9			; file block
 LDR	R3,[R8,#w_bpl]
 LDR	R4,[R8,#w_tabc]
 LDR	R5,[R8,#w_cr]
 LDR	R6,[R8,#w_clogl]
 LDR	R7,[R8,#w_cline]
 LDR	R9,[R8,#w_coff]
 CMP	R10,R9,LSR#1		; if offset nearer start of file
 MOVLS	R6,#0
 MOVLS	R7,#0
 MOVLS	R9,#0			; base offsets
cln_nex_2
 CMP	R9,R10
 BHI	cln_nex_backward	; move back if R9>R10
cln_nex_1
 MOV	R11,R6			; save log line
 BL	cln_FORWARD
 BVS	cln_nex_3		; off end of file
 CMP	R10,R9
 BCS	cln_nex_1		; if not past R10 yet then loop
 CMP	R6,R11
 BHI	cln_nex_end		; moved onto next log line so finish
 FNLDR	R10,scn_yos
 FNLDR	R0,scn_magy
 MOV	R10,R10,LSR R0
 MOV	R10,R10,LSR#3		; max num of phy lines to bother checking
cln_nex_5
 BL	cln_FORWARD
 BVS	cln_nex_3		; off end of file
 SUBS	R10,R10,#1
 BLE	cln_nex_3		; give up and give end of file offset
 CMP	R6,R11
 BLE	cln_nex_5		; log line not increased
cln_nex_end
 LDR	R0,[R2,#f_len]
 CMP	R9,R0
 BCS	cln_nex_3		; off end of file (may not have had a VS)
 MOV	R0,R9			; offset of line
 MOV	R1,R7			; phy line
 LDMFD	R13!,{R2-R11,PC}^	; returns with no error
cln_nex_backward
 BL	cln_BACKWARD
 BVC	cln_nex_2
 LDMFD	R13!,{R2-R11,PC}		; return with error
cln_nex_3
 ADDS	R1,R7,#0			; phy line and clv
 LDR	R0,[R2,#f_len]		; end of file
 LDMFD	R13!,{R2-R11,PC}

;call_mode_prevline		; call sw mode...
; BL	  modesw_prevline ; call_mode_prevline
; LDMFD	  R13 !,{PC}

mode0_prevline
 STMFD	R13 !,{R14}
 LDR	R14,[R8,#w_format];
 ANDS	R14,R14,#bit_softwrap
 BLNE	modesw_prevline ; call_mode_prevline
 ;BNE	  call_mode_prevline
 LDMFD	R13!,{PC}
 ;MOV	  PC,R14 ; 's OK...

;E R0=file offset R9=file
;X R0=first non white space char offset |

mode0_autoplus
 STMFD	R13!,{R1-R7,R14}
 MOV	R7,R0			; save offset
 LDR	R6,[R9,#f_len]		; length of file
 LDRB	R5,[R8,#w_cr]
 LDRB	R4,[R8,#w_tabc]
au1
 CMP	R7,R6
 MOVCS	R0,R6			; end of file
 LDMCSFD	R13!,{R1-R7,PC}
 MOV	R0,R7
 BL	cln_readc
 TEQ	R0,R5
 MOVEQ	R0,R7			; hit a return character
 LDMEQFD R13!,{R1-R7,PC}
 TEQ	R0,#' '
 TEQNE	R0,R4
 ADDEQ	R7,R7,#1
 BEQ	au1			; on a white space
 MOV	R0,R7
 LDMFD	R13!,{R1-R7,PC}

mode0_selection
 TEQ	R0,#0
 BEQ	se51			; starting selection
 TEQ	R0,#1
 BEQ	se46			; updating a selection
 MOV	PC,R14
se51
 FNLDR	R0,car_mode
 TEQ	R0,#3			; cursor selection
 MOVEQ	R0,#0
 FNSTR	R0,wimp_dragdepth,EQ
 MOV	PC,R14
se46
 FNLDR	R0,wimp_dragdepth
 CMP	R0,#2
 MOVLT	PC,R14			; no need to alter
 STMFD	R13!,{R1-R3,R14}
 MOV	R2,R0			; save the depth
 ADRL	R3,mode0_linestart	; default sub (lines)
 TEQ	R2,#2			; words
 ADR	R0,mode0_wordminus
 MOVEQ	R3,R0
 TEQ	R2,#4			; paras
 ADR	R0,mode0_parastart
 MOVEQ	R3,R0
 LDR	R0,[R10,#c_owidth]		; current offset
 MOVS	R14,PC
 MOV	PC,R3			; call the sub
 LDMVSFD R13!,{R1-R3,PC}
 STR	R0,[R10,#c_owidth]		; new offset
 BL	offset_line_column
 LDMVSFD R13!,{R1-R3,PC}
 STR	R2,[R10,#c_ocol]
 STR	R3,[R10,#c_oline]		; new coords
 LDMFD	R13!,{R1-R3,PC}

mode0_copy
 TEQ R0,#2
; MOVEQ R0,#2			; enter via mode0_char (unnecessary)
 MOVEQ PC,R14			; so spaces work etc
; B modes_copy
; fall through...

; As for e_copy but R0=2 been taken care of

modes_copy
 STMFD R13!,{R1,R4-R7,R10,R14}
; BL scrub_input_carets
 ;all_on_this_file ; remove_carets2 ; scrub_caret			; scrub it here?
 ; multiple views problems...
 FNLDR R3,wimp_kbdbuf		; output buffer
 MOV R2,R1			; save number of times
 MOV R4,#0			; number typed
 LDR R7,[R10,#c_off]		; file offset
 LDR R6,[R9,#f_len]		; end of file
co19
 CMP R7,R6
 BCS co20
 MOV R0,R7
 BL cln_readc
 STRB R0,[R3,R4]
 ADD R7,R7,#1
 ADD R4,R4,#1
 CMP R4,R2
 BLT co19
co20
 MOV R2,R4			; number actually typed
 BL fake_right$l ; Right
; STR R7,[R10,#c_off]
; BL update_caret
; BL reflect_caret
 ;FNLDR R10,car_input
 ;BL reflect_caret
 LDMFD R13!,{R1,R4-R7,R10,PC}

fake_right$l
 FNJSR "R1-R11"			; overkill
 ;FNLDR R10,car_cursor
 LDR R0,[R10,#c_wind]
 BL conv_wind_off
 ;LDR R0,[R9,#f_depth]
 ;CMP R0,#0
 ;SWIGT &107

 MOV R0,R7
 BL goto_file_offset
 ;MOV R1,#0
 ;MOV R2,#1
 ;MOV R3,#0
 ;BL move_cursor
 ;MOV R1,#0
 ;MOV R2,#-1
 ;MOV R3,#0
 ;BL move_cursor
 ;SWI &107
 FNRTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INSERT AND DEL CHAR KEY SUBS				      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ; R4=w_flags R5=num bytes R6=w_format R7=data R8/R9/R10=input caret

mode0_char
	TST	R3,#1
	ADR	R3,mode0_char_doit

; R3=routine to call (top bit set if deleting) R4-R10=as above
; Z set if R3b0 was clear before setting it to the routine address
; Routine called with R0=0 if not in block or not block editing, else R0=1

char_del_dispatch
	ORRNE	R3,R3,#1
; To disable block editing, uncomment the following lines:
;	MOV	R0,#0
;	MOV	PC,R3
	LDR	R1,[R8,#w_info]
	TST	R1,#1<<10		; block edit?
	MOVEQ	R0,#0
	MOVEQ	PC,R3
	PUSH	"R3-R10,R14"
	BL	get_selection
	MOV	R11,R8
	PULL	"R3-R10,R14"
	MOVCS	R0,#0
	MOVCS	PC,R3
	TEQ	R8,R11			; and in same window?
	MOVNE	R0,#0
	MOVNE	PC,R3
	LDR	R0,[R10,#c_off]
	ADD	R2,R2,R1
	CMP	R1,R0
	CMPLS	R0,R2			; and in selection?
	MOVCS	R0,#0
	MOVCS	PC,R3
	FNJSR	"R4-R7,R11"		; if so, do block editing
	LDR	R0,[R8,#w_flags]
	STR	R0,local_wflags$l
	LDR	R0,[R8,#w_format]
	STR	R0,local_wformat$l
	FNLDR	R0,opt_flags
	STR	R0,local_oflags$l
	BIC	R0,R0,#1<<22		; prevent selection auto-clear
	FNSTR	R0,opt_flags

;	LDR	R0,[R8,#w_info]
;	STR	R0,local_winfo$l
;	BIC	R0,R0,#1<<9		; clear strong softwrap
;	STR	R0,[R8,#w_info]

	LDR	R11,[R10,#c_off]
	BIC	R4,R4,#1<<13		; clear wordwrap
	BIC	R4,R4,#1<<26		; clear linewrap
	STR	R4,[R8,#w_flags]	; and store (just in case)
	STR	R6,[R8,#w_format]	;

	MOV	R4,R1			; start of selection
	MOV	R5,R2			; end of selection

	ADR	R0,local_sel$l
	STMIA	R0,{R4,R5}

	LDR	R0,[R10,#c_off]
;	BL	offset_line_number	;** activate when softwrap fixed
;	MOV	R0,R2
;	BL	logical_line_number	;** instead of the following line
	BL	find_line_start		; get start of logical line
	LDRVC	R1,[R10,#c_off]
	BLVC	logical_column_number
	MOVVC	R7,R0			; R7 = column number
	LDRVC	R0,[R10,#c_loff]
	LDRVC	R1,[R10,#c_off]
	BLVC	cln_lineoff
	LDRVC	R1,[R10,#c_col]		; to allow for line numbers.
	LDRVC	R14,[R8,#w_margin]	; to allow for line numbers.
	SUBVC	R1,R1,R14
	SUBVC	R1,R1,R0
	ADDVC	R7,R7,R1		; adjust R7 a little...
	MOVVC	R0,R5
	BLVC	offset_line_number
	MOVVC	R6,R2			; R6 = log line no last line in sel
	MOVVC	R0,R4
	BLVC	offset_line_number
	MOVVC	R5,R2			; R5 = log line no first line in sel
	BVS	err1$l

	PUSH	"R10"
	LDR	R0,[R10,#c_off]
	BL	ensure_mark		; if not already there,
	MOVEQ	R0,#0
	MOVNE	R0,#1			; remember to delete it later
	STR	R0,placedmark$l
	PULL	"R10"
	LDRNE	R0,[R10,#c_off]
	BLNE	insert_marker		; place it
	BVS	err1$l

	BL	start_operation
	BL	insert_approved_space
	; Minor redraw problem which shows up in read-only mode:
	; we're not deleting the caret
loop$l	MOV	R0,R6
	BL	logical_line_number
	BLVC	find_line_start		;** avoid softwrap problems
	STRVC	R0,[R10,#c_loff]	; fiddle line start
	MOV	R1,R7
	BL	logical_column_offset
	STR	R0,[R10,#c_off]
	BL	update_caret
	BVS	err$l
	LDR	R4,[R10,#c_col]		; adjust cursor column a little
	ADD	R4,R4,R1
	STR	R4,[R10,#c_col]

	LDR	R0,[R10,#c_off]

	ADR	R2,local_sel$l
	LDMIA	R2,{R2,R14}

	CMP	R0,R2
	BLO	outside_sel$l
	CMP	R0,R14
	BHS	outside_sel$l

	MOV	R14,R13
	LDR	R4,[R10,#c_off]

	PUSH	"R1,R3-R11"		; stack return address etc.
	LDMIA	R14,{R4-R7}		; get parameters
	TST	R3,#1<<31
	BEQ	not_del$l
	SUBS	R5,R5,R1
	BLE	nowttodel$l
not_del$l
	BIC	R4,R4,#3<<13		; clear wordwrap; link cursor
	BIC	R4,R4,#1<<26		; clear linewrap
	BL	call_r3
nowttodel$l
	PULL	"R1,R3-R11"		; stack return address etc.
	BVS	err$l
	TEQ	R4,R11
	TSTEQ	R3,#1<<31		; um, delete...?
	BNE	not_char$l
	LDR	R0,[R8,#w_flags]
	TST	R0,#2			; overwrite fiddle...
	LDRNE	R0,[R13,#4]
	ADDNE	R4,R4,R1		; - spaces inserted
	ADDNE	R4,R4,R0		; - characters inserted/overwritten
	LDRNE	R2,[R9,#f_mark]
	LDRNE	R1,[R9,#f_mptr]
	SUBNE	R2,R2,#8
	STRNE	R4,[R1,R2]
not_char$l
outside_sel$l
	SUB	R6,R6,#1
	CMP	R6,R5			; any more lines in selection?
	BGE	loop$l

	LDR	R5,[R9,#f_mark]
	LDR	R4,[R9,#f_mptr]
	SUB	R5,R5,#8
	LDR	R0,[R4,R5]		; file offset of marker
	BL	goto_file_offset	; goto this offset (any mark?)
	BLVC	plot_caret
	BVS	err$l
	LDR	R0,placedmark$l
	TST	R0,#1
	BLNE	delete_marker
	BL	insert_approved_space
err$l	BL	stop_operation

err1$l	LDR	R4,local_wflags$l	; restore w_flags
	LDR	R14,[R8,#w_flags]
	BIC	R4,R4,#8
	AND	R14,R14,#8
	ORR	R4,R4,R14		; ...preserving the 'changed' flag
	STR	R4,[R8,#w_flags]

	LDR	R4,local_wformat$l	; restore w_format
	STR	R4,[R8,#w_format]
	LDR	R4,local_oflags$l
	FNSTR	R4,opt_flags
;	LDR	R4,local_winfo$l	; restore w_info
;	STR	R4,[R8,#w_info]
	FNRTS
call_r3	MOV	R0,#1
	MOV	PC,R3

local_wflags$l	& 0
local_wformat$l	& 0
local_oflags$l	& 0
;local_winfo$l	& 0
placedmark$l	& 0
local_sel$l	& 0,0

;\E R8,R9,R10 R3 bit 31 set if deleting...
insert_approved_space
	FNJSR	"R1-R4"
	TST	R3,#1<<31
	LDRNE	R2,[R10,#c_col]
	LDRNE	R3,[R10,#c_line]
	MOVNE	R4,R2
	BLNE	find_offset		; R0=file offset
	CMPNE	R4,R2
	FNRTS	NE			; not appropriate to disturb
	LDR	R4,[R9,#f_flags]
	BIC	R14,R4,#1<<14		; input now linked...
	STR	R14,[R9,#f_flags]
	LDR	R3,[R8,#w_flags]
	BIC	R14,R3,#2		; insert mode...
	STR	R14,[R8,#w_flags]
	LDR	R0,[R10,#c_off]
	BL	space_at_offset
	STR	R3,[R8,#w_flags]
	STR	R4,[R9,#f_flags]
	FNRTS

	LOCAL

; E R0=logical line start offset R1='cursor' offset R8/R9
;   (uses w_format)
; X R0=logical column number
; Replace with call to e_lineoff when softwrap problem fixed

logical_column_number
	FNJSR	"R2-R9"
	MOV	R2,#0
	LDR	R3,[R9,#f_ptr]
	LDR	R4,[R9,#f_splito]
	LDR	R5,[R9,#f_splits]
	LDR	R6,[R8,#w_format]
	LDR	R7,[R9,#f_len]
	LDRB	R9,[R8,#w_cr]
	LDRB	R8,[R8,#w_tabc]
	CMP	R0,R4
	ADDHI	R3,R3,R5
lcn$l	CMP	R0,R1
	BHS	lcnret$l
	TEQ	R0,R4
	ADDEQ	R3,R3,R5
	TEQ	R0,R7
	LDRNEB	R14,[R3,R0]
	ADD	R0,R0,#1
	TEQNE	R14,R9
	BEQ	lcnret$l
	ADD	R2,R2,#1
	TEQ	R14,R8
	BNE	lcn$l
	TST	R6,#3<<12
	ADDNE	R2,R2,#7
	BICNE	R2,R2,#7
	B	lcn$l
lcnret$l
	MOV	R0,R2
	FNRTSS

	LOCAL

; E R0=logical line start offset R1=logical column number R8/R9
;   (uses w_format)
; X R0=corresponding file offset
;   R1=offset within character (eg. number of spaces to insert)
; Replace with call to e_linecol when softwrap problem fixed

logical_column_offset
	FNJSR	"R2-R10"
	MOV	R2,#0
	TEQ	R2,R1
	BEQ	lcoret$l
	MOV	R10,#0
	LDR	R3,[R9,#f_ptr]
	LDR	R4,[R9,#f_splito]
	LDR	R5,[R9,#f_splits]
	LDR	R6,[R8,#w_format]
	LDR	R7,[R9,#f_len]
	LDRB	R9,[R8,#w_cr]
	LDRB	R8,[R8,#w_tabc]
	CMP	R0,R4
	ADDHI	R3,R3,R5
	SUB	R0,R0,#1
lco$l	TEQ	R2,R1
	BEQ	lcoret$l
	ADD	R0,R0,#1
	TEQ	R0,R4
	ADDEQ	R3,R3,R5
	TEQ	R0,R7
	LDRNEB	R14,[R3,R0]
	MOV	R2,R10
	TEQNE	R14,R9
	BEQ	lcoret$l
	ADD	R10,R10,#1
	TEQ	R14,R8
	BNE	lco$l
	TST	R6,#3<<12
	ADDNE	R10,R10,#7
	BICNE	R10,R10,#7
	CMP	R10,R1
	BLO	lco$l
	ADDEQ	R0,R0,#1
	MOVEQ	R2,R1
lcoret$l
	SUB	R1,R1,R2
	FNRTSS

	LOCAL

; E R0=file offset
; X R0=logical line start
; Remove when softwrap problem fixed

find_line_start
	FNJSR	"R1-R4"
	LDR	R1,[R9,#f_ptr]
	LDR	R2,[R9,#f_splito]
	LDR	R3,[R9,#f_splits]
	LDRB	R4,[R8,#w_cr]
	CMP	R0,R2
	ADDHS	R1,R1,R3
loop$l	TEQ	R0,R2
	SUBEQ	R1,R1,R3
	SUBS	R0,R0,#1
	BMI	found$l
	LDRB	R14,[R1,R0]
	TEQ	R14,R4
	BNE	loop$l
found$l	ADD	R0,R0,#1
	FNRTS

mode0_char_doit
 FNJSR
 LDR R0,[R10,#c_loff]
 LDR R1,[R10,#c_off]
 BL cln_lineoff			; R0=column offset on screen - margin
 FNRTS VS
 BL start_operation		; concatenate ops (phew!)
 LDR R1,[R8,#w_margin]
 ADD R0,R0,R1			; add margin
 LDR R1,[R10,#c_col]
 SUBS R1,R1,R0			; number of spaces to insert before entry
 BLE in15
 MOV R0,R1
 BL ensure_redblk		; ensure enough spaces in spaces buffer
 FNRTS VS
 MOV R2,R1			; number of spaces
 LDR R1,[R10,#c_off]
 FNLDR R3,red_blkbuf
 MOV R0,#&11
 BL execute_command		; insert the spaces
 BVS endofcharinsertion
in15
 TST R4,#2			; in overwrite mode
 BEQ in1			; if not then insert the chars
 LDR R1,[R10,#c_off]
 MOV R0,R1
 BL mode0_lineend		; find offset of end of line
 BVS endofcharinsertion
 SUBS R11,R0,R1			; number of chars that can be replaced
 CMP R11,R5
 MOVGT R11,R5
in1
 BL insert_chars_at		; replace as many chars as possible
 BVS endofcharinsertion
 TST R4,#1<<26			; linewrap
 BEQ endofcharinsertion
 LDR R1,[R10,#c_off]
 MOV R0,R1
 BL mode0_linestart		; R0=start of the line
 BVS endofcharinsertion
 MOV R3,R0			; save start of line
 BL mode0_lineoff		; R0=column offset from line start
 BVS endofcharinsertion
 LDR R2,[R8,#w_wrapwidth]	; wordwrap width
 CMP R0,R2
 BLE endofcharinsertion
 ;SWI &107
 MOV R0,R3			; offset of line start
 MOV R1,R2			; column to split at!
 BL mode0_linecol		; R0=column offset
 BVS endofcharinsertion
 ADD R0,R0,#1			; start of imaginary word
 LDR R14,[R9,#f_len]
 CMP R0,R14
 SUBCS R0,R14,#1
 BL mode0_wordminus_whole	; R0=first letter of word
 BVS endofcharinsertion
 CMP R0,R3
 BLE endofcharinsertion
 SUB R1,R0,#1			; replace offset
 MOV R2,#1			; one byte
 ADD R3,R8,#w_cr		; return character
 MOV R0,#&23			; replace + delink caret
 BL execute_command		; do the replacement
endofcharinsertion
 BL stop_operation		; concatenate ops
 FNRTS

; R5=num bytes R7=del type R8-R10=input caret
; X R0=num bytes deleted

mode0_delete
	TST	R3,#1
	ADR	R3,mode0_delete_doit
	ORR	R3,R3,#1<<31		; it's a deletion
	STMFD	R13!,{R4,R6,R14}
	LDR	R4,[R8,#w_flags]
	LDR	R6,[R8,#w_format]
	ORR	R6,R6,#1<<14		; set line edit
	BL	char_del_dispatch
	LDMFD	R13!,{R4,R6,PC}

mode0_delete_doit
 FNJSR
 LDR R14,[R8,#w_format]
 TST R14,#1<<14			; line edit?
 BEQ de12			; no
 LDR R1,[R10,#c_off]
 TEQ R7,#0
 BNE de13			; forward delete
 MOV R0,R1
 BL mode0_linestart
 FNRTS VS
 SUB R0,R1,R0			; number of chars we can delete
 CMP R5,R0
 MOVCS R5,R0
 B de12
de13
 MOV R0,R1
 BL mode0_lineend
 FNRTS VS
 SUB R0,R0,R1
 CMP R5,R0
 MOVCS R5,R0
de12
 CMP R5,#0
 FNRTS LE
 LDR R0,[R10,#c_loff]
 LDR R1,[R10,#c_off]
 BL cln_lineoff
 FNRTS VS
 LDR R1,[R8,#w_margin]
 ADD R0,R0,R1			; add margin
 LDR R1,[R10,#c_col]
 SUBS R1,R1,R0			; number of blank chars before
 TEQ R1,#0
 BEQ de9
 BL reflect_caret		; move caret back to line "end" (also tabs)
 FNRTS VS
 SUB R5,R5,#1
de9
 STMFD R13!,{R5}
 BL mode1_delete
 LDMVCFD R13!,{R0}		; return nun bytes deleted
 ADDVS R13,R13,#4
 FNRTS

mode0_tab
 FNJSR
 LDR R5,[R8,#w_flags]
 PUSH "R5"
 BIC R5,R5,#2
 STR R5,[R8,#w_flags]		; temporarily disable overwrite
 ANDS R0,R5,#3<<9
 BNE ta1			; not unix mode
 LDRB R0,[R8,#w_tabc]
 BL k_char_fill			; write tab chars
 B ta2
ta1
 BL insert_tab			; sub for other cases
ta2
 PULL "R5"
 STR R5,[R8,#w_flags]
 FNRTS

mode0_return
 FNJSR
 LDR R0,[R8,#w_format]
 TST R0,#1<<14
 BEQ re32			; no line edit
 LDR R0,[R10,#c_off]
 BL mode0_lineend
 FNRTS VS
 STR R0,[R10,#c_off]		; new posn to add return
re32
 LDR R4,[R8,#w_flags]
 BIC R14,R4,#1<<13		; turn off wordwrap
 STR R14,[R8,#w_flags]
 AND R4,R4,#1<<13		; preserve wordwrap state
 BL insert_returns		; insert the returns
 LDR R14,[R8,#w_flags]
 BIC R14,R14,#1<<13
 ORR R14,R14,R4
 STR R14,[R8,#w_flags]		; restore wordwrap state
 FNRTS

; Zap_ReturnWord entry point
; \E R0 delimiters type flags, R1 delimiters list, R2 offset R8,R9
; \X R0=file offset, R1=length
returnword
 FNJSR "R2-R7,R10,R11"		; keep in step with below...
 MOV R10,R2			; ready for do_returnword
 B do_returnword

 LOCAL
; \E R8
; \X R0=file offset
;    R1=length
mode0_returnword
 FNJSR "R2-R7,R10,R11"		; keep in step with above...
 MOV R10,R0
 MOV R11,#e_interrogate
 MOV R0,#17
 BL call_mode
 FNRTS VS
 CMP R0,#17
 BLEQ mode0_returndelimiters

 ; R0 b0 gives type (0=>delimiters, 1=>non-delimiters)
 ;  b1 set => control characters form a list
 ;  b2 gives control characters type as above
 ; R1 is list
 ; R10 is offset

do_returnword
 LDR R2,[R9,#f_splito]
 LDR R3,[R9,#f_splits]
 LDR R4,[R9,#f_len]
 LDR R11,[R9,#f_ptr]
 MOV R5,R10
; LDR R5,[R10,#c_off]
 CMP R5,R2
 ADDGT R11,R11,R3		; test will catch if exactly on
				; R7 scratch : current character under test
 MOV R6,#2			; situation; 2 => starting
				; 0 => from delimiter, 1 => from non-delimiter

forwardloop$l
 CMP R5,R2			; are we at the split?
 ADDEQ R11,R11,R3

 CMP R5,R4
 ADDGE R5,R5,#1		; because it recorrects
 BGE forwardstop$l

 LDRB R7,[R11,R5]
 ADD R5,R5,#1

 BL is_delimiter		; \E R0,R1,R7,R8 \X R7 =0 yes, =1 no, =2 lwsp

 CMP R6,#2
 BNE dochar$l			; not first character

 CMP R7,#2			; lwsp
 BEQ noword$l

 MOVNE R6,R7			; situation
 B forwardloop$l

dochar$l
 CMP R7,#2			; lwsp, so stop
 BEQ forwardstop$l
 CMP R7,R6			; have we changed type?
 BEQ forwardloop$l		; nope

forwardstop$l			; R5 is the char after the one that failed
 SUB R5,R5,#1			; correct for that
 PUSH "R5"			; store the offset of the char after the word

 MOV R5,R10
; LDR R5,[R10,#c_off]
 LDR R11,[R9,#f_ptr]
 CMP R5,R2
 ADDGE R11,R11,R3		; split point

backwardloop$l
 CMP R5,R2
 SUBEQ R11,R11,R3

 SUBS R5,R5,#1
 BLT backwardstop$l

 LDRB R7,[R11,R5]

 BL is_delimiter

 CMP R7,#2
 BEQ backwardstop$l		; lwsp, so stop
 CMP R7,R6			; have we changed type?
 BEQ backwardloop$l		; nope

backwardstop$l			; R5 is the char before the one that failed
 ADD R5,R5,#1			; correct for that
 PULL "R4"

 MOV R0,R5
 SUB R1,R4,R0			; length
 FNRTS

noword$l
 MOV R0,R10
; LDR R0,[R10,#c_off]
 MOV R1,#0			; no word
 FNRTS

is_delimiter			; \E r7=char to test
 ; r1=list of non-/delimiters
 ; r0 b0 =  list type (1=>non)
 ;    b1 => control chars form a list
 ;    b2 =  control type (1=>non)
 FNJSR "R2,R3"
 LDRB R2,[R8,#w_cr]
 LDRB R3,[R8,#w_tabc]
 CMP R7,R2
 CMPNE R7,R3
 CMPNE R7,#32
 MOVEQ R7,#2			; lwsp
 FNRTS EQ

 TST R0,#2			; control chars?
 BEQ delimjump$l		; nope
 CMP R7,#32
 BGE delimjump$l
 MOV R7,R0,LSR #2
 AND R7,R7,#1			; type
 FNRTS

delimjump$l
 BL strchr_range		; \E R1=string, R7=char; \X NE if not present
 AND R14,R0,#1
 RSBNE R7,R14,#1
 MOVEQ R7,R14
 FNRTS

 LOCAL

; \E r1=string, r7=char
; \X ~Z (=NE) if not present
strchr_range
 FNJSR "r0-r2"
loop$l
 LDRB r0,[r1],#1
 TEQ r0,#0			; 0 is not considered
 BEQ end$l			; part of this list!
 TEQ r0,#'\'
 BLEQ quote$l			; unquote if necessary
 TEQ r0,r7
 FNRTS EQ			; found!
 LDRB r2,[r1]
 TEQ r2,#'-'			; is this starting a range?
 BNE loop$l
 MOV r2,r0			; store start of range
 LDRB r0,[r1,#1]		; get end of range
 TEQ r0,#0			; end of list - note that r1 points
 BEQ loop$l			; to '-', so this will be tested
				; this works as Zap_Search \[...]
 ADD r1,r1,#2			; jump over this
 CMP r0,#'\'
 BLEQ quote$l			; unquote if necessary
 CMP r0,r2			; make sure that r0 is low, r2 high
 EORHI r0,r2,r0			; r0 = B ^ A
 EORHI r2,r2,r0			; r2 = B ^ (B ^ A) = A
 EORHI r0,r2,r0			; r0 = (B ^ A) ^ A = B
 CMP r7,r0
 RSBHSS r14,r7,r2
 BLO loop$l
 TEQ r7,r7			; SEZ
 FNRTS

end$l
 TEQ r0,#1			; CLZ (r0 = 0)
 FNRTS

; \E r0 '\', r1 => char after '\'
; \X r0 unquoted character, r1 updated
	IMPORT	wild_get_char	; from s.Search
quote$l
	LDRB	R0,[R1]
	TEQ	R0,#'h'
	TEQEQ	R0,#'w'		; we don't want words!
	MOVEQ	R0,#'\'
	MOVEQ	PC,R14
	FNJSR	"R2,R5"
	SUB	R1,R1,#1
	MOV	R5,#0
	BL	wild_get_char
	CMP	R2,#0		; R2=0 -> R0 literal
	MOVLT	R0,#'\'		; R2<0 -> set R0 to '\'
	ANDGT	R0,R0,#255	; R2>0 -> R0 masked (just in case)
	FNRTS

;  LOCAL
; ; \E r1=string, r7=char
; ; \X CC if not present
; strchr
;  FNJSR "r0,r1"
; loop$l
;  LDRB r0,[r1],#1
;  CMP r0,r7
;  FNRTS EQ			; found!
;  CMP r0,#0
;  BNE loop$l
;
;  CMP r0,#1			; CLV...? CLC perhaps...
;  FNRTS

	LOCAL

; \E R0, R8/R9
; \X R0=number of possibilities (R0=0 => R1 undefined)
;    R1=heap block containing (R0) pointers to heap blocks
mode0_help
	FNJSR	"R2-R7,R11"
	MOV	R11,#e_returnword
	BL	call_mode
	FNRTS	VS
	CMP	R1,#0
	MOVEQ	R0,#0
	FNRTS	EQ

	MOV	R3,R0

	ADD	R0,R1,#1		; space for NUL
	BL	heap_claim
	FNRTS	VS
	MOV	R2,R0
; copy the stuff from R3 into the heap block R2. Length is R1
; R3 is scratch, because we clear it into R4
; R0 is destination, R2 saved destination base
	LDR	R4,[R9,#f_ptr]
	LDR	R5,[R9,#f_splito]

	ADD	r5,r4,r5
	LDR	r6,[r9,#f_splits]
	ADD	r7,r3,r1
	LDR	r1,[r9,#f_len]

	CMP	R7,R1
	MOVGE	R7,R1			; validate against file length
	ADD	R7,R4,R7		; limit
	ADD	R4,R4,R3		; initial address
loop$l
	CMP	r4,r5
	ADDGE	r4,r4,r6		; skip split
	ADDGE	r7,r7,r6		; in limit also
	ADDGE	r5,r7,#1		; additional line

	CMP	R4,R7

	LDRLTB	R3,[R4],#1
	STRLTB	R3,[R0],#1
	BLT	loop$l

	MOV	R3,#0
	STRB	R3,[R0]			; terminate

	MOV	R0,#4
	BL	heap_claim
	BVS	fail$l
	MOV	R1,R0
	STR	R2,[R1]			; heap block containing word
	MOV	R0,#1			; one possibility
	FNRTS

fail$l
	MOV R7,R0
	MOV R0,R2
	BL heap_free
	MOV R0,R7
	FNRTV

mode0_interrogate
; CMP R0,#11
; MOVEQ PC,R14
; CMP R0,#4
; ADREQ R0,swcharshere
; MOV PC,R14
; BEQ mode0_getswchars
 CMP R0,#10
 BEQ seeif_ins_pt_if_needed
 CMP R0,#17
 BEQ mode0_returndelimiters
 CMP R0,#0
 CMPNE R0,#3
 MOVNE PC,R14
 MOV R0,R1
 MOV PC,R14

mode0_returndelimiters
 MOV R0,#1			; listing non-delimiters
 ADR R1,mode0_delimiters
 MOV PC,R14

; delimiters
mode0_delimiters
  = "A-Za-z0-9_",0
; = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",0
 ALIGN

seeif_ins_pt_if_needed
 FNJSR
 BL adjust_ins_pt_if_needed
 MOVEQ R0,#0 ; EQ!!!!
 FNRTS

;mode0_getswchars
; ADR R0,swcharshere
; MOV PC,R14

;swcharshere ; - the default anyway...
;  = " -",0,0

splus_smart
 STMFD	 R13!,{R3,R14}
 LDR	 R2,[R9,#f_ptr]
 LDR	 R3,[R9,#f_splito]
 CMP	 R1,R3
 LDRCS	 R3,[R9,#f_splits]
 ADDCS	 R1,R1,R3
 LDRCS	 R0,[R9,#f_len]
 ADDCS	 R3,R3,R0
 BL	 SPlusBrG
 BCC	 SPlusBrB
 ADD	 R1,R1,#1
 B	 SPlusBrD

SPlusBrA
 BL	 SPlusBrF

SPlusBrB
 BCS	 SPlusBrD
 BNE	 SPlusBrA

SPlusBrC
 TEQ	 R0,#&20
 LDRNEB  R14,[R8,#w_tabchar]
 TEQNE	 R0,R14
 BEQ	 SPlusBrE
 BL	 SPlusBrF
 BCS	 SPlusBrD
 BEQ	 SPlusBrC
SPlusBrD
 LDR	 R0,[R9,#f_splite]
 CMP	 R1,R0
 LDRCS	 R0,[R9,#f_splits]
 SUBCS	 R1,R1,R0
 MVN	 R2,#0
 LDMFD	 R13!,{R3,PC}

SPlusBrE
 BL	 SPlusBrF
 TEQ	 R0,#&20
 LDRNEB  R14,[R8,#w_tabchar]
 TEQNE	 R0,R14
 BEQ	 SPlusBrE
 B	 SPlusBrD

SPlusBrF
 ADD	 R1,R1,#1

SPlusBrG
 CMP	 R1,R3
 BCC	 SMinusBrG
 LDR	 R0,[R9,#f_splito]
 TEQ	 R1,R0
 BNE	 SPlusBrD
 LDR	 R0,[R9,#f_splits]
 ADD	 R1,R1,R0
 LDR	 R3,[R9,#f_len]
 ADD	 R3,R3,R0

 STMFD	 R13!,{R14}
 LDR	 R14,[R9,#f_bufl]
 SUB	 R14,R14,#1
 CMP	 R1,R14
 LDRCCB  R0,[R2,R1]
 ANDCS	 R0,R1,#&FF
 LDMFD	 R13!,{R14}
 B	 CursorPriority

 LOCAL

sminus_smart
 CMP	 R2,#1
 BHI	 SMinusBrA
 TEQ	 R1,#0
 SUBNE	 R1,R1,#1
 MVN	 R2,#0
 MOV	 PC,R14
SMinusBrA
 STMFD	 R13!,{R3,R14}
 LDR	 R2,[R9,#f_ptr]
 LDR	 R0,[R9,#f_splito]
 CMP	 R1,R0
 LDRCS	 R0,[R9,#f_splits]
 ADDCS	 R1,R1,R0
 LDRCS	 R3,[R9,#f_splite]
 MOVCC	 R3,#0
SMinusBrB
 BL	 SMinusBrF
 BCS	 SMinusBrD
 BNE	 SMinusBrB
SMinusBrC
 TEQ	 R0,#&20
 LDRNEB  R14,[R8,#w_tabchar]
 TEQNE	 R0,R14
 BEQ	 SMinusBrE
 BL	 SMinusBrF
 BCS	 SMinusBrD
 BEQ	 SMinusBrC
SMinusBrD
 ADD	 R1,R1,#1
 LDR	 R0,[R9,#f_splite]
 CMP	 R1,R0
 LDRCS	 R0,[R9,#f_splits]
 SUBCS	 R1,R1,R0
 MVN	 R2,#0
 LDMFD	 R13!,{R3,PC}

SMinusBrE
 BL	 SMinusBrF
 TEQ	 R0,#&20
 LDRNEB  R14,[R8,#w_tabchar]
 TEQNE	 R0,R14
 BEQ	 SMinusBrE
 B	 SMinusBrD

SMinusBrF
 SUB	 R1,R1,#1
 CMP	 R1,R3
 BCS	 SMinusBrG
 TEQ	 R1,#0
 MVNEQ	 R2,#0
 LDMEQFD R13!,{R3,PC}
 LDR	 R0,[R9,#f_splits]
 SUB	 R1,R1,R0
 MOV	 R3,#0
SMinusBrG
 CMP	 R1,#0
 LDRPLB  R0,[R2,R1]
 ANDMI	 R0,R1,#&FF

 ;B	  CursorPriority		; fall through...

CursorPriority
 STMFD	 R13!,{R1}
 LDRB	 R1,[R8,#w_cr] ; lf char
 TEQ	 R0,R1
 LDMFD	 R13!,{R1}
 ORREQS  PC,R14,#Cbit
 BIC	 R14,R14,#Cbit
 CMP	 R0,#&30
 ORRCCS  PC,R14,#Zbit
 CMP	 R0,#&3A
 MOVCC	 PC,R14
 CMP	 R0,#&40			; @...
 ORRCCS  PC,R14,#Zbit
 CMP	 R0,#&5B
 MOVCC	 PC,R14
 CMP	 R0,#&61
 ORRCCS  PC,R14,#Zbit
 CMP	 R0,#&7B
 MOVCC	 PC,R14
 CMP	 R0,#&81
 ORRCCS  PC,R14,#Zbit
 CMP	 R0,#&83
 MOVCC	 PC,R14
 CMP	 R0,#&85
 ORRCCS  PC,R14,#Zbit
 CMP	 R0,#&87
 MOVCC	 PC,R14
 CMP	 R0,#&9E
 ORRCCS  PC,R14,#Zbit
 CMP	 R0,#&A0
 MOVCC	 PC,R14
 CMP	 R0,#&C0
 ORRCCS  PC,R14,#Zbit
; CMP	  R0,#&100
; MOVS	 PC,R14
 BICS	 PC,R14,#Cbit		; accented characters are normal...

CursorPriority2
 CMP	 R0,#&20
 MOVLE	 PC,R14
 CMP	 R0,#'$'
 CMPNE	 R0,#'%'
 MOVEQ	 R0,#&41
 MOVEQ	 PC,R14
 CMP	 R0,#&30
 MOVCC	 PC,R14
 CMP	 R0,#&3A ; numbers
 MOVCC	 R0,#&41 ; A
 MOVCC	 PC,R14
 CMP	 R0,#&40
 MOVCC	 R0,#&3F
 MOVCC	 PC,R14
 CMP	 R0,#&5F
 CMPNE	 R0,#&5A
 MOVLE	 R0,#&41 ; A
 MOVLE	 PC,R14
 CMP	 R0,#&61
 MOVCC	 R0,#&60
 MOVCC	 PC,R14
 CMP	 R0,#&7B
 MOVCC	 R0,#&41 ; A
 MOVCC	 PC,R14
 CMP	 R0,#&80
 MOVCC	 R0,#&7F
 MOVCC	 PC,R14
 CMP	 R0,#&C0
 MOVCC	 PC,R14
 MOV	 R0,#&41 ; A
 MOV	 PC,R14

; mode0_openwindow
;  MOV PC,R14

;E R0=character R1=number of times to type R8-R10=input caret
;X charcter inserted at input caret R1 times #

k_char_fill
 FNJSR "R1-R7,R11"
 MOV R2,R0			; save the character
 FNLDR R0,wimp_kbdbuf
 MOV R4,R0
 MOV R3,#0			; as a flag to say R3 points nowhere...
 BL start_operation		; concatonate
 BL insertsomespaces
 MOV R3,R1
re10
 STRB R2,[R4],#1
 SUBS R3,R3,#1
 BHI re10			; fill up keyboard buffer
; MOV R0,#1
; MOV R2,R1			; number of chars
; LDR R1,[R10,#c_off]
; FNLDR R3,wimp_kbdbuf
; BL execute_command		; insert the chars
 LDR R4,[R8,#w_flags]
 MOV R5,R1
 LDR R6,[R8,#w_format]
 FNLDR R7,wimp_kbdbuf
 MOV R11,#e_char
 BL call_mode
 BL stop_operation		; concatonate
 FNRTS

getnextoneback
 FNJSR
 SUBS R0,R7,#1
 BLPL cln_readc
 FNRTS

ask_mode_about_this_word
 STMFD R13!,{R1,R8-R11,R14}	; stack (exception...!)
 MOV R1,R7
 MOV R0,#20
 MOV R11,#e_interrogate
 BL call_mode
 MOV R7,R1
 LDMFD R13!,{R1,R8-R11,PC}	; unstack

; ***********************
; * Join and Split subs *
; ***********************

mode0_joinline
 FNJSR
 LDR R6,[R10,#c_off]
 LDR R7,[R9,#f_len]
 LDRB R5,[R8,#w_cr]
in14
 CMP R6,R7
 FNRTS GE			; off end of text
 MOV R0,R6
 BL cln_readc
 TEQ R0,R5
 ADDNE R6,R6,#1
 BNE in14
 MOV R0,#2
 MOV R1,R6
 MOV R2,#1
 BL execute_command		; delete the return char
 FNRTS

mode0_splitline
 FNJSR
 MOV R1,#1
 LDR R4,[R8,#w_flags]
 BIC R14,R4,#1<<13		; turn off wordwrap
 STR R14,[R8,#w_flags]
 AND R4,R4,#1<<13		; preserve wordwrap state
 BL insert_returns		; insert the returns
 LDR R14,[R8,#w_flags]
 BIC R14,R14,#1<<13
 ORR R14,R14,R4
 STR R14,[R8,#w_flags]		; restore wordwrap state
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Multiple clicks on a text file			   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mode0_click
	TEQ R1,#0
	FNSTR R1,wimp_dragdepth,EQ
	CMP R1,#2
	BCC default_click		; drag/place cursor

	STMFD R13!,{R1-R11,R14}
cl17
	CMP R1,#6
	SUBCS R1,R1,#4
	BCS cl17			; cycle clicks
	TST R4,#1<<3			; multidrag?
	BNE cl20
	MOV R11,R1			; save click depth
	BL find_offset			; R0=file offset
	LDMVSFD R13!,{R1-R11,PC}
	MOV R10,R0			; save file offset
 TEQ R11,#2
 BEQ cl_select_word
 TEQ R11,#3
 BEQ cl_select_line
 TEQ R11,#4
 BEQ cl_select_para
 TEQ R11,#5
 BEQ cl_select_all
;	SUBS R11,R11,#2
;	BEQ cl_select_word ; =2
;	CMP R11,#4-2
;	BLO cl_select_line ; =3
;	BEQ cl_select_para ; =4
;	TEQ R11,#5-2
;	BEQ cl_select_all ; =5
	LDMFD R13!,{R1-R11,PC}
cl20
	FNSTR R1,wimp_dragdepth
;	SWI &107
	MOV R1,#0			; normal drag
	MOV R4,#1			; pretend adjust pressed
	BL default_click		; start drag as normal
	LDMFD R13!,{R1-R11,PC}

clearselandreturn
	BL clear_selection
	LDMFD R13!,{R1-R11,PC}

cl_select_word
	BL test_shiftctrl
	TST R1,#1
	BNE cl_select_big_word
	MOV R0,R10
	BL mode0_wordplus
	MOVVC R3,R0			; end of word
	MOVVC R0,R10
	BLVC mode0_wordminus
	LDMVSFD R13!,{R1-R11,PC}
;	CMP R0,R3
;	BEQ clearselandreturn
	MOV R2,R0			; start of word
	BL select_region
	LDMFD R13!,{R1-R11,PC}

cl_select_big_word
	MOV R0,R10
	BL mode0_wordplus_whole
	MOVVC R3,R0			; end of word
	MOVVC R0,R10
	BLVC mode0_wordminus_whole
	LDMVSFD R13!,{R1-R11,PC}
;	CMP R0,R3
;	BEQ clearselandreturn
	MOV R2,R0			; start of word
	BL select_region
	LDMFD R13!,{R1-R11,PC}

cl_select_line
	MOV R0,R10
	BL mode0_linenext
	MOVVC R3,R0			; end of word
	MOVVC R0,R10
	BLVC mode0_linestart
	LDMVSFD R13!,{R1-R11,PC}
;	CMP R0,R3
;	BEQ clearselandreturn
	MOV R2,R0			; start of word
	BL select_region
	LDMFD R13!,{R1-R11,PC}

cl_select_para
	MOV R0,R10
	BL mode0_paraend
	MOVVC R3,R0			; end of para
	MOVVC R0,R10
	BLVC mode0_parastart
	LDMVSFD R13!,{R1-R11,PC}
;	CMP R0,R3
;	BEQ clearselandreturn
	MOV R2,R0			; start of para
	BL select_region
	LDMFD R13!,{R1-R11,PC}

cl_select_all
	MOV R2,#0
	LDR R3,[R9,#f_len]
;	CMP R3,#0
;	BEQ clearselandreturn
	BL select_region		; select all text (if any)
	LDMFD R13!,{R1-R11,PC}

; **************
; * SAVEANDRUN *
; **************

mode0_saveandrun
	FNJSR	"R1,R2,R7"
	BL	save_text
	MOV	R0,#25
	MOV	R11,#e_interrogate
	BL	call_mode
	CMP	R0,#25
	BEQ	nosaveandrunthanks$l
;mode0_run				; ???
	FNLDR	R7,wimp_buffer
	MOV	R1,R7
	LDR	R0,prestoregap$l
	STR	R0,[R1],#4
	LDR	R2,[R9,#f_name]
	BL	strcopy
	MOV	R0,R7
	SWI	XWimp_StartTask
	FNRTS
nosaveandrunthanks$l
	ADR	R0,warn$l
	MOV	R1,#5<<29
	BL	warn_user
	FNRTS

mode0_compile
	FNJSR	"R1,R2,R7"
	BL	save_text
	MOV	R0,#25
	MOV	R11,#e_interrogate
	BL	call_mode
	CMP	R0,#25
	BEQ	nosaveandrunthanks$l

	FNLDR	R7,wimp_buffer
	MOV	R1,R7
	ADR	R2,twstartstr
	BL	strcpy
	LDR	R0,[R9,#f_name]
	BL	find_leaf_name
	MOV	R2,R0
	BL	strcpy
	ADR	R2,twstartstr2
	BL	strcpy
	LDR	R2,[R9,#f_name]
	BL	strcpy			; complete command
	MOV	R14,#'"'
	STRB	R14,[R1],#1
	MOV	R14,#0
	STRB	R14,[R1],#1
	MOV	R0,R7
	SWI	XWimp_StartTask
	FNRTS
prestoregap$l
	= "Run "
twstartstr
 = "TaskWindow -quit -ctrl -name ",34,0
twstartstr2
 = 34,32,34,"Run ",0
warn$l
	FNS ("zap_NoRunFile")

; *****************************************
; * More misc word start/end like subs... *
; *****************************************

;E R0=offset R8/R9
;X paragraph end |

mode0_paraend
 STMFD R13!,{R1,R14}
pa1
 BL mode0_linenext		; move to start of next line
 MOV R1,R0			; save offset
 BL mode0_wordplus		; start of next word
 CMP R0,R1
 MOV R0,R1			; restore line start
 BGT pa1			; don't match
 LDMFD R13!,{R1,PC}

 END
