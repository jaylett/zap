;test string: \\\aaa+++aaa\\\aaa\\\+++aaa+++\\\aaa
; Contains mode entry points for text mode.
; $Id: Mode0,fff,v 2.18 2005/02/23 12:35:43 christian Exp $

 GET h.ZapHeader
 GET h.Commands
 GET h.AlterTxt
 GET h.StartCode
 GET h.Heap
 GET h.ModeBits
 GET h.Redraw
 GET h.Cursors
 GET h.Template
 GET h.Mode1+2
 GET h.SoftWrap
 GET h.TMTVars

 IMPORT get_SaveBox
 IMPORT discard_file
 IMPORT conv_wind_off
 IMPORT test_shiftctrl
 IMPORT find_leaf_name
 IMPORT strcpy
 IMPORT strcopy
 IMPORT warn_user
 IMPORT save_text
 IMPORT zephyr

 EXPORT mode_table_0
 EXPORT mode0_author
 EXPORT cln_FORWARD
 EXPORT mode0_splus
 EXPORT mode0_init
 EXPORT mode0_copy
 EXPORT mode0_click
 EXPORT mode0_linestart
 EXPORT mode0_linecol
 EXPORT mode0_autoplus
 EXPORT mode0_setwidth
 EXPORT mode0_prevline
 EXPORT modes_copy
 EXPORT returnword
 EXPORT next_line_number
 EXPORT offset_line_number
 EXPORT physical_line_number
 EXPORT logical_line_number
 EXPORT char_del_dispatch
 EXPORT redraw_tab
 EXPORT utf8_table
 EXPORT utf8_max

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Default modes added and their blocks			      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mode_table_0
	DCD	mode_table_0
	DCD	mode0_title
	DCD	mode0_author
	DCD	0
	DCD	0 :OR: emode_MayBeCloned
	DCD	mode0_init
	DCD	0
	DCD	mode0_table_end-mode_table_0

	DCD	Null			; postload
	DCD	Null
	DCD	Null
	DCD	modes_start
	DCD	modes_end
	DCD	mode0_width
	DCD	mode0_linecol
	DCD	mode0_lineoff
	DCD	mode0_clnlog
	DCD	mode0_clnphy
	DCD	mode0_clnoff
	DCD	mode0_nextline
	DCD	mode0_minus
	DCD	mode0_plus
	DCD	mode0_sminus
	DCD	mode0_splus
	DCD	mode0_cminus
	DCD	mode0_cplus
	DCD	mode0_redrawline
	DCD	mode0_redrawlnum
	DCD	mode0_char
	DCD	mode0_delete
	DCD	mode0_tab
	DCD	mode0_return
	DCD	Null			; renumber
	DCD	mode0_saveandrun	; save and run
	DCD	mode0_linestart
	DCD	mode0_lineend
	DCD	mode0_linenext
	DCD	mode0_lineprev
	DCD	mode0_copy
	DCD	mode0_joinline
	DCD	mode0_splitline
	DCD	Null			; align caret
	DCD	mode0_command
	DCD	mode0_compile		; compile
	DCD	mode0_formattext
	DCD	Null			; run
	DCD	Null			; run and quit (e_compile)
	DCD	Null			; e_basic
	DCD	Null			; e_search
	DCD	replace_area
	DCD	mode0_selection
	DCD	mode0_click
	DCD	Null			; messages
	DCD	mode0_setwidth
	DCD	Null			; list fns
	DCD	mode0_prevline
	DCD	Null			; Open window
	DCD	mode0_interrogate	; interrogate
	DCD	mode0_returnword	; returnword
	DCD	mode0_help		; help
	DCD	Null			; strip spaces
mode0_table_end

mode0_author
	=	"Dominic Symes, Tim Tyler, Daniel Wagenaar, James Aylett and Christian Ludlam",0
	ALIGN

mode0_title
	FNS	("Text")


mode0_init
	TEQ	R1,#3			; killing an ext edit / OLE file?
	BEQ	free_exteditole
	TEQ	R1,#4			; saving an ext edit / OLE file?
	BEQ	save_exteditole
	TEQ	R1,#0			; quitting ?
	MOVEQ	R0,#-1			; don't kill this module!!
	MOV	PC,R14

	LOCAL


free_exteditole
	LDR	R0,[R9,#f_cmode]
	TEQ	R0,#0			; check it's owned by text mode
	MOVNE	PC,R14
	FNJSR	"R1-R10"
	LDR	R10,[R9,#f_source]	; the data block
	LDR	R0,[R10,#ee_ee]
	CMP	R0,#1
	BLO	free_extedit		; R0=0 -> EE file
	FNRTS	HI			; not an OLE file
					; do OLE here
	FNLDR	R1,wimp_block		; somewhere for the message
	MOV	R14,#0
	LDR	R0,[R10,#ole_session]
	STR	R14,[R1,#20]
	STR	R0,[R1,#24]		; session number
	LDR	R0,oleclosesession$l
	LDR	R2,[R10,#ole_taskhandle]
	MOV	R3,#28			; length of message
	BL	message_send		; close session
	MOVVC	R0,R10			; get block pointer
	BLVC	heap_free
	FNRTS
oleclosesession$l
	DCD	&80E23

free_extedit
	FNLDR	R1,wimp_block
	MOV	R0,#0
	STR	R0,[R1,#20]
	LDR	R0,[R10,#ee_jobhandle]  ; now #4
	STR	R0,[R1,#24]		; job handle
	LDR	R0,fr_d0		; message number
	LDR	R2,[R10,#ee_taskhandle] ; task handle
	MOV	R3,#28			; length
	BL	message_send		; abort session
	MOVVC	R0,R10
	BLVC	heap_free		; free the data block
	FNRTS
fr_d0	DCD	&45D83			; abort

	LOCAL


save_exteditole
	FNJSR	"R1-R11"		; hardwired later!...
	LDR	R10,[R9,#f_source]	; info block
	LDR	R2,[R10,#ee_ee]
	CMP	R2,#0
	BEQ	save_extedit		; EE file
	CMP	R2,#1
	FNRTS	NE			; not an OLE file
	; do OLE here
	FNLDR	R1,wimp_block		; unlike EE, OLE actually saves the temp file
	LDR	R2,[R10,#ole_taskhandle] ; ?
	MOV	R14,#0			; TT
	STR	R14,[R1,#20]		; TT
	LDR	R3,[R10,#ole_session]
	STR	R3,[R1,#24]
	STR	R14,[R1,#12]		; your_ref (new message)	; TT
	ADD	R0,R1,#28		; session name starts here
	LDR	R8,[R9,#f_name]		; from
	ADD	R7,R1,#255		; limit (with space for a trailing NUL)
saveloop$l
	LDRB	R9,[R8],#1
	STRB	R9,[R0],#1
	CMP	R0,R7
	BNE	saveloop$l
	MOV	R9,#0
	STRB	R9,[R0],#1
	; Note that the following bit probably isn't necessary, but I could
	; never get the correct method:
	; ADD R3,R1,#28
	; ORR R3,R3,#(1:SHL:31)
	; which should make Zap calculate it automatically from the start
	; of the string, to work properly.
	SUB	R3,R0,R1		; bytes in message
	ADD	R3,R3,#3
	BIC	R3,R3,#3		; whole words
	LDR	R0,olefilechanged$l
	BL	message_send
	FNRTS
olefilechanged$l
	DCD	&80E1E
	FNRTS

save_extedit
	MOV	R2,#0			; use file name
	LDR	R3,[R10,#ee_jobhandle]  ; job handle
	LDR	R4,[R10,#ee_taskhandle] ; task handle
	MOV	R10,#1			; ext edit
	ADR	R7,sub$l		; routine to call when finished
	MOV	R11,R9			; file pointer (routine data)
	BL	send_data_save
	FNPULL
	MOVVC	R1,#-1			; stop the normal save!
	MOVVC	R0,#-1			; data not safe yet
	MOV	PC,R14

sub$l	FNJSR	"R9"
	MOV	R9,R11
	LDR	R0,[R9,#f_source]
	LDR	R0,[R0,#ee_flags]	; external edit flags
	TST	R0,#1			; continue?
	MOVEQ	R0,#-1
	STREQ	R0,[R9,#f_cmode]	; no longer an external edit file
	BLEQ	discard_file
	FNRTS

	LOCAL


	FNAME	mode0_width
mode0_width
	FNJSR	"R1-R2"
	MOV	R0,#-1
	LDRB	R1,[R8,#w_format]	; mode number
	MOV	R2,#0
	BL	mode_data		; read mode word
	MOV	R1,R0,LSL#16
	MOV	R1,R1,LSR#16		; get bottom 16 bits
	LDR	R0,[R8,#w_flags]
	TST	R0,#1<<6		; no auto width so...
	MOVEQ	R0,R1			; text width (not auto width)
	BEQ	width$l			; normal, not auto width
	LDR	R0,[R8,#w_format]
	TST	R0,#1<<27		; softwrap, so...
	MOVNE	R0,R1			; text width (not auto width)
	BNE	width$l			; normal, not auto width
	FNLDR	R0,wimp_maxaw
	STR	R0,[R8,#w_bpl]		; max line width (used in cln_count)
	BL	cln_count		; R0=max logical line length
	FNRTS	VS
	TEQ	R0,#0
	MOVEQ	R0,R1			; default width if file null
	FNLDR	R1,wimp_minaw
	CMP	R0,R1
	MOVLT	R0,R1
	FNLDR	R1,wimp_maxaw
	CMP	R0,R1
	MOVGT	R0,R1			; clip width to desired bounds
width$l	CMP	R0,#5			; b0-b15 of R0 is the width
	MOVLE	R0,#5			; ensure width at least 5
	STR	R0,[R8,#w_bpl]		; save as byte (line) width
	FNRTS


	FNAME	mode0_setwidth
mode0_setwidth
	FNJSR	"R1-R3"
	MOV	R3,R0			; save mode width
	MVN	R0,#0			; read
	TEQ	R8,#0
	FNLDRB  R1,opt_format,EQ
	LDRNEB  R1,[R8,#w_format]	; mode number
	MOV	R2,#0
	BL	mode_data		; read mode width word
	CMP	R3,#0			; if negative, then...
	BMI	ms10			; just reading the width
	MOV	R0,R0,LSR#16		; clear bottom 16 bits
	MOV	R3,R3,LSL#16
	MOV	R3,R3,LSR#16		; new mode width
	CMP	R3,#1
	MOVLE	R3,#1			; clip below
	ADD	R0,R3,R0,LSL#16		; new mode word
	TEQ	R8,#0
	FNLDRB  R1,opt_format,EQ
	LDRNEB  R1,[R8,#w_format]	; mode number
	MOV	R2,#0
	BL	mode_data		; write the word
	FNRTS

ms10	MOV	R0,R0,LSL#16
	MOV	R0,R0,LSR#16		; isolate the mode width
	FNRTS


	FNAME	mode0_redrawlnum
mode0_redrawlnum
	FNJSR
	MOVS	R1,R7
	MOVEQ	R0,#0			; check for SOF
	BEQ	mo1
	BL	minus			; get char before start of line
	LDRB	R1,[R8,#w_cr]
	TEQ	R0,R1
	BEQ	mo1			; match so we are at line start
	SUBS	R0,R0,#0		; sec
	FNRTS
mo1	ADDS	R0,R0,#0		; clc
	FNRTS


	FNAME	mode0_redrawline
mode0_redrawline
	FNJSR	"R11"
	LDR	R11,[R8,#w_info]
	MOV	R1,#0			; col offset
	LDRB	R2,[R8,#w_cr]		; get return code
	LDR	R3,[R8,#w_bpl]		; length of line
	LDRB	R4,[R8,#w_tabc]		; get tab code
	ORR	R2,R2,R4,LSL #24
	LDR	R4,[R8,#w_txtw]		; width of cache as line width
	TST	R11,#info_WideRedraw    ;
	ADDNE	R4,R4,R4,LSL #2		;
	MOVEQ	R4,R4,LSL #1		;
	ADD	R4,R4,R6		; colour bg mask buffer...
red_c0_l1
	CMP	R7,R10
	BLCS	red_overflow		; off buffer section
	BVS	red_c0_6		; hit file end
	BL	cln_readc_addr_auto	; get next char
	AND	R14,R2,#&FF
	TEQ	R0,R14			; is it a cr
	BEQ	red_c0_6		; end of this line
	TEQ	R0,R2,LSR #24		; is it a tab
	BEQ	red_c0_1
red_c0_3
	TST	R11,#info_WideRedraw	; write character
	STRNE	R0,[R6,R1,LSL #2]	;
	STREQB	R0,[R6,R1]		;
	MOV	R0,#1			; bg coloured...
	STRB	R0,[R4,R1]
	ADD	R1,R1,#1		; update column count
red_c0_4
	CMP	R1,R3			; are we at end of line
	BCC	red_c0_l1		; next if not
	CMP	R7,R10
	BLCS	red_overflow		; off buffer section
	BVS	red_c0_6		; off end of file
	PUSH	"R7"
	BL	cln_readc_addr_auto	; get next char
	AND	R14,R2,#&FF
	TEQ	R0,R14
	PULL	"R7",NE
	ADDEQ	R13,R13,#4		; skip return if follows
	BEQ	red_c0_6
	FNRTS

red_c0_1
	BL	redraw_tab
	B	red_c0_4

red_c0_6
	FNPULL
	ADDS	R11,R11,#1		; new logical line & clv
	MOV	PC,R14

	LOCAL

; redraw a tab
; E r1 = column  r6 -> output buffer / 0  r8
; X r1 = new column
	FNAME	redraw_tab
redraw_tab
	FNJSR	"R0,R2-R5,R12"
	LDR	R5,[R8,#w_info]
	TST	R5,#info_WideRedraw

	MOV	R0,#9			; an arrow
	LDR	R3,[R8,#w_txtw]
	ADDEQ	R12,R6,R3		; fg colour list
	ADDNE	R12,R6,R3,LSL #2	; fg colour list
	ADD	R4,R12,R3		; bg colour list
	LDR	R3,[R8,#w_bpl]		; limit

	LDR	R2,[R8,#w_format]	; get tab display bits
	AND	R2,R2,#3<<12
	MOVS	R2,R2,LSR #12
	ADDEQ	R1,R1,#1
	BEQ	done$l

	LDR	R14,[R8,#w_tabstops]	; get offset to next tabstop
	LDR	R14,[R14,R1,LSL #1]
	MOV	R14,R14,LSR #16

	TEQ	R6,#0			; just update column if nowhere to output to
	ADDEQ	R1,R1,R14
	FNRTS	EQ

	TEQ	R2,#2			; '->    '
	BNE	not2$l
	TST	R5,#info_WideRedraw
	STREQB  R0,[R6,R1]		; arrow at start
	STRNE	R0,[R6,R1,LSL #2]	;
	MOV	R0,#1			; colour background
	STRB	R0,[R4,R1]

not2$l	TEQ	R2,#3
	BNE	spaces$l

loop$l	CMP	R1,R3
	BHS	done$l

	SUBS	R14,R14,#1		; zero when "there"
	MOVNE	R0,#"-"
	MOVEQ	R0,#9
	TST	R5,#info_WideRedraw
	STREQB	R0,[R6,R1]		; visible chr
	STRNE	R0,[R6,R1,LSL #2]	;
	MOV	R0,#8
	STRB	R0,[R12,R1]		; FG colour
	MOV	R0,#1
	STRB	R0,[R4,R1]		; BG colour

	ADD	R1,R1,#1
	TEQ	R14,#0
	BNE	loop$l
	CMP	R1,R3
	FNRTS	LO

done$l	TEQ	R6,#0
	FNRTS	EQ
	SUB	R14,R1,#1
	TST	R5,#info_WideRedraw
	MOV	R0,#9			; store -> char
	STREQB	R0,[R6,R14]
	STRNE	R0,[R6,R14,LSL #2]
	MOV	R0,#1			; colour background
	STRB	R0,[R4,R14]
	FNRTS

spaces$l
	ADD	R14,R14,R1
	MOV	R0,#1			; bg colour
sloop$l	CMP	R1,R3
	FNRTS	HS
	STRB	R0,[R4,R1]
	ADD	R1,R1,#1
	CMP	R1,R14
	BLO	sloop$l
	FNRTS




	LOCAL


; ***************************************************************
; *		Calculation of line number routines		*
; ***************************************************************

; veneers:

; if calling these from within Zap and you know that the base mode
; is Text mode, then it's probably best to write code which avoids
; calling 'call_given_base_mode' and place it somewhere nearby.

	FNAME	next_line_number
next_line_number
	FNJSR	"R11"
	MOV	R11,#e_nextline
	BL	call_mode
; post-processing...
	FNRTS

	FNAME	offset_line_number
offset_line_number
	FNJSR	"R11"
	MOV	R11,#e_clnoff
	BL	call_mode
; post-processing...
	FNRTS

	FNAME	physical_line_number
physical_line_number
	FNJSR	"R11"
; pre-processing...?
	MOV	R11,#e_clnphy
	BL	call_mode
	FNRTS

	FNAME	logical_line_number
logical_line_number
	FNJSR	"R11"
	MOV	R11,#e_clnlog
	BL	call_mode
; post-processing...
	FNRTS

; subs:

	FNAME	mode0_clnphy
mode0_clnphy
	FNJSR	"R2-R12"
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	FNPULL  NE
	BNE	modesw_clnphy
	LDR	R1,[R8,#w_tabstops]
	MOV	R2,R9			; file block
	LDR	R3,[R8,#w_bpl]
	LDR	R4,[R8,#w_tabc]
	LDR	R5,[R8,#w_cr]
	LDR	R6,[R8,#w_clogl]
	LDR	R7,[R8,#w_cline]
	LDR	R9,[R8,#w_coff]
	LDR	R12,[R8,#w_info]
	MOV	R10,R0			; search phy line
	CMP	R10,R7,LSR#1
	MOVLS	R6,#0
	MOVLS	R7,#0
	MOVLS	R9,#0			; base offsets
cln_phy_2
	CMP	R10,R7
	BCC	cln_phy_backward
	BEQ	cln_phy_end
cln_phy_1
	BL	cln_FORWARD
	BVS	cln_phy_end
	CMP	R10,R7
	BHI	cln_phy_1
	BCC	cln_phy_vs
cln_phy_end
	MOV	R0,R9
	ADDS	R1,R6,#0		; clv
	FNRTS				; returns with no error
cln_phy_backward
	BL	cln_BACKWARD
	BVC	cln_phy_2
cln_phy_vs
	BLVC	err$l
	FNRTS				; return with error
err$l	ERRlit  "Internal error: cln_phy"

	LOCAL


	FNAME	mode0_clnlog
mode0_clnlog
	FNJSR	"R2-R12"
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	FNPULL  NE
	BNE	modesw_clnlog
	LDR	R3,[R8,#w_tabstops]
	MOV	R2,R9			; file block
	LDR	R3,[R8,#w_bpl]
	LDR	R4,[R8,#w_tabc]
	LDR	R5,[R8,#w_cr]
	LDR	R6,[R8,#w_clogl]
	LDR	R7,[R8,#w_cline]
	LDR	R9,[R8,#w_coff]
	LDR	R12,[R8,#w_info]
	MOV	R10,R0			; search log line
	CMP	R10,R6,LSR#1
	MOVLS	R6,#0
	MOVLS	R7,#0
	MOVLS	R9,#0			; base offsets
	TEQ	R10,#0
	BEQ	cln_log_end		; case when search line is 0
cln_log_2
	CMP	R10,R6
	BLS	cln_log_backward	; may be in the line
cln_log_1
	BL	cln_FORWARD
	BVS	cln_log_end
	CMP	R10,R6
	BHI	cln_log_1
	BCC	cln_log_vs
cln_log_end
	MOV	R0,R9
	ADDS	R1,R7,#0		; clv
	FNRTS				; returns with no error
cln_log_backward
	BL	cln_BACKWARD
	BVC	cln_log_2
cln_log_vs
	BLVC	err$l
	FNRTS				; return with error
err$l	ERRlit  "Internal error: cln_log"



	FNAME	mode0_clnoff
mode0_clnoff
	LDR	R1,[R8,#w_format]
	TST	R1,#bit_softwrap
	BNE	modesw_clnoff
	FNJSR	"R3-R12"
	LDR	R1,[R9,#f_len]
	TEQ	R1,#0			; null length file special case
	BEQ	cln_off_0
	CMP	R0,R1
	MOVCC	R10,R0
	MOVCS	R10,R1			; search offset in file or on end
	LDR	R1,[R8,#w_tabstops]
	MOV	R2,R9			; file block
	LDR	R3,[R8,#w_bpl]
	LDR	R4,[R8,#w_tabc]
	LDR	R5,[R8,#w_cr]
	LDR	R6,[R8,#w_clogl]
	LDR	R7,[R8,#w_cline]
	LDR	R9,[R8,#w_coff]
	LDR	R12,[R8,#w_info]
	CMP	R10,R9,LSR#1		; if offset nearer start of file
	MOVLS	R6,#0
	MOVLS	R7,#0
	MOVLS	R9,#0			; base offsets
cln_off_2
	CMP	R10,R9
	BCC	cln_off_backward	; was/still is CC
	BEQ	cln_off_end
	ADR	R11,cln_off_blk		; temp data store
cln_off_1
	STMIA	R11,{R6,R7,R9}		; save start of line
	BL	cln_FORWARD
	BVS	cln_off_3		; off end of file
	CMP	R10,R9
	BEQ	cln_off_end		; match
	BHI	cln_off_1		; still further on
	LDMIA	R11,{R6,R7,R9}		; get previous line vals
cln_off_end
	MOV	R0,R7			; phy line
	MOV	R1,R9			; start offset of line
	ADDS	R2,R6,#0		; log line, clv
	FNRTS				; returns with no error
cln_off_backward
	BL	cln_BACKWARD
	BVC	cln_off_2
	FNRTS				; return with error

cln_off_blk
	DCD	0
	DCD	0
	DCD	0			; small data block

cln_off_3
	LDMIA	R11,{R6,R7,R9}		; get previous line vals
	B	cln_off_end

cln_off_0
	MOV	R0,#0
	MOV	R1,#0
	MOV	R2,#0
	FNRTS				; null file


;;;; middle level forward/backward subs & split buffer handling ;;;;

;E R1 = tabstops R2=fileblk R3=line len R4=tab mask R5=ret mask R6=log ln R7=phy ln
;  R9=file off of start of phy line  R12 = w_info
;X Vals updated to the start of the next physical line. R8=len of this
;  phy line (exc 0A). It returns VS if the end of the buffer lies on
;  this line. Saves R10-R11.
	FNAME	cln_FORWARD
cln_FORWARD
	FNJSR	"R10-R12"
	TST	R12,#info_UTF8		; quick check for UTF-8
	ADRNE	R12,cln_forward_utf8
	ADREQ	R12,cln_forward
	MOV	R8,#0			; current column offset
	LDR	R10,[R2,#f_ptr]
	LDR	R11,[R2,#f_splito]
	CMP	R9,R11
	ADD	R9,R10,R9
	BCS	cln_FO_1
	ADD	R11,R10,R11
	MOV	R14,PC
	MOV	PC,R12			; first half of buffer
	SUBVC	R9,R9,R10
	FNRTS	VC
cln_FO_1
	LDR	R0,[R2,#f_bufl]
	ADD	R11,R10,R0
	LDR	R0,[R2,#f_splits]
	ADD	R10,R10,R0		; aparant start of second half
	ADD	R9,R9,R0
	MOV	R14,PC
	MOV	PC,R12			; second half of buffer
	SUB	R9,R9,R10		; file offset
	FNRTS	VC
	CMP	R8,R3			; is the last line full
	FNRTV

	LOCAL


;E R1 = tabstops R2=fileblk R3=line len R4=tab mask R5=ret mask R6=log ln R7=phy ln
;  R9=file off of start of phy line
;X vals updated to _A_ previous phy line, VS if error R10-R11 saved
	FNAME	cln_BACKWARD
cln_BACKWARD
	FNJSR	"R1,R10-R11"
	MOV	R11,R9			; save current start of phy line
	PUSH	"R6,R7"			; save line counts
	LDR	R8,[R2,#f_ptr]		; start of first half
	LDR	R7,[R2,#f_splito]	; len of first half
	CMP	R9,R7
	ADD	R9,R8,R9		; address in first half
	BLS	cln_BA_1		; in first half
	LDR	R6,[R2,#f_splits]	; split gap size
	ADD	R10,R8,R7		; end of first half
	ADD	R10,R10,R6		; start of second half
	ADD	R9,R9,R6		; address in second half
	BL	cln_backward		; second half of buffer
	SUB	R9,R9,R6		; address in first half
	BVC	cln_BA_2		; at start of a log line
cln_BA_1
	MOV	R10,R8			; start of first half
	BL	cln_backward		; first half of buffer
cln_BA_2
	SUBS	R9,R9,R8		; file offset of phy line (&clv)
	MOV	R10,R9			; save new offset
	MOV	R7,#0
	MOV	R6,#0			; zero line counts
cln_BA_3
	BL	cln_FORWARD		; move forward one phy line
	BVS	cln_BA_vs
	CMP	R9,R11
	BLT	cln_BA_3		; not reached start pos yet
	BHI	cln_BA_vs		; no match = error
	MOV	R9,R10			; new offset
	PULL	"R0,R1"			; origional line vals
	SUB	R6,R0,R6
	SUB	R7,R1,R7		; new line vals
	FNRTS
cln_BA_vs
	PULL	"R0,R1"			; restore stack
	BL	err$l			; internal error
	FNRTS				; ret with error

err$l	ERRlit  "Internal error: cln_BACKWARD"



;;;;;;;;;;;;;;;; low level forward/backward subs ;;;;;;;;;;;;;;;;;;;

;E R1 = tabstops R3=line len R4=tab mask R5=ret mask R6=log ln R7=phy ln R8=cur offset
;  in phy line R9=curr address in buffer R11=end of section
;X All values moved to start of the next physical line in the section.
;  R2 & R10-R11 saved. Note that if it reaches the end of the section
;  before it is certain that it has reached the next phy line the returns
;  VS. Otherwise returns VC.

	FNAME	cln_forward
cln_forward
	FNJSR	"R1"
cln_fo_l
	CMP	R9,R11			; was R11 (fix of bug mentioned below...?)
	BCS	cln_fo_vs		; end of section reached
	AND	R14,R9,#3
	BIC	R9,R9,#3
	LDR	R0,[R9],#4		; this instruction has caused an abort...
					; ...on one occasion in TW mode... :(
	EOR	R1,R0,R4		; tab mask
	EOR	R0,R0,R5		; return mask
	SUB	R8,R8,R14		; compensate for branching into code
	ADD	R14,R14,R14,LSL#1	; times 3
	ADD	PC,PC,R14,LSL#2		; branch into code
	DCD	0
cln_fo_a
	TST	R0,#&000000FF
	TSTNE	R1,#&000000FF
	BEQ	cln_fo_0		; do first char
	TST	R0,#&0000FF00
	TSTNE	R1,#&0000FF00
	BEQ	cln_fo_1		; do second char
	TST	R0,#&00FF0000
	TSTNE	R1,#&00FF0000
	BEQ	cln_fo_2		; do third char
	TST	R0,#&FF000000
	TSTNE	R1,#&FF000000
	BEQ	cln_fo_3		; do fourth char
	ADD	R8,R8,#4		; new offset
	CMP	R9,R11
	BCS	cln_fo_v		; overflow and compensate
	CMP	R8,R3			; off end of line?
	LDRLS	R0,[R9],#4
	EORLS	R1,R0,R4		; tab
	EORLS	R0,R0,R5		; ret
	BLS	cln_fo_a		; loop if not off end of line
cln_fo_nl
	SUB	R0,R8,R3		; find overflow
	SUB	R9,R9,R0		; start of phy line
	ADD	R7,R7,#1		; inc phy line
	FNRTS

cln_fo_v
	SUB	R0,R9,R11		; size of overflow
	SUB	R8,R8,R0		; subtract the chars
	MOV	R9,R11			; new nextchar
	CMP	R8,R3
	BHI	cln_fo_nl		; we've gone onto a newline
cln_fo_vs
	FNRTV				; overflown buffer before next phy line
cln_fo_0
	SUB	R9,R9,#4
	B	cln_fo_m
cln_fo_1
	ADD	R8,R8,#1
	MOV	R0,R0,LSR#8
	SUB	R9,R9,#3
	B	cln_fo_m
cln_fo_2
	ADD	R8,R8,#2
	MOV	R0,R0,LSR#16
	SUB	R9,R9,#2
	B	cln_fo_m
cln_fo_3
	ADD	R8,R8,#3
	MOV	R0,R0,LSR#24
	SUB	R9,R9,#1
cln_fo_m
	CMP	R9,R11
	BCS	cln_fo_v		; overflowed buffer
	TST	R0,#&FF			; char valid
	BNE	cln_fo_tab		; not a return (thus a tab)
	CMP	R8,R3
	BHI	cln_fo_nl		; already on next line
	ADD	R9,R9,#1		; include this char
	ADD	R7,R7,#1
	ADD	R6,R6,#1		; next phy & log line
	FNRTS
cln_fo_tab
	CMP	R8,R3
	BCS	cln_fo_nl		; gone to next phy line if R8>=R3
	ADD	R9,R9,#1		; include this tab
	LDR	R1,[R13]
	LDR	R1,[R1,R8,LSL #1]
	ADD	R8,R8,R1,LSR #16
	CMP	R8,R3
	MOVCS	R8,R3			; align to edge
	B	cln_fo_l		; do next character

	LOCAL

;E R1 = tabstops  R3=line len (columns)  R4=tab mask  R5=ret mask  R6=log ln  R7=phy ln
;  R8=cur offset in phy line  R9=curr address in buffer  R11=end of section
;X All values moved to start of the next physical line in the section.
;  R2 & R10-R12 saved. Note that if it reaches the end of the section
;  before it is certain that it has reached the next phy line the returns
;  VS. Otherwise returns VC.

; we assume that the first character is never a continuation byte - this relies that the
; split will never be 'inside' a UTF-8 character, which should be true all the time, I think

; currently the return and tab characters cannot be > &100

	FNAME	cln_forward_utf8
cln_forward_utf8
	FNJSR	"R1-R2,R10-R12"		; R1 pulled below
	ADR	R12,utf8_table		; get count of bytes
loop$l	CMP	R9,R11
	BCS	vs$l			; end of section reached

	LDRB	R0,[R9],#1		; get the character
	TEQ	R0,R4,LSR #24
	TEQNE	R0,R5,LSR #24
	BEQ	tr$l

	ADD	R8,R8,#1		; next column
	CMP	R8,R3
	BHI	done$l

	CMP	R0,#&80			;
	BLO	loop$l			; ascii

	SUBS	R14,R0,#&C0		;
	BMI	loop$l			; malformed

	LDRB	R10,[R12,R14]		;
	CMP	R10,#6			;
	BHS	loop$l			; too many

	MOV	R1,R10

	ADD	R14,R14,#64		; get mask for 1st byte
	LDRB	R14,[R12,R14]		;
	AND	R0,R0,R14

next$l	CMP	R9,R11
	BHS	vs$l			; end of section reached

	LDRB	R2,[R9],#1		; get next byte

	AND	R14,R2,#&C0		; validate
	TEQ	R14,#&80		;
	SUBNE	R9,R9,#1		;
	BNE	loop$l			;

	BIC	R2,R2,#&C0		; add in
	ORR	R0,R2,R0,LSL #6		;

	SUBS	R10,R10,#1		; loop for next continuation byte
	BNE	next$l			;
	B	loop$l

	; a tab or return character
tr$l	TEQ	R0,R4,LSR #24
	BEQ	tab$l

	; a return
	ADD	R7,R7,#1
	ADD	R6,R6,#1
	FNRTS

	; a tab
tab$l	LDR	R1,[R13]
	LDR	R1,[R1,R8,LSL #1]
	ADD	R8,R8,R1,LSR #16
	CMP	R8,R3
	MOVCS	R8,R3			; align to edge
	B	loop$l

done$l	SUB	R9,R9,#1
	ADD	R7,R7,#1		; next phy line
	FNRTS

vs$l	FNRTV

		; number of further bytes to read
utf8_table
	=	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	; 110xxxxx
	=	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 ;
	=	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2	; 1110xxxx
	=	3,3,3,3,3,3,3,3			; 11110xxx
	=	4,4,4,4				; 111110xx
	=	5,5				; 1111110x
	=	&FF,&FF				; invalid

		; mask for first character
	=	&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F
	=	&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F,&1F
	=	&0F,&0F,&0F,&0F,&0F,&0F,&0F,&0F,&0F,&0F,&0F,&0F,&0F,&0F,&0F,&0F
	=	&07,&07,&07,&07,&07,&07,&07,&07
	=	&03,&03,&03,&03
	=	&01,&01
	=	0,0

		; minimum character number for this encoding sequence
utf8_max
	DCD	&00000000
	DCD	&00000080
	DCD	&00000800
	DCD	&00010000
	DCD	&00200000
	DCD	&04000000

	LOCAL

;E R1 = tabstops  R5=ret mask R9=addr in buffer R10=start of section
;X VS if overflowed section before prev log line }
;  VC if reached prev logical line (in R9)	 } R1-R4,R6-R8,R11 saved
	FNAME	cln_backward
cln_backward
	CMP	R9,R10			; start of buf
	BLS	cln_ba_vs
	SUB	R9,R9,#1		; skip 0A/a char (if already at start)
cln_ba_2
	CMP	R9,R10
	BLS	cln_ba_vs		; start of buf
	TST	R9,#3
	BEQ	cln_ba_a		; word aligned
	LDRB	R0,[R9,#-1]!
	TEQ	R0,R5,LSR#24
	BNE	cln_ba_2
	ADD	R9,R9,#1		; start of log line
	MOV	PC,R14			; ret
cln_ba_a
	LDR	R0,[R9,#-4]!		; word aligned R9
	EOR	R0,R0,R5		; ret mask
	TST	R0,#&FF000000
	TSTNE	R0,#&00FF0000
	TSTNE	R0,#&0000FF00
	TSTNE	R0,#&000000FF
	BEQ	cln_ba_m		; match found
	CMP	R9,R10
	BHI	cln_ba_a		; still some chars left
cln_ba_vs
	MOV	R9,R10
	RTV				; return start of buffer error
cln_ba_m
	TST	R0,#&FF000000
	ADDEQ	R9,R9,#1
	TSTNE	R0,#&00FF0000
	ADDEQ	R9,R9,#1
	TSTNE	R0,#&0000FF00
	ADDEQ	R9,R9,#1		; R9 points to the 0A
	CMP	R9,R10
	BCC	cln_ba_vs		; off start of buffer
	ADD	R9,R9,#1		; start of next line
	MOV	PC,R14

	LOCAL


;E R0=offset of physical line start R1=file offset R8/R9
;X R0=column offset (exc margin) R1=caret width
	FNAME	mode0_lineoff
mode0_lineoff
	FNJSR	"R2-R11"
	LDR	R11,[R8,#w_tabstops]
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
	LDR	R7,[R9,#f_len]
	MOV	R6,#0			; current column
	MOV	R10,R1			; file offset to stop at
	MOV	R1,R0			; current offset
	CMP	R1,R10
	BHS	end$l			; already passed it
loop$l	CMP	R1,R7			; eof?
	BCS	end$l
	BL	cln_readc_auto
	TEQ	R0,R5
	BEQ	end$l
	TEQ	R0,R4
	LDREQ	R0,[R11,R6,LSL #1]
	ADDEQ	R6,R6,R0,LSR #16
	ADDNE	R6,R6,#1
	CMP	R10,R1
	BHI	loop$l
end$l	MOV	R0,R6
	MOV	R1,#1			; caret width
	FNRTS


	LOCAL


;E R0=file offset of physical line start
;  R1=column offset on screen (exc margin) R8/R9
;X R0=file offset of nearest character on the left
	FNAME	mode0_linecol
mode0_linecol
	FNJSR
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	FNPULL
	BNE	call_mode_linecol
default_mode0_linecol
	FNJSR	"R1-R11"
	LDR	R11,[R8,#w_tabstops]
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
	LDR	R3,[R9,#f_len]
	MOV	R6,#0
	ADDS	R10,R1,#0
	MOV	R1,R0
	BLE	cln_lc_2		; at start of line
cln_lc_1
	CMP	R1,R3
	BCS	cln_lc_2		; off end of file
	MOV	R7,R1
	BL	cln_readc_auto
	TEQ	R0,R5
	MOVEQ	R1,R7
	BEQ	cln_lc_2
	TEQ	R0,R4
	LDREQ	R0,[R11,R6,LSL #1]
	ADDEQ	R6,R6,R0,LSR #16
	ADDNE	R6,R6,#1
	CMP	R10,R6
	BHI	cln_lc_1
	MOVLO	R1,R7			; restore previous
cln_lc_2
	MOV	R0,R1
	CMP	R0,R3
	MOVCS	R0,R3
	FNRTS


	LOCAL

;  \E r0 = sophysl offset
;     r1 = column #
;     r8-r10
;  \X r0 = offset corresp. to column #
call_mode_linecol			; *don't* call sw mode...
;  main routine for mode_linecol
;  \X CS if at eol, CC if not
;     OTHER FLAGS CORRUPT, INCL. V!!!
;  FIXME: this routine is disgusting - cl
	FNJSR	"r1-r11"
	PUSH	"R0"
	LDR	R11,[r8,#w_info]	; sufficient.
	ORR	R14,R11,#bit_strongsw	; clear is not relevant here...!
	STR	R14,[r8,#w_info]
	BL	mode0_lineend
	STR	R11,[r8,#w_info]
	MOV	r3,r0
					; r3 = lineend offset
	PULL	"r0"
	BL	default_mode0_linecol
	CMP	r0,r3
	MOVCS	r0,r3
	FNRTS


;E R0=line off R1=caret off R2=caret col R8/R9
;X R1/R2 new posn after / R2=-1 and R1=new file offset #
	FNAME	mode0_plus
mode0_plus
	FNJSR
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	FNPULL
	BNE	call_mode_plus
mode0_normalplus
	FNJSR	"R6,R7,R11"
	LDR	R11,[R8,#w_tabstops]
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_confinehorizontal
	BNE	cln_p2			; confined.
	FNLDR	R14,car_mode
	CMP	R14,#3
	BEQ	cln_p2
	LDR	R7,[R9,#f_len]
	CMP	R1,R7
	BCS	cln_p3			; off end of file so *stop* if needed
	MOV	R6,R1
	BL	cln_readc_auto		; get char currently on
	LDRB	R7,[R8,#w_cr]
	TEQ	R0,R7
	MOVEQ	R1,R6			; a return - restore previous offset
	BEQ	cln_p1			;
	LDRB	R7,[R8,#w_tabc]
	TEQ	R0,R7
	LDREQ	R0,[R11,R2,LSL#1]
	ADDEQ	R2,R2,R0,LSR#16
	ADDNE	R2,R2,#1		; new column offset
	LDR	R7,[R9,#f_len]
	CMP	R1,R7
	MOVCS	R1,R7
	FNRTS	CS			; at end of file (so return f_len)
	MOV	R6,R1
	BL	cln_readc_auto
	LDRB	R7,[R8,#w_cr]
	TEQ	R0,R7
	MOVEQ	R1,R6
	FNRTS	EQ
	LDR	R7,[R8,#w_bpl]
	CMP	R2,R7
	MOVHS	R2,#-1			; next line
	MOVLO	R1,R6
	FNRTS

cln_p1
	ADD	R2,R2,#1		; next column
	LDR	R7,[R8,#w_bpl]
	CMP	R2,R7
	FNRTS	CC
; fall through...

cln_p2	BL	cln_readc_auto		; set up R1 for next offset
	MVN	R2,#0
	FNRTS

cln_p3	ADD	R2,R2,#1		; next column
	LDR	R7,[R8,#w_bpl]
	CMP	R2,R7
	FNRTS	CC
; fall through...

cln_p4	SUB	R2,R2,#1		; TT
	SUB	R1,R1,#0		; TT
	FNRTS


call_mode_plus
	FNJSR	"R0,R1,R7"
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_confinehorizontal
	BNE	assw_normal
	MOV	R7,R1			; save caret offset
	LDR	R1,[R9,#f_len]
	CMP	R7,R1
	BCS	assw_normal		; off end of file so *stop* if needed
	MOV	R0,R7
	BL	cln_readc		; get char currently on
	LDRB	R1,[R8,#w_cr]
	TEQ	R0,R1
	FNPULL  EQ
	BEQ	mode0_normalplus
assw_normal
	FNPULL
	B	modesw_plus


	LOCAL

;E R0=line off R1=caret off R2=caret col R8/R9
;X R1/R2 new posn after / R2=-1 R1=new offset #
	FNAME	mode0_minus
mode0_minus
	FNJSR	"R3-R11"
	LDR	R11,[R8,#w_tabstops]
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
	MOV	R3,R1			; current file offset
	MOV	R6,#0			; current col
	MOV	R1,R0			; current address in line
	ADDS	R10,R2,#0		; search column
	BLE	prev$l			; at start of line already
	LDR	R2,[R9,#f_len]		; end of file
loop$l	CMP	R1,R2
	BCS	back$l			; cursor is off the end of the file
	MOV	R7,R1
	BL	cln_readc_auto
	TEQ	R0,R5
	MOVEQ	R1,R7
	BEQ	back$l			; a return
	MOV	R14,R6			; temp save of previous column
	TEQ	R0,R4
	LDREQ	R0,[R11,R6,LSL#1]
	ADDEQ	R6,R6,R0,LSR#16
	ADDNE	R6,R6,#1
	CMP	R10,R6
	BGT	loop$l
	MOV	R1,R7			; new offset of caret
	MOV	R2,R14			; new col of caret
	FNRTS

prev$l	BL	minus			; go back a character
	MOV	R2,#-1
	FNRTS				; move to end of previous line

back$l	SUB	R2,R10,#1		; and move back one column
	FNRTS

	LOCAL


; E R1 = file offset of character R8 R9
; X R0 = previous character
;   R1 = file offset of previous character
	FNAME	minus
minus	FNJSR	"R7,R10-R11"		; explicit pull below
	LDR	R0,[R8,#w_info]
	TST	R0,#info_UTF8
	BEQ	notutf8$l

	MOV	R11,R1			; keep offset
	MOV	R10,#0
	MOV	R7,#0

loop$l	CMP	R11,#0
	MOVEQ	R7,#0
	BEQ	err$l
	SUB	R11,R11,#1
	MOV	R0,R11
	BL	cln_readc
	CMP	R0,#&FE			; FE-FF illegal anywhere
	MOVHS	R7,#0
	BHS	err$l
	CMP	R0,#&80			; ascii
	BLO	got$l
	CMP	R0,#&C0			; a continuation byte
	ADDLO	R10,R10,#1
	BLO	loop$l

got$l	ADRHSL	R7,utf8_table		; work out number of continuation
	SUBHS	R0,R0,#&C0		;  bytes expected
	LDRHSB	R7,[R7,R0]		;

err$l	SUBS	R0,R10,R7		; if we got too many continuation
	ADDHI	R1,R11,R0		;  bytes, go back _one_ character
	MOVHI	R0,#&FF00		;  and return the replacement character
	ORRHI	R0,R0,#&FD		;
	FNRTS	HI			;

	MOV	R1,R11			; otherwise read the actual character
	BL	cln_readc_utf8		;
	MOV	R1,R11			;
	FNRTS				;

notutf8$l
	TEQ	R1,#0
	SUBNE	R1,R1,#1
	MOV	R0,R1
	PUSH	"R1"
	BL	cln_readc
	PULL	"R1,R7,R10-R11,PC"


	LOCAL

;E R0=phy line start R1=cur off R2=cur col R8-R10
;X R1,R2=new posn / R2<0 for specials #
	FNAME	mode0_splus
mode0_splus
	PUSH	"R2"
	LDR	R2,[R8,#w_format]	; w_format
	TST	R2,#1 << 25
	PULL	"R2"
	BNE	splus_smart
	FNJSR	"R3-R7"
	LDR	R6,[R9,#f_len]		; length of file
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
	MOV	R3,#-1			; have met a white space flag
	MOV	R2,#-1			; returns offset
loop$l	CMP	R1,R6
	MOVCS	R1,R6			; end of file
	FNRTS	CS
	MOV	R7,R1
	BL	cln_readc_auto
	TEQ	R0,#' '
	TEQNE	R0,R4
	TEQNE	R0,R5
	MOVEQ	R3,#1			; reached a white space
	BEQ	loop$l			; a white space character
	MOVS	R3,R3
	BMI	loop$l			; no white spaces yet!
	MOV	R1,R7
	FNRTS

	LOCAL


; as for mode0_splus
	FNAME	mode0_sminus
mode0_sminus
	PUSH	"R2"
	LDR	R2,[R8,#w_format]	; w_format
	TST	R2,#1 << 25
	PULL	"R2"
	BNE	sminus_smart
	FNJSR	"R3-R7"
	MOV	R7,R1			; save offset
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
	MOV	R3,#-1			; have met a white space flag
	MOV	R2,#-1			; returns offset
loop$l	CMP	R1,#0
	MOVLE	R1,#0			; start of file
	FNRTS	LE
	MOV	R7,R1
	BL	minus
	TEQ	R0,#' '
	TEQNE	R0,R4
	TEQNE	R0,R5
	MOVEQ	R3,#1			; reached a white space
	BEQ	loop$l			; a white space character
	MOVS	R3,R3
	BMI	loop$l			; no white spaces yet!
	MOV	R1,R7
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Wordwrap/Line format						  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

	FNAME	mode0_formattext
mode0_formattext
	FNJSR
	BL	start_operation		; concatonate
	LDR	R0,[R10,#c_loff]
line$l	BL	format_line
	BVS	err$l
	TEQ	R1,#1			; reached para end?
	BNE	line$l
	STR	R0,[R10,#c_off]		; new caret offset
	BL	stop_operation		; print result
	BLVC	reflect_caret
	BLVC	make_cursor_visible
	FNRTS

err$l	BL	stop_operation
	FNRTS


	LOCAL

;E R0=file offset to take for line start R8-R9
;X R0=file offset of next line after (uses command_primative) #
;  R1=0 if nothing done/1 if reached para end/2 if moved stuff
; (Algorithm: If line stops short of end then sees if it can join on a bit
; of the next line - if so then joins on the whole of the next line and
; loops back to the start. If line goes over end then splits it and returns).
	FNAME	format_line
format_line
	FNJSR	"R2-R11"
	MOV	R7,R0			; save file offset
	LDR	R6,[R9,#f_len]
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
	CMP	R7,R6
	BCS	fileend$l		; reached file end
	MOV	R3,#0			; current column
	LDR	R2,[R8,#w_wrapwidth]	; format width
	MOV	R10,#0			; last valid split offset (none currently)
	MOV	R11,#0			; done nothing flag
search$l				; search for somewhere to split at
	CMP	R7,R6
	BCS	lineend$l		; fileend$l	; reached file end
	MOV	R0,R7
	BL	cln_readc		; get next character
	ADD	R7,R7,#1		; update offset
	TEQ	R0,R5
	BEQ	lineend$l		; reached line end
	TEQ	R0,R4
	ADDNE	R3,R3,#1
	LDREQ	R14,[R8,#w_tabstops]
	LDREQ	R14,[R14,R3,LSL #1]
	ADDEQ	R3,R3,R14,LSR #16	; update column
	TEQ	R0,#&20
	TEQNE	R0,R4
	SUBEQ	R10,R7,#1		; update last valid split posn
	BEQ	search$l		; and loop ignoring overflow
	CMP	R3,R2			; have we overflowed line end
	BLE	search$l		; (not overflow)
	CMP	R10,#0
	BLE	search$l		; nowhere to split - keep going anyway because it's rude not to
	MOV	R0,#3			; replace
	MOV	R1,R10			; file offset
	MOV	R2,#1			; number of bytes
	ADD	R3,R12,#tmp_formline	; data to replace with
	STRB	R5,[R3]
	BL	command_primative	; (this sub may be called in exec_command)
	ADDVC	R0,R10,#1		; next line
	MOVVC	R1,#2			; done stuff
	FNRTS
lineend$l
	TEQ	R3,#0
	BEQ	end$l			; this line was blank so skip
	MOV	R10,R7			; start of next line
join$l					; get bit to join on
	SUBS	R0,R10,R7		; number of bytes planning to add (exc ret)
	BLE	check$l			; don't test adding null text
	ADD	R0,R0,R3		; total length of old line (exc extra space)
	CMP	R0,R2
	BCS	end$l			; no split posn close enough to join
check$l					; check for a split posn
	CMP	R10,R6			; at EOF?
	MOVHS	R0,R5			; ...if so, pretend it's a CR
	MOVLO	R0,R10
	BLLO	cln_readc		; otherwise, get next char
	TEQ	R0,#&20
	TEQNE	R0,R5
	TEQNE	R0,R4
	ADDNE	R10,R10,#1
	BNE	join$l			; not reached a split posn yet
	SUBS	R0,R10,R7		; offset in line
	BLE	para$l			; if at start of line then at new para
	ADD	R1,R3,R0
	ADD	R1,R1,#1		; col we would reach if joined
	CMP	R1,R2
	BHI	end$l			; no good don't bother to join
	MOV	R3,R1			; update col
	PUSH	"R2-R3"
	MOV	R0,#3			; replace
	SUB	R1,R7,#1		; file offset
	MOV	R2,#1			; number of bytes
	ADD	R3,R12,#tmp_formline	; data to replace with
	MOV	R14,#&20
	STRB	R14,[R3]
	BL	command_primative	; (this sub may be called in exec_command)
	PULL	"R2-R3"
	SUBVC	R0,R7,#1		; last valid spilt posn
	MOVVC	R7,R10			; update offset
	MOVVC	R10,R0			; update last valid posn
	MOVVC	R11,#2			; done something
	BVC	search$l		; continue with line
	FNRTS

end$l	MOV	R0,R7			; next line
	MOV	R1,R11			; return what I've done
	FNRTS

fileend$l
	MOV	R0,R6			; file end
	MOV	R1,#1
	FNRTS

para$l	MOV	R0,R7			; start of a new paragraph
	MOV	R1,#1
	FNRTS



	FNAME	mode0_command
mode0_command
	FNJSR
	BL	adjust_ins_pt_if_needed
	BLEQ	changeposn$l
	LDR	R14,[R8,#w_flags]
	TST	R14,#(1<<13)		; wordwrap?
	BNE	co23			; wordwrap
	BL	command_primative	; do the original command
	FNRTS

co23	BL	start_operation
	BL	command_primative
	BLVS	stop_operation
	FNRTS	VS
	FNPULL
	FNJSR	"R1-R3"
	ADD	R3,R1,R2		; last altered offset
	MOV	R0,R1			; first file offset
	BL	mode0_linestart		; start of the logical line
	BVS	co22
	LDR	R2,[R9,#f_flags]
	ORR	R14,R2,#1<<14		; unlink input
	STR	R14,[R9,#f_flags]

co21	BL	format_line
	BVS	co22
	TEQ	R1,#1
	BEQ	co22			; reached para end
	CMP	R0,R3
	BCC	co21			; haven't yet reached change end
	TEQ	R1,#0
	BNE	co21			; has done something so continue

co22	LDR	R14,[R9,#f_flags]
	AND	R2,R2,#1<<14
	BIC	R14,R14,#1<<14
	ORR	R14,R14,R2
	STR	R14,[R9,#f_flags]	; restore linked state
	BL	stop_operation
	FNRTS


;X NE if insert as normal.  EQ if changes needed...
adjust_ins_pt_if_needed
	FNJSR	"R0,R1,R2,R3,R10"
	LDR	R14,[R8,#w_info]
	TST	R14,#1<<6
	BEQ	exitclear$l		; not a full line
	AND	R14,R0,#7		; get basic command number
	TEQ	R14,#1			; insert
	BNE	exitclear$l		; not a full line
	CMP	R2,#3
	BLT	exitclear$l		; not a full line
	MOV	R1,#0
	LDRB	R0,[R8,#w_cr]
loop1$l	SUB	R2,R2,#1
	LDRB	R14,[R3,R2]		; last character
	CMP	R14,#33
	ORRCS	R1,R1,#1<<31		; flag for 'sensible character used'.
	TEQ	R14,R0
	ORREQ	R1,R1,#1<<30		; flag for CR hit
	CMP	R2,#0
	BGT	loop1$l
	TST	R1,#1<<30
	BNE	co2
exitclear$l
	MOVS	R14,#-1			; NE if not.
	FNRTS

co2	TST	R1,#1<<31
	BEQ	exitclear$l
	MOVS	R14,#0			; EQ if as full line...
	FNRTS

changeposn$l
	FNJSR	"R0,R10,R11"
	MOV	R0,R1
	MOV	R11,#e_lineprev
	BL	call_mode
	MOV	R1,R0
	FNRTS


	LOCAL



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Move to line start/end					  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	FNAME	mode0_lineend
mode0_lineend
	FNJSR	"R1-R2"
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_softwrap
	BEQ	asnormal$l
	LDR	R14,[R8,#w_info]
	TST	R14,#bit_strongsw
	FNPULL  NE
	BNE	modesw_lineend
asnormal$l
	MOV	R1,R0
	BL	mode0_cplus
	MOV	R0,R1
	FNRTS


	LOCAL

	FNAME	mode0_lineprev
mode0_lineprev
	FNJSR	"R1-R2"
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	BEQ	basemode_linestart
	LDR	R14,[R8,#w_info]
	TST	R14,#bit_strongsw
	BEQ	basemode_linestart
	FNPULL
	B	modesw_lineprev


	LOCAL

	FNAME	mode0_linestart
mode0_linestart
	FNJSR	"R1-R2"
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_softwrap
	BEQ	basemode_linestart
	LDR	R14,[R8,#w_info]
	TST	R14,#bit_strongsw
	FNPULL  NE
	BNE	modesw_linestart
basemode_linestart
	MOV	R1,R0
	BL	mode0_cminus
	MOV	R0,R1
	FNRTS


	LOCAL

	FNAME	mode0_linenext
mode0_linenext
	FNJSR	"R1-R2"
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_softwrap
	BEQ	asnormal$l
	LDR	R14,[R8,#w_info]
	TST	R14,#bit_strongsw
	FNPULL  NE
	BNE	modesw_linenext
asnormal$l
	MOV	R1,R0
	BL	mode0_cplus
	ADD	R0,R1,#1
	LDR	R1,[R9,#f_len]
	CMP	R0,R1
	MOVCS	R0,R1
	FNRTS


	LOCAL

	FNAME	mode0_cplus
mode0_cplus
	FNJSR	"R3-R7"
	LDR	R14,[R8,#w_format]
	TST	R14,#bit_softwrap
	BEQ	asnormal$l
	LDR	R14,[R8,#w_info]
	TST	R14,#bit_strongsw
	FNPULL  NE
	BNE	modesw_cplus
asnormal$l
	LDRB	R5,[R8,#w_cr]
	LDR	R6,[R9,#f_len]
	MOV	R2,#-1			; returning offset
cln_l1	CMP	R1,R6
	MOVCS	R1,R6			; end of file
	FNRTS	CS
	MOV	R7,R1			; keep current offset
	BL	cln_readc_auto
	TEQ	R0,R5
	BNE	cln_l1
	MOV	R1,R7			; end of line
	FNRTS


	LOCAL

	FNAME	mode0_cminus
mode0_cminus
	FNJSR	"R3-R7"
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	BEQ	asnormal$l
	LDR	R14,[R8,#w_info]
	TST	R14,#bit_strongsw
	MOVNE	R2,#0
	MOVNE	R1,R0
	FNRTS	NE
asnormal$l
	LDRB	R5,[R8,#w_cr]
	MOV	R2,#-1			; returning offset
cln_l2	CMP	R1,#0
	MOVLE	R1,#0			; start of file
	FNRTS	LE
	MOV	R7,R1			; save offset
	BL	minus
	TEQ	R0,R5
	BNE	cln_l2
	MOV	R1,R7
	FNRTS


;E R0=offset R8/R9
;X R0=start of word |
	FNAME	mode0_wordminus_whole
mode0_wordminus_whole
	FNJSR	"R1-R7"
	LDR	R6,[R9,#f_len]
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
	MOV	R7,R0
	CMP	R7,R6
	MOVCS	R0,R6
	FNRTS	CS
wo1a	CMP	R7,#0
	MOVLE	R0,#0
	FNRTS	LE
	SUB	R0,R7,#1
	BL	cln_readc
	TEQ	R0,R5
	TEQNE	R0,R4
	TEQNE	R0,#&20			; just spaces; simple.
	SUBNE	R7,R7,#1
	BNE	wo1a
	MOV	R0,R7
	FNRTS


;E R0=offset R8/R9
;X R0=start of word |
	FNAME	mode0_wordplus_whole
mode0_wordplus_whole
	FNJSR	"R1-R7"
	LDR	R6,[R9,#f_len]
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
	MOV	R7,R0
	CMP	R7,R6
	MOVCS	R0,R6
	FNRTS	CS

wo1b	CMP	R7,R6
	MOVCS	R0,R6
	FNRTS	CS
	MOV	R0,R7
	BL	cln_readc
	TEQ	R0,R5
	TEQNE	R0,R4
	TEQNE	R0,#&20			; just spaces; simple.
	ADDNE	R7,R7,#1
	BNE	wo1b
	MOV	R0,R7
	FNRTS


;E R0=offset R8/R9
;X R0=start of word |
	FNAME	mode0_wordminus
mode0_wordminus
	FNJSR	"R1-R7"
	LDR	R6,[R9,#f_len]
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
	MOV	R7,R0
	CMP	R7,R6
	MOVCS	R0,R6
	FNRTS	CS
	MVN	R3,#0
	BL	ask_mode_about_this_word

wo1	MOV	R0,R7
	BL	cln_readc
	CMP	R0,R5
	BLEQ	getnextoneback		; endoflinewordcr
	BL	CursorPriority2		; result in R2
	MOV	R2,R0

woon1a	CMP	R7,#0
	MOVLE	R0,#0
	FNRTS	LE
	SUB	R0,R7,#1
	BL	cln_readc
	CMP	R0,R5
	BEQ	endoflinewnoncr		; endoflinewordcr
	BL	CursorPriority2
	CMP	R0,R2
	ADDEQ	R7,R7,R3
	BEQ	woon1a
	PUSH	"R1,R8-R11"		; stack
	MOV	R0,#19
	MOV	R11,#e_interrogate
	SUB	R1,R7,#1
	BL	call_mode
	PULL	"R1,R8-R11"		; unstack
	CMP	R0,#19
	ADDNE	R7,R7,R3
	BNE	woon1a
	B	endoflinewnoncr


;E R0=offset R8/R9
;X R0=end of word |
	FNAME	mode0_wordplus
mode0_wordplus
	FNJSR	"R1-R7"
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
	LDR	R6,[R9,#f_len]
	MOV	R3,#1
	MOV	R7,R0
	BL	ask_mode_about_this_word

wo2	MOV	R0,R7
	CMP	R0,R6
	MOVCS	R0,R6
	FNRTS	CS			; new beyond eof check...
	BL	cln_readc
	CMP	R0,R5
	BEQ	endoflinewnoncr		; endoflinewordcr
	BL	CursorPriority2		; result in R2
	MOV	R2,R0
	ADD	R7,R7,R3

woon1	CMP	R7,R6
	MOVCS	R0,R6
	FNRTS	CS
	MOV	R0,R7
	BL	cln_readc
	CMP	R0,R5
	BEQ	endoflinewnoncr
	BL	CursorPriority2
	CMP	R0,R2
	ADDEQ	R7,R7,R3
	BEQ	woon1
	PUSH	"R1,R8-R11"
	MOV	R0,#19
	MOV	R11,#e_interrogate
	MOV	R1,R7
	BL	call_mode
	PULL	"R1,R8-R11"
	CMP	R0,#19
	ADDNE	R7,R7,R3
	BNE	woon1

endoflinewnoncr
	MOV	R0,R7
	FNRTS

endoflinewordcr
	ADD	R0,R7,#1
	FNRTS


;E R0=offset R8/R9
;X paragraph start |
	FNAME	mode0_parastart
mode0_parastart
	FNJSR	"R1"
pa2	CMP	R0,#0
	MOVLE	R0,#0
	FNRTS	LE
	BL	mode0_linestart
	MOV	R1,R0
	BL	mode0_wordplus
	CMP	R0,R1
	SUBGT	R0,R1,#1		; end of previous line
	BGT	pa2
	MOV	R0,R1
	BL	mode0_lineend		; are we at end of this line
	TEQ	R0,R1
	ADDEQ	R0,R1,#1		; null line
	MOVNE	R0,R1			; line not null
	FNRTS


	FNAME	mode0_nextline
mode0_nextline
	FNJSR	"R2-R12"		; WARNING - stack pull below
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	FNPULL  NE
	BNE	modesw_nextline
	MOV	R10,R0
	LDR	R1,[R8,#w_tabstops]
	MOV	R2,R9			; file block
	LDR	R3,[R8,#w_bpl]
	LDR	R4,[R8,#w_tabc]
	LDR	R5,[R8,#w_cr]
	LDR	R6,[R8,#w_clogl]
	LDR	R7,[R8,#w_cline]
	LDR	R9,[R8,#w_coff]
	LDR	R12,[R8,#w_info]
	CMP	R10,R9,LSR#1		; if offset nearer start of file
	MOVLS	R6,#0
	MOVLS	R7,#0
	MOVLS	R9,#0			; base offsets
cln_nex_2
	CMP	R9,R10
	BHI	cln_nex_backward	; move back if R9>R10
cln_nex_1
	MOV	R11,R6			; save log line
	BL	cln_FORWARD
	BVS	cln_nex_3		; off end of file
	CMP	R10,R9
	BCS	cln_nex_1		; if not past R10 yet then loop
	CMP	R6,R11
	BHI	cln_nex_end		; moved onto next log line so finish
	LDR	R0,[R13,#10*4]		; recover R12
	LDR	R10,[R0,#scn_yos]
	LDR	R0,[R0,#scn_magy]
	MOV	R10,R10,LSR R0
	MOV	R10,R10,LSR#3		; max num of phy lines to bother checking
cln_nex_5
	BL	cln_FORWARD
	BVS	cln_nex_3		; off end of file
	SUBS	R10,R10,#1
	BLE	cln_nex_3		; give up and give end of file offset
	CMP	R6,R11
	BLE	cln_nex_5		; log line not increased
cln_nex_end
	LDR	R0,[R2,#f_len]
	CMP	R9,R0
	BCS	cln_nex_3		; off end of file (may not have had a VS)
	MOV	R0,R9			; offset of line
	MOV	R1,R7			; phy line
	FNRTVC				; returns with no error
cln_nex_backward
	BL	cln_BACKWARD
	BVC	cln_nex_2
	FNRTS				; return with error
cln_nex_3
	ADDS	R1,R7,#0		; phy line and clv
	LDR	R0,[R2,#f_len]		; end of file
	FNRTS


mode0_prevline
	FNJSR
	LDR	R14,[R8,#w_format]
	ANDS	R14,R14,#bit_softwrap
	BLNE	modesw_prevline		; call_mode_prevline
	FNRTS


;E R0=file offset R9=file
;X R0=first non white space char offset |
	FNAME	mode0_autoplus
mode0_autoplus
	FNJSR	"R1-R7"
	MOV	R1,R0			; save offset
	LDR	R6,[R9,#f_len]		; length of file
	LDRB	R5,[R8,#w_cr]
	LDRB	R4,[R8,#w_tabc]
au1	CMP	R1,R6
	MOVCS	R0,R6			; end of file
	FNRTS	CS
	MOV	R7,R1
	BL	cln_readc_auto
	TEQ	R0,R5
	MOVEQ	R0,R7			; hit a return character
	FNRTS	EQ
	TEQ	R0,#' '
	TEQNE	R0,R4
	BEQ	au1			; on a white space
	MOV	R0,R7
	FNRTS


	FNAME	mode0_selection
mode0_selection
	TEQ	R0,#0
	BEQ	se51			; starting selection
	TEQ	R0,#1
	BEQ	se46			; updating a selection
	MOV	PC,R14

se51	FNLDR	R0,car_mode
	TEQ	R0,#3			; cursor selection
	MOVEQ	R0,#0
	FNSTR	R0,wimp_dragdepth,EQ
	MOV	PC,R14

se46	FNLDR	R0,wimp_dragdepth
	CMP	R0,#2
	MOVLT	PC,R14			; no need to alter
	FNJSR	"R1-R3"
	MOV	R2,R0			; save the depth
	ADRL	R3,mode0_linestart	; default sub (lines)
	TEQ	R2,#2			; words
	ADRL	R0,mode0_wordminus
	MOVEQ	R3,R0
	TEQ	R2,#4			; paras
	ADRL	R0,mode0_parastart
	MOVEQ	R3,R0
	LDR	R0,[R10,#c_owidth]	; current offset
	MOVS	R14,PC
	MOV	PC,R3			; call the sub
	FNRTS	VS
	STR	R0,[R10,#c_owidth]	; new offset
	BL	offset_line_column
	FNRTS	VS
	STR	R2,[R10,#c_ocol]
	STR	R3,[R10,#c_oline]	; new coords
	FNRTS

mode0_copy
	TEQ	R0,#2
	MOVEQ	PC,R14			; so spaces work etc
; fall through...

; As for e_copy but R0=2 been taken care of
	FNAME	modes_copy,1
modes_copy
	FNJSR	"R1,R4-R7,R10"
	FNLDR	R3,wimp_kbdbuf		; output buffer
	MOV	R2,R1			; save number of times
	MOV	R4,#0			; number typed
	LDR	R7,[R10,#c_off]		; file offset
	LDR	R6,[R9,#f_len]		; end of file
co19	CMP	R7,R6
	BCS	co20
	MOV	R0,R7
	BL	cln_readc
	STRB	R0,[R3,R4]
	ADD	R7,R7,#1
	ADD	R4,R4,#1
	CMP	R4,R2
	BLT	co19
co20	MOV	R2,R4			; number actually typed
	BL	fake_right$l		; Right
	FNRTS

fake_right$l
	FNJSR	"R1-R11"		; overkill
	LDR	R0,[R10,#c_wind]
	BL	conv_wind_off
	MOV	R0,R7
	BL	goto_file_offset
	FNRTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INSERT AND DEL CHAR KEY SUBS				      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;  R4=w_flags R5=num bytes R6=w_format R7=data R8/R9/R10=input caret
	FNAME	mode0_char
mode0_char
	ADRL	R3,mode0_char_doit
	MOV	R0,#0


; R0b31 set if deletion  R3 = routine to call  R4-R10 as above
; Routine called with R0 = 0 if not in block or not block editing, else R0=1
	FNAME	char_del_dispatch,1
char_del_dispatch
; To disable block editing, uncomment the following lines:
;	MOV	R0,#0
;	MOV	PC,R3
	LDR	R1,[R8,#w_info]
	TST	R1,#1<<10		; block edit?
	MOVEQ	R0,#0
	MOVEQ	PC,R3
	PUSH	"R0,R3-R10,R14"
	BL	get_selection
	MOV	R11,R8
	PULL	"R0,R3-R10,R14"
	MOVCS	R0,#0
	MOVCS	PC,R3
	TEQ	R8,R11			; and in same window?
	MOVNE	R0,#0
	MOVNE	PC,R3
	PUSH	"R0"
	LDR	R0,[R10,#c_off]
	ADD	R2,R2,R1
	CMP	R1,R0
	CMPLS	R0,R2			; and in selection?
	PULL	"R0"
	MOVCS	R0,#0
	MOVCS	PC,R3
	FNJSR	"R0,R4-R7,R11"		; if so, do block editing
	LDR	R0,[R8,#w_flags]
	STR	R0,local_wflags$l
	LDR	R0,[R8,#w_format]
	STR	R0,local_wformat$l
	FNLDR	R0,opt_flags
	STR	R0,local_oflags$l
	BIC	R0,R0,#1<<22		; prevent selection auto-clear
	FNSTR	R0,opt_flags

;	LDR	R0,[R8,#w_info]
;	STR	R0,local_winfo$l
;	BIC	R0,R0,#1<<9		; clear strong softwrap
;	STR	R0,[R8,#w_info]

	LDR	R11,[R10,#c_off]
	BIC	R4,R4,#1<<13		; clear wordwrap
	BIC	R4,R4,#1<<26		; clear linewrap
	STR	R4,[R8,#w_flags]	; and store (just in case)
	STR	R6,[R8,#w_format]

	MOV	R4,R1			; start of selection
	MOV	R5,R2			; end of selection

	ADR	R0,local_sel$l
	STMIA	R0,{R4,R5}

	LDR	R0,[R10,#c_off]
;	BL	offset_line_number	;** activate when softwrap fixed
;	MOV	R0,R2
;	BL	logical_line_number	;** instead of the following line
	BL	find_line_start		; get start of logical line
	LDRVC	R1,[R10,#c_off]
	BLVC	logical_column_number
	MOVVC	R7,R0			; R7 = column number
	LDRVC	R0,[R10,#c_loff]
	LDRVC	R1,[R10,#c_off]
	BLVC	cln_lineoff
	LDRVC	R1,[R10,#c_col]		; to allow for line numbers.
	LDRVC	R14,[R8,#w_margin]	; to allow for line numbers.
	SUBVC	R1,R1,R14
	SUBVC	R1,R1,R0
	ADDVC	R7,R7,R1		; adjust R7 a little...
	MOVVC	R0,R5
	BLVC	offset_line_number
	MOVVC	R6,R2			; R6 = log line no last line in sel
	MOVVC	R0,R4
	BLVC	offset_line_number
	MOVVC	R5,R2			; R5 = log line no first line in sel
	BVS	err1$l

	PUSH	"R10"
	LDR	R0,[R10,#c_off]
	BL	ensure_mark		; if not already there,
	MOVEQ	R0,#0
	MOVNE	R0,#1			; remember to delete it later
	STR	R0,placedmark$l
	PULL	"R10"
	LDRNE	R0,[R10,#c_off]
	BLNE	insert_marker		; place it
	BVS	err1$l

	BL	start_operation
	BL	insert_approved_space
	; Minor redraw problem which shows up in read-only mode:
	; we're not deleting the caret
loop$l
	BL	altesc
	BCC	notesc$l
	LDR	R0,[R13]
	TEQ	R0,#0
	ADRPL	R0,escins$l
	ADRMI	R0,escdel$l
	BL	query_abort
	BEQ	exitloop$l
notesc$l
	MOV	R0,R6
	BL	logical_line_number
	BLVC	find_line_start		; ** avoid softwrap problems
	STRVC	R0,[R10,#c_loff]	; fiddle line start
	MOV	R1,R7
	BL	logical_column_offset
	STR	R0,[R10,#c_off]
	BL	update_caret
	BVS	err$l
	LDR	R4,[R10,#c_col]		; adjust cursor column a little
	ADD	R4,R4,R1
	STR	R4,[R10,#c_col]

	LDR	R0,[R10,#c_off]

	ADR	R2,local_sel$l
	LDMIA	R2,{R2,R14}

	CMP	R0,R2
	BLO	outside_sel$l
	CMP	R0,R14
	BHS	outside_sel$l

	MOV	R14,R13
	LDR	R4,[R10,#c_off]

	PUSH	"R1,R3-R11"		; stack return address etc.
	LDMIA	R14,{R0,R4-R7}		; get parameters
	TST	R0,#1<<31
	BEQ	not_del$l
	SUBS	R5,R5,R1
	BLE	nowttodel$l
not_del$l
	BIC	R4,R4,#3<<13		; clear wordwrap; link cursor
	BIC	R4,R4,#1<<26		; clear linewrap
	BL	call_r3
nowttodel$l
	PULL	"R1,R3-R11"		; stack return address etc.
	BVS	err$l
	LDR	R0,[R13]
	TEQ	R4,R11
	TSTEQ	R0,#1<<31		; um, delete...?
	BNE	not_char$l
	LDR	R0,[R8,#w_flags]
	TST	R0,#2			; overwrite fiddle...
	LDRNE	R0,[R13,#8]
	ADDNE	R4,R4,R1		; - spaces inserted
	ADDNE	R4,R4,R0		; - characters inserted/overwritten
	LDRNE	R2,[R9,#f_mark]
	LDRNE	R1,[R9,#f_mptr]
	SUBNE	R2,R2,#8
	STRNE	R4,[R1,R2]
not_char$l
outside_sel$l
	SUB	R6,R6,#1
	CMP	R6,R5			; any more lines in selection?
	BGE	loop$l
exitloop$l
	LDR	R5,[R9,#f_mark]
	LDR	R4,[R9,#f_mptr]
	SUB	R5,R5,#8
	LDR	R0,[R4,R5]		; file offset of marker
	BL	goto_file_offset	; goto this offset (any mark?)
	BLVC	plot_caret
	BVS	err$l
	LDR	R0,placedmark$l
	TST	R0,#1
	BLNE	delete_marker
	BL	insert_approved_space
err$l	BL	stop_operation

err1$l  LDR	R4,local_wflags$l	; restore w_flags
	LDR	R14,[R8,#w_flags]
	BIC	R4,R4,#8
	AND	R14,R14,#8
	ORR	R4,R4,R14		; ...preserving the 'changed' flag
	STR	R4,[R8,#w_flags]

	LDR	R4,local_wformat$l	; restore w_format
	STR	R4,[R8,#w_format]
	LDR	R4,local_oflags$l
	FNSTR	R4,opt_flags
;	LDR	R4,local_winfo$l	; restore w_info
;	STR	R4,[R8,#w_info]
	FNRTS
call_r3 MOV	R0,#1
	MOV	PC,R3

escins$l
	&	0
	FNS	("zap_q_insrep")
escdel$l
	&	0
	FNS	("zap_q_delrep")

local_wflags$l	&	0
local_wformat$l	&	0
local_oflags$l	&	0
;local_winfo$l  & 0
placedmark$l	&	0
local_sel$l	&	0,0


;\E R8,R9,R10 R3 bit 31 set if deleting...
insert_approved_space
	FNJSR	"R1-R4"
	TST	R3,#1<<31
	LDRNE	R2,[R10,#c_col]
	LDRNE	R3,[R10,#c_line]
	MOVNE	R4,R2
	BLNE	find_offset		; R0=file offset
	CMPNE	R4,R2
	FNRTS	NE			; not appropriate to disturb
	LDR	R4,[R9,#f_flags]
	BIC	R14,R4,#1<<14		; input now linked...
	STR	R14,[R9,#f_flags]
	LDR	R3,[R8,#w_flags]
	BIC	R14,R3,#2		; insert mode...
	STR	R14,[R8,#w_flags]
	LDR	R0,[R10,#c_off]
	BL	space_at_offset
	STR	R3,[R8,#w_flags]
	STR	R4,[R9,#f_flags]
	FNRTS


	LOCAL

; E R0=logical line start offset R1='cursor' offset R8/R9
;   (uses w_format)
; X R0=logical column number
; Replace with call to e_lineoff when softwrap problem fixed
	FNAME	logical_column_number
logical_column_number
	FNJSR	"R2-R10"
	LDR	R10,[R8,#w_tabstops]
	MOV	R2,#0
	LDR	R3,[R9,#f_ptr]
	LDR	R4,[R9,#f_splito]
	LDR	R5,[R9,#f_splits]
	LDR	R6,[R8,#w_format]
	LDR	R7,[R9,#f_len]
	LDRB	R9,[R8,#w_cr]
	LDRB	R8,[R8,#w_tabc]
	CMP	R0,R4
	ADDHI	R3,R3,R5
lcn$l	CMP	R0,R1
	BHS	lcnret$l
	TEQ	R0,R4
	ADDEQ	R3,R3,R5
	TEQ	R0,R7
	LDRNEB  R14,[R3,R0]
	ADD	R0,R0,#1
	TEQNE	R14,R9
	BEQ	lcnret$l
	ADD	R2,R2,#1
	TEQ	R14,R8
	BNE	lcn$l
	TST	R6,#3<<12
	LDRNE	R14,[R10,R2,LSL#1]
	ADDNE	R2,R2,R14,LSR#16
	B	lcn$l
lcnret$l
	MOV	R0,R2
	FNRTS


	LOCAL

; E R0=logical line start offset R1=logical column number R8/R9
;   (uses w_format)
; X R0=corresponding file offset
;   R1=offset within character (eg. number of spaces to insert)
; Replace with call to e_linecol when softwrap problem fixed
	FNAME	logical_column_offset
logical_column_offset
	FNJSR	"R2-R11"
	LDR	R11,[R8,#w_tabstops]
	MOV	R2,#0
	TEQ	R2,R1
	BEQ	lcoret$l
	MOV	R10,#0
	LDR	R3,[R9,#f_ptr]
	LDR	R4,[R9,#f_splito]
	LDR	R5,[R9,#f_splits]
	LDR	R6,[R8,#w_format]
	LDR	R7,[R9,#f_len]
	LDRB	R9,[R8,#w_cr]
	LDRB	R8,[R8,#w_tabc]
	CMP	R0,R4
	ADDHI	R3,R3,R5
	SUB	R0,R0,#1
lco$l	TEQ	R2,R1
	BEQ	lcoret$l
	ADD	R0,R0,#1
	TEQ	R0,R4
	ADDEQ	R3,R3,R5
	TEQ	R0,R7
	LDRNEB  R14,[R3,R0]
	MOV	R2,R10
	TEQNE	R14,R9
	BEQ	lcoret$l
	ADD	R10,R10,#1
	TEQ	R14,R8
	BNE	lco$l
	TST	R6,#3<<12
	LDRNE	R14,[R11,R10,LSL #1]
	ADDNE	R10,R10,R14,LSR #16
	CMP	R10,R1
	BLO	lco$l
	ADDEQ	R0,R0,#1
	MOVEQ	R2,R1
lcoret$l
	SUB	R1,R1,R2
	FNRTS


	LOCAL

; E R0=file offset
; X R0=logical line start
; Remove when softwrap problem fixed
	FNAME	find_line_start
find_line_start
	FNJSR	"R1-R4"
	LDR	R1,[R9,#f_ptr]
	LDR	R2,[R9,#f_splito]
	LDR	R3,[R9,#f_splits]
	LDRB	R4,[R8,#w_cr]
	CMP	R0,R2
	ADDHS	R1,R1,R3
loop$l  TEQ	R0,R2
	SUBEQ	R1,R1,R3
	SUBS	R0,R0,#1
	BMI	found$l
	LDRB	R14,[R1,R0]
	TEQ	R14,R4
	BNE	loop$l
found$l ADD	R0,R0,#1
	FNRTS


	FNAME	mode0_char_doit
mode0_char_doit
	FNJSR
	LDR	R0,[R10,#c_loff]
	LDR	R1,[R10,#c_off]
	BL	cln_lineoff		; R0=column offset on screen - margin
	FNRTS	VS
	BL	start_operation		; concatenate ops (phew!)
	LDR	R1,[R8,#w_margin]
	ADD	R0,R0,R1		; add margin
	LDR	R1,[R10,#c_col]
	SUBS	R1,R1,R0		; number of spaces to insert before entry
	BLE	in15
	MOV	R0,R1
	BL	ensure_redblk		; ensure enough spaces in spaces buffer
	FNRTS	VS
	MOV	R2,R1			; number of spaces
	LDR	R1,[R10,#c_off]
	FNLDR	R3,red_blkbuf
	MOV	R0,#&11
	BL	execute_command		; insert the spaces
	BVS	endofcharinsertion

in15	TST	R4,#2			; in overwrite mode
	BEQ	in1			; if not then insert the chars
	LDR	R1,[R10,#c_off]
	MOV	R0,R1
	BL	mode0_lineend		; find offset of end of line
	BVS	endofcharinsertion
	SUBS	R11,R0,R1		; number of chars that can be replaced
	CMP	R11,R5
	MOVGT	R11,R5

in1	BL	insert_chars_at		; replace as many chars as possible
	BVS	endofcharinsertion
	TST	R4,#1<<26		; linewrap
	BEQ	endofcharinsertion
	LDR	R1,[R10,#c_off]
	MOV	R0,R1
	BL	mode0_linestart		; R0=start of the line
	BVS	endofcharinsertion
	MOV	R3,R0			; save start of line
	BL	mode0_lineoff		; R0=column offset from line start
	BVS	endofcharinsertion
	LDR	R2,[R8,#w_wrapwidth]	; wordwrap width
	CMP	R0,R2
	BLE	endofcharinsertion
	MOV	R0,R3			; offset of line start
	MOV	R1,R2			; column to split at!
	BL	mode0_linecol		; R0=column offset
	BVS	endofcharinsertion
	ADD	R0,R0,#1		; start of imaginary word
	LDR	R14,[R9,#f_len]
	CMP	R0,R14
	SUBCS	R0,R14,#1
	BL	mode0_wordminus_whole	; R0=first letter of word
	BVS	endofcharinsertion
	CMP	R0,R3
	BLE	endofcharinsertion
	SUB	R1,R0,#1		; replace offset
	MOV	R2,#1			; one byte
	ADD	R3,R8,#w_cr		; return character
	MOV	R0,#&23			; replace + delink caret
	BL	execute_command		; do the replacement
endofcharinsertion
	BL	stop_operation		; concatenate ops
	FNRTS


	LOCAL


; --------- e_delete ----------------

; E R5=num bytes R7=del type R8-R10=input caret
; X R0=num bytes deleted
	FNAME	mode0_delete
mode0_delete
	ADR	R3,mode0_delete_doit
	MOV	R0,#1<<31		; it's a deletion
	FNJSR	"R4,R6"
	LDR	R4,[R8,#w_flags]
	LDR	R6,[R8,#w_format]
	ORR	R6,R6,#1<<14		; set line edit
	BL	char_del_dispatch
	FNRTS

	FNAME	mode0_delete_doit
mode0_delete_doit
	FNJSR
	LDR	R14,[R8,#w_format]
	TST	R14,#1<<14		; line edit?
	BEQ	de12			; no
	LDR	R1,[R10,#c_off]
	TEQ	R7,#0
	BNE	de13			; forward delete
	MOV	R0,R1
	BL	mode0_linestart
	FNRTS	VS
	SUB	R0,R1,R0		; number of chars we can delete
	CMP	R5,R0
	MOVCS	R5,R0
	B	de12

de13	MOV	R0,R1
	BL	mode0_lineend
	FNRTS	VS
	SUB	R0,R0,R1
	CMP	R5,R0
	MOVCS	R5,R0

de12	CMP	R5,#0
	FNRTS	LE
	LDR	R0,[R10,#c_loff]
	LDR	R1,[R10,#c_off]
	BL	cln_lineoff
	FNRTS	VS
	LDR	R1,[R8,#w_margin]
	ADD	R0,R0,R1		; add margin
	LDR	R1,[R10,#c_col]
	SUBS	R1,R1,R0		; number of blank chars before
	TEQ	R1,#0
	BEQ	de9
	BL	reflect_caret		; move caret back to line "end" (also tabs)
	FNRTS	VS
	SUB	R5,R5,#1

de9	TST	R7,#1
	BNE	delnext$l
	LDR	R1,[R10,#c_off]
	CMP	R5,R1
	MOVGT	R5,R1			; clip to file start
	CMP	R5,#1
	FNRTS	LT			; none to delete

	MOV	R2,R1			; current offset
lo9$l	BL	minus			; search back this many chars
	SUBS	R5,R5,#1		;
	BNE	lo9$l			;

	SUBS	R2,R2,R1		; number of bytes to delete
	MOVEQ	R0,#2			; delete char
	MOVHI	R0,#&12			; delete block
	BL	execute_command		; delete the chars
	FNRTS

delnext$l
	LDR	R1,[R10,#c_off]
	LDR	R2,[R9,#f_len]
	SUB	R2,R2,R1		; max number to delete
	CMP	R5,R2
	MOVGT	R5,R2			; clip
	CMP	R5,#1
	FNRTS	LT			; none to delete

	MOV	R3,R1			; current offset
n$l	BL	cln_readc_auto		; search forward this many chars
	SUBS	R5,R5,#1		;
	BNE	n$l			;

	SUBS	R2,R1,R3		; number of bytes to delete
	MOV	R1,R3
	MOVEQ	R0,#5			; delete char
	MOVHI	R0,#&15			; delete block
	BL	execute_command		; delete the chars
	FNRTS


	LOCAL


	FNAME	mode0_tab
mode0_tab
	FNJSR
	LDR	R5,[R8,#w_flags]
	PUSH	"R5"
	BIC	R5,R5,#2
	STR	R5,[R8,#w_flags]	; temporarily disable overwrite
	ANDS	R0,R5,#3<<9
	BNE	ta1			; not unix mode
	LDRB	R0,[R8,#w_tabc]
	BL	k_char_fill		; write tab chars
	B	ta2
ta1	BL	insert_tab		; sub for other cases
ta2	PULL	"R5"
	STR	R5,[R8,#w_flags]
	FNRTS


mode0_return
	FNJSR
	LDR	R0,[R8,#w_format]
	TST	R0,#1<<14
	BEQ	re32			; no line edit
	LDR	R0,[R10,#c_off]
	BL	mode0_lineend
	FNRTS	VS
	STR	R0,[R10,#c_off]		; new posn to add return
re32	LDR	R4,[R8,#w_flags]
	BIC	R14,R4,#1<<13		; turn off wordwrap
	STR	R14,[R8,#w_flags]
	AND	R4,R4,#1<<13		; preserve wordwrap state
	BL	insert_returns		; insert the returns
	LDR	R14,[R8,#w_flags]
	BIC	R14,R14,#1<<13
	ORR	R14,R14,R4
	STR	R14,[R8,#w_flags]	; restore wordwrap state
	FNRTS


; Zap_ReturnWord entry point
; \E R0 delimiters type flags, R1 delimiters list, R2 offset R8,R9
; \X R0=file offset, R1=length
returnword
	FNJSR	"R2-R7,R10,R11"		; keep in step with below...
	MOV	R10,R2			; ready for do_returnword
	B	do_returnword


	LOCAL

; \E R8
; \X R0=file offset
;    R1=length
	FNAME	mode0_returnword
mode0_returnword
	FNJSR	"R2-R7,R10,R11"		; keep in step with above...
	MOV	R10,R0
	MOV	R11,#e_interrogate
	MOV	R0,#17
	BL	call_mode
	FNRTS	VS
	CMP	R0,#17
	BLEQ	mode0_returndelimiters

	; R0 b0 gives type (0=>delimiters, 1=>non-delimiters)
	;  b1 set => control characters form a list
	;  b2 gives control characters type as above
	; R1 is list
	; R10 is offset

do_returnword
	LDR	R2,[R9,#f_splito]
	LDR	R3,[R9,#f_splits]
	LDR	R4,[R9,#f_len]
	LDR	R11,[R9,#f_ptr]
	MOV	R5,R10
	CMP	R5,R2
	ADDGT	R11,R11,R3		; test will catch if exactly on
					; R7 scratch : current character under test
	MOV	R6,#2			; situation; 2 => starting
					; 0 => from delimiter, 1 => from non-delimiter

forwardloop$l
	CMP	R5,R2			; are we at the split?
	ADDEQ	R11,R11,R3

	CMP	R5,R4
	ADDGE	R5,R5,#1		; because it recorrects
	BGE	forwardstop$l

	LDRB	R7,[R11,R5]
	ADD	R5,R5,#1

	BL	is_delimiter		; \E R0,R1,R7,R8 \X R7 =0 yes, =1 no, =2 lwsp
	CMP	R6,#2
	BNE	dochar$l		; not first character

	CMP	R7,#2			; lwsp
	BEQ	noword$l

	MOVNE	R6,R7			; situation
	B	forwardloop$l

dochar$l
	CMP	R7,#2			; lwsp, so stop
	BEQ	forwardstop$l
	CMP	R7,R6			; have we changed type?
	BEQ	forwardloop$l		; nope

forwardstop$l				; R5 is the char after the one that failed
	SUB	R5,R5,#1		; correct for that
	PUSH	"R5"			; store the offset of the char after the word

	MOV	R5,R10
	LDR	R11,[R9,#f_ptr]
	CMP	R5,R2
	ADDGE	R11,R11,R3		; split point

backwardloop$l
	CMP	R5,R2
	SUBEQ	R11,R11,R3

	SUBS	R5,R5,#1
	BLT	backwardstop$l

	LDRB	R7,[R11,R5]
	BL	is_delimiter

	CMP	R7,#2
	BEQ	backwardstop$l		; lwsp, so stop
	CMP	R7,R6			; have we changed type?
	BEQ	backwardloop$l		; nope

backwardstop$l				; R5 is the char before the one that failed
	ADD	R5,R5,#1		; correct for that
	PULL	"R4"

	MOV	R0,R5
	SUB	R1,R4,R0		; length
	FNRTS

noword$l
	MOV	R0,R10
	MOV	R1,#0			; no word
	FNRTS


;  \E r7=char to test
;  r1=list of non-/delimiters
;  r0 b0 =  list type (1=>non)
;     b1 => control chars form a list
;     b2 =  control type (1=>non)
	FNAME	is_delimiter
is_delimiter
	FNJSR	"R2,R3"
	LDRB	R2,[R8,#w_cr]
	LDRB	R3,[R8,#w_tabc]
	CMP	R7,R2
	CMPNE	R7,R3
	CMPNE	R7,#32
	MOVEQ	R7,#2			; lwsp
	FNRTS	EQ

	TST	R0,#2			; control chars?
	BEQ	delimjump$l		; nope
	CMP	R7,#32
	BGE	delimjump$l
	MOV	R7,R0,LSR #2
	AND	R7,R7,#1		; type
	FNRTS

delimjump$l
	BL	strchr_range		; \E R1=string, R7=char; \X NE if not present
	AND	R14,R0,#1
	RSBNE	R7,R14,#1
	MOVEQ	R7,R14
	FNRTS


	LOCAL

; \E r1=string, r7=char
; \X ~Z (=NE) if not present
	FNAME	strchr_range
strchr_range
	FNJSR	"r0-r2"
loop$l	LDRB	r0,[r1],#1
	TEQ	r0,#0			; 0 is not considered
	BEQ	end$l			; part of this list!
	TEQ	r0,#'\'
	BLEQ	quote$l			; unquote if necessary
	TEQ	r0,r7
	FNRTS	EQ			; found!
	LDRB	r2,[r1]
	TEQ	r2,#'-'			; is this starting a range?
	BNE	loop$l
	MOV	r2,r0			; store start of range
	LDRB	r0,[r1,#1]		; get end of range
	TEQ	r0,#0			; end of list - note that r1 points
	BEQ	loop$l			; to '-', so this will be tested
					; this works as Zap_Search \[...]
	ADD	r1,r1,#2		; jump over this
	CMP	r0,#'\'
	BLEQ	quote$l			; unquote if necessary
	CMP	r0,r2			; make sure that r0 is low, r2 high
	EORHI	r0,r2,r0		; r0 = B ^ A
	EORHI	r2,r2,r0		; r2 = B ^ (B ^ A) = A
	EORHI	r0,r2,r0		; r0 = (B ^ A) ^ A = B
	CMP	r7,r0
	RSBHSS  r14,r7,r2
	BLO	loop$l
	TEQ	r7,r7			; SEZ
	FNRTS

end$l	TEQ	r0,#1			; CLZ (r0 = 0)
	FNRTS


; \E r0 '\', r1 => char after '\'
; \X r0 unquoted character, r1 updated
	IMPORT  wild_get_char		; from s.Search
quote$l	LDRB	R0,[R1]
	TEQ	R0,#'h'
	TEQEQ	R0,#'w'			; we don't want words!
	MOVEQ	R0,#'\'
	MOVEQ	PC,R14
	FNJSR	"R2,R5"
	SUB	R1,R1,#1
	MOV	R5,#0
	BL	wild_get_char
	CMP	R2,#0			; R2=0 -> R0 literal
	MOVLT	R0,#'\'			; R2<0 -> set R0 to '\'
	ANDGT	R0,R0,#255		; R2>0 -> R0 masked (just in case)
	FNRTS


	LOCAL

; \E R0, R8/R9
; \X R0=number of possibilities (R0=0 => R1 undefined)
;    R1=heap block containing (R0) pointers to heap blocks
	FNAME	mode0_help
mode0_help
	FNJSR	"R2-R7,R11"
	MOV	R11,#e_returnword
	BL	call_mode
	FNRTS	VS
	CMP	R1,#0
	MOVEQ	R0,#0
	FNRTS	EQ

	MOV	R3,R0

	ADD	R0,R1,#1		; space for NUL
	BL	heap_claim
	FNRTS	VS
	MOV	R2,R0
	; copy the stuff from R3 into the heap block R2. Length is R1
	; R3 is scratch, because we clear it into R4
	; R0 is destination, R2 saved destination base
	LDR	R4,[R9,#f_ptr]
	LDR	R5,[R9,#f_splito]

	ADD	r5,r4,r5
	LDR	r6,[r9,#f_splits]
	ADD	r7,r3,r1
	LDR	r1,[r9,#f_len]

	CMP	R7,R1
	MOVGE	R7,R1			; validate against file length
	ADD	R7,R4,R7		; limit
	ADD	R4,R4,R3		; initial address
loop$l	CMP	r4,r5
	ADDGE	r4,r4,r6		; skip split
	ADDGE	r7,r7,r6		; in limit also
	ADDGE	r5,r7,#1		; additional line

	CMP	R4,R7

	LDRLTB  R3,[R4],#1
	STRLTB  R3,[R0],#1
	BLT	loop$l

	MOV	R3,#0
	STRB	R3,[R0]			; terminate

	MOV	R0,#4
	BL	heap_claim
	BVS	fail$l
	MOV	R1,R0
	STR	R2,[R1]			; heap block containing word
	MOV	R0,#1			; one possibility
	FNRTS

fail$l	MOV	R7,R0
	MOV	R0,R2
	BL	heap_free
	MOV	R0,R7
	FNRTV


	FNAME	mode0_interrogate
mode0_interrogate
	CMP	R0,#10
	BEQ	seeif_ins_pt_if_needed
	CMP	R0,#17
	BEQ	mode0_returndelimiters
	TEQ	R0,#einterrogate_TabStops
	TEQNE	R0,#einterrogate_WideRedraw
	TEQNE	R0,#einterrogate_UTF8
	BEQ	claim_if_text$l
	CMP	R0,#0
	CMPNE	R0,#3
	MOVNE	PC,R14
	MOV	R0,R1
	MOV	PC,R14

claim_if_text$l
	FNJSR	"R1"			; default is fixed tabs, but modes inherit
	MOV	R1,R0
	MOV	R0,#0			; from Text, which /does/ support variable
	BL	isthisaclonebase	; tabs, so only claim if Text mode
	MOVEQ	R0,#0
	MOVNE	R0,R1
	FNRTS

mode0_returndelimiters
	MOV	R0,#1			; listing non-delimiters
	ADR	R1,mode0_delimiters
	MOV	PC,R14

; delimiters
mode0_delimiters
	=	"A-Za-z0-9_",0
	ALIGN

seeif_ins_pt_if_needed
	FNJSR
	BL	adjust_ins_pt_if_needed
	MOVEQ	R0,#0
	FNRTS


; There are 5 categories of character, classified in descending order as:
;
;   5: Newline character
;   4: Letters and numbers
;   3: Anything else non-whitespace (ie. symbols)
;   2: Whitespace (space and tab)
;   1: Newline character
;
; When you press shift-left or shift-right, the cursor will be moved in that
; direction until the classification of the next character (in the direction it
; is moving) is greater than that of the current character, upon which it will
; stop. Newline appears twice in order to ensure that the cursor will always
; stop on each side of it. (ie. at start & end of line).
;
; Line:  if((char2=getchar())!=0 && char2!=line_terminator)
; Fwd :^ ^   ^	   ^	       ^ ^  ^	   ^	^	   ^
; Back:^   ^	  ^	  ^	^  ^	 ^     ^	  ^^

;E R0=phy line start R1=cur off R2=cur col R8-R10
;X R1,R2=new posn / R2<0 for specials #
splus_smart
	FNJSR	"R3"
	LDR	R3,[R9,#f_len]
	BL	pgetchar$l
	MOVCC	R1,R2
	BCC	firstchar$l
	MOV	R2,#-1
	FNRTS				; got lf already

ploop1$l				; search for non-alphabetic
	BL	pgetchar$l		;
firstchar$l				;
	BCS	pfound$l		;
	BNE	ploop1$l		;

ploop2$l
	TEQ	R0,#' '			; check for whitespace
	LDRNEB  R14,[R8,#w_tabchar]	;
	TEQNE	R0,R14			;
	BEQ	ploop3$l		;
	BL	pgetchar$l		; or non-alphabetic
	BCS	pfound$l		;
	BEQ	ploop2$l		;
pfound$l
	MOV	R1,R2
	MOV	R2,#-1
	FNRTS

ploop3$l
	BL	pgetchar$l		; check for whitespace
	TEQ	R0,#' '			;
	LDRNEB  R14,[R8,#w_tabchar]	;
	TEQNE	R0,R14			;
	BEQ	ploop3$l		;
	B	pfound$l		;

pgetchar$l
	CMP	R1,R3
	BHS	pfound$l		; eof
	FNJSR
	MOV	R2,R1			; keep current offset
	BL	cln_readc_auto
	FNPULL
	B	CursorPriority


	LOCAL

;E R0=phy line start R1=cur off R2=cur col R8-R10
;X R1 = new offset, R2 = -1
sminus_smart
	FNJSR
	CMP	R2,#1			; column 1
	BHI	mloop1$l
	BL	minus			; so move to the end of the previous line
	MOV	R2,#-1
	FNRTS

mloop1$l
	BL	mgetchar$l
	BCS	mfound$l
	BNE	mloop1$l
mloop2$l
	TEQ	R0,#' '
	LDRNEB  R14,[R8,#w_tabchar]
	TEQNE	R0,R14
	BEQ	mloop3$l
	BL	mgetchar$l
	BCS	mfound$l
	BEQ	mloop2$l
mfound$l
	MOV	R1,R2
	MOV	R2,#-1
	FNRTS

mloop3$l
	BL	mgetchar$l
	TEQ	R0,#' '
	LDRNEB  R14,[R8,#w_tabchar]
	TEQNE	R0,R14
	BEQ	mloop3$l
	B	mfound$l

mgetchar$l
	FNJSR
	MOV	R2,R1
	BL	minus
	FNPULL
	; FALL THROUGH

; E R0 = char
; E C set if start/end of line found, else Z set if r0 is non-alphabetic
; consider using Territory_CharacterPropertyTable ?
CursorPriority
	PUSH	"R1"
	LDRB	R1,[R8,#w_cr]		; lf char
	TEQ	R0,R1
	PULL	"R1"
	RTCS	EQ
	CMP	R0,#&30			; 0-9
	RTZS	CC
	CMP	R0,#&3A
	MOVCC	PC,R14
	CMP	R0,#&40			; @ A-Z
	RTZS	CC
	CMP	R0,#&5B
	MOVCC	PC,R14
	CMP	R0,#&61			; a-z
	RTZS	CC
	CMP	R0,#&7B
	MOVCC	PC,R14
	CMP	R0,#&81			;  
	RTZS	CC
	CMP	R0,#&83
	MOVCC	PC,R14
	CMP	R0,#&85			;  
	RTZS	CC
	CMP	R0,#&87
	MOVCC	PC,R14
	CMP	R0,#&9E			;  
	RTZS	CC
	CMP	R0,#&A0
	MOVCC	PC,R14
	CMP	R0,#&C0			; mostly alphabetic, but also /multiply and /divide
	RTZS	CC
	RTCC

CursorPriority2
	CMP	R0,#&20
	MOVLE	PC,R14
	CMP	R0,#'$'
	CMPNE	R0,#'%'
	MOVEQ	R0,#&41
	MOVEQ	PC,R14
	CMP	R0,#&30
	MOVCC	PC,R14
	CMP	R0,#&3A			; numbers
	MOVCC	R0,#&41			; A
	MOVCC	PC,R14
	CMP	R0,#&40
	MOVCC	R0,#&3F
	MOVCC	PC,R14
	CMP	R0,#&5F
	CMPNE	R0,#&5A
	MOVLE	R0,#&41			; A
	MOVLE	PC,R14
	CMP	R0,#&61
	MOVCC	R0,#&60
	MOVCC	PC,R14
	CMP	R0,#&7B
	MOVCC	R0,#&41			; A
	MOVCC	PC,R14
	CMP	R0,#&80
	MOVCC	R0,#&7F
	MOVCC	PC,R14
	CMP	R0,#&C0
	MOVCC	PC,R14
	MOV	R0,#&41			; A
	MOV	PC,R14


	LOCAL


;E R0=character R1=number of times to type R8-R10=input caret
;X charcter inserted at input caret R1 times #
k_char_fill
	FNJSR	"R1-R7,R11"
	MOV	R2,R0			; save the character
	FNLDR	R0,wimp_kbdbuf
	MOV	R4,R0
	MOV	R3,#0			; as a flag to say R3 points nowhere...
	BL	start_operation		; concatonate
	BL	insertsomespaces
	MOV	R3,R1
re10	STRB	R2,[R4],#1
	SUBS	R3,R3,#1
	BHI	re10			; fill up keyboard buffer
	LDR	R4,[R8,#w_flags]
	MOV	R5,R1
	LDR	R6,[R8,#w_format]
	FNLDR	R7,wimp_kbdbuf
	MOV	R11,#e_char
	BL	call_mode
	BL	stop_operation		; concatonate
	FNRTS

getnextoneback
	FNJSR
	SUBS	R0,R7,#1
	BLPL	cln_readc
	FNRTS

ask_mode_about_this_word
	FNJSR	"R1,R8-R11"
	MOV	R1,R7
	MOV	R0,#20
	MOV	R11,#e_interrogate
	BL	call_mode
	MOV	R7,R1
	FNRTS



; ***********************
; * Join and Split subs *
; ***********************

	FNAME	mode0_joinline
mode0_joinline
	FNJSR
	LDR	R6,[R10,#c_off]
	LDR	R7,[R9,#f_len]
	LDRB	R5,[R8,#w_cr]
in14	CMP	R6,R7
	FNRTS	GE			; off end of text
	MOV	R0,R6
	BL	cln_readc
	TEQ	R0,R5
	ADDNE	R6,R6,#1
	BNE	in14
	MOV	R0,#2
	MOV	R1,R6
	MOV	R2,#1
	BL	execute_command		; delete the return char
	FNRTS


	FNAME	mode0_splitline
mode0_splitline
	FNJSR
	MOV	R1,#1
	LDR	R4,[R8,#w_flags]
	BIC	R14,R4,#1<<13		; turn off wordwrap
	STR	R14,[R8,#w_flags]
	AND	R4,R4,#1<<13		; preserve wordwrap state
	BL	insert_returns		; insert the returns
	LDR	R14,[R8,#w_flags]
	BIC	R14,R14,#1<<13
	ORR	R14,R14,R4
	STR	R14,[R8,#w_flags]	; restore wordwrap state
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Multiple clicks on a text file			   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	FNAME	mode0_click
mode0_click
	TEQ	R1,#0
	FNSTR	R1,wimp_dragdepth,EQ
	CMP	R1,#2
	BCC	default_click		; drag/place cursor

	FNJSR	"R1-R11"
cl17	CMP	R1,#6
	SUBCS	R1,R1,#4
	BCS	cl17			; range for multiple clicks is 2 (word),
	TST	R4,#1<<3		;   3 (line), 4 (paragraph), 5 (text)
	BNE	cl20			; multidrag?
	SUB	R11,R1,#2		; R11 = number of clicks - 2
	BL	find_offset		; R0=file offset
	FNRTS	VS
	MOV	R10,R0			; save file offset
	CMP	R11,#1
	BLO	cl_select_word
	BEQ	cl_select_line
	CMP	R11,#3
	BLO	cl_select_para
	BEQ	cl_select_all
	FNRTS
cl20	FNSTR	R1,wimp_dragdepth
	MOV	R1,#0			; normal drag
	MOV	R4,#1			; pretend adjust pressed
	BL	default_click		; start drag as normal
	FNRTS

clearselandreturn
	BL	clear_selection
	FNRTS

cl_select_word
	BL	test_shiftctrl
	TST	R1,#1
	BNE	cl_select_big_word
	MOV	R0,R10
	BL	mode0_wordplus
	MOVVC	R3,R0			; end of word
	MOVVC	R0,R10
	BLVC	mode0_wordminus
	FNRTS	VS
	MOV	R2,R0			; start of word
	BL	select_region
	FNRTS

cl_select_big_word
	MOV	R0,R10
	BL	mode0_wordplus_whole
	MOVVC	R3,R0			; end of word
	MOVVC	R0,R10
	BLVC	mode0_wordminus_whole
	FNRTS	VS
	MOV	R2,R0			; start of word
	BL	select_region
	FNRTS

cl_select_line
	MOV	R0,R10
	BL	mode0_linenext
	MOVVC	R3,R0			; end of word
	MOVVC	R0,R10
	BLVC	mode0_linestart
	FNRTS	VS
	MOV	R2,R0			; start of word
	BL	select_region
	FNRTS

cl_select_para
	MOV	R0,R10
	BL	mode0_paraend
	MOVVC	R3,R0			; end of para
	MOVVC	R0,R10
	BLVC	mode0_parastart
	FNRTS	VS
	MOV	R2,R0			; start of para
	BL	select_region
	FNRTS

cl_select_all
	MOV	R2,#0
	LDR	R3,[R9,#f_len]
	BL	select_region		; select all text (if any)
	FNRTS



; **************
; * SAVEANDRUN *
; **************

	FNAME	mode0_saveandrun
mode0_saveandrun
	FNJSR	"R1,R2,R7"
	BL	save_text
	MOV	R0,#25
	MOV	R11,#e_interrogate
	BL	call_mode
	CMP	R0,#25
	BEQ	nosaveandrunthanks$l
	FNLDR	R7,wimp_buffer
	MOV	R1,R7
	LDR	R0,prestoregap$l
	STR	R0,[R1],#4
	LDR	R2,[R9,#f_name]
	BL	strcopy
	MOV	R0,R7
	SWI	XWimp_StartTask
	FNRTS
nosaveandrunthanks$l
	ADR	R0,warn$l
	MOV	R1,#5<<29
	BL	warn_user
	FNRTS


	FNAME	mode0_compile
mode0_compile
	FNJSR	"R1,R2,R7"
	BL	save_text
	MOV	R0,#25
	MOV	R11,#e_interrogate
	BL	call_mode
	CMP	R0,#25
	BEQ	nosaveandrunthanks$l

	FNLDR	R7,wimp_buffer
	MOV	R1,R7
	ADR	R2,twstartstr
	BL	strcpy
	LDR	R0,[R9,#f_name]
	BL	find_leaf_name
	MOV	R2,R0
	BL	strcpy
	ADR	R2,twstartstr2
	BL	strcpy
	LDR	R2,[R9,#f_name]
	BL	strcpy			; complete command
	MOV	R14,#'"'
	STRB	R14,[R1],#1
	MOV	R14,#0
	STRB	R14,[R1],#1
	MOV	R0,R7
	SWI	XWimp_StartTask
	FNRTS

prestoregap$l	=	"Run "
twstartstr	=	"TaskWindow -quit -ctrl -name ",34,0
twstartstr2	=	34,32,34,"Run ",0
warn$l		FNS	("zap_NoRunFile")



; *****************************************
; * More misc word start/end like subs... *
; *****************************************

;E R0=offset R8/R9
;X paragraph end |
	FNAME	mode0_paraend
mode0_paraend
	FNJSR	"R1"
pa1	BL	mode0_linenext		; move to start of next line
	MOV	R1,R0			; save offset
	BL	mode0_wordplus		; start of next word
	CMP	R0,R1
	MOV	R0,R1			; restore line start
	BGT	pa1			; don't match
	FNRTS





 END
