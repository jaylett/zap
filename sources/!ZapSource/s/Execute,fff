; Contains processing command code and Zap command table.
; $Id: Execute,fff,v 1.1.2.7 2000/02/15 19:49:51 ds Exp $

	GET	h.ZapHeader
	GET	h.Messages
	GET	h.Template
	GET	h.CreateWind
	GET	h.KeyBits
	GET	h.MiniBuff
	GET	h.Heap
	GET	h.ModeBits
	GET	h.Cursors
	GET	h.AlterTxt
	GET	h.Search
	GET	h.CreateFile
	GET	h.Undo
	GET	h.Redraw
	GET	h.Strings
	GET	h.Menus
	GET	h.StartUp
	GET	h.StartCode
	GET	h.ModuleBits
	GET	h.Fonts
	GET	h.Mode1+2
	GET	h.Mode4
	GET	h.Mode11
	GET	h.Update
	GET	h.TMTVars
	GET	h.Boxes
	GET	h.Commands

	IMPORT	open_UndoBox
	IMPORT	message_send
	IMPORT	update_all_save_boxes

	EXPORT	evaluate_string
	EXPORT	function_string
	EXPORT	find_key_command
	EXPORT	look_key_command
	EXPORT	find_command_fromkey
	EXPORT	read_command
	EXPORT	read_one_command
	EXPORT	read_validate_command
	EXPORT	process_command
	EXPORT	process_function
	EXPORT	process_key_command
	EXPORT	command_string
	EXPORT	validate_command
	EXPORT	get_command_flags
	EXPORT	universal_arg
	EXPORT	check_arg_valid
	EXPORT	command_data
	EXPORT	make_varname
	EXPORT	validate_varname
	EXPORT	validate_varname_wild

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; KEY COMMAND TABLE SUBS					  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E,X as for read_command (plus validate_command)
; Returns R1=0 on read error (for block freeing purposes)
read_validate_command
	STMFD	R13!,{R14}
	BL	read_command
	MOVVS	R1,#0
	BLVC	validate_command
	LDMFD	R13!,{PC}

	LOCAL

;E R0=command name terminated by <=32 or colon/&/quote
;X R0=command address/0 if not found WB #
;  Module with command in is loaded if need be.

find_key_command
	FNJSR	"R7"
	BL	look_key_command
	TST	R0,#1
	FNRTS	EQ			; found or not found at all!
	MOV	R7,R0
; SWI &107				; called if SPELL...
	BL	validate_command	; try to load the command
	MOVVC	R0,R7
; MOVCS R0,R7
	FNRTS

	LOCAL

;E R7=command address / 0 / bit 0 set form
;X CC R7 not altered (wasn't bit 0 set form)
;  CS R7 altered - module containg command loaded (/0) WB #
;NB It tests to see if the command exists even if it was the b0 set form
;   since the module may have already been loaded - don't want the module
;   being loaded twice!

validate_command
	TST	R7,#1
	BICEQS	PC,R14,#1<<29		; not the bit 0 set form + CC
	FNJSR
; ANDS R0,R7,#3
; CMP R0,#1
; FNRTS EQ				; not the bit 0 set form + CC
	BIC	R7,R7,#3		; get the address
	MOV	R0,R7
	BL	look_key_command	; try looking for this command again
	TST	R0,#1
	BEQ	end$l			; the module is now loaded
	MOV	R0,R7
	BL	str_len			; length of the command name
	ADD	R0,R7,R0
	ADD	R0,R0,#4
	BIC	R0,R0,#3
	LDR	R0,[R0]			; module name containing command
	BL	load_mode_module
	FNRTS	VS
	MOV	R0,R7
	BL	look_key_command	; try looking for this command again
	TST	R0,#1
	MOVNE	R0,#0			; still not found - give up.
end$l					; R0=command address to return
	SUBS	R7,R0,#0		; set new command address (set carry)
	FNRTS

	LOCAL

;E R7=command address / 0 / bit 0 set form
;X R0=command flags word (from External info if command not loaded)
;  R7 updated if b0 set and command is loaded

get_command_flags
	FNJSR
	TST	R7,#1
	BIC	R0,R7,#3
got$l	LDREQ	R0,[R0,#-4]
	FNRTS	EQ
	BL	look_key_command	; try looking for this command again
	TEQ	R0,#0
	FNRTS	EQ			; not found at all
	TST	R0,#1
	ANDEQ	R7,R7,#2
	ORREQ	R7,R0,R7
	BEQ	got$l			; is already loaded
	FNLDR	R14,ext_comm_flags	; isn't - use External info
	LDR	R0,flags_word
	LDR	R0,[R14,R0]
	FNRTS

	LOCAL

;E R0=command name terminated by <=32 colon/#/$/&/quote
;     top bit set if terminated by non-alphanumeric (exc. '_') (fn call)
;X R0=command address if found and loaded
;    =pointer to command name in external table with bottom bit set
;    =0 if not found anywhere WB |

look_key_command
	FNJSR	"R1-R7"
	FNLDR	R5,wimp_block		; buffer to store command name
	MOV	R3,R5
	AND	R7,R0,#1<<31
	BIC	R0,R0,#1<<31
upper$l					; transform command to upper case
	LDRB	R1,[R0],#1
	CMP	R1,#&20
	BLE	end$l			; found end
	TEQ	R1,#'"'
	TEQNE	R1,#'#'
	TEQNE	R1,#'$'
	TEQNE	R1,#'&'
	TEQNE	R1,#':'
	TEQNE	R1,#'''
	TEQNE	R1,#'('
	BEQ	end$l			; found end
	CMP	R1,#'a'
	RSBHSS	R14,R1,#'z'
	SUBHS	R1,R1,#32		; force upper case
	TEQ	R7,#0
	TEQNE	R1,#'_'
	STREQB	R1,[R3],#1
	BEQ	upper$l
	CMP	R1,#'0'
	RSBHSS	R14,R1,#'Z'
	BLO	end$l			; found end
	CMP	R1,#'9'
	RSBHIS	R14,R1,#'A'
	STRLSB	R1,[R3],#1
	BLS	upper$l			; not found end
end$l					; reached end of command name
	MOV	R0,#0
	STRB	R0,[R3],#1
	STRB	R0,[R3],#1
	STRB	R0,[R3],#1
	STRB	R0,[R3],#1		; store zeros till at least wd end
	FNADD	R6,R12,command_store	; start of table list
	FNLDR	R7,com_number		; number of table to look at
table$l					; command tables loop
	CMP	R7,#0
	BLE	notloaded$l		; run out of tables!
	LDR	R4,[R6],#4
	SUB	R7,R7,#1		; R4=next table
	LDR	R1,[R4]			; offset from module start
	SUB	R1,R4,R1		; start of module (for offsets)
	ADD	R4,R4,#8		; skip offset & flags at start
	BL	search_command_table	; R0=match R4=table address
	BCS	table$l			; not found
	ADD	R0,R0,R1		; address of command
	FNRTS
notloaded$l
	FNLDR	R4,ext_comms		; list of externally stored commands
	BL	search_command_table	; look (R4=table address of math)
	MOVCS	R0,#0			; not found
	ORRCC	R0,R4,#1		; found
	FNRTS

	LOCAL

;E R4=pointer of 0 terminated list of <string><zero padding><word>
;  R5=string (command) to look for with 4 zeros on the end.
;X R0=word if found CS if not |
;  R4=start of the matching string in the table (if found)
;  flags_word=offset into flags words table (for not-yet-loaded commands)

search_command_table
 FNJSR "R1-R3,R11"		; don't push R4
 MOV R11,#4			; offset into flags words table
next$l				; look at next entry in table
 LDRB R0,[R4]
 CMP R0,#0			; reached end of table ?
 FNRTS EQ			; return with carry set (not found)
 MOV R3,R5			; get command
 MOV R1,R4			; current point in table
command$l			; check this one command
 LDR R0,[R1],#4			; get next word from table
 LDR R2,[R3],#4			; get next word from command
 TEQ R0,R2
 BNE fail$l			; fail
 TST R0,#&FF000000
 BNE command$l			; more to come
 LDR R0,[R1]			; word there
 STR R11,flags_word
 ADDS R0,R0,#0			; carry clear
 FNRTS
fail$l				; this command didn't match
 TST R0,#&FF000000
 LDRNE R0,[R1],#4
 BNE fail$l			; skip to end of command in table
 ADD R11,R11,#4
 ADD R4,R1,#4			; skip past command offset
 B next$l			; try next one in list

flags_word & 0

 LOCAL

;E R0=command address
;X R0=address of command name (upper case)/0 if not found #

find_command_fromkey
 FNJSR "R1-R7"
 MOV R5,R0			; save the command we're looking for
 FNADD R6,R12,command_store	; start of list of command tables
 FNLDR R7,com_number		; number of tables to look at
table$l
 CMP R7,#0
 MOVLE R0,#0
 FNRTS LE
 LDR R4,[R6],#4
 SUB R7,R7,#1			; next table
 LDR R1,[R4]			; offset from module start
 SUB R1,R4,R1			; start of module
 ADD R4,R4,#8			; skip flags
 SUB R1,R5,R1			; offset of the command in this module
next$l
 LDRB R0,[R4]
 TEQ R0,#0
 BEQ table$l			; go to next table
 MOV R3,R4			; save address of command start
com$l
 LDR R0,[R4],#4
 TST R0,#&FF000000
 BNE com$l			; set R4 to command offset posn
 LDR R0,[R4],#4			; command offset
 TEQ R0,R1
 BNE next$l
 MOV R0,R3			; start of command
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read command string					  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R10=pointer to string terminated by <&20
;X R0=-1 => args invalid (only tested if command loaded)
;     0  => all ok
;     1  => args valid for keymaps only (uses n form)
;  R7=command address (or with b0 set if external) (error if not found)
;  R1=parameter
;  R6=parameter type 0=none 1=num 2=usekeynum 3=stringblock 4=data
;     5,6=int/str expr
;  R10 updated to next non-white space which is not a ':'
;  (String of commands concatenated to a single Multicommand)
;  (:<return> skipped so can have multiple lines)
;  (See buffer_stroke for Mulicommand data format) #

read_command
 FNJSR "R2-R5"
 BL read_one_command
 BLVC check_arg_valid
 FNRTS VS
 TST R10,#1<<31
 FNRTS NE			; if r10b31 set, only ever read one command
 LDRB R14,[R10]
 TEQ R14,#';'
 BLEQ comment$l
 TEQ R14,#':'
 FNRTS NE			; only one command
 TEQ R0,#0
 TEQNE R0,#2
 BLNE err41			; not allowed keynums and minibuf strings
 MOVVC R0,#16			;   for multiple commands
 BLVC heap_claim
 FNRTS VS
 MOV R4,R0			; start heap block of multicommand
 MOV R5,#0			; valid length
add$l				; add the next command to the buffer
 TEQ R6,#1			; was data type number
 FNLDR R0,wimp_kbdbuf,EQ
 STREQ R1,[R0]			; save arg + assume it is a word to
 MOVEQ R6,#2			; buffer (it doesn't matter)
 MOVNE R0,R1			; arg
 MOV R1,#1			; only do once
 BL buffer_stroke		; enter this stroke
 FNRTS VS
 CMP R6,#3			; OK, we're not going to see arg type 4...
 BLHS heap_free			; free heap block (avoid memory leak)
 ADDS R14,R14,#0		; CLV because the heap not alloc'd if 1<<27
 LDRB R14,[R10]
 TEQ R14,#';'
 BLEQ comment$l
 TEQ R14,#':'
 BNE end$l			; finished
skipcolon$l
 LDRB R14,[R10,#1]!
 TEQ R14,#' '
 TEQNE R14,#':'
 BEQ skipcolon$l
 ;FNRTS VS; RETURNS HERE!
 BLVC read_one_command		; get next command
 BLVC check_arg_valid
 FNRTS VS; RETURNS HERE!
;	TEQ R0,#1
;	BEQ checkmini$l
 TEQ R0,#0
 TEQNE R0,#2			; never error...
 BLNE err41
 BVC add$l			; buffer next command
 FNRTS
;checkmini$l
;	BL get_command_flags
;	AND R0,R0,#1<<6:OR:1<<10
;	TEQ R0,#1<<6:OR:1<<10
;null$l	MOVEQ R0,#0
;	ADREQ R1,null$l
;	BEQ add$l
;	BL err41
;	FNRTS
end$l
 ADRL R7,Multicommand		; command address
 MOV R1,R4			; block pointer
 MOV R6,#4			; data arg type
 MOV R0,#0			; arg is ok
 FNRTS
comment$l
	FNJSR
c$l	LDRB	R14,[R10,#1]!	; find ':' or end-of-string
	CMP	R14,#':'
	CMPNE	R14,#31
	BHI	c$l
	FNRTS

 LOCAL

;E R0=command addr (or 0 or 2 or b0/b1 form)
;     (b1 set if intending to call as function)
;  R1=parameter
;  R6=parameter type (0-3,5,6)
;  R10=pointer in text (command if not found)
;X VS if command not known (R0=0 on entry)
;  (R0 preserved unless error)
;  R0=0 if parameters match command/command not loaded...
;  R0=1 if parameter is string and R1=0 (for minibuffer) or Keynum
;  R0=? *not* 2 if parameter is string and it's OK to ignore in multicommands
;  R0=-1 if parameter not valid
;  R7=command address #

check_arg_valid
 FNJSR
 MOV R7,R0
 BICS R14,R0,#2
 BLEQ err$l			; command not known
; TST R7,#1
; BNE ok$l			; command isn't loaded so don't check!
; LDR R0,[R7,#-4]		; get command flags
 BLVC get_command_flags
; ADRVS R0,f$l
 FNRTS VS
 MOV R14,R0
 TST R7,#2
 MOVEQ R0,R0,LSR #3		; ...if calling as command
 MOVNE R0,R0,LSR #24		; ...if calling as function
 ANDS R0,R0,#7			; argument type
 BEQ noarg$l
 CMP R0,#3
 BEQ string$l			; string
 BGT nogood$l			; can't use data block
 TEQ R6,#1
 TEQNE R6,#8
 BEQ ok$l			; valid number
 TEQ R6,#2
 MOVNE R0,#-1			; not a number
 MOVEQ R0,#1
 FNRTS
noarg$l
 TEQ R6,#0
 BNE nogood$l
ok$l
 MOV R0,#0
 FNRTS
nogood$l
 MOV R0,#-1
 FNRTS
string$l
 TST R14,#1<<27			; new code here...
 BNE ok$l			; no checking...
 TEQ R6,#3
 TEQNE R6,#9
 BEQ ok$l			; valid string or expression
 TEQ R6,#0
 MOVNE R0,#-1
 MOVEQ R0,#1			; ...minibuffer?
; ADRVS R0,f$l
 FNRTS
;stringnotgood$l
;; SWI &107
; ;LDR R0,[R7,#-4]		; get command flags
; ;TST R0,#1<<27		; OK to ignore in multi-commands?
; ;MOVNE R0,#2
; MOV R0,#-1
; FNRTS
err$l
 FNJSR "R1,R4"
 TST R0,#2
 ADREQ R0,s$l
 ADRNE R0,f$l
 BL lookup_token_R0
 MOV R1,R10
 BL generate_error
 FNRTS
s$l = "zap_e_unkcmd",0
f$l FNS ("zap_e_unkfn")

 LOCAL

;E R10=pointer to string terminated by =<&20 or :&"
;      (top bit set if terminated by non-alphanumeric exc. '_') (fn call)
;X R0=command address (or 0 or 2 or bit set form - see look_key_command)
;      (b1 set to R10 b31)
;  R1=parameter/0 if none
;  R6=parameter type 0=none 1=number 2=usekeynum 3=string
;  R10 updated (eg to colon) (preserved if no command found) WB #
;      (top bit preserved regardless)
;  (command string is just read - no type checking is done)

read_one_command
 FNJSR "R2-R3,R11"
 AND R11,R10,#1<<31
 BIC R10,R10,#1<<31
 BL str_skip			; skip spaces
 STRVC R10,cmdaddr$l
 MOVVC R6,#0			; no argument to start with
 MOVVC R1,#0			; no argument
 ORRVC R0,R10,R11		; start of command name
 BLVC look_key_command		; get entry in R0
; ADRVS R0,aproblema$l;DEBUG...
 FNRTS VS
 MOVS R2,R0			; save key command address
 MOVEQ R0,R11,LSR #30
 FNRTS EQ			; not found
 TEQ R11,#0			; was top bit of R10 set?
 BLNE str_fnseparator
 BLEQ str_separator		; move to next arg
 TST R2,#1			; get flags word
 FNLDR R14,ext_comm_flags,NE	; from table
 LDRNE R3,flags_word
 LDREQ R3,[R2,#-4]		; or from module
 LDRNE R3,[R14,R3]
 TEQ R11,#0
 MOVNE R3,R3,LSR #21		; if fn, shuffle parameter type bits along
 BL read_arg$l
 ORRVC R0,R2,R11,LSR #30	; command address
 ORRVC R10,R10,R11
; ADRVS R0,aproblema$l;DEBUG...
 FNRTS
cmdaddr$l & 0

aproblema$l
 & 0
 FNS ("aproblema$l...")

read_arg$l
 FNJSR "R2"
 LDRB R0,[R10]
 TEQ R0,#'>'			; menu stuff
 FNRTS EQ
 ANDS R14,R3,#7<<3
 BEQ null_arg$l
 CMP R14,#3<<3			; (never 0)
 BLO read_num_arg$l
 FNRTS HI			; return if can't handle
 TEQ R0,#'"'
 BEQ str$l			; string argument
 TEQ R0,#'('
 BEQ expr$l			; string argument
 TEQ R0,#'$'
 BEQ eval$l			; string expression argument
nullstr$l ; take advantage of zero byte in following instruction
 TEQ R0,#0
 TEQNE R0,#10
 TEQNE R0,#':'
 TEQNE R0,#';'
 BNE bad_arg$l
 TST R3,#1<<27			; no argument strictly necessary...?
 ADRNE R1,anullstr$l		; um, /where/ exactly !?!?
 MOVNE R6,#3			; string
 FNRTSS				; clv...???
anullstr$l
 DCD 0

read_num_arg$l
 MOV R6,#1
 TEQ R0,#'('
 BEQ numbracketed$l
 TEQ R0,#'"'
 BEQ numquoted$l
 TEQ R0,#'&'
 TEQNE R0,#'-'
 BEQ num$l			; number argument
 TEQ R0,#'#'
 BEQ eval$l			; numeric expression argument
 TEQ R0,#'''
 BEQ asc$l			; single ascii byte
 CMP R0,#'0'
 BCC no_arg$l			; no arg supplied
 CMP R0,#'9'
 BLE num$l			; number argument
 TEQ R0,#'n'
 BNE no_arg$l			; no arg supplied
 MOV R6,#2			; current key is the argument
endskip$l			; R2=command address
 BL str_separator		; get to the next arg
 FNRTS
null_arg$l			; no argument expected
 MOV R6,#0
 TEQ R11,#0			; function? assume OK
 FNRTS NE
no_arg$l			; end/LF/':'/';' -> no arg supplied (is OK)
 TEQ R0,#0
 TEQNE R0,#10
 TEQNE R0,#':'
 TEQNE R0,#';'
 MOVEQ R1,#0
 FNRTS EQ
bad_arg$l			; non-arg-star character found
 TEQ R11,#0
 ADR R14,bad_arg2$l
 BNE badparam_fn
 BEQ err41
bad_arg2$l
 ADD R0,R0,#4
 LDR R1,cmdaddr$l
 BL generate_error
 FNRTS
num$l
 BL str_readnum			; does a str_separator as well
 MOVVC R1,R0			; value
 MOVVC R6,#1
 FNRTS
str$l				; string constant
 BL str_strlen			; find length of quoted argument
 CMP R0,#0
 FNRTS LT			; no argument
 ADD R0,R0,#1			; room for terminator
 BL heap_claim
 FNRTS VS
 MOV R1,R0			; buffer address
 MOV R3,R1			; save buffer address
 BL str_strcopy			; copy string argument into buffer
 MOV R6,#3			; string
 MOV R1,R3			; parameter address
 B endskip$l			; R2=command address
expr$l
 BL expr_strlen			; find length of quoted argument
 CMP R0,#0
 FNRTS LT			; no argument
; BLT end$l			; no argument
 ADD R0,R0,#1			; room for terminator
 BL heap_claim
 FNRTS VS
 MOV R1,R0			; buffer address
 MOV R3,R1			; save buffer address
 BL expr_strcopy		; copy string argument into buffer
 MOV R6,#3			; string
 MOV R1,R3			; parameter address
 B endskip$l			; R2=command address

eval$l	MOV	R6,R0
	LDRB	R0,[R10,#1]!
	TEQ	R0,#32
	BLEQ	str_separator
	LDRB	R0,[R10]
	TEQ	R0,#'='
	BEQ	eval_expr$l
	TEQ	R0,#'('
	TEQNE	R0,#'"'		; not a string? must be a function
	BNE	func$l
	STMFD	R13!,{R6}
	MOV	R3,#3<<3
	BL	read_arg$l	; recursion!
	LDMFD	R13!,{R2}
	FNRTS	VS
	TEQ	R6,#3
	FNRTS	NE		; return if not a string
	TEQ	R2,#'#'
	MOVEQ	R6,#8
	MOVNE	R6,#9
	FNRTS
func$l	BL	function_string
	FNRTS	VS
	TEQ	R6,#'#'
	MOV	R6,R1
	MOV	R1,R0
	BEQ	fnum$l
	TEQ	R6,#3
	FNRTS	EQ
	MOV	R0,#12		; convert to string
	BL	heap_claim
	MOV	R2,R0
	MOV	R0,R1
	MOV	R1,R2
	MOV	R2,#12
	SWI	XOS_ConvertCardinal4
	MOV	R1,R0
	MOV	R6,#3
	FNRTS
fnum$l	TEQ	R6,#3
	MOVNE	R6,#1
	FNRTS	NE
	BL	err41
	FNRTV
eval_expr$l
	LDRB	R0,[R10,#1]!
	TEQ	R0,#'('
	TEQNE	R0,#'"'		; not a string? must be a function
	BNE	func$l		; let's allow [$#]=func (I'm being lazy)
	STMFD	R13!,{R6}
	MOV	R3,#3<<3
	BL	read_arg$l	; recursion!
	LDMFD	R13!,{R2}
	FNRTS	VS
	TEQ	R6,#3
	FNRTS	NE		; return if not a string
	MOV	R0,R1
	STMFD	R13!,{R1}
	MOV	R1,#256
	BL	evaluate_string
	BVS	eval_fail$l
	TEQ	R0,#0
	BEQ	eval_exprnum$l
	MOV	R1,R0		; string ptr
	TEQ	R2,#'$'
	MOVEQ	R6,#3
	BEQ	eval_gotexpr$l
	BL	heap_free
eval_wrongexpr$l
	MOV	R1,#0
	MOV	R6,#15
eval_gotexpr$l
	LDMFD	R13!,{R0}
	BL	heap_free
	FNRTS
eval_exprnum$l
	TEQ	R2,#'#'
	MOVEQ	R6,#1
	BEQ	eval_gotexpr$l
	B	eval_wrongexpr$l

eval_fail$l
	LDR	R1,[R13]
	STR	R0,[R13]
	MOV	R0,R1
	BL	heap_free
	LDMFD	R13!,{R0}
	FNRTV

;n$l
; MOV R6,#2
; B endskip$l
asc$l
	LDRB	R1,[R10,#1]!	; value
	TEQ	R1,#0		; don't allow file end
	ADDNE	R10,R10,#1	; closing quote
	LDRB	R0,[R10]
	TEQ	R0,#'''
	ADDEQ	R10,R10,#1	; skip ending quote
	MOV	R6,#1		; number
	B	endskip$l

numbracketed$l
	MOV	R0,#')'
numquoted$l
	MOV	R6,R0
	ADD	R10,R10,#1
	BL	str_skip
	TEQ	R0,#'('
	TEQNE	R0,#'"'
	BEQ	bad_arg$l
	BL	str_readnum	; does a str_separator as well
	FNRTS	VS
	MOV	R1,R0		; value
	LDRB	R0,[R10]
	TEQ	R0,R6
	BNE	bad_arg$l
	MOV	R6,#1
	ADD	R10,R10,#1
	BL	str_separator
	TEQ	R0,#0
	TEQNE	R0,#10
	TEQNE	R0,#':'
	BEQ	endskip$l
	B	bad_arg$l

;E R0=universal arg value to set for next command

universal_arg
	FNSTR	R0,key_count	; count number
	FNLDR	R0,key_flags
	ORR	R0,R0,#1<<4		; set univ arg flag
	FNSTR	R0,key_flags
	MOV	PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Learn key strokes					  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=command data
;  R1=number of times command executed
;  R4=heap block to insert the stroke into
;  R5=current length of valid data in the heap block (exc -1)
;  R6=data type (0=none 1=byte 2=word 3=string 4=block 5=num expr 6=str expr)
;  R7=command address (can be b0 set form - not looked at)
;X Stroke buffered and R4/R5 updated #
;  A buffer_stroke heap block contains a -1 terminated list of blocks
;  of the following format:
;  #0	Command address to execute (can be b0 set form)
;  #4	Data type
;  #8	Data_length
;  #12	Data, then aligned to next entry. Format depends on data type
;	None (0) Data block empty (data_length=num times to execute)
;	Byte (1) byte list of data_length bytes
;	Word (2) Word list of data_length words
;	String (3) Zero terminated string (data_length=num times to exec)
;	Block (4) Pointer to the block (data_length=4) (data_length=num)
;       Byte/word expression (5) as string
;       String expression (6) as string

buffer_stroke
 FNJSR "R0-R3,R6-R8"
 MOV R2,R0			; save data (address)
 MOV R8,R1			; save number of times
 BL command_data
 MOVVC R3,R0			; length of data store (aligned)
 ADDVC R1,R3,#20		; entry size + -1 term + 4 luck
 MOVVC R0,R4			; heap block
 ADDVC R1,R5,R1			; new len
 BLVC heap_ensure		; make sure big enough
 BVS end$l
 SUB R5,R1,#8			; end of last entry (new length)
 MOV R4,R0			; save new addr of block
 MOV R14,#-1
 STR R14,[R0,R5]!		; add -1 terminator
 SUB R0,R0,R3			; beginning of data part
 STR R7,[R0,#-12]		; command address
 STR R6,[R0,#-8]
 STR R8,[R0,#-4]		; number of times pressed
 TEQ R6,#0
 BEQ end$l			; no data
 CMP R6,#4
 STREQ R2,[R0]
 BEQ end$l			; save pointer to data
 MOV R1,R2			; data start
 MOV R2,R0			; data dest
 SWI XZapRedraw_MoveBytes	; BL move_bytes			; copy in data
end$l
 STRVS R0,[R13]
 FNRTS

;E R1=number of times
;  R3=process command internal flags
;  R6=command data
;  R7=command address (validated)
;X key stroke inserted into key_learn buffer
;  (and bungs a -1 on the end) #

learn_stroke
 FNJSR "R4-R6"
 TST R3,#1<<31
 FNRTS NE			; don't learn this command
 ADRL R14,Learn
 TEQ R14,R7			; don't buffer any learn on/off
 FNRTS EQ
 ADRL R14,Execute
 TEQ R14,R7			; don't buffer any execute
 FNRTS EQ
 FNLDR R4,key_learn
 FNLDR R5,key_llen
 MOV R0,R6			; command data
 MOV R6,R3,LSR #24		; is this OK? Yes.
 AND R6,R6,#15
; LDR R6,[R7,#-4]
; MOV R6,R6,LSR#3
; AND R6,R6,#7			; data type
 BL buffer_stroke		; buffer the stroke
 FNSTR R4,key_learn,VC
 FNSTR R5,key_llen,VC		; update (even on error)
 BLVC Beep			; beep to remind user
 FNRTS

 LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Call a key command							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=data => The byte/word if mode 1/2 and ptr to data if mode 3+
;  R2=call type with learn flag (usually 0) & supplied param type
;  R7=command address
;  R8-R10=window/file/cursor or 0
;X Command called once via process command with R1=1 #

process_key_command
 STMFD R13!,{R1,R13,R14}	; R13 for workspace
; TST R2,#1<<27			; bit of param type
; BNE do$l
 ANDS R14,R2,#15<<24
 BEQ do$l
 CMP R14,#3<<24			; only use pointer if arg is byte or word
 STRCC R0,[R13,#4]
 ADDCC R0,R13,#4		; pointer to the argument
do$l
 MOV R1,#1			; 1 arg
 BL process_command
 LDMFD R13!,{R1,R14,PC}

 LOCAL

;E R0=data => Pointer to the data whether it be word/byte or string
;  R1=num  => Number of time the key auto-repeated
;  R2=reason+flags (b31 => do not learn the command) (b30 => internal use)
;     (b24-27 => parameter type (as returned in R6 by read_command))
;  R8=window/0 R9=file/0 R10=caret/0
;  R7=command address (R3 is set up automatically)
;X command called / error if R8-R10 needed but not given #
;  if R2>1 then command passed on (setup calls), the returns.
;  if R2=0 , R0=0 type=string then minibuffer opened, returns.
;  if R2<=1 then command learnt if flag set and then executed
;  they are executed multiple times if universal arg bit set.
;  If R2=0 on entry then returns R0=0 / -1 if minibuffer opened
;  If R2>0 on entry then R0=output of the command

process_command
 FNJSR "R1-R11"
 MOV R6,R0			; save R0 value to send to command
 LDR R4,[R7,#-4]		; command flags
 TST R4,#1<<22			; command?
 BLNE notcommand$l
 FNRTS VS
 MOV R5,R4,LSR#3
 AND R5,R5,#7			; command data type
 AND R3,R2,#&FF000000		; start info word with 0 + R2 flags
 BIC R2,R2,R3			; clear those stored in R2
 CMP R8,#0			; also CLV
 TEQNE R9,#0
 TEQNE R10,#0
 BLEQ check_args		; check the arguments are valid
 FNRTS VS
 CMP R2,#1
 BGT setup$l			; call to set parameters (not execute)
 TEQ R5,#3			; string command?
 TEQEQ R6,#0			; empty argument?
 BEQ mini$l			; open the minibuffer
 BL checklearn			; repeating a REPEAT/WHILE loop?
 BNE nolearn$l			; if so, don't learn command
 FNLDR R11,key_flags
 TST R11,#4
 BLNE learn_stroke		; learn this command (it's main)
 FNRTS VS
nolearn$l
 TST R4,#1<<21			; execute regardless if b21 of cmd flags set
 BNE if_istrue$l
 BL checktrue   		; is condition true?
 MOV R0,#0
 FNRTS EQ			; no? don't execute
 FNLDR R14,if_skip		; are we skipping IFs?
 TEQ R14,#0
 FNRTS NE			; yes? don't execute
if_istrue$l
 TST R11,#1<<4
 MOVEQ R11,#1			; none - universal arg rate =1
 BLNE get_uni_arg		; R11=universal arg (+state cleared)
 FNLDR R0,key_lastcom
 TEQ R0,R7
 ORREQ R3,R3,#1			; flag a repeat of the command
 AND R0,R3,#&F<<24
 TEQ R0,#8<<24
 TEQNE R0,#9<<24
 BEQ execeval$l
 TEQ R5,#1
 TEQNE R5,#2
 BEQ list$l			; argument is a list of bytes or words
execeval$l
 ANDS R4,R4,#3<<12		; get argument details
 BLNE get_ptr_multiplicities	; sort out R1,R11 for this argument type
 TEQ R11,#1
 BNE execlots$l			; do lots of times
execonce$l
 TST R3,#1<<30
 LDRNE R4,[R13,#20]		; get stacked R6
 MOVEQ R4,#0			; (if used, cmd may return a value in R4)
 STMFD R13!,{R2,R7,R12}		; stacking R12 for the first time...?
 BL exec_command		; low level
 LDMFD R13!,{R2,R7,R12}		; stacking R12 for the first time...?
 FNRTS VS
 MOV R11,R0			; preserve in case R3 b30 set
end$l				; tidy up and go home
 TEQ R2,#0
 MOVEQ R0,#0			; minibuffer not opened
 FNSTR R7,key_lastcom		; last command called ; abort location?
 MOV R0,R11
 FNRTS
list$l				; argument in list form
 ANDS R4,R4,#3<<12		; get argument details
 BLNE get_list_multiplicities	; sort out R1,R11,R4,R5,R6
 TEQ R11,#1
 BNE execlotswithinc$l
 TST R4,#1
 BEQ execonce$l			; don't need to worry about the buffer
 TST R3,#1<<30
 LDRNE R4,[R13,#20]		; get stacked R6
 MOVEQ R4,#0			; (if used, cmd may return a value in R4)
 STMFD R13!,{R2,R6-R7,R12}	; stacking R12 for the first time...?
 BL exec_command		; low level
 LDMFD R13!,{R2,R6-R7,R12}	; restore buffer pointer
 MOVVC R11,R0			; preserve in case R3 b30 set
 MOVVC R0,R6
 BLVC heap_free
 BVC end$l
 FNRTS
execlots$l			; exec R11 (>1) times
 MOV R5,#0			; R6 increment between calls
execlotswithinc$l		; R5=increment R4=b1 to free buffer
 TST R4,#1
 MOVEQ R4,#0			; no buffer
 MOVNE R4,R6			; buffer pointer
 TEQ R9,#0
 BLNE start_operation		; start an operation on this file
loop$l
 STMFD R13!,{R1-R12}		; stacking R12 for the first time...?
 FNLDR R1,key_count
 TEQ R1,#0
 MOVEQ R1,#1
 SUB R0,R1,R11
 MOV R14,#100
 MUL R0,R14,R0
 SWI XZapRedraw_Divide
 SWI XHourglass_Percentage
 LDMIA R13,{R1-R3}
 MOV R4,#0			; (bug catcher)
 BL exec_command		; do the command corrupting registers
 LDMFD R13!,{R1-R12}		; stacking R12 for the first time...?
 BVS exit$l
 ORR R3,R3,#1			; ensure the repeat flag now set
 FNSTR R7,key_lastcom		; last called command
 ADD R6,R6,R5			; increment list pointer
 SUBS R11,R11,#1		; decrement counter
 BGT loop$l
 MOV R0,#0
exit$l				; error occurred with the command or exit
 MOVVC R11,R0			; new preseve... ; not needed?
 BL stop_operation		; handles zeros in R9
 FNRTS VS
 MOVS R0,R4			; buffer needs to be freed?
 BLNE heap_free
 MOVVC R0,R11			; new un-preseve... ; not needed?
 FNRTS
setup$l				; just a simple setup call
 MOV R0,R6			; set up the data pointer
 MOVS R14,PC			; return address
 MOV PC,R7			; call command
 FNRTS				; return with any data in R0
mini$l				; string with no parameter
 EOR R14,R4,#1<<10
 TST R14,#1<<6:OR:1<<10		; b6 clear, b10 set?
 BLEQ err41			; if so, not allowed to use minibuffer
 BLVC minibuffer_clear		; else get rid of old command
 FNRTS VS
 TST R4,#1<<6			; supports prompts?
 BEQ promptdone$l		; no
 FNSTR R7,mini_command		; set this up temp - done by start as well
 CMP R9,#0
 MOVEQ R0,#1			; abort flag...
 BEQ abort$l			; give up - no minibuffer on the IB.
 MOV R2,#6			; ask for prompt
 BL fake_minibuffer_command	; re-entrancy!!!
 FNRTS VS
 TST R4,#1<<10
 BEQ promptdone$l		; open minibuffer regardless
 TEQ R0,#0
 BNE abort$l			; abort opening
promptdone$l
 BL minibuffer_start		; start new command (and update)
 MOVVC R0,#-1			; minibuffer opened
 FNRTS
abort$l				; R0=abort type (1=total abort)
 MOV R1,#1
 MOV R2,#0
 CMP R0,#1
 MOVLE R0,#0			; minibuffer not opened
 BLGT process_command		; do the operation instead if there is one.
 FNRTS				; go home (R0=0 I hope??!)

notcommand$l
 ERR "zap_e_notcmd"


;E as for process_command, except
;  R2 not required
;  R6=parameter type
;X command executed / error if R8-R10 needed but not given #
;  R0=output of the command, R1=output type

process_function
	FNJSR	"R2-R11"
	MOV	R2,#23
	MOV	R3,R6,LSL #24	; supplied data type
	MOV	R6,R0		; save R0 value to send to command
	BIC	R7,R7,#3
	LDR	R4,[R7,#-4]	; command flags
	TST	R4,#1<<23	; function?
	BLEQ	notfunction$l
	FNRTS	VS
	MOV	R5,R4,LSR #24
	AND	R5,R5,#7	; expected function data type
	TEQ	R5,#3
	TEQEQ	R3,#9<<24	; string expression
	BEQ	ok$l
	TEQ	R5,#1
	TEQNE	R5,#2
	TEQEQ	R3,#8<<24	; int expression
	BEQ	ok$l
	TEQ	R3,#1<<24
	TEQEQ	R5,#2		; cope with word masquerading as byte
	TEQNE	R3,R5,LSL #24
	BLNE	badparam_fn
	FNRTS	VS
ok$l	TEQ	R8,#0
	TEQNE	R9,#0
	TEQNE	R10,#0
	BLEQ	check_args	; check the arguments are valid
	FNRTS	VS
	STMFD	R13!,{R12}	; stacking R12 for the first time...?
	ORR	R7,R7,#1
	BL	exec_command	; low level
	LDMFD	R13!,{R12}	; stacking R12 for the first time...?
	FNRTS
notfunction$l
	ERR	"zap_e_notfn"
badparam_fn
	ERR	"zap_e_fnarg"

fake_minibuffer_command
 STMFD R13!,{R1,R7-R10,R14}
; BL get_input_caret
; BCS mi12			; no input caret
; FNLDR R7,mini_command		; minibuffer command
 CMP R7,#0
 BLE mi12			; none
; BL reclaim_caret		; reclaim caret for the duration
 FNLDR R0,mini_ptr
 FNLDR R1,mini_mark
 ADD R0,R0,R1			; minibuffer after mark
 MOV R1,#1			; only one time
 BL process_command
; BLVC declaim_caret
 LDMFD R13!,{R1,R7-R10,PC}
mi12
 MOV R0,#0
 LDMFD R13!,{R1,R7-R10,PC}

;E R1=number of times buffered R11=universal arg num of times
;  R4=1-3 in bits 12-13 (0 done)
;X R1=value to pass to command R11=number of times to call the command |

get_ptr_multiplicities
 TEQ R4,#1<<12
 MULEQ R1,R11,R1
 MOVEQ R11,#1
 MOVEQ PC,R14
 TEQ R4,#2<<12
 MULEQ R11,R1,R11
 MOVEQ R1,#1
 MOVNE R0,R1
 MOVNE R1,R11
 MOVNE R11,R0
 MOV PC,R14

 LOCAL

;E R1=number of times buffered R11=universal arg num of times
;  R4=1-3 in bits 12-13 (0 done) R5=command type R6=pointer to data list
;X R1=value to pass to command
;  R4=b0 is set if buffer needs to be freed after the command calls
;  R5=amount to increment buffer pointer by on each command call
;  R6=buffer to pass to command
;  R11=number of times to call the command

get_list_multiplicities
 TEQ R5,#2
 MOVEQ R5,#4			; 4 bytes per arg
 MOVNE R5,#1			; 1 byte per arg
 TEQ R4,#3<<12
 MOVEQ R0,R1
 MOVEQ R1,R11
 MOVEQ R11,R0
 MOVEQ PC,R14

 FNJSR				; we need to duplicate the list
 CMP R11,#1
 BLE a$l			; no need to duplicate
 BL duplicate_args		; duplicate to R0
 FNRTS VS
 MOV R6,R0			; new data pointer
 ORR R4,R4,#1			; needs to be freed
a$l
 TST R4,#1<<12			; if set then only call once
 MULNE R1,R11,R1
 MOVNE R11,#1
 MULEQ R11,R1,R11
 MOVEQ R1,#1
 FNRTS

;E R11=keyflags
;X R11=universal argument rate for the command

get_uni_arg
 BIC R11,R11,#1<<4
 FNSTR R11,key_flags		; clear universal state
 FNLDR R11,key_count		; number of times to call command
 CMP R11,#0			; any left?
 MOVLE R11,#1			; default to one call
 MOV PC,R14

 LOCAL

;E R1=r1 value to pass to the command R2=0 or 1 (execute) R3=flags
;  R4=command block pointer (internal use)
;  R6=R0 to pass to the command
;  R7=command address (b0 set if function)
;  R8-R10 checked and setup
;X Make a low level execution of the command
;  Calls the align caret and then the command address
;  Corrupts R0-R11 #

exec_command
	FNJSR ; STMFD	R13!,{R14} ; trouble...
	MOV	R11,#e_aligncaret
	TEQ	R8,#0			; check window AND caret both exist.
	TEQNE	R9,#0
	TEQNE	R10,#0
	BLNE	call_mode		; make sure the caret is in ok posn
	FNRTS	VS ; LDMVSFD	R13!,{PC}
	AND	R0,R3,#15<<24
	TEQ	R0,#8<<24
	BEQ	execint$l
	TEQ	R0,#9<<24
	BEQ	execstr$l
	MOV	R0,R6			; set up the data pointer
	MOVS	R14,PC			; return address
	MOV	PC,R7			; call command
	FNRTS ; hmm?
execint$l
	MOV	R0,R6
	STMFD	R13!,{R1}
	MOV	R1,#0
	BL	evaluate_string
	LDMVSFD	R13!,{R1,PC}
	MOV	R0,R1
	LDR	R1,[R13]
	STR	R0,[R13]
	TST	R7,#1
	MOVEQ	R0,R13			; set up the data pointer
	MOV	R14,PC			; return address
	MOV	PC,R7			; call command
	LDMFD	R13!,{R14,PC}

execstr$l
	MOV	R0,R6 ; LDR	R0,[R6]
	STMFD	R13!,{R1,R2}
	MOV	R1,#256
	BL	evaluate_string
	LDMVSFD R13!,{R1,R2,PC}
	TEQ	R0,#0
	BNE	isstr$l
	MOV	R0,#12		; convert to string
	BL	heap_claim
	LDMVSFD	R13!,{R1,R2,PC}
	MOV	R2,R0
	MOV	R0,R1
	MOV	R1,R2
	MOV	R2,#12
	SWI	XOS_ConvertCardinal4
isstr$l	LDMFD	R13!,{R1,R2}
	STMFD	R13!,{R0}
	MOVS	R14,PC			; return address
	MOV	PC,R7			; call command
	STMFD	R13!,{R0,R1}
	MOV	R1,PC
	LDR	R0,[R13,#8]
	BL	heap_free		; free block, preserving R0+flags
	TEQP	R1,#0
	MOV	R0,R0
	LDMFD	R13!,{R0,R1,R14,PC}


 LOCAL

;E R2=Command call type R4=command flags R8-R10=arguments
;X Arguments updated so valid or an error given #

check_args
 FNJSR				; must check for window/file first
 TST R4,#2			; (eg called from options menu)
 TEQEQ R8,#0
 BEQ err$l			; it wanted window
 TST R4,#4
 TEQEQ R9,#0
 BEQ err$l			; it wanted file
 TEQ R2,#15
 FNRTS EQ			; menu setup calls don't require R10
 TST R4,#1			; does he need the cursor?
 TEQEQ R10,#0			; cursor given?
 FNRTS NE			; cursor given or not needed
 BL get_input_caret		; get it
 FNRTS CC			; R10 sorted out - can call command
err$l
 BL err2$l			; invalid parameters
 FNRTS
err2$l ERRlit "Internal error: Bad command call"

 LOCAL

;E R1=length of argument data (word/bytes) > 0
;  R5=length of data seqment (eg 1/4 for bytes/words)
;  R6=source data
;  R11=number of copies to have (>1)
;X R0=heap block pointer with data #

duplicate_args
 FNJSR "R1-R11"
 MUL R1,R5,R1			; length of the argument data
 MUL R5,R1,R11			; length we want
 MOV R0,R5
 BL heap_claim			; claim the block
 FNRTS VS
 MOV R11,R0			; save the block pointer
 MOV R7,R1			; save the length of the source
 MOV R1,R6			; source
 MOV R2,R11			; dest
 MOV R3,R7
 SWI XZapRedraw_MoveBytes ; BL move_bytes			; copy the source block across
 ADD R4,R11,R7			; new dest
 SUB R5,R5,R7			; number of bytes left to do
a$l
 CMP R5,#0			; finished?
 MOVLE R0,R11			; return heap block
 FNRTS LE
 CMP R7,R5			; source bigger then dest?
 MOVLE R10,R7
 MOVGT R10,R5			; number of bytes to copy
 MOV R1,R11			; source
 MOV R2,R4			; dest
 MOV R3,R10
 SWI XZapRedraw_MoveBytes ; BL move_bytes
 ADD R4,R4,R10			; new dest
 ADD R7,R7,R10			; new source length
 SUB R5,R5,R10			; new number left
 B a$l

 LOCAL

;E R0=string + b31 if don't want commands learnt
;  R8-R10=input caret/0's (uses wimp_kbdbuf)
;X Command string executed R0=0/-1 if minibuf opened #

command_string
 FNJSR "R1-R7"
 AND R2,R0,#1 << 31		; get the learn flag
 BIC R0,R0,R2
 PUSH "R10"			; save input caret
 MOV R10,R0			; string start
 BL read_validate_command	; R7=command address
; BL read_command		; R7=command address / b0 set form
; BLVC validate_command		; R7=command address (command now loaded)
 PULL "R10"			; restore caret pointer
 BVS err$l
 CMP R0,#0
 BLMI err41			; check command params ok
 MOVVC R0,R1			; parameter
 ORRVC R2,R2,R6,LSL #24
 BLVC process_key_command
err$l
 MOV R2,R0
 MOV R3,PC
 CMP R6,#3
 MOVGE R0,R1
 BLGE heap_free			; free arg, error or not, if string/block
 TEQP R3,#0
 MOV R0,R2
 FNRTS

 LOCAL

;E R0=string to be evaluated
;  R1=max length of result, if string; -ve for parse only
;X R0=0, or pointer to string (in Zap heap) [always string if R1 was -ve]
;  R1=integer, or length of string
;  Block containing string is 'just big enough'

evaluate_string
	FNJSR	"R0-R11"
	BIC	R10,R0,#1<<31		; input expression
	MOV	R0,#260			; allow a little overflow :-)
	BL	heap_claim
	STR	R0,[R13]
	FNRTS	VS
	MOV	R11,R0			; buffer ptr
	MOV	R5,#255			; space left in buffer
	MOV	R4,#32			; prev char
parse$l	LDRB	R0,[R10],#1
	TEQ	R0,#64
	BEQ	fncall$l
	TEQ	R4,#32
	TEQEQ	R0,#32
	BEQ	parse$l
	CMP	R0,#32
	MOVLO	R0,#0
	STRB	R0,[R11],#1
	MOV	R4,R0
	BLO	evaluate$l
atat$l	SUBS	R5,R5,#1
	BEQ	bufferfull$l
	TEQ	R0,#'"'
	BNE	parse$l
strlit$l
	LDRB	R0,[R10],#1
	SUBS	R5,R5,#1
	BEQ	bufferfull$l
	STRB	R0,[R11],#1
	TEQ	R0,#'"'
	BNE	strlit$l
	B	parse$l
fncall$l
	LDRB	R0,[R10]
	TEQ	R0,#64			; "@@"?
	ADDEQ	R10,R10,#1
	STREQB	R0,[R11],#1
	BEQ	atat$l
	TEQ	R0,#'$'
	TEQNE	R0,#'#'
	BEQ	var$l
	TEQ	R0,#'='
	BEQ	eval$l
	BL	function_string
	BVS	error$l
	CMP	R1,#2
	BHI	string$l
	ANDLO	R0,R0,#255		; ...if byte
int$l	MOV	R1,R11
	MOV	R2,R5
	SWI	XOS_ConvertInteger4	; convert result & put in buffer
	MOVVC	R11,R1
	MOVVC	R5,R2
	BVC	parse$l
	B	error$l
string$l
	MOV	R7,R0
	MOV	R1,#'"'
	STRB	R1,[R11],#1
	SUBS	R5,R5,#1
	BEQ	str_bufferfull$l
	TEQ	R0,#0			; trap null pointers :-)
	BEQ	donestr$l
;	BEQ	nostr$l
cpstr$l	LDRB	R1,[R0],#1
	CMP	R1,#127
	CMPNE	R1,#31
	BLS	donestr$l
	STRB	R1,[R11],#1
	SUBS	R5,R5,#1
	BEQ	str_bufferfull$l
	TEQ	R1,#'"'
	BNE	cpstr$l
nostr$l	STRB	R1,[R11],#1
	SUBS	R5,R5,#1
	BNE	cpstr$l
str_bufferfull$l
	MOVS	R0,R7
	BLNE	heap_free
	B	bufferfull$l
donestr$l
	MOV	R1,#'"'
	STRB	R1,[R11],#1
	SUBS	R5,R5,#1
	BEQ	str_bufferfull$l
	MOV	R0,R7
	BL	heap_free
	B	parse$l
var$l	ADD	R10,R10,#1	; @$, @#
	MOV	R0,R10
	BL	validate_varname
	BLEQ	bad_zap_variable
	BVS	error$l
	ADR	R1,var_prefix	; Cheat - put the var name in
	MOV	R2,#8		; instead of evaluating it
	SUBS	R5,R5,#8
	BLE	bufferfull$l
vp$l	LDRB	R14,[R1],#1
	SUBS	R2,R2,#1
	STRB	R14,[R11],#1
	BNE	vp$l
	SUB	R0,R0,R10
	SUBS	R5,R5,R0
	BLE	bufferfull$l
vn$l	LDRB	R14,[R10],#1
	SUBS	R0,R0,#1
	STRB	R14,[R11],#1
	BNE	vn$l
	B	parse$l
eval$l	ADD	R10,R10,#1	; @=
	MOV	R0,R10
	BL	validate_varname
	BLEQ	bad_zap_variable
	SUBVC	R1,R0,R10
	MOVVC	R0,R10
	ADDVC	R10,R0,R1
	BLVC	make_varname
	CMP	R13,#&8100
	BLLT	noroom$l
	BVS	error$l
	MOV	R0,#256
	BL	heap_claim		; claim space for expression
	MOVVS	R7,#0
	MOVVC	R7,R0
	MOVVC	R3,#0
	MOVVC	R2,#255
	MOVVC	R1,R0
	FNLDR	R0,wimp_buffer,VC
	SWIVC	XOS_ReadVarVal		; read expression
	BVS	str_bufferfull$l
	TEQ	R4,#1
	MOVEQ	R2,#0
	LDREQ	R1,[R7]
	BEQ	eval_int$l
	MOV	R0,#0
	STRB	R0,[R7,R2]
	MOV	R0,R7
	MOV	R1,#256
	BL	evaluate_string		; evaluate expression
	BVS	eval_err$l
	MOV	R2,R0
eval_int$l
	MOV	R0,R7
	BL	heap_free		; free space for expression
	TEQ	R2,#0
	MOVEQ	R0,R1
	BEQ	int$l
	MOV	R0,R2
	B	string$l
eval_err$l
	MOV	R1,R0
	MOVS	R0,R7
	BLNE	heap_free
	MOV	R0,R1
	B	error$l
noroom$l
	ERR	"zap_e_noroom"
evaluate$l
	LDR	R2,[R13,#4]		; max result len
	MOVS	R0,R2
	LDRMI	R0,[R13]
	SUBMI	R1,R11,R0
	STRMI	R1,[R13,#4]
	BMI	no_eval$l
	BLNE	heap_claim		; claim result buffer if necessary
	BVS	error$l
	STMFD	R13!,{R0}
	MOV	R1,R0
	LDR	R0,[R13,#4]		; parsed expr buffer
	SWI	XOS_EvaluateExpression
	LDMFD	R13!,{R3}		; result buffer
	BVC	done_eval$l
	MOV	R1,R0			; if error...
	MOVS	R0,R3
	BLNE	heap_free		; free result buffer if claimed
	MOV	R0,R1
	LDR	R2,[R0]
	TEQ	R2,#484			; "Buffer overflow" error
	BNE	error$l
	LDR	R2,[R13,#4]		; - replace it :-)
	TEQ	R2,#0
	ADREQ	R0,badeval_int$l
	ADRNE	R0,badeval_any$l
	B	error$l
done_eval$l
	LDR	R0,[R13]
	BL	heap_free
	STMIA	R13,{R1,R2}		; preserve result ready for return
	MOVS	R0,R1
	MOVNE	R14,#0
	STRNEB	R14,[R0,R2]
	ADDNE	R1,R2,#1
no_eval$l
	BLNE	heap_ensure		; minimise result buffer length
	SUBS	R0,R0,R0		; ignore errors
	FNRTS
bufferfull$l
	ADR	R0,bufferfullmsg$l
error$l	LDR	R14,[R13]
	STR	R0,[R13]
	MOV	R0,R14			; SWP R0,R0,[R13] would be better
	BL	heap_free		; free expr buffer
	FNRTV
bufferfullmsg$l
	&	0
	=	"Expression buffer overflow",0
	ALIGN
badeval_int$l
	&	484
	=	"Expression must evaluate to an integer",0
	ALIGN
badeval_any$l
	&	484
	=	"Expression result too long",0
	ALIGN
separator$l
	SUB	R10,R10,#1			; compensate
a$l	LDRB	R0,[R10,#1]!
	TEQ	R0,#32
	BEQ	skip$l
	CMP	R0,#'0'
	RSBHSS	R1,R0,#'z'
	MOVLOS	PC,R14
	CMP	R0,#'9'
	RSBHSS	R1,R0,#'A'
	MOVHIS	PC,R14
	CMP	R0,#'Z'
	RSBHSS	R1,R0,#'a'
	BLS	a$l
	MOVS	PC,R14
skip$l	LDRB	R0,[R10,#1]!
	TEQ	R0,#32
	BEQ	skip$l
	MOVS	PC,R14


	LOCAL

; E R10=function string
; X R0=result (ptr if R1=3), or error if V set
;   R1=result type (1=byte,2=word,3=string)

function_string
	FNJSR	"R2-R9"
	ORR	R10,R10,#1<<31
	BL	read_validate_command	; well, function...
	FNRTS	VS
	BIC	R10,R10,#1<<31
	STMFD	R13!,{R1,R6,R10}	; stack parameter & type
	MOV	R0,R1
	MOV	R2,R6,LSL #24
	MOV	R10,#0
	BL	process_function
	MOV	R2,PC
	LDMFD	R13!,{R3,R4,R10}	; unstack them
	MOV	R7,R0			; result/error preservation
	CMP	R4,#3
	MOVHS	R0,R3
	BLHS	heap_free		; free the parameter block if string
	TST	R2,#1<<28		; was there an error?
	MOV	R0,R7
	BNE	error$l
	TEQ	R1,#0
	ADREQ	R0,noreturnvalue$l
	BEQ	error$l
	CMP	R1,#3
	FNRTS	LS
	BL	heap_free
	ADR	R0,badreturnvalue$l
error$l
	FNRTV
noreturnvalue$l
	&	0
	=	"Function must have a return value",0
	ALIGN
badreturnvalue$l
	&	0
	=	"Function must return byte, word or string",0
	ALIGN

	LOCAL

;E R0=pointer to the data
;  R1=length as in number of times command executed
;  R6=data type (0=none ... 6=str expr)
;X R0=actual length of data block to be stored in a buffer_command
;  write (excluding first two words) length is word aligned |

command_data
 FNJSR
 CMP R6,#10
 FNRTS HS
 LDR R14,[PC,R6,LSL #2]
 ADD PC,PC,R14
cmd$l
 & type0$l-cmd$l-4 ; none
 & type1$l-cmd$l-4 ; byte list
 & type2$l-cmd$l-4 ; word list
 & type3$l-cmd$l-4 ; string
 & type4$l-cmd$l-4 ; block
 & typex$l-cmd$l-4
 & typex$l-cmd$l-4
 & typex$l-cmd$l-4
 & type3$l-cmd$l-4 ; byte/word expr
 & type3$l-cmd$l-4 ; string expr
type0$l
 MOV R0,#0
typex$l
 FNRTS
type1$l
 ADD R0,R1,#3
 BIC R0,R0,#3
 FNRTS
type2$l
 MOV R0,R1,LSL #2
 FNRTS
type3$l
 BL str_len
 ADD R0,R0,#4
 BIC R0,R0,#3			; word align
 FNRTS
type4$l
 MOV R0,#4
 FNRTS

 LOCAL

;E R0->variable name
;X R0->char following var name
;  R1=char following var name
;  EQ if input R0 == output R0

validate_varname
	FNJSR	"R2"
	MOV	R2,R0
	LDRB	R1,[R0],#1
	CMP	R1,#'A'
	RSBHSS	R14,R1,#'z'
	BHS	chk_e$l
	B	end$l
chk$l	LDRB	R1,[R0],#1
	TEQ	R1,#'$'
	BEQ	chk$l
	CMP	R1,#'0'
	RSBHSS	R14,R1,#'z'
	BLO	end$l
	CMP	R1,#'9'
	RSBHIS	R14,R1,#'A'
	BHI	end$l
chk_e$l	CMP	R1,#'Z'
	RSBHIS	R14,R1,#'_'
	BLS	chk$l
end$l	SUB	R0,R0,#1
	TEQ	R0,R2
	FNRTS


	LOCAL

;E R0->variable name
;X R0->char following var name
;  R1=char following var name
;  EQ if input R0 == output R0

validate_varname_wild
	FNJSR	"R2"
	MOV	R2,R0
	LDRB	R1,[R0],#1
	TEQ	R1,#'#'
	TEQNE	R1,#'*'
	BEQ	chk$l
	CMP	R1,#'A'
	RSBHSS	R14,R1,#'z'
	BHS	chk_e$l
	B	end$l
chk$l	LDRB	R1,[R0],#1
	TEQ	R1,#'#'
	TEQNE	R1,#'*'
	TEQNE	R1,#'$'
	BEQ	chk$l
	CMP	R1,#'0'
	RSBHSS	R14,R1,#'z'
	BLO	end$l
	CMP	R1,#'9'
	RSBHIS	R14,R1,#'A'
	BHI	end$l
chk_e$l	CMP	R1,#'Z'
	RSBHIS	R14,R1,#'_'
	BLS	chk$l
end$l	SUB	R0,R0,#1
	TEQ	R0,R2
	FNRTS


	LOCAL

;E R0->variable name R1=var name length
;X R0->wimp_buffer (containing variable name, prefixed by "Zap$Var_")

make_varname
	FNJSR	"R1-R3"
	CMP	R1,#247
	MOVHS	R1,#247
	MOV	R2,R0
	FNLDR	R0,wimp_buffer
	ADR	R14,var_prefix
	LDMIA	R14,{R3,R14}
	STMIA	R0,{R3,R14}
	ADD	R3,R0,#8
cp$l	LDRB	R14,[R2],#1
	SUBS	R1,R1,#1
	STRB	R14,[R3],#1
	BNE	cp$l
	MOV	R14,#0
	STRB	R14,[R3]
	FNRTS
var_prefix =	"Zap$Var_"	; 8 characters


;E R0->message string (for error box)
;X EQ if OK/Continue pressed
;  R0-R5 corrupt

; DCD 1
;Removelf
; STMFD R13!,{R0-R6,R14}
; LDR R0,[R9,#f_len]
; TEQ R0,#0
; LDMEQFD R13!,{R0-R6,PC}^
; FNcall Zap_SaveWinStatus,R6
; MOV R0,#0
; MOV R1,#0
; ;BL split_buffer
; FNcall Zap_SplitBuffer         ; get the split out of the way
; LDR R0,[R9,#f_ptr]
; LDR R1,[R9,#f_bufl]		; f_len]
; ADD R1,R1,R0
; LDRB R2,[R8,#w_cr]
;rlf_lp
; LDRB R14,[R0],#1
; TEQ R14,R2
; BLEQ rlf_cr
; CMP R0,R1
; BCC rlf_lp
; LDR R0,[R9,#f_flags]
; ORR R0,R0,#1<<3
; STR R0,[R9,#f_flags]
; FNcall Zap_NewWinStatus,R6
; LDMFD R13!,{R0-R6,PC}^
;
; DCD 1
;Removelfsel
; STMFD R13!,{R0-R6,R14}
; LDR R0,[R9,#f_len]
; TEQ R0,#0
; LDMEQFD R13!,{R0-R6,PC}^
; MOV R4,R9
; BL get_selection
; ;FNcall Zap_GetSel
; LDMCSFD R13!,{R0-R6,PC}^
; CMP R4,R9
; LDMNEFD R13!,{R0-R6,PC}^
; MOV R4,R1
; FNcall Zap_SaveWinStatus,R6
; ;BL split_buffer
; FNcall Zap_SplitBuffer,R6         ; get the split out of the way
; LDR R0,[R9,#f_ptr]
; LDR R1,[R9,#f_splite]
; ADD R0,R0,R1
; ADD R0,R0,R4
; ADD R1,R2,R0
; LDRB R2,[R8,#w_cr]
;rlf_lp2
; LDRB R14,[R0],#1
; TEQ R14,R2
; BLEQ rlf_cr
; CMP R0,R1
; BCC rlf_lp2
; LDR R0,[R9,#f_flags]
; ORR R0,R0,#1<<3
; STR R0,[R9,#f_flags]
; FNcall Zap_NewWinStatus,R6
; LDMFD R13!,{R0-R6,PC}^
;
;rlf_cr
; CMP R0,R1
; MOVCSS PC,R14
; STMFD R13!,{R14}
; LDRB R14,[R0],#1
; TEQ R14,#9
; TEQNE R14,#32
; LDMEQFD R13!,{PC}^	; if followed by ;t or ' ' -> don't replace it
; TEQ R14,R2
; BNE rlf_rcr		; if not followed by ;t, ' ', or ;n -> replace it
;rlf_skiplp
; CMP R0,R1
; LDMCSFD R13!,{PC}^
; LDRB R14,[R0],#1
; TEQ R14,R2
; BEQ rlf_skiplp
; LDMFD R13!,{PC}
;
;rlf_rcr
; MOV R14,#32
; STRB R14,[R0,#-2]
; LDMFD R13!,{PC}^

; DCD 0
;Mcv
; B make_cursor_visible


 END
