; Contains Zap search/replace code and throwback generation
; $Id: Search,fff,v 1.1.2.9 2000/01/27 16:34:58 james Exp $
; -*- armasm -*-

	GET	h.ZapHeader
	GET	h.Messages
	GET	h.Template
	GET	h.Heap
	GET	h.Strings
	GET	h.ModeBits
	GET	h.CreateWind
	GET	h.CreateFile
	GET	h.Cursors
	GET	h.AlterTxt
	GET	h.MiniBuff
	GET	h.Commands
	GET	h.Redraw
	GET	h.KeyBits
	GET	h.TMTVars

	IMPORT	err3
	IMPORT	get_NextBox
	IMPORT	new_link_entry
	IMPORT	create_throwback
	IMPORT	add_throwback_entry
	IMPORT	insert_line_number
	IMPORT	mode11_insprepare
	IMPORT	mode11_inspostpare

	EXPORT	wildcard_match
	EXPORT	search_string
	EXPORT	search_data
	EXPORT	search_as_you_type
	EXPORT	search_init
	EXPORT	replace_data
	EXPORT	replace_string
	EXPORT	default_search
	EXPORT	default_search_flags
	EXPORT	default_replace
	EXPORT	new_search_string
	EXPORT	new_replace_string

	EXPORT	wild_get_char


	LOCAL

;E R0,R3,R4 as for search_data (below)
;  R1=pointer to string to be searched
;  R2=-1 (if string is ctrl-terminated) or length of string
;  R5=search flags as below, except b21=0, b25=1, b27=0, b31=1
;  (A file block is faked.)
;X As for search_data with input R1=2

search_string
	FNJSR	"R8-R10"
	CMP	R2,#0
	BPL	gotlen$l
	SUB	R2,R1,#1
getlen$l
	LDRB	R14,[R2,#1]!
	CMP	R14,#32
	BHS	getlen$l
	SUB	R2,R2,R1
gotlen$l
	BIC	R5,R5,#zsearch_MatchAtCursor :OR: zsearch_AllWindows
	ORR	R5,R5,#zsearch_DontBeep :OR: zsearch_RawSearch
	BL	search_init
	MOVVC	R0,R2
	MOVVC	R2,R3
	BLVC	search_text
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Main search code						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R0=pointer to search string
;  R1=output 0=to cursor 1=to buffer 2=no output 3=count
;	  OR &100+offset of throwback window to add search matches to.
;  R3=start offset of the search
;  R4=search direction +1/-1/0 (if 0, match must start at R3)
;  R5=search flags b31=set for a raw search (don't search by lines)
;		   b30=set if case sensitive
;		   b29=set if macros shouldn't be expanded
;		   b28=set if \commands should be ignored (and `s etc)
;		   b27=set to search all windows (move to next one after)
;		   b26=don't update hourglass in search_text
;		   b25=don't beep if no match found
;		   b24=return end of match offset in R1
;		   b23=search_init sets this if wild_conv_chars found \s
;		   b22=don't display hourglass percentage if set (TT)
;		   b21=match must start at cursor/point (DS) (R3,R4 ignored)
;  R8/R9=current window of search
;X If R1=0 or 1 then output displayed
;  If R1=0 or 2 then R0=match offset on exit / -ve if none
;  If R1=1 then R0=offset of throwback window / -ve if none
;  If R1=3 then R0=number of matches
;  If b24 of R5 was set then R1=end of match offset (if there was one)

search_data
 FNJSR "R10"
 ADR R10,sub$l
 BL do_longop
 FNRTS
sub$l
 FNJSR "R1-R11"
 FNSTR R0,fnd_string2		; save pointer to the string for throwback
 MOV R7,#0
 STR R7,countsearchdata		; set count to zero...
 MOV R7,R1			; R7=output type
 BL get_wind_off		; R0=window offset
 ADDS R6,R0,#0			; R6=window offset of source window
 FNRTS MI
 FNLDR R0,fnd_string2		; restore string pointer
 BL search_init			; put search string into the correct form
 FNRTS VS			; and create the fnd_tree
 ADD R3,R3,R4			; first offset to try
 TST R5,#zsearch_RawSearch
 ORREQ R5,R5,#zsearch_NoHourglass
 B first$l
next$l				; R3=next posn to try
 TEQ R4,#0
 BEQ end$l
first$l
 MOV R0,R6			; set up R8/R9 of the search window
 BL conv_wind_off		; (may change across calls)
 TST R5,#zsearch_MatchAtCursor
 BEQ nocur$l
 ORR R5,R5,#zsearch_NoHourglassPercent :OR: zsearch_NoHourglass
 FNLDR R10,car_cursor
 LDR R0,[R10,#c_wind]
 TEQ R0,R6			; Cursor in window being searched?
 LDREQ R3,[R10,#c_off]		; Yes - get offset
 LDRNE R3,[R8,#w_poff]		; No - get point position
 MOV R4,#0			; hmm...
nocur$l
 LDR R0,[R9,#f_len]
 CMP R3,R0
 BCS nextfile$l			; off start or end of file
 TST R5,#zsearch_RawSearch
 BNE raw$l			; do a raw search
 SWI XOS_ReadEscapeState	; do once for each line (code mode)
 BCS esc$l
 TST R5,#zsearch_NoHourglassPercent
 MOVEQ R0,R3
 BLEQ sumlen_long_op_display
 BLVC search_line_setup		; set up R1,R2,R3,R10
 FNRTS VS
 PUSH "R1"			; save address of the line
 MOV R0,R10			; line length
 BL search_text			; R0=match R1=end of next match in the line
 MOV R11,R1			; end of match
 PULL "R1"			; restore line start
 FNRTS VS
 CMP R0,#-1
 BLT esc$l
 MOV R2,R0			; match offset / -1
 TST R5,#zsearch_ReturnEndOfMatch
 BLNE search_line_delimit	; get end of match offset in R11
 BLVC search_line_end		; R2=match offset R3=next posn to try
 FNRTS VS
 MOVS R0,R2
 BMI next$l			; no match
 MOV R1,R11			; end of match offset (if valid)
; B match$l			; found a match
match$l				; found a match (in R0)
 BL search_data_buffer		; end in R1 if b24 of R5 set
 FNRTS VS
 CMP R11,#0
 BPL next$l			; go onto next match (buffering them)
 TST R5,#zsearch_ReturnEndOfMatch
 STRNE R1,[R13]			; overwrite R1 on the stack if wanted
 B secondend$l			; return values of this match
 ;FNRTS				; return values of this match
esc$l
 MOV R0,#-2
 BL search_data_buffer		; set up the return values
 B secondend$l
 ;FNRTS
raw$l
 BL split_for_search		; R0=apparant start
 FNRTS VS;
 MOV R1,R0
 LDR R0,[R9,#f_len]
 MOV R2,R3
 BL search_text			; R0=match R1=match end
 FNRTS VS;
 CMP R0,#-1
 BMI esc$l
 ADDGT R3,R0,R4			; next offset to look at
 BGT match$l
 MOVEQ R3,#-1			; finished this file
 B next$l
nextfile$l			; move onto next file
 TST R5,#zsearch_AllWindows
 BEQ end$l			; all files option not requested
 MOV R0,R6			; current file
 BL next_wind_offset
 FNRTS VS;
 MOVS R6,R0
 BMI end$l			; run out of windows
 SUB R14,R7,#zsearch_ToThrowback
 TEQ R14,R0
 BEQ nextfile$l			; Don't search the throwback!!!!
 BL conv_wind_off		; set up R8/R9
 CMP R4,#0
 MOVPL R3,#0			; file length may be 0 so goto next$l
 LDRMI R3,[R9,#f_len]
 SUBMI R3,R3,#1			; get the start offset
 B next$l			; try again (the offset may be -1)
end$l
 MOV R0,#-1			; no more matches
 BL search_data_buffer		; set up the return values
secondend$l
 TEQ R7,#zsearch_Count
 LDREQ R0,countsearchdata
 FNRTS

countsearchdata
 DCD 0

 LOCAL

;E R0=match offset or -ve if finished (-1=no matches -2=escape)
;  R5=search flags
;  R6=search window off
;  R7=output (0/1/2/&100+throwback window off)
;X R0=value to return to user R7=updated R11=abort flag (-ve=abort)
; Ie,
; If R0<0 on entry then returns R11=R0
;  If R7=0-2 then preserves R0. If R7>=&100 then R0=R7-&100 & file shown.
; If R0>=0 on entry then
;  If R7=0 then goes to match offset and returns R0=offset R11=-1
;  If R7=1 then creates new buffer for matches and R11=R0 on entry
;  If R7=2 then returns R0=match offset R11=-1
;  If R7=3 then returns R0=match offset R11=R0 on entry
;  If R7>=&100 then inserts match in buffer and R11=R0 on entry

search_data_buffer
 FNJSR "R1-R6,R8-R10"
 MOVS R11,R0			; save match offset
 BMI nomatch$l			; finished search
 CMP R7,#zsearch_ToThrowback
 BGE buffer$l			; insert match into buffer
 CMP R7,#zsearch_ToBuffer
 BLO goto$l			; 0
 BEQ newbuffer$l		; 1: create new buffer and insert
 CMP R7,#zsearch_Count
 BLO off$l			; 2: just return offset
 BEQ count$l			; 3: for counting; just return offset
goto$l
 MOV R0,R6
 BL conv_wind_off		; get source window
 FNRTS VS
 MOV R0,#3
 BL open_a_window		; bring window to the front (eg all files)
 FNLDR R10,car_cursor,VC
 MOVVC R0,R11
 BLVC goto_offset		; goto that offset
 FNRTS VS
off$l
 MOV R0,R11			; match offset
 MOV R11,#-1			; no more to do
 FNRTS
count$l
 LDR R0,countsearchdata		; set count to zero...
 ADD R0,R0,#1
 STR R0,countsearchdata
 MOV R0,R11			; match offset
 FNRTS				; maybe more to do
nomatch$l
 CMP R7,#zsearch_ToThrowback	; was there some output
 BGE openthrowback$l		; open window on search file
 TST R5,#zsearch_DontBeep
 BLEQ Beep
 ;SWIEQ &107			; no match found
 MOV R0,R11			; return value
 FNRTS
newbuffer$l
 MOV R0,R6
 BL conv_wind_off		; R8/R9 of source window
 LDR R0,[R8,#w_txtw]		; width of cache
 LDR R14,[R8,#w_margin]
 SUB R0,R0,R14
 ADD R0,R0,#10			; width we want throwback window to be
 ORR R0,R0,#throwback_FilenameIsToken
 ADR R1,searchtitle$l
 BL create_throwback
 FNRTS VS
 ADD R7,R0,#zsearch_ToThrowback	; set up R7 as the window offset
buffer$l			; insert the match
 BL enter_search_buffer
 FNRTS
searchtitle$l
 = "zap_tb_search", 0
 ALIGN
openthrowback$l
 SUB R0,R7,#zsearch_ToThrowback	; window offset
 BL conv_wind_off		; get R8/R9
 MOV R0,#0
 BL mark_changed_unchanged	; not changed ...
; LDR R0,[R9,#f_flags]
; BIC R0,R0,#flags_Modified	; file not altered
; STR R0,[R9,#f_flags]		; new flags
 BL new_file_title
 SUBVC R0,R7,#zsearch_ToThrowback	; return offset of throwback buffer
 FNRTS

 LOCAL

;E R6=source window off
;  R7=dest window offset +&100 R11=match offset
;X match entered into buffer KB #

enter_search_buffer
 FNJSR "R1-R9"
 ADR R1,search$l
 FNLDR R2,wimp_kbdbuf
 MOV R3,#10
 STRB R3,[R2],#1
 MOV R3,#255
 FNLDR R4,fnd_string2
 BL lookup_token
 MOV R0,R6
 BL conv_wind_off		; set up R8/R9 of source window
 LDR R1,[R9,#f_name]
 ADR R2,null$l
 ADR R3,source$l
 ORR R3,R3,#zap_IsToken
 LDR R4,[R8,#w_file]		; file offset of search file
 SUB R0,R7,#zsearch_ToThrowback	; window offset of throwback file
 BL conv_wind_off		; set up R8/R9 of throwback file
 BL start_operation		; do in one go
 FNRTS VS
 MOV R5,#1:SHL:links_NumberHeadingLines_shift	; (Matches: heads the lines)
 ADR R6,match$l
 ORR R6,R6,#zap_IsToken
 FNLDR R7,wimp_kbdbuf
 ORR R0,R11,#zthrowback_SuppressOffset
 BL add_throwback_entry		; uses KB as well!
 BVS end$l
 LDMFD R13,{$StackedRegs}	; get back R1-R9
 MOV R0,R6
 BL conv_wind_off		; R8/R9 of source window
 MOV R0,R11
 BL search_data_getline
 FNRTS VS			; R9 not on correct file!
 SUB R0,R7,#zsearch_ToThrowback
 BL conv_wind_off		; R8/R9 of dest window
 MOV R0,R4
 ORR R1,R5,#1:SHL:insertlinenumber_InsertOffset_shift
 BL insert_line_number
 BVS end$l
 MOV R0,#command_Insert :OR: command_Atomic
 LDR R1,[R9,#f_len]
 SUB R1,R1,#1
 BL mode11_insprepare
 BL execute_command
 BL mode11_inspostpare
end$l
 BL stop_operation
 FNRTS
null$l	 = 0
source$l = "zap_tb_srcf",0
search$l = "zap_tb_srch",0
match$l  = "zap_tb_srcm",0
 ALIGN

;E R0=file offset R8/R9=file
;X R2=length of text
;  R3=pointer to text for this line stored in wimp_cacheline
;  R4=number to display in the margin
;  R5=b0 for hex display in margin
;  Pointer updated so past line number & margin

search_data_getline
 FNJSR "R1,R10"
 MOV R10,R0			; save the file offset
 BL cln_off			; R0=phy linenum R1=phyline off R2=logline
 FNRTS VS
 MOV R4,R2			; logical line
 MOV R5,#0			; default number to display
 LDR R14,[R8,#w_format]
 TST R14,#format_ShowLineNumbers
 BEQ line$l			; no line numbers
 TST R14,#format_LinesBase
 ORRNE R5,R5,#1			; hex display
 TST R14,#format_LinesAreLines
 LDREQ R4,[R8,#w_addr]
 ADDEQ R4,R4,R10
 BEQ ok$l			; address
 TST R14,#format_LinesPhysical
 MOVNE R4,R0			; physical line
line$l				; got the line number
 LDR R14,[R8,#w_stline]
 ADD R4,R4,R14			; get user-line-number
ok$l				; worked out R4/R5
 MOV R2,R0			; start (physical) line
 ADD R3,R2,#1
 BL update_cache		; saves all R0=address of cached data
 LDRVC R2,[R8,#w_txtw]		; cache width
 MOVVC R1,R0			; address
 MOVVC R0,#0
 BLVC tidy_cache_line		; R1=wimp_cacheline R2=length (exc 0A)
 LDRVC R0,[R8,#w_margin]
 SUBVC R2,R2,R0			; data length
 ADDVC R3,R1,R0			; data address
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search Subs							   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=search string (zero terminated)
;X R0=wimp_kbdbuf contains the search string with macros replaced #

replace_macros
 FNJSR "R1-R11"
 MOV R9,R0			; text
 FNLDR R10,wimp_kbdbuf		; address of data buffer
 MOV R11,#0			; known size of buffer
 MOV R8,R10			; buffer pointer
 FNLDR R7,fnd_macros		; macro data
char$l				; next character
 SUB R8,R8,R10			; buffer offset
 SUB R0,R11,R8			; amount known free in buffer
 CMP R0,#20
 BGE free$l			; enough free
 ADD R11,R11,#&80		; increase size by 128 bytes
 MOV R0,R10
 MOV R1,R11
 BL heap_ensure
 FNRTS VS
 MOV R10,R0			; new address of wimp data
 FNSTR R0,wimp_kbdbuf
free$l				; space reserved
 ADD R8,R8,R10			; buffer pointer
 LDRB R0,[R9]
 CMP R0,#&20
 BCC end$l			; end of string
 MOV R6,#16			; count
 MOV R1,R7			; start of macros
 MOV R2,R9			; text
macro$l
 BL strcmpstr
 BEQ match$l			; match
 ADD R1,R1,#search_macro_size	; next entry ; entry size...
 SUBS R6,R6,#1
 BHI macro$l			; next macro
 LDRB R0,[R9],#1		; no match
 STRB R0,[R8],#1
 TEQ   R0,#'\'			; is it a special code
 TEQNE R0,#'`'
 BNE char$l			; if not next byte
 LDRB R0,[R9],#1		; skip next if so (dont want  ;* -> ;;#;*)
 CMP R0,#&20
 BCC end$l			; unless at end
 STRB R0,[R8],#1
 B char$l			; next
match$l
 MOV R9,R0			; update string pointer
 ADD R2,R1,#8			; replacement string (may need to change)
 MOV R1,R8			; dest
 BL strcpy			; copy in string
 MOV R8,R1			; new pointer
 B char$l			; next char
end$l
 MOV R0,#0
 STRB R0,[R8]			; finish string
 FNLDR R0,wimp_kbdbuf		; address of new string with macros replaced
 FNRTS

 LOCAL

;E R0=string (to be converted to one char per word) R5=search flags
;X b23 of R5 set if \ or ` expanded, is clear otherwise.
;  wimp_data contains converted string with
;   \a -> a<<8 if a unrecognised and R0=byte len #
;  (unless no \ commands flag set)

wild_conv_chars
 FNJSR "R1-R2,R9-R11"
 BIC R5,R5,#zsearch_WildConvChars; clear initially
 MOV R1,R0			; string
 FNLDR R10,wimp_data		; data buffer
 MOV R11,#0			; known size
 MOV R9,R10			; buffer pointer
char$l
 SUB R9,R9,R10			; buffer offset
 SUB R0,R11,R9			; amount free
 CMP R0,#&18			; possible 4 chars = &10 space
 BGE free$l			; ok
 ADD R11,R11,#&80
 MOV R0,R10
 PUSH "R1"
 MOV R1,R11
 BL heap_ensure
 PULL "R1"			; preserve text pointer R1
 FNRTS VS
 MOV R10,R0
 FNSTR R0,wimp_data
free$l
 ADD R9,R9,R10			; buffer pointer
 BL wild_get_char		; find value of character in R0,R2
 CMP R2,#0
 BLT end$l
 MOVEQ R0,R0,LSL#8		; unknown control code to &xx00
a$l
 SUBS R2,R2,#1
 STRLE R0,[R9],#4		; write last character
 BLE char$l
 AND R14,R0,#&FF
 STR R14,[R9],#4
 MOV R0,R0,LSR#8
 B a$l
end$l
 SUB R0,R9,R10			; length
 FNRTS

 LOCAL

;E R1=text pointer of string R5=search flags
;X R0=output R1=next character to read R2=type of output
;  R2=-1 => End of string reached (no output)
;  R2=0  => Unrecognised control code byte R0=&xx
;  R2>0  => R2 bytes of data stored in R0 (little endian).
;	    (padded with 0's)
;  Sets b23 of R5 if \ or ` expanded.

wild_get_char
 FNJSR
 MOV R2,#1			; default=1 byte
 LDRB R0,[R1],#1		; get char
 CMP R0,#&20
 MOVCC R2,#-1
 FNRTS CC			; end of text
 TST R5,#zsearch_NoCommands
 FNRTS NE			; ignore \commands and quotes
 TEQ R0,#'`'
 BEQ quote$l			; one character escape
 TEQ R0,#'\'
 FNRTS NE			; a normal char
 ORR R5,R5,#zsearch_WildConvChars
 LDRB R0,[R1],#1		; char after the '\'
 CMP R0,#&20
 SUBCC R1,R1,#1
 MOVCC R0,#'\'
 FNRTS CC			; return with R0="\" if no more
 TEQ   R0,#'&'
 TEQNE R0,#'x'
 BEQ hex$l			; hex number
 TEQ R0,#'w'
 BEQ decword$l
 TEQ R0,#'h'
 BEQ hexword$l
 CMP R0,#'0'
 BCC slash$l			; not decimal
 CMP R0,#'9'
 BLE dec$l			; a decimal digit
 CMP R0,#'A'
 BCC slash$l			; not a ctrl code
 CMP R0,#'Z'
 BLE ctrl$l
slash$l				; \x for lower case x (or unrecognised)
 ADR R2,table$l
t$l
 LDRB R14,[R2],#2
 TEQ R14,#0
 MOVEQ R2,#0			; special character
 FNRTS EQ			; return
 TEQ R0,R14
 BNE t$l
 LDRB R0,[R2,#-1]		; has decayed into a normal character
 MOV R2,#1			; single byte
 FNRTS
table$l				; 0 termianted table of control codes
 = 'a',7,'b',8,'t',9,'n',10
 = 'v',11,'f',12,'r',13		; C special codes
 = '?',127,'\','\',0		; \\ decays into an ordinary \.
 ALIGN
hexword$l
 MOV R2,#4
hex$l
 MOV R0,#16			; base
 B read$l
decword$l
 MOV R2,#4
 MOV R0,#10
 B read$l
dec$l
 MOV R0,#10			; base
 SUB R1,R1,#1			; first char
read$l				; read a general base number
 PUSH "R3-R5"			; R0=base R1=ptr R2=number of bytes
 MOV R3,R0			; base
 MOV R4,#0			; current sum
 MOV R5,#3			; digits to process for decimal byte
 CMP R2,#1
 MOVGT R5,#10			; 10 in general (eg a word)
 TEQ R3,#16
 MOVEQ R5,R2,LSL#1		; twice number of bytes if hex
a$l
 LDRB R0,[R1]
 CMP R0,#&20
 BCC b$l			; run out of chars
 BL hex_char
 BCS b$l			; not a vaild number
 CMP R0,R3
 BCS b$l			; greater than base
 MLA R14,R4,R3,R0		; new number
 TEQ R2,#1
 BNE c$l
 CMP R14,#&100
 BCS b$l			; too big
c$l				; still within limits so store
 ADD R1,R1,#1
 MOV R4,R14			; ok
 SUBS R5,R5,#1			; reduce the number of digits
 BGT a$l			; may be some more digits
b$l
 MOV R0,R4			; result (R2 already set)
 PULL "R3-R5"
 FNRTS
quote$l
 ORR R5,R5,#zsearch_WildConvChars
 LDRB R0,[R1],#1		; char after the `
 CMP R0,#&20
 SUBCC R1,R1,#1
 MOVCC R0,#'`'			; not valid
 FNRTS				; return char R0
ctrl$l
 SUB R0,R0,#&40			; ctrlA-ctrlZ
 FNRTS

 LOCAL

;E R3=start offset R4=direction R8/R9=file
;X buffer split so search area lies in second half of buffer
;  and R0=apparent text address start (=f_ptr+f_splits) #

split_for_search
 FNJSR "R1"
 MOV R0,#0			; split offset
 CMP R4,#0
 BMI split$l			; have to split at start (going backwards)
 LDR R0,[R9,#f_splito]
 CMP R3,R0
 BCS ok$l			; already split ok
 MOV R0,R3
split$l
 MOV R1,#0			; amount free
 BL split_buffer
 FNRTS VS
ok$l
 LDR R0,[R9,#f_ptr]
 LDR R1,[R9,#f_splits]
 ADD R0,R0,R1			; apparent start
 FNRTS

 LOCAL

;E R8/R9=window to search (ignored if searching all)
;X R0=string R1=output (0,1) R3=start offset R4=direction R5=search flags
;  R8/R9=new window to start from if searching all.
;  for search on this window using the default flags/switches option.

default_search
 FNJSR "R10"
 BL default_search_flags
 MOV R4,#1			; positive direction
 MOV R3,#-1			; start offset of file (1 gets added)
 FNLDR R0,opt_switches
 TST R0,#switch_SearchToBuffer
 MOVEQ R1,#0
 MOVNE R1,#1			; search to buffer
 ANDS R0,R0,#switch_SearchDirAndExtent
 BEQ end$l
 TEQ R0,#(search_AllFiles :SHL: search_DirAndExtent_shift)
 BEQ all$l
 TEQ R0,#(search_Backwards :SHL: search_DirAndExtent_shift)
 MOVEQ R4,#-1			; reverse search
 FNLDR R10,car_cursor
 BL test_cblk
 MOVNE R3,#-1			; not in this window so cursor at start
 LDREQ R3,[R10,#c_off]		; start at cursor
 B end$l
all$l				; search all windows
 MOV R0,#-1			; R4=+1
 BL next_wind_offset		; find first valid window
 BL conv_wind_off		; set up R8/R9
end$l
 FNLDR R0,fnd_string		; search string
 FNRTS

 LOCAL

;E R8/R9=window to sar (ignored if sar'ing all)
;X R1=output (0=selective,1=global) R3=start offset R4=direction
;  R5=search flags
;  R8/R9=new window to start from if searching all.
;  for search & replace on this window using the default flags options.

default_replace
 FNJSR "R10"
 BL default_search_flags
 MOV R4,#1			; positive direction
 MOV R3,#-1			; start offset of file (1 gets added)
 FNLDR R0,opt_switches
 TST R0,#switch_SearchGlobalReplace
 MOVEQ R1,#0			; selective
 MOVNE R1,#1			; global
 ANDS R0,R0,#switch_SearchDirAndExtent
 BEQ end$l
 TEQ R0,#(search_AllFiles :SHL: search_DirAndExtent_shift)
 BEQ all$l
 FNLDR R10,car_cursor
 BL test_cblk
 MOVNE R3,#-1			; not in this window so cursor at start
 LDREQ R3,[R10,#c_off]		; start at cursor
 FNLDR R0,opt_switches		; as R0 corrupted by above BL :-(
 AND R0,R0,#switch_SearchDirAndExtent
 TEQ R0,#(search_Backwards :SHL: search_DirAndExtent_shift)
 MOVEQ R4,#-1			; reverse search
 B end$l
all$l				; search all windows
 MOV R0,#-1			; R4=+1
 BL next_wind_offset		; find first valid window
 BL conv_wind_off		; set up R8/R9
end$l
 FNRTS

 LOCAL

;X R5=default search flags as read from opt_flags & opt_switches

default_search_flags
 MOV R5,#0			; zero flags
 FNLDR R0,opt_flags
 TST R0,#flags_SearchCaseSensitive
 ORRNE R5,R5,#zsearch_CaseSensitive
 TST R0,#flags_NoSearchMacros
 ORRNE R5,R5,#zsearch_NoMacros
 FNLDR R0,opt_switches
 TST R0,#switch_SearchRawSearch
 ORRNE R5,R5,#zsearch_RawSearch
 TST R0,#switch_SearchUseCommands
 ORRNE R5,R5,#zsearch_NoCommands
 AND R0,R0,#switch_SearchDirAndExtent
 TEQ R0,#(search_AllFiles :SHL: search_DirAndExtent_shift)
 ORREQ R5,R5,#zsearch_AllWindows
 MOV PC,R14

 LOCAL

;E R0=pointer to string
;X string placed in fnd_string buffer (installed as default string) #
;  R0=0 if string was null (aborts).

new_search_string
 FNJSR "R1-R3"
 MOV R3,R0			; save search string
 BL str_len
 TEQ R0,#0
 FNRTS EQ			; string null so forget it
 ADD R1,R0,#1			; amount to reserve for string
 FNLDR R0,fnd_string
 BL heap_ensure
 FNRTS VS
 FNSTR R0,fnd_string		; ensure buffer size
 MOV R1,R0
 MOV R2,R3
 BL strcopy			; copy in search string
 MOV R0,#1			; string was valid
 FNRTS

 LOCAL

;E R0=pointer to string
;X string placed in fnd_replace buffer (installed as default string) #
;  Null strings are entered (usefull to replace with a null string)

new_replace_string
 FNJSR "R1-R3"
 MOV R3,R0			; save replace string
 BL str_len
 ADD R1,R0,#1			; amount to reserve for string
 FNLDR R0,fnd_replace
 BL heap_ensure
 FNSTR R0,fnd_replace,VC	; ensure buffer size
 MOVVC R1,R0
 MOVVC R2,R3
 BLVC strcopy			; copy in search string
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Standard line search setup subs (for text like modes) ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R3=file off R4=dir R8/R9
;X R3=start of line file off R2=off in line R1=line ptr R10=line len #
;  (uses e_search,3)
;  (first makes sure split posn is on a line boundry)

search_line_setup
 FNJSR "R5-R6,R11"
 MOV R1,#esearch_StartLineSearch
 MOV R11,#e_search
 BL call_mode			; R0=len R1=str R2=off in str R3=line off
 FNRTS VS
 TEQ R1,#esearch_StartLineSearch
 FNRTS NE			; the mode did it
 LDR R1,[R9,#f_ptr]		; start default action (we'll have to do it)
 LDR R11,[R9,#f_len]
 LDRB R5,[R8,#w_cr]
 LDR R6,[R9,#f_splito]
 CMP R6,R11
 BCS ok$l			; split at end of file
 CMP R6,#0
 BLE ok$l			; split at start of file
 ADD R0,R1,R6			; split address
 LDRB R14,[R0,#-1]
 TEQ R14,R5
 BEQ ok$l			; CR at end of first part of split
a$l				; find start of line loop (then split)
 CMP R0,R1			; ONLY USUALLY GETS REACHED ON FIRST CALL
 BLE b$l
 LDRB R14,[R0,#-1]!
 TEQ R14,R5
 BNE a$l
 ADD R0,R0,#1			; start of the line
b$l
 SUB R0,R0,R1			; split offset
 MOV R1,#0
 BL split_buffer
 FNRTS VS
 LDR R1,[R9,#f_ptr]
 LDR R11,[R9,#f_len]
 LDR R6,[R9,#f_splito]		; values after the split (rarely happens)
ok$l				; split R1=ptr R11=flen R5=cr R6=split
 CMP R3,R6			; R3=file offset in the line
 MOVCC R2,R3
 SUBCS R2,R3,R6			; set R1=start of section R6=len of sect
 LDRCS R0,[R9,#f_splite]	; R2=offset in section
 ADDCS R1,R1,R0			; boost to second half of file
 SUBCS R6,R11,R6
 ADD R2,R1,R2			; address in the section
 ADD R6,R1,R6			; address of end of section
 CMP R2,R1
 BLE line$l
 LDRB R14,[R2,#-1]
 TEQ R14,R5
 MOVEQ R1,R2
 BEQ line$l
 MOV R0,R2
c$l				; get R1 to start of line loop
 CMP R0,R1
 BLE line$l
 LDRB R14,[R0,#-1]!
 TEQ R14,R5
 BNE c$l
 ADD R1,R0,#1
line$l				; set section start (R1) to line start
 MOV R0,R2
d$l
 CMP R0,R6
 BCS end$l
 LDRB R14,[R0],#1
 TEQ R14,R5
 BNE d$l
end$l				; set R0 to line end (terminator)
 SUB R10,R0,R1			; line len
 SUB R2,R2,R1			; offset in line
 SUB R3,R3,R2			; file offset of line start
 FNRTS

;E R1=detokenised string
;  R2=string offset of match
;  R3=offset in file of line
;  R4=search direction R8/R9
;  R10=line length
;X R1 saved R2=file offset of match R3=next file offset to look at
;  (uses e_search,4)

search_line_end
 FNJSR "R1,R11"
 MOV R1,#esearch_EndLineSearch
 MOV R11,#e_search
 BL call_mode
 FNRTS VS			; set up new R3 and match offset in R2
 TEQ R1,#esearch_EndLineSearch
 FNRTS NE			; the mode did it
 CMP R2,#0			; start default action
 ADDPL R2,R3,R2			; offset of match
 ADDPL R3,R2,R4			; next offset to try
 FNRTS PL
 CMP R4,#0
 SUBMI R3,R3,#1			; end of previous line
 ADDPL R3,R3,R10		; start of next line
 FNRTS

 LOCAL

;E R1=detokenised line R2=start of match offset/-1 if none
;  R3=start of line file offset R4=direction R11=end of match line offset
;  R8/R9
;X If R2 +ve then R11=end of match file offset #

search_line_delimit
 CMP R2,#0
 MOVMI PC,R14			; no match to consider
 FNJSR "R1-R3"			; result returned in R11
 MOV R2,R11			; end of match offset
 MOV R1,#esearch_MatchEnd
 MOV R11,#e_search
 BL call_mode			; corrupt R3 and match end offset in R2
 FNRTS VS
 TEQ R1,#esearch_MatchEnd
 ADDEQ R2,R3,R2			; default action for end offset
 MOV R11,R2			; file offset of the end of the match
 FNRTS				; restore everything

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create search tree					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=string of words R1=length in bytes
;X fnd_tree contains the search tree / VS if bad syntax #

wildcard_tree
 FNJSR "R7-R11"
 MOV R7,#0			; buffer offset
 MOV R8,R0			; start
 ADD R9,R8,R1			; end
 FNLDR R10,fnd_tree		; buf
 MOV R11,#0			; size
 BL wild_tree_sub
 FNRTS

;E R7=buffer off R8=text start R9=text end R10=buffer R11=buffer length
;X R1-R6 saved R7 updated R8-R9 corrupt R10,R11 updated #

wild_tree_sub
 STMFD R13!,{R1-R2,R6,R14}
wt0
 MOV R0,#32
 BL wild_tree_free		; make sure 8 words free
 LDMVSFD R13!,{R1-R2,R6,PC}
 MOV R1,R8			; start of string
wt1
 CMP R1,R9
 BCS wt3			; reached end
 LDR R0,[R1],#4
 TEQ   R0,#'('<<8
 TEQNE R0,#'['<<8
 TEQNE R0,#'{'<<8
 BEQ wt2			; brackets to skip
 TEQ R0,#'|'<<8
 BNE wt1			; no OR
 MOV R0,#2
 STR R0,[R10,R7]		; or block
 ADD R6,R7,#4			; save block offset
 ADD R7,R7,#16			; offset of next block
 STR R7,[R10,R6]		; pointer to first string
 MOV R2,R9
 SUB R9,R1,#4			; text end of first string
 BL wild_tree_sub		; draw its tree
 LDMVSFD R13!,{R1-R2,R6,PC}
 ADD R6,R6,#4
 STR R7,[R10,R6]		; pointer to second string
 MOV R8,R1
 MOV R9,R2			; second string
 B wt0				; do this
wt2
 SUB R1,R1,#4			; get pointer to bracket
 BL wild_tree_brackets		; NB always a bracket by above so R1<R9
 LDMVSFD R13!,{R1-R2,R6,PC}
 MOV R1,R2			; skipped
 B wt1				; carry on
wt3
 MOV R1,R8
 BL wild_tree_brackets		; get bracket status
 LDMVSFD R13!,{R1-R2,R6,PC}
 CMP R1,R9
 BCS wt8			; no brackets found
 TEQ R1,R8
 BNE wt7			; first bracket not at start so split
 CMP R2,R9
 BCC wt4			; second bracket not at end
 LDR R0,[R8]			; text of form (...) where {=;[,;(,;{
 TEQ R0,#'['<<8
 BEQ wt11			; ;[..] construct
 TEQ R0,#'{'<<8
 BEQ wt16			; ;{..;} construct
 ADD R8,R8,#4
 SUB R9,R9,#4			; remove brackets
 B wt0				; and carry on
wt4
 MOV R1,R2			; split posn
 LDR R0,[R1]			; find char after sec bracket
 TEQ R0,#'*'<<8
 TEQNE R0,#'%'<<8
 BNE wt7			; split here
 ADD R1,R1,#4			; include ;* in the expression
 CMP R1,R9
 BCC wt7			; split here (not at end)
wt5
 LDR R14,[R9,#-4]		; the ;* or ;%
 MOV R0,#3			; ;* block
 TEQ R14,#'%'<<8
 MOVEQ R0,#6			; ;% block
 STR R0,[R10,R7]
 ADD R6,R7,#4
 ADD R7,R7,#12
 STR R7,[R10,R6]		; set up block
 SUB R9,R9,#4			; remove ;* or ;%
 B wt0				; and do this block
wt7
 MOV R0,#1			; sequential
 STR R0,[R10,R7]
 ADD R6,R7,#4
 ADD R7,R7,#16
 STR R7,[R10,R6]
 MOV R2,R9
 MOV R9,R1
 BL wild_tree_sub		; do first pointer
 LDMVSFD R13!,{R1-R2,R6,PC}
 ADD R6,R6,#4
 STR R7,[R10,R6]
 MOV R8,R1
 MOV R9,R2			; second string
 B wt0
wt8
 ADD R1,R8,#4
wt9
 CMP R1,R9
 BCS wt10			; none
 LDR R0,[R1],#4
 TEQ R0,#'*'<<8
 TEQNE R0,#'%'<<8
 BNE wt9
 SUB R0,R1,R8			; offset in string
 CMP R0,#8
 SUBHI R1,R1,#8
 BHI wt7			; split if e;* not at start
 CMP R1,R9
 BCC wt7			; split if e;* not at end
 B wt5				; create ;* block
wt10
 MOV R0,#0
 STR R0,[R10,R7]
 ADD R7,R7,#4			; string block
 SUB R0,R9,R8			; data length
 MOV R2,R0,LSR#2		; number of entries
 STR R2,[R10,R7]
 ADD R7,R7,#4
 BL wild_tree_free
 LDMVSFD R13!,{R1-R2,R6,PC}
 STMFD R13!,{R3}
 MOV R1,R8
 ADD R2,R10,R7
 SUB R3,R9,R8
 ADD R7,R7,R3
 BL move_bytes
 LDMFD R13!,{R3}		; copy data
 LDMFD R13!,{R1-R2,R6,PC}	; finished
wt11
 MOV R0,#4
 STR R0,[R10,R7]		; save block type
 ADD R6,R7,#4			; offset to store number of ranges
 ADD R7,R7,#8			; first range
 ADD R8,R8,#4
 SUB R9,R9,#4			; range
 MOV R2,#0			; count m
 CMP R8,R9
 BCS wt15			; finished
 LDR R0,[R8]
 TEQ R0,#'^'
 ORREQ R2,R2,#1<<30		; set not flag
 ADDEQ R8,R8,#4
wt12
 CMP R8,R9
 BCS wt15
 LDR R0,[R8],#4
 SUB R14,R9,R8
 CMP R14,#8
 BLT wt13			; no room for a range
 LDR R1,[R8]
 TEQ R1,#'-'
 BNE wt13
 LDR R1,[R8,#4]
 ADD R8,R8,#8			; next lot
 CMP R0,R1
 BLE wt14
 EOR R0,R0,R1			; swap if start>end
 EOR R1,R0,R1
 EOR R0,R0,R1
 STR R0,[R8,#-12]		; store so don't have to swap again
 STR R1,[R8,#-4]
 B wt14
wt13
 MOV R1,R0
wt14
 AND R0,R0,#&FF
 AND R1,R1,#&FF
 ORR R1,R0,R1,LSL#8		; range
 MOV R0,#8
 BL wild_tree_free
 LDMVSFD R13!,{R1-R2,R6,PC}
 STR R1,[R10,R7]
 ADD R7,R7,#4
 ADD R2,R2,#1			; increment count
 B wt12				; next char in range
wt15
 STR R2,[R10,R6]		; save count
 LDMFD R13!,{R1-R2,R6,PC}
wt16
 MOV R0,#5
 STR R0,[R10,R7]
 ADD R6,R7,#4			; first pointer
 ADD R7,R7,#16			; offset of next
 STR R7,[R10,R6]		; save node pointer
 ADD R8,R8,#4
 SUB R9,R9,#4
 B wt0				; do contents

 LOCAL

;E R1=text start R9=text end (NB handles ( and [ constructs)
;X R1=first bracket or R9 if none AND R2=last bracket(+1) /vs not matched

wild_tree_brackets
 FNJSR				; text start in R1
wb1
 CMP R1,R9
 FNRTS CS			; no first bracket
 LDR R0,[R1],#4
 TEQ   R0,#'('<<8
 TEQNE R0,#'['<<8
 TEQNE R0,#'{'<<8
 BNE wb1
 SUB R1,R1,#4			; R1 now points to first bracket
 MOV R2,R1			; start searching for second
 MOV R14,#0			; bracket depth
wb2
 CMP R2,R9
 BLCS err$l			; brackets don't match
 FNRTS VS
 LDR R0,[R2],#4
 TEQ R0,#'['<<8
 BEQ wb3			; ;[..] construct to skip
 TEQ   R0,#'('<<8
 TEQNE R0,#'{'<<8
 ADDEQ R14,R14,#1
 TEQ   R0,#')'<<8
 TEQNE R0,#'}'<<8
 SUBEQ R14,R14,#1
 TEQEQ R14,#0
 BNE wb2			; not a ;) on zero level
 FNRTS				; end
wb3
 CMP R2,R9
 BLCS err$l
 FNRTS VS
 LDR R0,[R2],#4
 TEQ R0,#']'
 BEQ wb4			; allow 1st char to be ]
 TEQ R0,#'^'
 BNE wb4
 CMP R2,R9
 BLCS err$l
 FNRTS VS
 LDR R0,[R2]
 TEQ R0,#']'
 ADDEQ R2,R2,#4			; or the second, if the first is '^'
wb4
 CMP R2,R9
 BLCS err$l
 FNRTS VS
 LDR R0,[R2],#4
 TEQ R0,#']'
 BNE wb4			; not found
 TEQ R14,#0			; are we on bottom level
 BNE wb2			; no so carry on
 FNRTS				; reached end
err$l ERR "zap_e_search_bracketmismatch"

;e R0=amount to have free R7=offset R10=ptr R11=len
;x R0 bytes free in buffer / vs

wild_tree_free
 FNJSR
 SUB R14,R11,R7			; current amount free
 CMP R14,R0
 LDMGEFD R13!,{PC}		; got enough free
 STMFD R13!,{R1}
 ADD R11,R11,R0			; need R0 more free
 ADD R11,R11,#&40
 MOV R0,R10
 MOV R1,R11
 BL heap_ensure			; ensure enough free
 LDMFD R13!,{R1}
 MOVVC R10,R0
 FNSTR R0,fnd_tree,VC		; new pointers
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Work out masks and short cuts					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R5=search flags (case sensitive bit used) & fnd_tree set up.
;X fnd_word contains the first character to match in form:
;  &yyxxyyxx where xx is the original character and yy the other case
;  OR 1 if there is no fixed string to match (use full match for each char)
;  OR 2 if the first character to match is \< (start of line only)
;  fnd_word2 contains the second and third characters to match, of form:
;  &bbbbaaaa where a is the second char and b the third, each of form:
;  &yyxx where xx is the original character and yy the othe case
;  OR 1 if there is no fixed string to match (use main)
; NB The characters are independent. word2 can be valid even if word isn't.

wildcard_mask
 FNJSR "R1-R3,R5"		; R5 corrupted as scans string
 MOV R0,#1
 FNSTR R0,fnd_word
 ORR R0,R0,R0,LSL#16
 FNSTR R0,fnd_word2		; initialise both words to no good
 FNLDR R1,fnd_tree		; tree start
 MOV R2,R1			; current pointer
loop$l
 LDR R0,[R2],#4			; get node type
 TEQ   R0,#2
 TEQNE R0,#4
 FNRTS EQ			; fail on an OR or a range
 TEQ R0,#0
 LDR R3,[R2],#4			; offset of left node or string length
 ADDNE R2,R1,R3			; take left branch (eg conjunction)
 BNE loop$l			; carry on down the tree if not string
 CMP R3,#0
 FNRTS LE			; no chars in the string
 LDR R0,[R2]			; first character
 TEQ R0,#'<'<<8			; start of line?
 ADDEQ R2,R2,#4
 SUBEQ R3,R3,#1
 MOVEQ R0,#2
 BEQ first$l			; first character is start of line
 BL wildcard_getmask		; get first character
 TEQ R0,#1
 ORRNE R0,R0,R0,LSL#16		; duplicate
first$l				; write first character word
 FNSTR R0,fnd_word
second$l			; do the second character
 BL wildcard_getmask		; R0=second character
 MOV R1,R0			; save
 BL wildcard_getmask		; R0=third character
 ORR R1,R1,R0,LSL#16		; complete second word
 FNSTR R1,fnd_word2
 FNRTS

 LOCAL

;E R2=address of next character (32 bit) of string
;  R3=number of characters left in string
;  R5=search flags
;X R0=mask of form &yyxx where x is original and y transverse case.
;  OR 1 if R0 was out of range (>&FF) or there wasn't one
;  R2,R3,R5 (case sensitive bit) updated

wildcard_getmask
 FNJSR
next$l				; get next character
 SUBS R3,R3,#1			; do another character
 MOVLT R0,#1
 FNRTS LT			; there wasn't one
 LDR R0,[R2],#4			; get next character
 TEQ R0,#'+'<<8
 ORREQ R5,R5,#zsearch_CaseSensitive
 BEQ next$l			; it matched a null character
 TEQ R0,#'-'<<8
 BICEQ R5,R5,#zsearch_CaseSensitive
 BEQ next$l
 TEQ R0,#'<'<<8
 TEQNE R0,#'>'<<8
 BEQ next$l			; these match null strings
 CMP R0,#&100
 MOVCS R0,#1
 FNRTS CS			; matched one unknown character
 MOV R14,R0			; default swapped case character
 TST R5,#zsearch_CaseSensitive
 BNE a$l			; case sensitive
 CMP R0,#'A'
 BCC a$l
 CMP R0,#'z'
 BHI a$l
 CMP R0,#'a'
 SUBCS R14,R0,#'a'-'A'
 CMP R0,#'Z'
 ADDLE R14,R0,#'a'-'A'
a$l
 ORR R0,R0,R14,LSL#8
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Main match routine to match an arbitrary tree			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=node offset R1=text offset/-1 to reset R2=text len
;  R3=flags (b0=case sensitive)
;  R4=search tree R9=text address
;X R0=offset of text after match / -1 if none |
;  Matching nodes have
;  ;E R8=address of the data for this node (node start+4)
;     R1=offset to look for match
;     R2=text len R3=flags R4=search tree R9=text addr
;  ;X Return via LDMFD R13!,{R1,R8,PC}
;     R0=offset after the match / -1 if none.
;  Reset nodes are as above except R1=-1 and R0 need not be
;  returned.

wildcard_match
 STMFD R13!,{R1,R8,R14}
 ADD R8,R0,R4			; address of node
 LDR R0,[R8],#4			; type
 CMN R1,#1
 BEQ reset$l
 ADD PC,PC,R0,LSL#2		; dispatch
 DCD 0
 B wildcard_0
 B wildcard_1
 B wildcard_2
 B wildcard_3
 B wildcard_4
 B wildcard_5
 B wildcard_6
reset$l
 ADD PC,PC,R0,LSL#2		; dispatch
 DCD 0
 B wild_reset_0
 B wild_reset_1
 B wild_reset_2
 B wild_reset_3
 B wild_reset_4
 B wild_reset_5
 B wild_reset_6

wildcard_0
 STMFD R13!,{R2-R5}
 LDR R5,[R8]			; number of chars
 TST R5,#1<<31
 BNE fail$l			; already matched
 ORR R0,R5,#1<<31
 STR R0,[R8],#4			; mark matched
 ADD R1,R9,R1			; address of text
 ADD R4,R9,R2			; address of text end
match$l				; match loop
 CMP R5,#0
 BLE matched$l			; matched (null string left)
 LDR R0,[R8],#4			; get next number
 SUB R5,R5,#1			; reduce length
 CMP R0,#&100
 BCS special$l			; special code
 CMP R1,R4
 BCS fail$l			; run out of text
 LDRB R14,[R1],#1
 TST R3,#1
 BNE case$l			; case sensitive
 CMP R14,#'a'
 RSBHSS R2,R14,#'z'
 SUBHS R14,R14,#32		; force upper case
 CMP R0,#'a'
 RSBHSS R2,R0,#'z'
 SUBHS R0,R0,#32
case$l				; R0,R14 in correct cases to be compared
 TEQ R0,R14
 BEQ match$l			; matched
fail$l
 LDMFD R13!,{R2-R5}
 MOV R0,#-1
 LDMFD R13!,{R1,R8,PC}
matched$l
 LDMFD R13!,{R2-R5}
 SUB R0,R1,R9			; offset of next char
 LDMFD R13!,{R1,R8,PC}
special$l			; code >= &100
 TEQ R0,#'+'<<8
 BEQ caseon$l			; case sensitive on
 TEQ R0,#'-'<<8
 BEQ caseoff$l			; case sensitive off
 TEQ R0,#'<'<<8
 BEQ linestart$l		; null char at line start
 TEQ R0,#'>'<<8
 BEQ lineend$l			; null char at line end
 CMP R1,R4
 BCS fail$l			; out of text
 LDRB R14,[R1],#1
 TEQ R0,#'#'<<8
 BEQ match$l			; # always matches
 TEQ R0,#'.'<<8
 BEQ dot$l			; . matches all but CR
 TEQ R0,#'o'<<8
 BEQ slasho$l			; o matches all but a '.'
 TEQ R14,R0,LSR#8		; not a special character
 BEQ match$l			; match
 B fail$l			; no match
linestart$l
 SUBS R0,R1,R9
 BEQ match$l			; match start of line/file
 B fail$l			; no match
lineend$l
 CMP R1,R4
 BCS match$l			; match end of line/file
 B fail$l			; no match
caseon$l
 ORR R3,R3,#1
 B match$l			; case sensitive
caseoff$l
 BIC R3,R3,#1
 B match$l			; not case sensitive
dot$l				; match all but LF
 TEQ R14,#10
 BNE match$l			; matches non CR
 B fail$l			; no match
slasho$l
 TEQ R14,#'.'
 BNE match$l			; matches non "."
 B fail$l

wildcard_1
 LDR R0,[R8,#8]
 CMP R0,#0
 BPL wd3			; already started
wd2
 LDR R0,[R8]
 BL wildcard_match
 CMP R0,#0
 LDMMIFD R13!,{R1,R8,PC}	; no more first matches
 STR R0,[R8,#8]			; offset after first match
wd3
 MOV R1,R0
 LDR R0,[R8,#4]
 BL wildcard_match		; try second match
 CMP R0,#0
 LDMPLFD R13!,{R1,R8,PC}	; match found
 MVN R1,#0
 LDR R0,[R8,#4]
 BL wildcard_match		; reset second match
 LDMFD R13,{R1}
 B wd2				; do next first match

wildcard_2
 LDR R0,[R8,#8]
 CMP R0,#0
 BPL wd4			; on second half
 LDR R0,[R8]
 BL wildcard_match		; next first match
 CMP R0,#0
 LDMPLFD R13!,{R1,R8,PC}	; match found
 MOV R0,#0
 STR R0,[R8,#8]			; mark second
wd4
 LDR R0,[R8,#4]
 BL wildcard_match		; next second match
 LDMFD R13!,{R1,R8,PC}

wildcard_3
 LDR R0,[R8,#4]
 CMP R0,#0
 BMI wd9			; not yet started
 MVN R1,#0
 LDR R0,[R8]
 BL wildcard_match		; reset node
 LDR R0,[R8]
 LDR R1,[R8,#4]
 BL wildcard_match		; look for first match
 CMP R0,#0
 LDMMIFD R13!,{R1,R8,PC}	; none found
 STR R0,[R8,#4]			; now pointer is after this first match
 LDMFD R13!,{R1,R8,PC}
wd9
 MOV R0,R1			; at start return current pointer
 STR R0,[R8,#4]			; (a 0*string match)
 LDMFD R13!,{R1,R8,PC}

wildcard_6
 LDR R0,[R8,#4]
 CMP R0,#0
 BPL wd22			; second time around
 STR R1,[R8,#4]			; save the start offset
wd23
 STMFD R13!,{R1}		; save the offset
 MVN R1,#0
 LDR R0,[R8]
 BL wildcard_match		; reset the node
 LDMFD R13!,{R1}		; restore the offset
 LDR R0,[R8]
 BL wildcard_match		; find a match
 CMP R0,#0
 BMI wd24			; couldn't find any more
 CMP R0,R1			; match did not increase ?
 MOVGT R1,R0
 BGT wd23			; found a match so carry on
wd24
 LDR R0,[R8,#4]			; get the start posn
 CMP R1,R0
 MVNLE R0,#0			; haven't moved on so no match
 MOVGT R0,R1			; end of match now here
 LDMFD R13!,{R1,R8,PC}
wd22
 MVN R0,#0			; can't match (done most)
 LDMFD R13!,{R1,R8,PC}

wildcard_4
 CMP R1,R2
 BCS wd8			; out of text
 LDR R0,[R8]
 TST R0,#1<<31
 BNE wd8			; already matched
 ORR R0,R0,#1<<31
 STR R0,[R8],#4			; mark already matched
 LDRB R1,[R9,R1]		; next byte
wd5
 TST R0,#&FF
 BEQ wd7			; no more ranges - not in any range
 SUB R0,R0,#1			; reduce range number
 LDRB R14,[R8],#4		; read range lower bound
 CMP R1,R14
 BCC wd5			; not in range
 LDRB R14,[R8,#-3]		; read range upper bound
 CMP R14,R1
 BCC wd5			; not in range
 ORR R0,R0,#&FF			; in a range so mark matched
wd7
 TST R0,#1<<30
 EORNE R0,R0,#&FF		; NOT ^ operator
 TST R0,#&FF
 BEQ wd8			; no match
 LDMFD R13!,{R1,R8,R14}
 ADD R0,R1,#1			; new file offset
 MOV PC,R14
wd8
 MVN R0,#0			; no match
 LDMFD R13!,{R1,R8,PC}

wildcard_5
 LDR R0,[R8]
 BL wildcard_match		; next match
 CMP R0,#0
 LDMLEFD R13!,{R1,R8,PC}	; no match
 STR R1,[R8,#4]			; save start offset of match
 STR R0,[R8,#8]			; save end offset of match
 LDMFD R13!,{R1,R8,PC}

wild_reset_0
wild_reset_4
 LDR R0,[R8]
 BIC R0,R0,#1<<31
 STR R0,[R8]
 LDMFD R13!,{R1,R8,PC}

wild_reset_1
wild_reset_2
 STR R1,[R8,#8]
 LDR R0,[R8]
 BL wildcard_match
 LDR R0,[R8,#4]
 BL wildcard_match
 LDMFD R13!,{R1,R8,PC}

wild_reset_3
wild_reset_6
 STR R1,[R8,#4]
 LDMFD R13!,{R1,R8,PC}

wild_reset_5
 LDR R0,[R8]
 BL wildcard_match		; pass on
 LDMFD R13!,{R1,R8,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search through a line string					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=length of the string to search
;  R1=pointer to string to search
;  R2=offset in string to search from
;  R4=search direction R5=search flags
;X The string searched through. \< and \> match start and end of string only.
;  R0=offset in string of match (if found)
;     -1 if end of string reached but no match found
;     -2 if Escape pressed #
;  R1=offset in string of end of match (valid if R0 +ve)
;  Internal:	R2=text len
;		R3=flags: b0=case sensitive
;			  b1=display % in line (eg raw search of file)
;		R4=tree address R5=direction R6=fnd_word
;		R7=second char/1 R8=third char/1
;		R9=text address
;		R10=spare
;		R11=current offset
;  NB Word aligned offsets need not be at word aligned addresses.
;  Searches through a text segment (\<=start of segment)

st_CaseSensitive	*	(1:SHL:0)
st_DisplayPercent	*	(1:SHL:1)

search_text
 FNJSR "R2-R11"
 MOV R3,#0			; flags
 TST R5,#zsearch_CaseSensitive
 ORRNE R3,R3,#st_CaseSensitive
 TST R5,#zsearch_NoHourglass
 ORREQ R3,R3,#st_DisplayPercent
 MOVS R5,R4			; save search direction
 MOVEQ R5,#1
 MOV R9,R1			; address
 MOV R11,R2			; start offset
 MOV R2,R0			; length
 FNLDR R4,fnd_tree		; address of search tree
 FNLDR R6,fnd_word		; first char match
 FNLDR R7,fnd_word2		; 2nd & 3rd chars to match
 MOV R8,R7,LSR#16
 BIC R7,R7,R8,LSL#16		; separate
 TEQ R6,#2			; start of segment only?
 BEQ start$l
 TEQ R6,#1
 TEQEQ R7,#1
 TEQEQ R8,#1
 BEQ complex$l			; don't know any of the letters
 SUB R11,R11,R5			; compensate
 B first$l
loop$l
 LDR R0,[R13,#8]		; get input search dir off stack
 TEQ R0,#0			; return failure if it's zero
 BEQ end$l
first$l
 ADD R11,R11,R5			; next offset
 CMP R11,R2
 BCS end$l			; off start or end
 ADD R0,R9,R11			; actual address to be used
 AND R14,R0,#3			; word offset 0,1,2,3
 TEQ R14,R5,LSR#30		; test 0 aligned / 3 aligned
 BEQ aligned$l			; aligned for a word search
test$l				; test to see if the search matches
 TEQ R6,#1
 BEQ a$l
 LDRB R0,[R9,R11]
 TEQ R0,R6,LSR#24		; case1 match sets EQ
 EORNE R0,R0,R6
 TSTNE R0,#&FF			; case2 match sets EQ
 BNE loop$l			; fail
a$l
 TST R11,#&0F			; first time need to retest for escape
 BLEQ escape$l
 TEQ R7,#1
 BEQ b$l
 ADD R1,R11,#1
 CMP R1,R2
 BCS loop$l			; run out of string so fail - NB could
 LDRB R0,[R9,R1]		; be going backwards
 TEQ R0,R7,LSR#8		; case1 match sets EQ
 EORNE R0,R0,R7
 TSTNE R0,#&FF			; case2 match sets EQ
 BNE loop$l			; fail
b$l
 TEQ R8,#1
 BEQ c$l
 ADD R1,R11,#2
 CMP R1,R2
 BCS loop$l			; run out of string so fail - NB could
 LDRB R0,[R9,R1]		; be going backwards
 TEQ R0,R8,LSR#8		; case1 match sets EQ
 EORNE R0,R0,R8
 TSTNE R0,#&FF			; case2 match sets EQ
 BNE loop$l			; fail
c$l				; do full test
 MOV R0,#0
 MOV R1,#-1
 BL wildcard_match		; reset nodes
 MOV R0,#0
 MOV R1,R11
 BL wildcard_match		; look for match
 CMP R0,#0
 BMI loop$l			; no match
 MOV R1,R0			; offset of match end
 MOV R0,R11			; offset of match start
 FNRTS
end$l
 MOV R0,#-1			; run out of string to search
 FNRTS
aligned$l
 TEQ R6,#1
 BEQ test$l			; no quick word
 CMP R5,#0
 BMI room$l
 SUB R0,R2,R11			; amount free
 CMP R0,#5			; +1 buffer on end for test$l
 BGE forward$l
 B test$l
room$l				; is there room for a backward search
 CMP R11,#5
 BLT test$l			; haven't got 5 chars to look for
 SUB R11,R11,#3			; first word to look at
 B backward$l			; R9+R11 word aligned
forward$l			; fast search for a character forward
 LDR R0,[R9,R11]		; get word aligned value
 EOR R1,R0,R6
 EOR R0,R0,R6,ROR#8		; get masks (upper and lower case)
 TST   R0,#&FF000000
 TSTNE R0,#&00FF0000
 TSTNE R0,#&0000FF00
 TSTNE R0,#&000000FF
 TSTNE R1,#&FF000000
 TSTNE R1,#&00FF0000
 TSTNE R1,#&0000FF00
 TSTNE R1,#&000000FF
 BEQ test$l			; there was a match in these 4 chars
 ADD R11,R11,R5,LSL#2		; move on 4 bytes
 SUB R0,R2,R11
 CMP R0,#5			; +1 buffer on end for test$l
 BLT test$l
 TST R11,#&FC			; trap on 0000 00xx at bottom
 BNE forward$l
 BL escape$l
 BVC forward$l
 FNRTS
backward$l			; fast search for a character backward
 LDR R0,[R9,R11]
 EOR R1,R0,R6
 EOR R0,R0,R6,ROR#8		; get masks
 TST   R0,#&FF000000
 TSTNE R0,#&00FF0000
 TSTNE R0,#&0000FF00
 TSTNE R0,#&000000FF
 TSTNE R1,#&FF000000
 TSTNE R1,#&00FF0000
 TSTNE R1,#&0000FF00
 TSTNE R1,#&000000FF
 ADDEQ R11,R11,#3
 BEQ test$l			; there was a match in these 4 chars
 ADDS R11,R11,R5,LSL#2		; move on 4 bytes
 CMP R11,#5
 ADDLT R11,R11,#3
 BLT test$l			; back to slow search
 TST R11,#&FC
 BNE backward$l
 BL escape$l
 BVC backward$l
 FNRTS
escape$l			; check for escape + possibly show %
 SWI XOS_ReadEscapeState	; doesn't corrupt R14 as in user mode
 MOVCS R0,#-2			; escape
 FNRTS CS
 TST R3,#st_DisplayPercent
 MOVEQ PC,R14			; log flag not set
 MOV R0,R11
 MOV R1,R2
 B long_op_display		; log the offset on the hourglass
start$l				; match at offset R11=0 only
 CMP R5,#0
 BMI startbac$l			; already going backwards - ok
 CMP R11,#0
 BGT end$l			; fails if wasn't at beginning of line
startbac$l
 MOV R11,#0			; jump to the start of the line
 MOV R5,#-1			; trick - always go backwards
 TEQ R7,#1
 MOVEQ R6,R7
 ORRNE R6,R7,R7,LSL#16		; shift down first character
 MOV R7,R8			; shift down second
 MOV R8,#1			; no third
 B test$l
complexloop$l
 LDR R0,[R13,#8]		; get input search dir off stack
 TEQ R0,#0			; return failure if it's zero
 BEQ end$l
complex$l			; no optimisations possible
 CMP R11,R2
 BCS end$l			; off start or end
 TST R11,#&0F			; check for escape every 16 chars
 BLEQ escape$l
 MOV R0,#0
 MOV R1,#-1
 BL wildcard_match		; reset nodes
 MOV R0,#0
 MOV R1,R11
 BL wildcard_match		; look for match
 TEQ R5,#0
 BEQ end$l
 CMP R0,#0
 ADDMI R11,R11,R5		; next offset
 BMI complexloop$l		; no match
 MOV R1,R0			; offset of match end
 MOV R0,R11			; offset of match start
 FNRTS

;E R0=search string R5=search flags R8/R9/ R8=0 for none
;X fnd_tree and find_word set up for the search WK,WD #
;  b23 of R5 set if wild_conv_chars expanded \s.

search_init
 FNJSR "R1-R2"
 TST R5,#zsearch_NoMacros
 BLEQ replace_macros		; replace macros -> wimp_kbdbuf
 BLVC wild_conv_chars		; convert chars -> wimp_data
 MOVVC R1,R0			; len
 FNLDR R0,wimp_data,VC
 BLVC wildcard_tree		; create tree -> fnd_tree
 BLVC wildcard_mask		; get mask for first char / 1 if none
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Main replace code					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R1=output
;     0=selective (find next match and highlight it & open box if not open)
;     1=global replace (no prompting)
;     2=replace in selection (no prompting)
;  R3=start offset
;  R4=direction (+1/-1)
;  R5=search flags (as for search_data; b21 ignored)
;  R8/R9=current window (to start on if more than one file)
;X fnd_string searched for and replaced with fnd_replace #
;  NB S & R takes part in second half of buffer to prevent shifting.

replace_data
 FNJSR "R10"
 BIC R5,R5,#zsearch_MatchAtCursor
 ADR R10,sub$l
 BL do_longop
; BL save_window_status
; BL new_window_status
 FNRTS

sub$l
 FNJSR "R1-R11"
 MOV R7,R1			; R7=output type
 BL get_wind_off		; R0=window offset
 ADDS R6,R0,#0			; R6=window offset of source window
 FNRTS MI
; CMP R7,#2
; BLEQ set_up_cur_pos_at_sel
 FNLDR R0,fnd_string		; get search string
 BL search_init			; put search string into the correct form
 FNRTS VS			; and create the fnd_tree
 ADD R3,R3,R4			; first offset to try
 TST R5,#zsearch_RawSearch
 ORREQ R5,R5,#zsearch_NoHourglass
 CMP R7,#1
 BLCS start_operation		; start op for global replace
 FNRTS VS
next$l				; R3=next posn to try (In start/stop cycle)
 MOV R0,R6			; set up R8/R9 of the search window
 BL conv_wind_off		; (may change across calls)
 LDR R0,[R9,#f_len]
 CMP R3,R0
 BCS nextfile$l			; off start or end of file
 TST R5,#zsearch_RawSearch
 BNE raw$l			; do a raw search
 TST R5,#zsearch_NoHourglassPercent
 MOVEQ R0,R3
 BLEQ sumlen_long_op_display
 BLVC search_line_setup		; set up R1,R2,R3,R10
 BVS error$l
 PUSH "R1"			; save address of the line
 MOV R0,R10			; line length
 BL search_text			; R0=match R1=end of next match in the line
 MOV R11,R1			; end of match
 PULL "R1"			; restore line start
 BVS error$l
 CMP R0,#-1
 BLT esc$l
 MOV R2,R0			; match offset / -1
 BL search_line_delimit		; get end of match offset in R11
 BLVC search_line_end		; R2=match offset R3=next posn to try
 BVS error$l
 MOVS R0,R2
 BMI next$l			; no match
; B match$l			; found a match
; fall through...
match$l				; R0=match st R1=searched str R11=match end
 BL replace_data_buffer
 BVS error$l
 ADDS R3,R11,#0			; new offset to start from
 BPL next$l			; go onto next match (buffering them)
 CMP R7,#1
 BLCS stop_operation
 CMP R7,#1
 BLCS adjust_vertical_extent	; ???
 FNRTS				; not in sel or to eof...
esc$l
 CMP R7,#1
 BLCS stop_operation
 MOVVC R0,#-2
 BLVC replace_data_buffer	; set up the return values
 FNRTS
raw$l
 BL split_for_search		; R0=apparant start
 BVS error$l
 MOV R1,R0
 LDR R0,[R9,#f_len]
 MOV R2,R3
 PUSH "R1"
 BL search_text			; R0=match R1=match end
 MOV R11,R1			; R11=match end
 PULL "R1"			; R1=searched string
 BVS error$l
 CMP R0,#-1
 BMI esc$l
 ADDGT R3,R0,R4			; next offset to look at
 BGT match$l
 MOVEQ R3,#-1			; finished this file
 B next$l
nextfile$l			; move onto next file
 CMP R7,#1
 BLCS stop_operation
 FNRTS VS			; stop on this file
 CMP R7,#1
 BLCS adjust_vertical_extent	; ???
 TST R5,#zsearch_AllWindows
 BEQ end$l			; all files option not supported
 MOV R0,R6			; current file
 BL next_wind_offset
 FNRTS VS
 MOVS R6,R0
 BMI end$l			; run out of windows
 BL conv_wind_off		; set up R8/R9
 CMP R7,#1
 BLCS start_operation		; start on the new file
 FNRTS VS
 CMP R4,#0
 MOVPL R3,#0			; file length may be 0 so goto next$l
 LDRMI R3,[R9,#f_len]
 SUBMI R3,R3,#1			; get the start offset
 B next$l			; try again (the offset may be -1)
end$l
 MOV R0,#-1			; no more matches
 BL replace_data_buffer		; set up the return values
 FNRTS
error$l				; cancel op if an error in global search
 CMP R7,#1
 BCC errend$l
 MOV R1,R0
 BL stop_operation
 MOVVC R0,R1			; restore (bearing error pointer in mind)
errend$l
 FNRTV

;set_up_cur_pos_at_sel
; FNJSR "R1,R2,R8,R9,R10"
; BL get_selection
; CMP R4,#0
; MOVPL R0,R1
; ADDMI R0,R1,R2
; FNLDR R10,car_cursor
; BL goto_file_offset
; FNRTS

 LOCAL

;E R0=match offset
;  R1=pointer to string that was searched through
;  R4=search dir
;  R5=search flags
;  R7=0=selective 1=global 2=in selection...
;  R8/R9=window
;  R11=end of match offset
;X If R0<0 on entry the returns R11=R0 (closing Replace? window if open)
;  Otherwise sets up fnd_string2 and then:
;  If R7=0 then makes the match the selected area and jumps there
;	   then opens NextBox and returns R11=-1
;  If R7=1 then performs the replacement and R11=new offset to start from
;  If R7=2 then performs the replacement and R11=new offset to start from
;          or R11 = -1 if outside selection...

replace_data_buffer
 FNJSR "R1-R10"
 ADDS R10,R0,#0			; save start of match offset
 BMI nomatch$l			; no more matches
 MOV R0,R6
 BL conv_wind_off		; set up R8/R9
 BL replace_find_string		; set up fnd_replace2
 FNRTS VS
 TEQ R7,#0
 BNE global$l
 MOV R2,R10			; start offset of region
 MOV R3,R11			; end offset of region
 BL select_region
 BLVC update_wind_state
 FNLDR R10,car_selection
 BLVC make_cursor_visible	; make match selected and visible
 ;SWI &107
 ;MOVVC R1,R8			;this doesn't fix things... :(
 ;BLVC reopen_window ; reopen_window again...! TT.
 FNRTS VS
 MOV R11,#-1			; finished (for now)
 BL get_NextBox			; R7=Next Box
 LDR R0,[R7,#8]			; window handle
 CMP R0,#0
 BLMI create_open_leaf		; open next window if not already open
 FNRTS
nomatch$l
 MOV R11,#-1			; finish
 TEQ R7,#0
 FNRTS NE			; not a selective replace
 BL get_NextBox			; R7=Next box
 LDR R0,[R7,#4]			; window handle
 CMP R0,#0
 FNRTS LE			; not open
 BL close_leaf_window		; close the window
 BLVC clear_selection		; clear currently selected area
 FNRTS
global$l
 CMP R7,#2
 BLEQ testforinsel
 BEQ notinsel$l
 MOV R0,R10			; match offset
 MOV R1,R11			; match end
 BL replace_string		; R1=offset after replace has been done
 FNRTS VS
 CMP R4,#0
 SUBMI R11,R10,#1
 MOVPL R11,R1			; next offset
 FNRTS
notinsel$l
 MOVS R11,#-1			; flagged
; ADR R0,fakeerror
 FNRTS
;fakeerror
 ; = "Error",0
 ; ALIGN

testforinsel
 FNJSR "R0,R1,R2,R8,R9"
; MOV R7,R0
 BL get_selection
 CMP R4,#0
 BMI backwards$l
 ADD R1,R1,R2
 CMP R10,R1
 MOVCSS R0,#0
 FNRTS
backwards$l
 CMP R10,R1
 MOVCCS R0,#0
 FNRTS

 LOCAL

;E R0=file offset of match start R1=file offset of match end
;  R8/R9
;X Match replaced with fnd_replace2 string (uses e_replace) #
;  R1=new file offset of match end (after the replace!)

replace_string
 FNJSR "R2-R4,R10-R11"
 SUB R2,R1,R0			; length of match
 MOV R1,R0			; file offset of match
 FNLDR R3,fnd_replace2		; address of len,replacement data
 LDR R4,[R3],#4			; length of replacement string
 ADD R10,R1,R4			; file offset after replacement
 LDR R14,[R9,#f_flags]
 ORR R14,R14,#flags_UnlinkCursor
 STR R14,[R9,#f_flags]		; unlink input
 MOV R11,#e_replace		; replace area call
 BL call_mode			; file flags may alter! (text altered *)
 LDR R14,[R9,#f_flags]		; save error pointer in R0
 BIC R14,R14,#flags_UnlinkCursor
 STR R14,[R9,#f_flags]		; relink caret
 MOVVC R1,R10			; end offset after the replacement
 FNRTS

 LOCAL

;E fnd_tree set up, fnd_replace contains string
;  R1=string that was searched through
;X fnd_replace2 contains length (#4), replace string #

replace_find_string
 FNJSR "R1-R11"
 MOV R9,R1			; pointer to text that was searched through
 FNLDR R10,fnd_replace2		; output buffer
 MOV R11,#0			; known length of buffer
 ADD R6,R10,#4			; current pointer (leave 4 bytes for len)
 FNLDR R1,fnd_replace		; replace string
 MOV R5,#0			; search flags
loop$l
 MOV R0,#8
 BL rep_find_free		; make sure 8 bytes free
 FNRTS VS
 LDRB R0,[R1]
 TEQ R0,#'&'
 BEQ substitute$l		; special character
 BL wild_get_char		; R0,R2=data alters R5 flags
 CMP R2,#0
 BLT end$l			; end of string
a$l
 STRB R0,[R6],#1
 MOV R0,R0,LSR#8
 SUBS R2,R2,#1
 BGT a$l
 B loop$l
out$l
 STRB R0,[R6],#1		; byte to replace
 B loop$l			; do next
substitute$l
 LDRB R14,[R1,#1]!		; next char
 TEQ R14,#'&'
 ADDEQ R1,R1,#1
 BEQ out$l			; && structure
 CMP R14,#'1'
 BCC out$l
 CMP R14,#'9'
 BHI out$l
 ADD R1,R1,#1			; next character
 SUB R0,R14,#'0'		; number of ;{}; pair to find
 BL replace_find_bracket	; R0=offset R2=len
 MOV R3,R0			; save offset
 ADD R0,R2,#4
 BL rep_find_free		; enlarge buffer
 FNRTS VS
 PUSH "R1"
 ADD R1,R9,R3			; source
 MOV R3,R2			; len
 MOV R2,R6			; dest
 ADD R6,R6,R3			; new dest
 BL move_bytes			; copy string
 PULL "R1"
 B loop$l
end$l
 SUB R0,R6,R10			; string length
 SUB R0,R0,#4			; omitting length word!
 FNLDR R1,fnd_replace2
 STR R0,[R1]			; write the string length in first word
 FNRTS

;E R0=amount to have free R6=current posn R10=ptr R11=len
;X R0 bytes free in buffer R6,R10-R11 updated #

rep_find_free
 FNJSR
 SUB R14,R6,R10			; offset
 SUB R14,R11,R14		; current amount free
 CMP R14,R0
 FNRTS GE			; got enough free
 SUB R6,R6,R10			; offset
 PUSH "R1"
 ADD R11,R11,R0			; need R0 more free
 ADD R11,R11,#&40
 MOV R0,R10
 MOV R1,R11
 BL heap_ensure			; ensure enough free
 PULL "R1"
 MOVVC R10,R0
 FNSTR R0,fnd_replace2,VC	; new pointers
 ADDVC R6,R6,R10		; new pointer
 FNRTS

 LOCAL

;E R0=n (1-9) from &n and fnd_tree set up
;X R0=match OFFSET (from fnd_tree) of n'th {} string / 0 if not found
;  R2=length of string (maybe null) / 0 if not found #

replace_find_bracket
 FNJSR "R3-R4"
 MOV R3,R0			; count
 FNLDR R4,fnd_tree
 MOV R0,#0			; node offset
 BL rfb_sub			; R0=address of {} node data if matched
 MOVCC R0,#0
 MOVCC R2,#0
 FNRTS CC			; not found
 LDR R2,[R0,#4]			; end offset
 LDR R0,[R0]			; start offset
 SUB R2,R2,R0			; len
 FNRTS

 LOCAL

;E R0=node offset
;  R3=number left (&n number, decremented after each &n find)
;  R4=fnd_tree
;X R3=new count, CC to continue / CS if found match
;  R0=node data addr (of {} node) |

rfb_sub
 FNJSR "R1"
node$l				; R0=node offset R3=num left
 ADD R1,R4,R0			; address of node
 LDR R0,[R1],#4			; node type
 TEQ R0,#5
 BEQ branode$l			; {} node
 TEQ   R0,#0
 TEQNE R0,#4
 BEQ endnode$l			; string or range
 TEQ   R0,#3			; a ;* node
 TEQNE R0,#6			; or a ;% node so jump
 BEQ downnode$l			; to its submember
 LDR R0,[R1],#4			; sequential or OR
 BL rfb_sub			; do left branch (rescursive)
 FNRTS CS			; found answer
downnode$l
 LDR R0,[R1]
 B node$l
branode$l
 SUBS R3,R3,#1			; reduce count
 BGT downnode$l			; not reached count yet
 ADD R0,R1,#4			; node data address
 SUBS R0,R0,#0			; sec (found)
 FNRTS
endnode$l
 ADDS R0,R0,#0			; clc
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search as you type				      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Search as you type uses a data block pointed to by key_off:
;  #0 = length of current search as you type string (n)
;  #4 = Original base file offset of search (in case of cancel)
;  #8 = reserved
; #&C = reserved
; &10/&14 = Current base of search*2 (null string match) (always used)
; &18/&1C = First match of first letter, end of match offset (if &18 +ve)
;	    -1 => Not saved - eg search string contains \ commands
;	    -2 => Fail - no match found
; &20/&24 = First match of first two letters/-1/-2 , end offset
; ...
; &10+n*8 = Start of match it's sitting at (full n words)/-2 , end offset

 LOCAL

;E R0-R2,R8-R10 from command entry point R4=dir (+1/-1=cS/cR)
;X as for the command - corrupts R0-R11

search_as_you_type
 FNJSR
 TEQ R2,#6
 BEQ prompt$l			; starting (init key_off)
 TEQ R2,#1
 BEQ ret$l			; user pressed return in minibuffer
 TEQ R2,#0
 BEQ search$l			; direct call
 TEQ R2,#7
 BEQ key$l			; key pressed
 SUBS R1,R2,#&8000
 CMP R1,#&200
 BCC prekey$l			; test for ctrl-S etc
 FNRTS
key$l
 BL key_match
 FNRTS VS
 CMP R0,#-2
 ADREQ R0,err$l
 BEQ p$l
 CMP R0,#0
 MOVMI R4,R4,LSL#1
 CMP R4,#1
 ADREQ R0,for$l
 CMP R4,#2
 ADREQ R0,ffail$l
 CMP R4,#-1
 ADREQ R0,bac$l
 CMP R4,#-2
 ADREQ R0,bfail$l
p$l
 BL minibuffer_prompt_token
 FNRTS
prompt$l			; starting search (init key_off)
 CMP R4,#0
 ADRPL R0,for$l
 ADRMI R0,bac$l
 BL minibuffer_prompt_token	; insert help string
 FNRTS VS
 FNLDR R1,key_off		; buffer
 LDR R0,[R10,#c_off]
 STR R0,[R1,#4]			; set up cancel base offset
 BL reset_key_off		; reset to a null string
 FNRTS
search$l
 MOV R2,R0			; save the string
 LDR R0,[R10,#c_off]
 BL reset_key_off
 MOVVC R0,R2
 BLVC key_match			; jump to the match
 FNRTS
prekey$l
 BL key_new_dir			; see if cS/cR etc
 FNRTS
ret$l
 BL new_search_string		; R2=1 return - install as current string
 MOVVC R0,#0			; close minibuffer
 FNRTS
for$l	FNS ("zap_p_srchfwd")
bac$l	FNS ("zap_p_srchbwd")
ffail$l FNS ("zap_p_srchfwf")
bfail$l FNS ("zap_p_srchbwf")
err$l	FNS ("zap_p_srcherr")

;E R0=file offset for base
;X key_off buffer reset to null string with this base
;  (for when you start with a new unrelated string)

reset_key_off
 FNJSR "R1"
 FNLDR R1,key_off		; buffer
 STR R0,[R1,#&10]		; current base (null string match)
 STR R0,[R1,#&14]		; and end offset
 MOV R0,#0
 STR R0,[R1]			; null string to start with
 FNRTS

 LOCAL

;E R0=search string R4=dir +1/-1 R8/R9 for search
;X key_off buffer enlarged to the length of this search string and
;   padded with -1's. String searched for (from last posn if available)
;   and final entry in key_of buffer filled with match/-2. #
;  Match jumped to if possible.
;  R0=-1 if failed (for prompt (fail)).
;  R0=-2 if failed due to a search error.

key_match
 FNJSR "R1-R11"
 MOV R11,R0			; save search string
 BL str_len			; get length
 MOV R6,R0			; save length
 FNLDR R0,key_off		; buffer
 MOV R1,#&20
 ADD R1,R1,R6,LSL#3		; size buffer needs to be
 BL heap_ensure
 FNRTS VS
 FNSTR R0,key_off		; buffer correct size
 ADD R10,R0,#&10		; start of string buffer
 LDR R0,[R0]			; current size of string stored
 MOV R14,#-1
a$l
 CMP R0,R6
 ADDLT R0,R0,#1
 STRLT R14,[R10,R0,LSL#3]
 BLT a$l			; fill buffer up to current point (R0>=R6)
 STR R6,[R10,#-&10]		; length of buffered string now R6
 ADD R1,R10,R6,LSL#3		; address of this entry
 LDR R0,[R1]
 CMP R0,#-1
 BLT fail$l			; was no match there
 LDRGT R1,[R1,#4]
 BGT stored$l			; already know answer (eg backwards)
 CMP R6,#0
 LDRLE R1,[R10]
 BLE stored$l			; null string - start of buffer
 BL default_search_flags	; get case sensitive bits etc
 FNRTS VS
 ORR R5,R5,#zsearch_NoMacros
 BIC R5,R5,#zsearch_AllWindows
 ORR R5,R5,#zsearch_ReturnEndOfMatch
 MOV R0,R11
 BL wild_conv_chars		; look at string (no macros to replace)
 FNRTS VS
 LDR R3,[R10]			; default start offset
 TST R5,#zsearch_WildConvChars
 BNE search$l			; string contains collapsed \ chars etc
 SUB R0,R6,#1
 LDR R0,[R10,R0,LSL#3]		; offset of one less letter match
 CMP R0,#-1
 BLT fail$l			; was no match
 MOVGT R3,R0			; use this offset
search$l			; R3=offset to start from
 MOV R0,R11
 MOV R1,#2			; no output
 SUB R3,R3,R4			; want to start at base
 LDR R14,[R9,#f_len]
 CMP R3,R14
 MOVGT R3,R14			; only allow it to go one byte off end
 BL search_data			; find next match R0=start R1=end
 BVS fail$l
 CMP R0,#0			; match offset
 BMI fail$l			; no match found
 STR R0,[R10,R6,LSL#3]!
 STR R1,[R10,#4]		; save the match limits
stored$l
 BL get_input_caret
 MOV R0,R1
 FNLDR R2,opt_flags
 ORR R14,R2,#flags_IgnoreInput
 FNSTR R14,opt_flags
 BL goto_file_offset		; move cursor
; SWI &107
 FNSTR R2,opt_flags		; restore
 MOVVC R0,#0			; found
 FNRTS
fail$l				; failed due to error or not found
 MOV R0,#-2
 STR R0,[R10,R6,LSL#3]		; mark as a fail
 MOVVC R0,#-1			; not found
 MOVVS R0,#-2			; error
 CMP R0,#0			; clv
 FNRTS

 LOCAL

;E R1=minibuf key (in a search as you type) R4=dir +1/-1 R8-R10
;X R0=key if you should pass it on /-1 if direction changed etc #

key_new_dir
 FNJSR "R1-R2"
 LDRB R0,[R8,#w_basemap]	; base map number
 BL find_key_entry		; R0=entry address (don't validate)
 FNRTS VS
 CMP R0,#0
 LDRGT R0,[R0]			; command address
 FNADR R2,ext1$l
 TEQ R0,R2
 BEQ jump$l			; ctrlS
 FNADR R2,ext2$l
 TEQ R0,R2
 BEQ jump$l			; ctrlR
 FNADR R2,ext3$l
 TEQ R0,R2
 BEQ cancel$l			; ctrlG
 FNADR R2,ext4$l
 TEQ R0,R2
 BEQ passon$l			; delete
 FNADR R2,ext5$l
 TEQ R0,R2
 BEQ passon$l			; return
 CMP R1,#&20
 BCC exec$l			; control code
 CMP R1,#&100
 BCC passon$l			; pass on normal keys
 TEQ R1,#&120
 BEQ passon$l			; shift space
 CMP R1,#&160
 BCC exec$l
 CMP R1,#&180
 BCC passon$l
 CMP R1,#&1C0
 BCC exec$l			; function and cursor keys
passon$l
 MOV R0,R1			; pass key on
 FNRTS
exec$l				; kill minibuffer then execute key
 ADD R0,R1,#&8000		; (so Escape does a Return first!!)
 FNRTS
jump$l				; ^S,^R to jump or change direction
 FNLDR R1,key_off		; buffer start
 FNLDR R0,mini_command
 TEQ R0,R2
 BNE newdir$l			; changing direction
 LDR R0,[R1]
 TEQ R0,#0
 BEQ recall$l			; substitute default string (main null)
 FNLDR R0,mini_ptr
 FNLDR R1,mini_mark
 ADD R0,R0,R1			; minibuffer string
 BL key_next_match		; jump to next match
 MOVVC R0,#-1			; no key to insert
 FNRTS
recall$l			; recall previous search string
 FNLDR R0,fnd_string
 BL minibuffer_write		; copy default to minibuffer
 MOVVC R0,#-1			; no key to insert
 FNRTS
newdir$l
 FNSTR R2,mini_command		; new command address
 RSB R4,R4,#0			; negate the direction
 MOV R0,#0
 STR R0,[R1]			; reset the offset list
 FNLDR R0,mini_ptr
 FNLDR R1,mini_mark
 ADD R0,R0,R1			; minibuffer string
 BL key_match			; find next match in new direction
 MOVVC R0,#-1			; no key to insert
 FNRTS
cancel$l
 FNLDR R1,key_off
 LDR R0,[R1,#4]			; initial offset
 BL goto_file_offset
 MOVVC R0,#7			; pass on the ctrl G
 FNRTS
ext1$l DCD Searchforward
ext2$l DCD Searchback
ext3$l DCD Cancel
ext4$l DCD Delete
ext5$l DCD Return

;E R0=search string R4=direction +1/-1
;X key_off moved to next match #

key_next_match
 FNJSR "R1-R2,R11"
 MOV R11,R0			; save search string
 FNLDR R1,key_off		; buffer
 LDR R0,[R1],#&10		; length
 ADD R2,R1,R0,LSL#3		; address of this entry
 LDR R0,[R2]			; start of match
 CMP R0,#0
 FNRTS MI			; there was no match so can't be a next one!
 CMP R4,#0
 SUBMI R0,R0,#1			; just before match is new base
 LDRPL R0,[R2,#4]		; end of match = new base
 CMP R0,#0
 MOVLE R0,#0			; clip to start of file
 BL reset_key_off		; set this as current base
 MOVVC R0,R11
 BLVC key_match			; jump to the match (if there is one)
 FNRTS

;E R0=file offset R5=search flags R8
;X Hourglass updated

sumlen_long_op_display
	TST	R5,#zsearch_AllWindows
	LDREQ	R1,[R9,#f_len]
	BEQ	long_op_display
	MOV	R1,#0
	STMFD	R13!,{R2-R6}
	FNLDR	R2,wind_list
	FNLDR	R3,wind_num
	FNLDR	R4,file_list
loop$l	SUBS	R3,R3,#1
	BMI	done$l
	LDR	R5,[R2],#1<<w_shift
	CMP	R5,#0
	BLE	loop$l
	LDR	R5,[R2,#w_file-1<<w_shift]
	ADD	R5,R4,R5,LSL #f_shift
	LDR	R5,[R5,#f_len]
	ADD	R1,R1,R5
	CMP	R8,R2
	ADDGE	R0,R0,R5
	B	loop$l
done$l	LDMFD	R13!,{R2-R6}
	B	long_op_display

 END
