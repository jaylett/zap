; Contains main module entry start code and wimp poll dispatches.
; $Id: StartCode,fff,v 1.1.2.24 1999/07/06 11:36:01 james Exp $
; -*- armasm -*-

 GET h.ZapHeader
 GET h.Messages
 GET h.StartUp
 GET h.ModeBits
 GET h.Menus
 GET h.Heap
 GET h.Template
 GET h.CreateFile
 GET h.Strings
 GET h.MiniBuff
 GET h.CreateWind
 GET h.Cursors
 GET h.KeyBits
 GET h.Menus
 GET h.Redraw
 GET h.AlterTxt
 GET h.Exceptions
 GET h.TMTVars
 GET h.Commands
 GET h.Execute

 IMPORT title_string
 IMPORT help_string_1
 IMPORT Module_header

 IMPORT correct_font
 IMPORT open_QuitBox
 IMPORT minimise_font_memory
 IMPORT gc_claimentity
 IMPORT gc_datarequest
 IMPORT poll_word_changed
 IMPORT get_MiniBuf

 IMPORT ClearGC
 IMPORT Mode
 IMPORT Cup
 IMPORT Updatewindow

 EXPORT start_code
 EXPORT wimp_passon
 EXPORT message_ack
 EXPORT message_reply
 EXPORT message_send
 EXPORT message_interested
 EXPORT call_back
 EXPORT drag_box
 EXPORT send_data_save
 EXPORT last_drag_box_event
 EXPORT mouse_event
 EXPORT main_loop
 EXPORT main_quit
 EXPORT main_quit_nodie
 EXPORT main_end
 EXPORT kill_wimp
 EXPORT clean_up
 EXPORT env_noicon_check
 EXPORT Installicon
 EXPORT are_we_initialising
 EXPORT user_message_act

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; RUN Module Entry Point
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; NB Wimp_Initialise takes all your application memory away if you are
; a module task. See Service_Memory 3-68. Must init_wimp before setting
; up the stack.

	[ LOGGING = SYSLOG
zap_log$l FNS (|zap$|:CC:"$Log")
	]

start_code
 LDR R12,[R12]			; R12=module workspace
 SWI XHourglass_On
 SUBS R0,R0,R0			; clv...
 MOV R0,#&8000
 FNSTR R0,env_start		; save environment start
 BL init_wimp_vsn		; read wimp version (before init_wimp)
 BLVC init_wimp			; log on as a wimp task (clears app memory)
 BLVC init_stack		; R13=stack now setup
 BLVC init_envstring		; read & store environment string
 MOVVS R10,#0			; kill the module on error
 BVS main_end
 BLVC init_fixed		; claim fixed buffers
 BLVC init_heap			; set up heap and dynamic areas

 [ LOGGING = SYSLOG
 ; Set up logging (we need the heap before we can do this) ...
 MOVVC R0,#16			; maximum size of Zap$Log
 BLVC heap_claim
 BVS fatal_wimp_error		; next section can be done without checking V
 MOV R1,R0
 ADR R0,zap_log$l
 MOV R2,#16
 MOV R3,#0
 MOV R4,#4
 SWI XOS_ReadVarVal
 CMP R2,#0
 MOVGT R0,#0
 STRGTB R0,[R1,R2]		; terminate
 STRGT R1,[R12,#zap_logname]
 MOVLE R0,R1
 MOVLE R1,#0
 STRLE R1,[R12,#zap_logname]	; 0 => no logging
 BLLE heap_free

 ADRL R4,title_string
; ADRL R5,help_string_1
 ADRL R6,Module_header
 ADD R5,R6,#(help_string_1 - Module_header)
 SYSLOGF "%4s %5s now starting; module base at %6x", LOG_STATUS

 BL init_vars			; set up variables (and variable buffers)
 |
 BLVC init_vars	
 ]
	
 ; Let's go with everything else
 BLVC init_config		; load !Config file / modedata (needs bufs)
 BLVC init_templates		; read template file (before init_settings!)
 BLVC init_settings		; read <Zap$Settings>
 BLVC init_external		; load External file (needs vars & settings)
 BLVC init_clones		; add clone modes to the external list
 BLVC init_icon			; put icon on iconbar
 BLVC init_keys			; read key bindings and t_macros!!
; BLVC init_modes		; initialise any mode that have been added
; MOVVC R0,#0
; BLVC init_comms		; initialise command tables starting at 0
 BLVC init_menus		; add old style menu structures
 BLVC load_menus		; read user menu defs and show key bindings
 BLVC init_mini			; initialise minibuffer - needs keys
 BLVC minibuffer_clear		; clear it...
 MOV R14,#-1
 STR R14,in_start_up		; flag...
 BLVC init_modes		; initialise any modes that have been added
 MOVVC R0,#0
 BLVC init_comms		; initialise command tables starting at 0
 BLVC init_opts			; setup options mode (after new init_modes!)
 BLVC init_flash		; start up flash interrupt
 BVS fatal_wimp_error
 BLVC init_setup_abort_handlers	; from Darren Salt...(TT)
 BLVC loadkeyextend
 BLVC loadhidepointer
 BLVC loadflashcar
 BVS wimp_error
 MOV R2,#0
 BL ClearGC			; no global clipboard contents, thank you.
 FNLDR R14,opt_switches
 TST R14,#switch_Autoload_iclear
 BLNE loadiclear
 BVS wimp_error
 BLVC init_load			; load file on startup (last thing to do)
 BLVC minimise_memory
; BLVC storewkspandstack	; for exception handler...
; gerph start >>>
; BLVC load_openfiles		; load the files from before crash
; <<< end gerph
 BVS wimp_error
 SWI XHourglass_Off
main_loop
 BL call_wimp_poll
 BVS wimp_error
 MOV R2,#0
 FNLDR R14,wimp_pollnum		; get previous poll number
 BIC R14,R14,#1<<31
 TEQ R0,R14
 FNSTR R0,wimp_pollnum,NE	; if new poll number then store this
 BL dispatch_wimp_poll
 BVC main_loop
 B wimp_error


 LOCAL

main_quit
 MOV R10,#0
 B main_exit

main_quit_nodie
 MOV R10,#1
; B main_exit ; fall through

main_exit			; unnecessary...
 BL set_up_quit_flag
 BL storewkspandstack		; !
 ;TEQ R10,#0
 ;SWIEQ OS_ExitAndDie		; ???????
 SYSLOG "Zap main_exit", LOG_STATUS
 SWI OS_Exit

;loopx				; ???????
; B loopx			; ???????
;...

main_end			; R10=0 to kill module - abort startup only
 BL set_up_quit_flag
 BL storewkspandstack
 BL unset_running_var
 MOV R1,#0
 MOV R2,#0
 ADR R3,t$l
 ;TEQ R10,#0
 ;SWIEQ OS_ExitAndDie
 SYSLOG "Zap main_end", LOG_STATUS
 SWI OS_Exit
t$l FNS |zap$|

clean_up
 FNJSR
; SWI &107
;  MOV R0,#'A'
;  BL outputlots$l
;  MOV R0,#'B'
;  BL outputlots$l
 MOV R0,#5
 SWI XWimp_ReadSysInfo
 SWIVC XDDEUtils_ThrowbackUnRegister ; &62586
 BL free_font_handles
 BL kill_files
 BL init_kill_list
;  MOV R0,#'C'
;  BL outputlots$l
 TEQ R10,#0
 BLEQ kill_modes		; kill off other mode modules
;  MOV R0,#'D'
;  BL outputlots$l
 TEQ R10,#0
 BLEQ kill_commands		; kill off other command modules
;  MOV R0,#'E'
;  BL outputlots$l
;;;;;;;;;;;;;;;;;;;;;; SUBS R0,R14,R14		; clear V flag
 TEQ R10,#0
 BLEQ kill_if_on_kill_list
;  MOV R0,#'F'
;  BL outputlots$l
; BLVS near_fatal_wimp_error	; error on quitting (eg ZapBASIC!)
 MOV R0,#0
 FNSTR R0,file_num		; no files (so finalise won't complain)
 ;MOV R0,#'G'
 ;BL outputlots$l
 BLVC kill_lineeditor		; kill line editor buffers
 ;MOV R0,#'H'
 ;BL outputlots$l
 BLVC kill_heap
 ;MOV R0,#'I'
 ;BL outputlots$l
 BLVC kill_wimp
 ;MOV R0,#'J'
 ;BL outputlots$l
; BLVC unset_running_var
 SUBS R0,R14,R14			; clear V flag
; MOVVC R1,#0
; MOVVC R2,#0
; ADRVC R3,t$l ; ?
 FNRTS

;outputlots$l
; MOV R2,#4096
;lp$l
; SWI XOS_WriteC
; SUBS R2,R2,#1
; BPL lp$l
; SUBS R0,R0,R0
; MOV PC,R14

 LOCAL

fatal_wimp_error
	[ LOGGING = SYSLOG  
 ADD R0,R0,#4
 SYSLOGF "Fatal error '%0s'",LOG_FATAL
 SUB R0,R0,#4
	]
 MOV R1,#2
 ADR R2,t$l
 SWI XWimp_ReportError
 MOV R10,#0			; kill module
 B main_end

near_fatal_wimp_error
 FNJSR "R1,R2"
	[ LOGGING = SYSLOG  
 ADD R0,R0,#4
 SYSLOGF "Near-fatal error '%0s'",LOG_ERROR
 SUB R0,R0,#4
	]
 MOV R1,#2
 ADR R2,t$l
 SWI XWimp_ReportError
 FNRTS

t$l
 FNS |zap$|

 LOCAL

;E R0=error block
;X Error reported and goes back to main loop

wimp_error
 FNLDR R14,wimp_pollnum		; get poll number
 TST R14,#1<<31			; did this poll number error before
 BNE cancel$l			; if so then cancel to prevent infinite loop
 ORR R14,R14,#1<<31
 FNSTR R14,wimp_pollnum		; mark this poll number as having errored
a$l				; report the error
 MOV R2,R0
 SWI XHourglass_Smash
 MOV R0,R2
 LDR R1,[R0]			; error number
 LDR R2,d$l
 TEQ R1,R2
 BEQ main_loop			; don't report it
	[ LOGGING = SYSLOG  
 ADD R0,R0,#4
 SYSLOGF "Error '%0s'",LOG_ERROR
 SUB R0,R0,#4
	]
 MOV R1,#1
 ADR R2,t$l
 SWI XWimp_ReportError
 B main_loop
cancel$l
 BIC R14,R14,#1<<31		; get poll number
 CMP R14,#4
 BCS a$l			; error if it wasn't a redraw etc
 ADDS R0,R0,#0			; clear error
 B main_loop
d$l
 DCD ENUM+12			; read only error - don't report
t$l
 FNS |zap$|

in_start_up
 DCD 0
are_we_initialising
 FNJSR
 LDR R14,in_start_up
 CMP R14,#0
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Perform the wimp poll						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=poll number R1=poll block R2=0,1 for poll idle flag (temporary)
;X All registers corrupted. Poll dealt with.

dispatch_wimp_poll
 FNJSR
 CMP R0,#(end$l-start$l)/8
 ADDCC PC,PC,R0,LSL #3		; dispatch
 BL wimp_passon			; out of range
start$l
 B end$l
  & 0
 BL redraw_request
  FNRTS
 BL open_request
  FNRTS
 BL close_request
  FNRTS
 BL wimp_passon
  B end$l
 BL wimp_passon
  B end$l
 BL mouse_event
  FNRTS
 BL drag_box_event
  FNRTS
 BL key_event
  B end$l
 BL menu_selection		; menu select
  B end$l
 BL scroll_event		; scroll request
  FNRTS
 BL lose_caret
  B end$l
 BL regain_caret
  B end$l
 BL poll_word_changed
  B end$l
 BL wimp_passon
  B end$l
 BL wimp_passon
  B end$l
 BL wimp_passon
  B end$l
 BL user_message		; messages
  B end$l
 BL user_message
  B end$l
 BL user_message_reply
  MOV R0,R0
end$l
 FNRTS VS
 FNPULL
 B call_null_events

;E R0=message number (0-19) R1=message block
;X message passed on to extension modes and command tables #

wimp_passon
 FNJSR "R2,R3,R11"
 MOV R3,R0			; message number
 LDR R2,[R1,#16]		; user message number
 MOV R11,#e_message
 BL broadcast			; tell all modes
 BLVC issue_service		; tell all command tables
 MOVVC R0,#&5500		; A flag
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Handle logging of message / wimp poll events			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R1= monotonic time to call back at (>0)
;      or -(time to wait) (=<0)
;  R2=sub to call R3=sub data
;X sub logged. Sub at R2 called with:
;  ;E R1=current time R11=sub data (private word)
;  ;X Save R1-R11.

call_back
 CMP R1,#0
 BGT a$l
 FNJSR
 SWI XOS_ReadMonotonicTime
 FNRTS VS
 PULL "R14"
 SUB R1,R0,R1
a$l
 MOV R0,#-1
; BL wimp_log
; FNRTS
; FALL THROUGH !!!

;E R0-R3=block to log
;X Block logged.
;  R0=0 => Terminator block (for internal use)
;  R0>0 => Reference of message that was sent expecting a reply
;	   R1=time message sent R2=reply sub (b31 set if wants bounces)
;	   R3=reply sub data
; R0=-1 => Call routine at a given time
;	   R1=earliest (monotonic) time to call the routine
;	   R2=sub to call R3=sub data
; R0=-2 => Interested in this message number...
;	   R1=message number
;	   R2=sub to call R3=sub data

wimp_log
 FNJSR "R6-R7"
 MOV R6,R0
 MOV R7,R1
 FNLDR R0,wimp_loglist
 FNLDR R1,wimp_loglen
 ADD R1,R1,#20			; block + terminator
 BL heap_ensure
 FNRTS VS
 FNSTR R0,wimp_loglist
 SUB R1,R1,#20
 ADD R0,R0,R1			; first free slot
 STMIA R0!,{R6,R7}
 STMIA R0!,{R2,R3}
 MOV R14,#0
 STR R14,[R0]
 ADD R1,R1,#16
 FNSTR R1,wimp_loglen
 FNRTS

;E R2=address of block to remove
;X block removed #

wimp_removelog
 FNJSR "R1-R5"
 FNLDR R4,wimp_loglist		; start of list
 FNLDR R5,wimp_loglen
 SUB R5,R5,#16			; new length
 FNSTR R5,wimp_loglen
 ADD R1,R2,#16			; source
 SUB R3,R2,R4			; current offset
 SUB R3,R5,R3			; amount left
 ADD R3,R3,#4			; terminator
 BL move_bytes
 FNRTS

 LOCAL

;X R0=poll event number R1=poll block (log looked at to see earliest call) #

call_wimp_poll
 FNJSR "R2"
 MOV R2,#-1
 FNLDR R1,wimp_loglist
a$l
 LDR R0,[R1],#16
 TEQ R0,#0
 BEQ end$l
 CMN R0,#1
 BNE a$l
 LDR R0,[R1,#-12]		; earliest time to call
 CMP R0,R2
 MOVCC R2,R0			; it's earlier than it was
 B a$l
end$l
 FNLDR R1,wimp_buffer
 CMP R2,#0
 BMI wait$l			; wait indefinitely
 MOV R0,#(1<<22)
 ADD R3,R12,#wimp_poll_word
 SWI XWimp_PollIdle		; wait until specified time
; BL dbgbeep
 FNRTS
wait$l
 MOV R0,#1			; mask out nulls
 ORR R0,R0,#(1<<22)
 ADD R3,R12,#wimp_poll_word
 SWI XWimp_Poll			; wait for 'ever'
; BL dbgbeep
 FNRTS

;dbgbeep
; FNJSR "R0"
; CMP R0,#6
; SWICS &107
; FNRTS

 LOCAL

;X Wimp_log examined and null events called.
;  Very old wimp messages deleted.

call_null_events
 FNJSR "R1-R3,R11"
 SWI XOS_ReadMonotonicTime
 FNRTS VS
 MOV R1,R0			; current time
 FNLDR R2,wimp_loglist		; start of list
 FNLDR R4,wimp_loglen		; length of log list
 B b$l
a$l
 ADD R2,R2,#16			; next block
b$l
 SUBS R4,R4,#16
 FNRTS LT			; examined all the ones origionally in list
 LDR R3,[R2]
 TEQ R3,#0
 FNRTS EQ			; reached end of list
 CMP R3,#-1
 BGT m$l			; it's a message
 BNE a$l			; not a call back block
 LDR R3,[R2,#4]			; earliest time to call back at
 CMP R3,R1
 BGT a$l			; haven't reached that time yet
 LDR R11,[R2,#12]		; private word
 LDR R3,[R2,#8]			; address to call
 BL wimp_removelog		; remove BEFORE calling in case of error
 FNLDR R0,wimp_loglist,VC
 SUBVC R2,R2,R0			; offset in log list
 FNRTS VS
 MOVS R14,PC
 MOV PC,R3			; call (may change log list posn
 FNRTS VS
 FNLDR R0,wimp_loglist		; (which we don't want to reexamine!!)
 ADD R2,R2,R0			; (hence use of R4)
 B b$l				; new next block has been shifted in
m$l
 LDR R0,[R2,#4]			; time message sent
 SUB R0,R1,R0			; time since message sent
 CMP R0,#1*&1800		; 1 minute (&8100cs is about 61 secs)
 BLT a$l			; keep
 LDR R3,[R2,#8]			; address
 LDR R11,[R2,#12]		; private word
 BL wimp_removelog		; too old
 FNRTS VS
 TST R3,#1<<30
 BEQ b$l			; doesn't want to know about it
 MOV R0,#0
 MOVS R14,PC
 BIC PC,R3,#3<<30		; call the sub
 BVC b$l			; new next block has been shifted in
 FNRTS

 LOCAL

; User message event

user_message
 LDR R0,[R1,#12]		; our reference if this is a reply
 CMP R0,#0
 BLE user_message_act		; this is an orginal message
 MOV R0,#17
; B user_message_reply		; this is a reply to one of our messages
 ; fall through...???

;E R0=17/19 if bounced R1=message block of a replied message
;X message reply code called if in the list. o/w passed on #

user_message_reply
 FNJSR "R1-R11"
 MOV R4,R0			; save the call number (17/19)
 FNLDR R2,wimp_loglist		; start of list
 LDR R5,[R1,#12]		; my reference for the message
 TEQ R0,#19
 LDREQ R5,[R1,#8]		; my ref hasn't been copied if it bounced
 SUB R2,R2,#16
; B b$l
a$l
 ADD R2,R2,#16			; next block
b$l
 LDR R3,[R2]
 CMP R3,#0
 BEQ end$l			; reached end of list
 BMI a$l			; not a message
 TEQ R3,R5
 BNE a$l			; wasn't a reply to this message
 LDR R11,[R2,#12]		; private word
 LDR R3,[R2,#8]			; address to call
 LDR R2,[R1,#16]		; message 'number'
 TEQ R4,#17			; (don't delete incase of repeat replies)
 BEQ c$l
 TST R3,#1<<31
 FNRTS EQ			; not interested in bounces
c$l				; call
 BICS R3,R3,#3<<30		; address of the sub to call
 BEQ d$l
 MOV R0,R4			; call type (17/19)
 MOVS R14,PC
 MOV PC,R3			; call (corrupts all)
 FNRTS				; may change log position
d$l				; want to treat message as normal
 BL user_message_act		; act on it
 FNRTS
end$l
 FNLDR R14,opt_switches
 TST R14,#bit_betolerant
 BNE forfresco$l
notforfresco$l
 MOV R0,R4
 BL wimp_passon
 FNRTS
forfresco$l
 CMP R4,#19
 BEQ notforfresco$l
; LDR R0,[R1,#4]			; task handle
; FNLDR R14,wimp_task		; us...
; CMP R0,R14			; is it us?
; BEQ notforfresco$l

; FNRTS EQ			; yes!
 LDR R0,[R1,#12]		; our reference?
; CMP R0,#0			; but it's never 0...
; FNRTS EQ
; PUSH "R1-R4"
 BL user_message_act		; a pseudo-orginal message :-/
; PULL "R1-R4"
 CMP R0,#&5500			; A flag to say message passed on
; BEQ notforfresco$l
 FNRTS EQ			; previously passed on
 ADR R0,badmessage$l
 MOV R1,#5<<29
 MOV R8,#0
 MOV R9,#0
 BL warn_user
 FNRTS

badmessage$l
 = "zap_UnexpReply",0

 ALIGN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Box dragging							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R0=flags b0 => call repeatedly on nulls while drag taking place
;	    b1+ reserved
;  R1=drag box block as for Wimp_DragBox R2=address of routine to call
;  R3=routine data
;X Wimp_DragBox called. Routine called with
;   ;E R0=reason code 1=drag in progress 2=drag finished
;   ;  R1=final drag box wimp block if R0=2 R11=routine data

local_wimp_temp_store
 DCD 0
 DCD 0
 DCD 0
 DCD 0
 DCD 0

drag_box
 FNJSR "R1-R3"
 FNSTR R2,wimp_dragsub
 FNSTR R3,wimp_dragdata
 MOV R3,R0			; save the flags
 SWI XWimp_DragBox		; initiate the drag
 FNRTS VS
 TST R3,#1
 FNRTS EQ			; wait until we get a dragged box event
 MOV R1,#0			; call on next null
 ADR R2,sub$l
 BL call_back			; call repeatedly
 FNRTS
sub$l				; called on a null event
 FNJSR "R1-R3,R11"
 FNLDR R11,wimp_dragdata

 FNLDR R1,wimp_dragsub		; get the drag sub
 CMP R1,#0			; has the drag finished?
 FNRTS LE
 BL to_last_drag_box_event		; to see if it is...

 FNLDR R1,wimp_dragsub		; get the drag sub
 CMP R1,#0			; has the drag finished?
 FNRTS LE

 MOV R0,#1			; drag in progress
 MOVS R14,PC
 MOV PC,R1			; call
 MOV R1,#0			; next 3 need VCs
 ADR R2,sub$l
 BL call_back			; schedule another call back
 FNRTS

to_last_drag_box_event
 FNJSR "R1"
 ADR R1,local_wimp_temp_store
 SWI XWimp_GetPointerInfo	; find mouse position
 LDR R14,[R1,#8]		; mouse butts
 ANDS R14,R14,#7
 BLEQ last_drag_box_event
 FNRTS

last_drag_box_event
 FNJSR "R0-R12"
 FNLDR R1,wimp_dragsub		; get the drag sub
 CMP R1,#0			; has the drag finished?
 FNRTS LE
 ADR R1,local_wimp_temp_store
 SWI XWimp_GetPointerInfo	; find mouse position
 LDR R14,[R1,#0]		;
 STR R14,[R1,#8]		;
 LDR R14,[R1,#4]		;
 STR R14,[R1,#12]		;
 BL drag_box_event
 FNRTS

drag_box_event			; R1=drag box block
 FNJSR "R11"
 FNLDR R0,wimp_dragsub		; call
 CMP R0,#0
 FNRTS LE
 MOV R0,#2			; drag finished
 FNLDR R11,wimp_dragdata
 MOVS R14,PC
 FNLDR PC,wimp_dragsub		; call
 MOV R0,#0
 FNSTR R0,wimp_dragsub		; cancel the drag
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialise wimp						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E No Stack!!
;X wimp initialised if task handle 0/-1
;  R0-R11 corrupted

local_wimp_dummy_version
 DCD 0 ; wimp_version

init_wimp
 FNLDR R0,wimp_task
 TEQ R0,#0
 CMPNE R0,#-1
 MOVNE PC,R14			; already inited
 ADR R0,s2$l			; name
 ADR R1,local_wimp_dummy_version;
 MOV R2,#4			; one word long
 MOV R3,#0
 MOV R4,#0
 SWI XOS_ReadVarVal
 ;BVS setup$l
 LDR R0,local_wimp_dummy_version
 CMP R0,#700
 BCS presetup$l
 CMP R0,#200
 BCS setup$l
 ;TEQ R4,#1
presetup$l
 FNLDR R0,wimp_version		; variable not found or not setup
setup$l
 LDR R1,init_wimp_task
 ADR R2,name$l
 ADR R3,messages$l		; -1 also works. 0 doesn't send you ANY
 SWI XWimp_Initialise		; contrary to what it says in the manual.
 FNSTR R0,wimp_realver
 FNSTR R1,wimp_task
 MOV PC,R14

name$l FNS |zap$|
s2$l FNS (|zap$|:CC:"$DummyOSVsn")

 ALIGN
messages$l			; null message list indicates you want
 DCD 0				; all messages - see RO3 errata

 LOCAL

;E No Stack!!
;X wimp version read from Zap$OsVsn
;  R0-R11 corrupted

init_wimp_vsn
 ADR R0,s$l			; name
 ADD R1,R12,#wimp_version	; buffer
 MOV R2,#4			; one word long
 MOV R3,#0
 MOV R4,#0
 SWI XOS_ReadVarVal
 MOVVS PC,R14
 TEQ R4,#1
 MOVNE R0,#200			; variable not found or not setup
 FNSTR R0,wimp_version,NE
 MOV R0,#129
 MOV R1,#0
 MOV R2,#255
 SWI XOS_Byte
 CMP R1,#165
 MOVLO R0,#&1000000
 MOVHI R0,#&1C00000
 FNSTR R0,wimp_limit		; app workspace limit: 16M or 28M
 ;ADR R0,s2$l			; name
 ;LDR R1,local_wimp_dummy_version;
 ;ADD R1,R12,R1
 ;MOV R2,#4			; one word long
 ;MOV R3,#0
 ;MOV R4,#0
 ;SWI XOS_ReadVarVal
 ;BVS setup$l
 ;TEQ R4,#1
 ;BEQ setup$l
 ;FNLDR R0,wimp_version		; variable not found or not setup
 ;LDR R1,local_wimp_dummy_version;
 ;STR R0,[R12,R1]
setup$l
 ;FNLDR R0,wimp_version
 MOV PC,R14
s$l FNS (|zap$|:CC:"$OSVsn")

 LOCAL

;X wimp task killed if task handle not 0/-1 #

kill_wimp
 FNJSR "R1"
 FNLDR R0,wimp_task
 CMP R0,#0
 CMPNE R0,#-1
 BEQ dead$l			; already dead
 LDR R1,init_wimp_task
 SWI XWimp_CloseDown		; kill
 FNRTS VS
dead$l
 MOV R0,#0
 FNSTR R0,wimp_task
 FNRTS
init_wimp_task	= "TASK"

 LOCAL

;X returns in R2 pointer to buffer entries...
env_noicon_check
 FNJSR
 ADR R0,parse_str
 FNLDR R2,wimp_block
 FNLDR R1,env_string
 MOV R3,#&100
 SWI XOS_ReadArgs
 FNRTS

parse_str
 = "noicon/S,/G,/G",0
 ALIGN

 DCD 7
Installicon
 FNJSR "R1"
 FNLDR R0,wimp_iconbar
 CMP R0,#0
 BEQ iibic$l
 FNRTS

;X main Zeta icon added to iconbar #

init_icon
 FNJSR "R1"
 BL env_noicon_check
 LDR R0,[R2]
 CMP R0,#0
 FNRTS NE
iibic$l
 ADR R1,d$l
 SWI XWimp_CreateIcon
 FNSTR R0,wimp_iconbar
 FNRTS
d$l
 DCD -1,0,-8,48,78,&1700301A
 FNS ("!":CC:|zap$|)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; WIMP POLL RETURNS						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

open_request
 FNJSR
 LDR R0,[R1]
 BL convert_wind_handle
 BCC text$l
 BL convert_leaf_wind_handle
 BCC leaf$l
 MOV R0,#2
 BL wimp_passon
 FNRTS
leaf$l
 SWI XWimp_OpenWindow
 FNRTS
text$l				; a Zap text window
 BL conv_wind_off		; set up R8/R9
 BL update_wind_state		; update flags and posn
 FNRTS VS
 LDR R0,[R8,#w_windowflags]	; get current window flags
 TST R0,#1<<19			; was this a toggle size request?
 LDRNE R7,[R8,#w_scrolly]	; save old y scroll
 LDMIB R1,{R0-R6}
 STMIB R8,{R0-R6}		; copy open values up to handle behind
 STRNE R7,[R8,#w_scrolly]	; restore y scroll
 LDR R0,[R8,#w_flags]
 TST R0,#1<<31
 BLNE alter_window		; alter window for mode change
 MOVVC R1,R8			; new updated open values
 BLVC reopen_window		; open window at new posn
 LDRVC R14,[R8,#w_format]	; this code complements similarly awful code
 BICVC R14,R14,#1<<29		; pay attention to redraws when the come.
 STRVC R14,[R8,#w_format]	; elsewhere - remove it and iconised 'new
 FNRTS				; views' may escape being redrawn :-(

 LOCAL

close_request
 FNJSR
 LDR R0,[R1]
 BL convert_wind_handle
 BCC text$l
 BL convert_leaf_wind_handle
 BCC leaf$l
 MOV R0,#3
 BL wimp_passon
 FNRTS
leaf$l
 MOV R7,R0			; leaf window index
 BL close_leaf_window
 FNRTS
text$l
 BL conv_wind_off
 BL test_open_dir		; open parent dir
 FNRTS VS
 TEQ R0,#0			; continue delete?
 FNRTS NE
 BL delete_window		; delete the window
 MOV R0,#3			; TT's additions...
 BL wimp_passon			; TT's additions...
 FNRTS

 LOCAL

mouse_event
 FNJSR
 LDR R2,[R1,#0]			; mouse x
 LDR R3,[R1,#4]			; mouse y
 LDR R4,[R1,#8]			; button type
 FNSTR R4,wimp_menub		; save button status
 LDR R0,[R1,#12]		; window handle
 CMN R0,#2
 BEQ icon$l			; iconbar click
 BL convert_wind_handle
 BCC text$l			; edit window
 BL convert_leaf_wind_handle
 BCC leaf$l
 MOV R0,#6
 BL wimp_passon
 FNRTS
leaf$l
 LDR R5,[R0,#4]			; leaf window flags
 TST R5,#&200			; auto background input focus allowed...
 LDREQ R5,[R1,#16]		; ...and click is on background?
 CMNEQ R5,#1
 BEQ leaf_focus$l		; if so, restore input focus
 MOV R7,R0			; window index
 BL process_leaf_click		; process leaf key click ; preserves R7
 FNRTS VS
 FNRTS CC			; don't close window
 FNLDR R0,wimp_menub		; get button status
 TST R0,#3			; menu or adjust...
 ; IS R7 OK?  yes...
 BLEQ close_leaf_window		; no - close window
 ; BL close_leaf_window		; no - close window
 FNRTS
leaf_focus$l
 LDR R5,[R1,#8]
 TST R5,#2
 LDREQ R0,[R1,#12]
 MVNEQ R1,#0
 MVNEQ R2,#0
 MVNEQ R3,#0
 MOVEQ R4,#1<<25
 MVNEQ R5,#0
 SWIEQ XWimp_SetCaretPosition
 FNRTS
text$l
 BL conv_wind_off		; set R8/R9
 TST R4,#2			; menu click ?
 BNE menu$l			; open menu
 BL process_window_click	; process the click
 FNRTS
icon$l				; iconbar Zap icon
 MOV R8,#0
 MOV R9,#0			; iconbar
 TST R4,#2
 BNE menu$l			; open menu
 TST R4,#1
 FNLDR R0,wimp_selecttype,EQ
 FNLDR R0,wimp_adjusttype,NE

 ORR R0,R0,#command_DontLearn
 BL command_string
; ; ought to have R1 = length for future, but
; ; Newfile doesn't actually use it.
; MOV R2,#0		; execute
; BL Newfile
; FNLDR R0,wimp_selecttype,EQ
; FNLDR R0,wimp_adjusttype,NE
; BL create_empty
; BLVC create_window_caret
 FNRTS

; E R2,R2 x/y mouse positions
menu$l				; create menu on R8/R9
 MOV R0,#-1
 STR R0,localmodeptr$l
 TEQ R8,#0
 BEQ normalmenu$l
; SWI &107
 MOV R0,#9
 MOV R11,#e_interrogate
 BL call_mode
 CMP R0,#&100
 BGT gotmenuhandle$l		; mode supplied menu handle
 SUB R13,R13,#32		; stack space
 MOV R1,R13
 SWI XWimp_GetPointerInfo	; being lied to by (eg.) Pinboard?
 FNLDR R0,wimp_buffer,VC
 LDRVC R0,[R0,#12]		; window handle returned by Wimp_Poll
 LDR R1,[R1,#12]		; window handle returned by Wimp_GetPointerInfo
 				; different only if someone's been passing us messages
 				; (eg: Pinboard passing shift+Menu over iconised window)
 ADD R13,R13,#32		; stack back up
 TEQ R0,R1
 BNE normalmenu$l		; being lied to - don't use modifiers

 MOV R0,#&2			; alt (modes, but alt+shift over selection -> sel menu)
 BL test_forkey
 BCC not_alt$l

 PUSH "r2,r3,r7-r9"
 MOV R7,R8
 BL get_selection
 TEQCC R7,R8			; is the selection in the same window?
 CMPNE R7,#0			; set carry if not
 PULL "r2,r3,r7-r9"
 BCS openmodes$l

 MOV R0,#&0			; shift
 BL test_forkey
 MOVCS R0,#5			; alt and shift - selection menu
 BCS specialmenu$l		; Z will be clear, as required ...
openmodes$l
 PUSH "R1-R10"
 MOV R2,#16
 MOV R0,#0
 MOV R1,#1
 BL Modelist
 PULL "R1-R10"
 MOV R1,R0
 B gotmenuhandle$l

not_alt$l
 MOV R0,#&0			; shift (colours, but ctrl+shift -> mode's menu)
 BL test_forkey
 BCS colourlist$l
 MOV R0,#&1			; ctrl (fonts)
 BL test_forkey
 MOVCSS R0,#4
 BCS specialmenu$l
normalmenu$l
 TEQ R8,#0
 MOVNE R0,#1			; window menu
 MOVEQ R0,#0			; main menu
specialmenu$l
 FNLDR R14,wimp_flagbits,EQ
 BICEQ R14,R14,#1
 FNSTR R14,wimp_flagbits,EQ
 BL read_menu_handle
gotmenuhandle$l
 TEQ R1,#0
 ORRNE R3,R3,#1<<31
 LDRNE R4,localmodeptr$l
 BLNE create_menu		; update the ticks and open
 FNRTS
colourlist$l
 MOV R0,#&1			; ctrl
 BL test_forkey
 BCS modemenu$l
 PUSH "R1-R10"
 MOV R2,#16
 MOV R0,#0
 MOV R1,#1
 BL Colourlist
 PULL "R1-R10"
 MOV R1,R0
 B gotmenuhandle$l
modemenu$l
 PUSH "R1-R10"
 LDRB R14,[R8,#w_format]
 STR R14,localmodeptr$l
 ADR R0,localmodeptr$l
 MOV R1,#1
 MOV R2,#19
 BL Mode
 PULL "R1-R10"
 MOVS R1,R0
 BEQ normalmenu$l
 LDR R0,localmodeptr$l
 BL set_mode_menu_title
 B gotmenuhandle$l

localmodeptr$l
 DCD 0

 LOCAL

key_event
 FNJSR
 MOV R11,R1			; data block
 LDR R0,[R1]			; input focus window
 BL convert_wind_handle
 BCC text$l			; a text window
 BL convert_leaf_wind_handle
 BCC leaf$l			; a leaf window
 MOV R0,#8
 BL wimp_passon
 FNRTS
leaf$l
 MOV R7,R0			; index entry
 LDR R0,[R1,#24]		; key
 LDR R5,[R1,#4]			; icon with input focus
 BL process_leaf_key
 FNRTS VS
 BLCS close_leaf_window
 FNRTS
text$l
 BL conv_wind_off		; set up R8/R9
 BL last_drag_box_event		; to see if it is...
 FNLDR R0,car_mode
 CMP R0,#0			; have we got input?
 BLMI restore_carets		; regain carets if hasn't been done
 FNRTS VS
 MOV R7,R8			; save the window
 MOV R6,R9
 BL get_input_caret
 BCC caret$l			; input caret found
 BL default_caret
 FNRTS VS
 BL get_input_caret
 FNRTS CS			; something badly wrong
caret$l				; caret setup
 TEQ R8,R7			; in correct window?
 BEQ wind$l
 MOV R8,R7
 MOV R9,R6
 BL enter_window
 FNRTS VS
 BL get_input_caret
 FNRTS CS			; something badly wrong
wind$l				; in the correct window
 MOV R6,#0			; not yet buffered anything
 MOV R1,R11
 B gotakey$l			; after a key read
loop$l
 MOV R0,#&30			; DO NOT MASK OUT NULL EVENTS
 ORR R0,R0,#1<<22		; no matter.
 ADD R3,R12,#wimp_poll_word
 SWI XWimp_Poll			; do another wimp poll (maybe more than one)
; BL dbgbeep
; FNRTS VS
 TEQ R0,#8			; is it a key
 BNE notakey$l			; if not then carry on
gotakey$l			; R1=wimp block of read key
 LDRVC R0,[R1,#24]		; get key
 BLVC process_key		; perform action/buffer
 FNRTS VS
 CMP R0,#0
 BPL loop$l			; try for next key
 FNRTS				; finished
notakey$l
 MOV R11,R0			; save poll val
 MVNVC R0,#0			; couldn't find any more keys
 BLVC process_key		; act on the buffered keys
 MOVVC R0,R11			; restore poll val
 MOVVC R2,#2
 BLVC dispatch_wimp_poll	; do this
 FNRTS				; finished

 LOCAL

menu_selection
 FNJSR
 MOV R11,R1			; menu tree
 FNLDR R1,wimp_block
 SWI XWimp_GetPointerInfo
 FNRTS VS
 LDR R0,[R1,#8]			; button state
 FNSTR R0,wimp_menub		; save button used to select entry
 FNLDR R4,car_mode		; get caret mode
 CMP R4,#-1			; is caret lost
 FNLDR R0,car_omode,EQ
 FNSTR R0,car_mode,EQ		; if so get mode before lost
 FNLDR R0,wimp_menu
 BL conv_wind_off
 FNLDR R1,wimp_menuptr		; menu to decode
 BL menu_click			; act
 BVS err$l			; error
 CMP R4,#-1			; was caret lost?
 FNLDR R14,car_mode,EQ
 FNSTR R14,car_omode,EQ
 FNSTR R4,car_mode,EQ		; restore status if so
 FNLDR R0,wimp_menub		; get button state
 TST R0,#1			; was adjust pressed
 FNRTS EQ			; if not carry on
 MOV R2,#0
 MOV R3,#0
 FNLDR R0,wimp_menu
 BL conv_wind_off
 FNLDR R1,wimp_menuptr		; menu
 BL update_menu_path		; update the submenus by the path in R11
 FNLDR R0,menu_count,VC
 SUBVC R0,R0,#1
 FNSTR R0,menu_count,VC		; don't want to update the root twice!
 BLVC create_menu		; recreate menu
 FNRTS
err$l
 CMP R4,#-1			; was caret lost?
 FNLDR R14,car_mode,EQ
 FNSTR R14,car_omode,EQ
 FNSTR R4,car_mode,EQ		; restore status if so
 FNRTV

	LOCAL

scroll_event
	FNJSR
; SWI &107				; ! NO???
	LDR R0,[R1]			; window handle
	BL	convert_wind_handle
	BCC	text$l
	BL	convert_leaf_wind_handle
	FNRTS	CC
	MOV	R0,#10
	BL	wimp_passon
	FNRTS
text$l
	BL	scroll_request
	FNRTS

	LOCAL

lose_caret
	FNJSR
	MOV	R11,R1
	LDR	R0,[R1]			; window handle of previous owner
	BL	convert_wind_handle
	BCC	text$l
	BL	convert_leaf_wind_handle
	MOVCS	R0,#11
	BLCS	wimp_passon
	FNRTS
text$l
	FNLDR	R0,car_mode
	CMN	R0,#1			; already lost?
	FNRTS	EQ			; yes
	FNSTR	R0,car_omode

	MVN	R0,#0
	FNSTR	R0,car_mode		; copy caret mode and mark lost
	BL	get_input_caret
	FNRTS	CS			; none
	BL	update_point		; update position of point caret
	BLVC	remove_carets		; update caret posns (+point pos)
	FNRTS VS

;	PUSH "R0,R1"
;	MOV	R1,#7			; focus lost: tell ZapButtons...?
;	BL	issue_service
;	PUSH "R0,R1"

	FNRTS

	LOCAL

regain_caret
 FNJSR
 MOV R11,R1			; MUST NOT CALL GAIN CARET!
 LDR R0,[R1]			; window handle of new owner
 BL convert_wind_handle
 BCC text$l
 BL convert_leaf_wind_handle
 MOVCS R0,#12
 BLCS wimp_passon
 FNRTS
text$l
 BL conv_wind_off		; set up R8/R9
; SWI &107
 FNLDR R0,car_mode
 CMN R0,#1
 BNE notlost$l			; carets were not lost
 FNLDR R10,car_cursor
 BL test_cblk
 BEQ restore$l			; window contains cursor caret
 FNLDR R10,car_input
 BL test_cblk
 BEQ restore$l			; window contains input caret
asnormal$l
 FNLDR R0,car_omode
 FNSTR R0,car_mode		; restore old mode
 BL set_caret_mode_to1		; set current mode to 1
 BLVC find_input		; find offset to goto in R0
 MOVVC R4,R0			; save offset
 FNLDR R10,car_cursor,VC	; cursor caret
 BLVC update_point		; save old position
 BLVC get_wind_off
 STRVC R0,[R10,#c_wind]		; set caret window
 STRVC R4,[R10,#c_off]
 BLVC reflect_caret		; show the caret
 MOVVC R0,#12
 BLVC wimp_passon
 FNRTS
restore$l
 BL restore_carets		; restore caret mode + update
 MOV R0,#12
 BL wimp_passon
 FNRTS
notlost$l
 PUSH "R8,R9"
 BL get_input_caret
 PULL "R8,R9"
 BCS asnormal$l ; restore$l			; ?
 BL clear_point			; remove point square
 MOV R0,#12
 BL wimp_passon
 FNRTS

 LOCAL

; calls the relevant user message sub with R1=message block R0=message num

user_message_act		; act on given user message as if sent
 MOV R11,R1			; Past compatability
 LDR R6,[R1,#16]		; message action
 FNLDR R2,wimp_loglist		; any non-mode interest in this message?
z$l
 LDR R3,[R2],#16
 TEQ R3,#0
 BEQ y$l
 CMN R3,#2
 LDREQ R3,[R2,#-12]
 TEQEQ R3,R6
 BNE z$l
 STMFD R13!,{R1-R11,R14}
 MOV R1,R11
 LDMDB R2,{R2,R3,R11}		; msg no, addr to call, private word
 MOVS R14,PC
 MOV PC,R3			; call (corrupts all)
 LDMFD R13!,{R1-R11,R14}
 BVS x$l
 TEQ R0,#0
 BEQ z$l
 SUB R2,R2,#16
 B wimp_removelog
x$l
 MOV R1,R0
 SUB R2,R2,#16
 MOV R3,R14
 BL wimp_removelog
 MOV R0,R1
 ORRS R14,R3,#1<<28
y$l
 ADR R2,list$l			; table of recognised messages
a$l
 LDMIA R2!,{R3,R4}
 TEQ R3,R6
 BEQ act$l
 CMP R3,#0
 BGE a$l			; not reached table end yet
 FNLDR R2,ext_messages		; check it's not wanted externally
 FNJSR
b$l
 LDMIA R2!,{R3,R4}
 CMP R3,#0
 BEQ end$l
 TEQ R3,R6
 BNE b$l
 ADDS R0,R4,#0			; module name
 BLGT load_mode_module		; load the module if need be
 BVC b$l
 FNRTS
end$l				; reached end of list so pass it on
 MOV R0,#17
 BL wimp_passon
 FNRTS
act$l
; FNPULL
 FNLDR R5,env_modstart		; start of the module
 ADD PC,R5,R4			; jump to the sub
list$l
 DCD 0,main_quit		; telling me to die (nodie???)
 DCD 1,data_save		; someone wants to save data to me
 DCD 3,data_load		; (filer) wants me to load a file
 DCD 5,data_open		; someone wants to edit a file
 DCD 8,pre_quit			; warning me before a shutdown
 DCD 9,palette_changed		; palette change
 DCD 10,save_desktop		; save desktop file being generated
 DCD 15,gc_claimentity		; claim entity (global clipboard - SJA)
 DCD 16,gc_datarequest		; data request (global clipboard - SJA)
 DCD &502,help_help		; Help wants info on a window
 DCD &400C0,menu_warning	; a submenu has been opened
 DCD &400C1,mode_changed	; mode change
 DCD &45D80,Edit_Rq		; request for external editing session
 DCD &45D82,Edit_Return		; request for return of data
 DCD &45D83,Edit_Abort		; abort editing session
 DCD &45D84,data_save		; external edit file to be updated
 DCD &45D85,Edit_Cursor		; place cursor or select area
 DCD &80E21,OLE_OpenSession	; request for OLE session (sja)
 DCD &80E23,OLE_CloseSession	; close the OLE session (sja)
 DCD -1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DATA TRANSFER PROTOCOL					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;; Saving to another App ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;E R2=proposed file/leaf name of the data (or 0 to use the file's)
;  R3=destination window handle or task handle
;  R4=destination icon handle (if R3=-2)
;  R5/R6=destination mouse coords (if applicable)
;  R7=routine to call after save finished (or 0 if none).
;  R8/R9=R8<>0 => Save whole file R8=window block R9=file block
;	 R8=0  => Save currently selected region.
;	 (or set b1 of R10 to save an arbitrary region).
;  R10=b0-b15 flags:
;      b0 set => External edit flag. In this case R3=ext edit
;		 job handle and R4=ext edit task handle and
;		 external edit message sent instead.
;      b1 set => R8=start address of data to save
;		 R9=size of the data to save
;		 b16-b31 of R10=filetype of data to save.
;      b2 set => use R1 as the WIMP message reply field...
;      b3 set => untyped file (if b1 set)
;      b16-b31 = extra data (see b1)
;  R11=data to pass to routine in R7 (if used).
;X Data transfer protocol initiated.
;  Sub pointed to by R7 is called with R11 as passed above and should
;  preserve R1+ as usual. WB #
; The information block passed on to the messages consists of:
;  &00 = routine to call after finished (R7) (or 0 if none)
;  &04 = data to pass to the routine (R11)
;  &08 = flags (R10) with filetype b16+
;  &0C = >=0 for offset of window block being saved
;	 -1 for selection being saved
;	 -2 for fixed area of memory being saved
;  &10 = address of start of area being saved OR -1 if not initialised
;  &14 = length being saved

temp$l
 DCD 0
 DCD 0
send_data_save
 FNJSR "R1-R11"
 TST R10,#4
 LDRNE R14,[R1,#4]
 STRNE R14,temp$l
 LDRNE R14,[R1,#8]
 STRNE R14,temp$l + 4
 MOV R0,#&20			; block size
 BL heap_claim			; claim it
 FNRTS VS
 STMIA R0,{R7,R11}		; save the routine to call when finished
 MOV R7,R2			; save file name pointer
 MOV R11,R0			; save the block address
 TST R10,#2
 BNE area$l			; save a general area
 MOV R0,#-1
 STR R0,[R11,#&10]		; no start of area yet
 CMP R8,#0
 BEQ sel$l			; selection
 BL get_wind_off		; R0=offset of the window
 LDR R2,[R9,#f_len]		; length
 B send$l
area$l
 STR R8,[R11,#&10]		; save start address of area
 MOV R0,#-2
 MOV R2,R9			; length
 B send$l
sel$l
 BL get_selection		; get R8/R9 and R2=length
 FNRTS CS
 MOV R0,#-1			; selection
send$l				; R0=offset (&C) R2=length (&14)
 STR R0,[R11,#&0C]		; window offset
 STR R2,[R11,#&14]		; length to save
 FNLDR R1,wimp_block
 STR R3,[R1,#20]		; window
 STR R4,[R1,#24]		; icon
 STR R5,[R1,#28]		; mouse x
 STR R6,[R1,#32]		; mouse y
 STR R2,[R1,#36]		; length

; TST R10,#4
; LDRNE R6,[R1,#8]		; message reference ; (NEW)
; MOVEQ R6,#0			; (NEW)

 TST R10,#2
 BNE type$l			; type already given 'cos R8/R9=area

 LDR R0,[R9,#f_load]		; file/selection R9
 BL calc_ftype			; get filetype
 ORRCC R10,R10,#1:SHL:3		; untyped
 MOV R10,R10,LSL#16
 MOV R10,R10,LSR#16		; either way, clear the filetype field
 ORRCS R10,R10,R0,LSL#16
 BICCS R10,R10,#1:SHL:3
type$l				; file type installed in R10
 STR R10,[R11,#8]		; save updated flags
 TST R10,#1:SHL:3		; is it untyped?
 MOVNE R0,#-1			; if so, use -1 as the filetype ...
 MOVEQ R0,R10,LSR #16		; else use whatever was supplied / calculated
 STR R0,[R1,#40]		; save the file type
 MOVS R0,R7			; path name
 LDREQ R0,[R9,#f_name]
 BL find_leaf_name
 MOV R6,R1
 ADD R1,R1,#44
 MOV R2,R0
 BL strcopy			; copy in the leaf name
 SUB R1,R1,R6
 ADD R1,R1,#3
 BIC R1,R1,#3			; align...
 STR R1,[R6]			; length...
 TST R10,#1			; test for an ExtEdit
 MOVEQ R0,#1			; DataSave message
 LDRNE R0,e$l			; EditDataSave
 FNLDR R1,wimp_block		; message start
 MOVEQ R2,R3			; dest window (& R4=icon)
 MOVNE R2,R4			; dest task (& thus R4 not used)
 ORR R0,R0,#&F<<28		; want all replies + delete
 MOV R3,#44
 ORR R3,R3,#1<<31		; string ending
 ADR R5,sub$l
 MOV R6,R11			; block to send
 TST R10,#4
 BNE areply$l
 BL message_send		; send the message
 FNRTS
areply$l
 LDRNE R14,temp$l
 STRNE R14,[R1,#4]
 LDRNE R14,temp$l + 4
 STRNE R14,[R1,#8]

 BL message_reply
 FNRTS

e$l DCD &45D84			; EditDataSave
sub$l				; reply to data save message
 TEQ R0,#0
 BEQ b$l			; message dying
 TEQ R0,#17
 BNE a$l			; message bounced
 TEQ R2,#2
 BEQ data_save_ack		; replied with a data_save_ack
 TEQ R2,#6
 BEQ ram_fetch			; replied with a ram fetch
 TEQ R2,#13
 BEQ data_saved			; sent a data saved message later on
 MOV PC,R14			; unrecognised message - don't abort!
a$l				; recognised one may follow !!
; B Beep ; SWI &107		; receiver died - but _that's OK_...
 MOV PC,R14
b$l
 MOV R0,R11
 B heap_free			; free the block when message killed

 LOCAL

; R1=message R11=data block

data_save_ack			; save out data to a file
 FNJSR
; SWI &107
 LDR R0,[R11,#&0C]		; window offset being saved
 CMP R0,#-1
 LDRLT R8,[R11,#&10]
 LDRLT R9,[R11,#&14]		; address of the area
 MOVEQ R8,#0
 MOVEQ R9,#0			; selection
 BLGT conv_wind_off		; R8/R9 of window
 LDR R10,[R11,#8]		; flags
 LDR R0,[R1,#36]
 MOV R2,R1			; save message block
 CMP R0,#-1
 ORREQ R10,R10,#4		; unsafe
 ADD R0,R1,#44			; pathname to save to
 MOV R1,R10			; flags
 BL save_to_file
 FNRTS VS
 TEQ R0,#0
 FNRTS NE			; save didn't occur!
 MOV R0,#3			; data load
 MOV R1,R2			; message
 LDMIA R11,{R5,R6}		; routine to call when finished
 CMP R5,#0
 ADDGT R0,R0,#&9<<28		; if there is a routine then we want a reply
 BL message_reply		; send data load reply
 FNRTS

 LOCAL

; R1=message block R11=data

ram_fetch			; save out data by Ram transfer
 FNJSR
 TEQ R0,#19
 BLEQ err$l			; repeat message bounced
 FNRTS VS
; SWI &107
 MOV R10,R1			; save source message
 LDR R0,[R11,#&10]		; start address of the data
 CMP R0,#0
 BGE a$l			; data has already been set up
 LDR R0,[R11,#&0C]		; window block offset
 BL conv_wind_off		; R8/R9 or 0 if sel
 BL selection_data		; R0=start R1=len of the data (unsplit)
 FNRTS VS
 STR R0,[R11,#&10]		; start of data
 STR R1,[R11,#&14]		; length of data
a$l				; data start address (set up)
 LDR R5,[R10,#24]		; dest buffer length
 LDR R6,[R11,#&14]		; amount of data left to move
 CMP R5,R6
 MOVLT R4,R5
 MOVGE R4,R6			; smallest of the two is the amount to move
 FNLDR R0,wimp_task		; source task (Zap)
 LDR R1,[R11,#&10]		; source buffer address
 LDR R2,[R10,#4]		; dest task
 LDR R3,[R10,#20]		; dest buffer
 TEQ R4,#0
 SWINE XWimp_TransferBlock	; transfer (non zero bytes)
 FNRTS VS
 ADD R1,R1,R4
 STR R1,[R11,#&10]		; new source buffer posn
 SUB R6,R6,R4
 STR R6,[R11,#&14]		; new amount left to move
 STR R4,[R10,#24]		; number of bytes transfered
 MOV R0,#7			; ram transmit
 SUBS R4,R5,R4			; number of bytes free in dest buffer
 ORREQ R0,R0,#&D<<28		; send recorded if expecting more
 MOV R1,R10
 ADR R5,ram_fetch		; send replies back here
 MOV R6,R11			; data block
 BL message_reply		; reply with ram transmit
 FNRTS VS
 TEQ R4,#0
 FNRTS EQ			; not finished yet (buffer was full)
 LDR R1,[R11,#0]		; routine to called when finished
 CMP R1,#0
 LDR R11,[R11,#4]
 FNRTS LE
 MOVS R14,PC
 MOV PC,R1			; call finish code (if it exists)
 FNRTS
err$l ERR "zap_e_ramxfer_receiver"

data_saved			; app has called us back saying
 FNJSR				; all went well
; SWI &107
 LDR R0,[R11,#&0C]		; window offset
 CMP R0,#0
 FNRTS MI			; not interested
 BL conv_wind_off		; R8/R9 of window
 LDR R0,[R9,#f_flags]
 BIC R0,R0,#1<<3
 STR R0,[R9,#f_flags]
 BL new_file_title		; mark as saved successfully
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Loading from another App					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

; Creates a block in R11 of the format:
; 0-&FF Wimp data save message
; length of block = &100 + proposed length of data +4

data_save			; another app (or external edit) wants to
 FNJSR				; saving to me
 MOV R14,#1
 FNSTR R14,opt_temporary	; tell inject_file not to check Shift
 LDR R0,[R1,#20]		; window handle
 BL convert_wind_handle
 BCC a$l			; dropped on an edit window
 CMP R0,#-2
 BEQ a$l			; dropped on the iconbar
 BL convert_job_handle
 BCC a$l			; an external edit request
 MOV R0,#17
 BL wimp_passon			; forward the message
 FNRTS
a$l				; we are accepting the message
 LDR R5,[R1,#36]		; expected file length
 CMP R5,#&10
 MOVLT R5,#&100			; it was ridiculously small (or -ve!!)
 CMP R5,#&100000		; compare with 1 meg
 MOVGT R5,#&10000		; was ridiculously large (default to 64k)
 STR R5,[R1,#36]		; write back
 ADD R5,R5,#4			; ram fetch buffer length
 ADD R0,R5,#&100		; add room for wimp message at start
 BL heap_claim
 MOVVC R11,R0			; buffer pointer
 MOVVC R10,R1			; save the wimp message
 MOVVC R2,R0
 MOVVC R3,#&100
 BLVC move_bytes		; copy wimp message
 MOVVC R1,R10			; the wimp message
 ADDVC R0,R11,#&100
 STRVC R0,[R1,#20]		; buffer address
 STRVC R5,[R1,#24]		; buffer length
 MOVVC R0,#6+(&D<<28)		; ram fetch
 ADRVC R5,sub$l			; reply sub
 MOVVC R6,R11			; reply data block
 BLVC message_reply		; send the message
 FNRTS
sub$l				; reply to ram fetch
 TEQ R0,#17
 BNE ram_fetch_back		; sender doesn't support ram fetch
 TEQ R2,#7
 BEQ ram_transmit		; sender replied with a transmit
 MOV PC,R14

;E R0=error pointer if VS R11=info block
;X Block freed with error status presered.

abort_transfer
 STMFD R13!,{R0,R14}
 MOV R0,R11
 BL heap_free
 LDMFD R13!,{R0,PC}^

 LOCAL

ram_fetch_back			; ram fetch message bounced
 FNJSR
 MOV R1,R11
 FNLDR R2,wimp_block
 MOV R3,#&100
 BL move_bytes			; copy original data save message to WB
 FNLDR R10,wimp_block
 MOV R0,#-1
 STR R0,[R10,#36]		; mark file unsafe
 ADR R0,t$l
 MOV R1,#0
 MOV R2,#-1
 MOV R3,#0
 MOV R4,#0
 SWI XOS_ReadVarVal
 CMP R2,#0			; clear V flag
 ADD R1,R10,#44			; destination file name
 BNE a$l			; does exist
 ADR R2,s$l
 B b$l				; quote wimpscrap as a filename
a$l
 ADR R2,u$l
 BL strcpy
 ADD R2,R11,#44			; get leaf name from original message
b$l
 BL strcopy			; finish the file name
 SUB R0,R1,R10			; block length
 ADD R0,R0,#3
 BIC R0,R0,#3			; word align
 STR R0,[R10]			; new message length
 MOV R0,#2+(&D<<28)		; DataSaveAck
 MOV R1,R10
 ADR R5,sub$l			; reply sub
 MOV R6,R11			; pass on the block
 BL message_reply		; reply with data save ack
 FNRTS
s$l FNS ("<Wimp$Scrap>")
t$l FNS ("Wimp$ScrapDir")
u$l FNS ("<Wimp$ScrapDir>.")
sub$l				; R0=type R1=mess R2=mess num R11=block
 TEQ R0,#17			; ignore bounced messages - task manager
 MOVNE PC,R14			; will reply later - don't delete block!
 TEQ R2,#3
 BEQ data_load_start		; replied to data_save_ack with a data_load
 MOV PC,R14

 LOCAL

;E R1=data load message R11=original data save message block / 0 if filer
; R8=?...

data_load			; app/filer wants me to load a file
 MOV R11,#0			; no data block if from filer
 FNSTR R11,opt_temporary	; tell inject_file to check Shift
data_load_start			; reply to previous messages R11=block
 FNJSR
 MOV R10,R1			; R10=save the message
 LDR R0,[R1,#20]		; window handle
 CMP R0,#-2			; the icon bar's icon number
 MOVEQ R8,#0			; ?!?!
 BEQ b$l			; save onto the iconbar
 BL get_MiniBuf
 LDR R2,[R7,#8]			; minibuffer window handle
 TEQ R0,R2
 BEQ e$l			; minibuffer...
 BL convert_wind_handle
 BCC a$l			; destination window
 BL convert_job_handle
 BCC f$l			; was an external edit request - :-<
; BCC b$l			; was an external edit request - :-)
 MOV R0,#17
 BL wimp_passon			; not a recognised window
 FNRTS
a$l
 BL conv_wind_off		; set up R8/R9
b$l				; R8/R9=window to save to / R8=0 for iconbar
 ADD R0,R1,#44			; name of file to load
 TEQ R8,#0			; !?!?!
 BNE c$l			; dropped on a window
 BL install_file		; install the file (all saved)
 FNRTS VS
 TEQ R11,#0
 BEQ ack$l			; came from filer
 CMP R0,#0
 FNRTS MI			; file hasn't been loaded yet
 BL conv_wind_off		; get R8/R9 for this file
 LDR R0,[R9,#f_flags]
 ORR R0,R0,#1<<3
 STR R0,[R9,#f_flags]		; file has not been saved yet
 MOV R0,#-1
 STR R0,[R9,#f_chklen]		; store -1 in chklen; ie: always modified until saved
 ADD R0,R11,#44			; leaf name sent in data save message
 BL new_file_name
 BLVC new_file_title		; give leaf name as title
 BVC d$l			; finished
 FNRTS
e$l
 ADD R0,R1,#44
 BL minibuffer_write		; insert into minibuffer
 BLVC minibuffer_update		; and redraw
 FNRTS
c$l
 BL inject_file			; insert in window
 FNRTS VS
; SWI &107			; beep...
 TEQ R11,#0
 BEQ ack$l
; !!! Removed because we shouldn't send DataSaved unless
; !!! we have actually saved it ...
d$l				; file loaded & R11=original message
; MOV R0,#20
; STR R0,[R11]			; len
; MOV R0,#13			; send data saved message
; MOV R1,R11
; BL message_reply		; use ref from original data save message
 BLVC abort_transfer		; free the buffer
 MOVVC R0,#6
 ADDVC R1,R10,#44		; filename of file we loaded in
 SWIVC XOS_File			; delete scrap file
; FNRTS VS -- this was commented anyway ...
ack$l				; acknowledge data load
 MOVVC R0,#4			; data load ack
 MOVVC R1,R10
 BLVC message_reply
 FNRTS
f$l
 LDR R0,[R10,#20]		; job handle...
 MOV R0,R0,LSR#16
 SUBS R0,R0,#1			; find file off
 FNLDR R14,file_num
 CMP R0,R14			; is it in range
 FNRTS CS			; gone!?!?!?
 BL conv_file_off		; get R9
 ADD R0,R10,#44			; name of file to load
 B c$l			; dropped on a window

 LOCAL

; fills in block with
;  #0=current offset in the block
;  #36=amount asked for

ram_transmit			; first reply to our ram fetch message
 FNJSR				; my buffer has been filled
; SWI &107
 MOV R0,#&100
 STR R0,[R11]
 LDR R0,[R11,#36]
 ADD R0,R0,#4
 STR R0,[R11,#36]
 MOV R0,#17			; ok
 BL sub$l
 FNRTS
sub$l				; repeat reply to ram fetch
 FNJSR
 TEQ R0,#17
 BLNE err$l			; transmitter died
 FNRTS VS
 MOV R10,R1			; save message pointer
 LDR R5,[R11,#36]		; amount asked for
 LDR R4,[R11]			; current offset
 LDR R0,[R1,#24]		; bytes written to buffer
 CMP R0,R5
 BLT finished$l			; buffer not filled
 ADD R4,R4,R5
 STR R4,[R11]			; new offset in buffer (of data end)
 MOV R0,R11
 ADD R1,R4,#&1000
 BL heap_ensure			; extend buffer by 4K
 FNRTS VS
 MOV R11,R0			; new block pointer
 ADD R0,R11,R4
 STR R0,[R10,#20]		; buffer address
 MOV R0,#&1000
 STR R0,[R10,#24]		; buffer length
 STR R0,[R11,#36]		; amount asked for
 MOV R0,#6+(&D<<28)		; ram fetch
 MOV R1,R10
 ADR R5,sub$l
 MOV R6,R11
 BL message_reply
 FNRTS
finished$l			; ram transfer complete
 ADD R4,R4,R0			; end of text offset
 LDR R0,[R11,#20]		; window handle where file was dropped
 BL convert_wind_handle
 BCC wind$l			; an edit window
 BL convert_job_handle
 BCC job$l			; an external edit window
 LDR R0,[R11,#40]		; file type
 BL calc_load			; R2=load address R3=exec address
 SUB R0,R4,#&100		; length of file
 ADD R1,R11,#44			; file name
 BL create_file_block
 FNRTS VS
 LDR R0,[R9,#f_flags]
 ORR R0,R0,#1<<3
 STR R0,[R9,#f_flags]		; this file hasn't been saved yet
 ADD R1,R11,#&100		; source
 LDR R2,[R9,#f_ptr]		; dest
 SUB R3,R4,#&100		; len
 BL move_bytes			; copy in file data
 BL create_window_block
 BLVC create_window_caret
 BVC done$l
 FNRTS
wind$l
 BL conv_wind_off		; set up R8/R9
job$l				; R8/R9=window to insert into
 BL find_input
 MOV R1,R0			; offset to insert data
 FNLDR R10,car_cursor
 BL goto_file_offset		; hopefully simply works...
 MOV R0,#&11			; insert block
 SUB R2,R4,#&100		; length of text
 ADD R3,R11,#&100		; address of text
 BL execute_command		; insert the block
 FNRTS VS
done$l				; R8/R9=window with file inserted
; !!! removed this, because we SHOULD NOT send DataSaved unless
; !!! we have actually saved the file ...
; MOV R0,#20
; STR R0,[R11]			; new length
; MOV R0,#13			; send data saved
; MOV R1,R11
; BL message_reply		; (using original data save ref)
 BL abort_transfer		; free the block
 FNRTS
err$l ERR "zap_e_ramxfer_transmitter"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Are we interested in editing a given file?			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

data_open
 FNJSR
; SWI &107
 LDR R0,[R11,#40]		; file type
 TEQ R0,#&3000
 MOVEQ R0,#&1000
 BEQ gottype$l			; untyped
 CMP R0,#&1000
 FNRTS CS			; invalid type (eg directory)
gottype$l
 BL calc_load			; get load/exec in R2/R3
 MOVVC R0,R2			; load address
 ADDVC R1,R11,#44		; pathname
 ORRVC R1,R1,#1<<31		; don't load the mode
 BLVC find_file_mode		; get keys data for this file type
 FNRTS VS
 LDR R0,[R0,#4]
 TST R0,#1<<31
 BNE load$l			; load even if shift not pressed
 MOV R0,#&81
 MOV R1,#(3 :EOR: &FF)		; left shift
 MOV R2,#&FF
 SWI XOS_Byte			; scan for key
 FNRTS VS
 TEQ R1,#&FF
 FNRTS NE			; not pressed
load$l
 MOV R0,#4			; data load ack
 MOV R1,R11
 BL message_reply
 ADDVC R0,R11,#44
 BLVC install_file
 FNRTS

pre_quit
 FNJSR
 BL test_quit_ok
 FNRTS CC			; if quit ok then don't acknowledge
 LDR R0,[R11]			; get message length
 CMP R0,#24
 MOVCC R0,#0
 LDRCS R0,[R11,#20]		; get flags word
 FNLDR R14,opt_switches
 TST R0,#1
 ORREQ R14,R14,#switch_QuitMeansShutdown	; everyone
 BICNE R14,R14,#switch_QuitMeansShutdown	; only quit this task
 FNSTR R14,opt_switches
 LDR R0,[R11,#8]
 STR R0,[R11,#12]		; copy my ref to your ref
 MOV R0,#19			; acknowledge
 MOV R1,R11
 LDR R2,[R11,#4]		; dest task
 FNSTR R2,wimp_quitsender	; task handle of person who sent it
 SWI XWimp_SendMessage
 BLVC open_QuitBox
 FNRTS

save_desktop
 FNJSR
 FNLDR R9,wimp_block		; buffer
 MOV R1,R9
 ADR R2,sd_d0
 BL strcpy
 ADR R0,sd_s0
 MOV R2,#&C0
 MOV R3,#0
 MOV R4,#3
 SWI XOS_ReadVarVal
 FNRTS VS
 ADD R1,R1,R2			; end of string
 MOV R0,#10
 STRB R0,[R1],#1		; add terminator
 SUB R3,R1,R9			; data length
 MOV R2,R9			; data pointer
 LDR R1,[R11,#20]		; file handle
 MOV R0,#2
 SWI XOS_GBPB			; add my line to file
 FNRTS
sd_d0 FNS ("RMEnsure Zap 0.01 Filer_Run ")
sd_s0 FNS (|zap$|:CC:"$Dir")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object Linking and Embedding (OLE) protocol		 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; OLE protocol files are owned by text mode (0).
; f_source points to a block of format:
; #0	1 (=> OLE)
; #4	Session number
; #8	Task handle of client task
;
; See also External Edit, below.

 LOCAL

OLE_OpenSession
 FNJSR "R1-R12"

 LDR R6,[R11,#20]
 LDR R7,zapname$l
 CMP R6,R7
 FNRTS NE			; "Zap " is unique since OLE pads with spaces

 LDR R6,[R11,#48]		; reason
 LDR R7,[R11,#4]		; task handle
 LDR R8,[R11,#52]		; session number
 CMP R6,#2
 BEQ reopen$l
 FNRTS GT

 MOV R0,#12			; size required
 BL heap_claim
 FNRTS VS

 MOV R2,#1
 STR R2,[R0,#ole_ole]		; I'm an OLE file
 STR R7,[R0,#ole_taskhandle]	; task handle of origin
 STR R8,[R0,#ole_session]	; session number
 MOV R7,R0			; so we don't lose it
 ADD R0,R11,#60			; filename way out here
 BL find_file			; returns R9, preseves R0
 BVC ok$l

 MOV R1,R0			; save error

 MOV R0,R7			; something went wrong, so
 BL heap_free			; free the data block and

 MOV R0,R1			; restore error
 FNRTV				; return, generating the error

ok$l
 MOV R0,#0
 STR R0,[R9,#f_cmode]		; newly created file, so we can own it
 STR R7,[R9,#f_source]		; data block

 ; For reasons I can't fathom, find_file doesn't get the mode right
 ; in this case. It's probably something to do with how it gets
 ; called under this situation, so I have to set it by hand.
 BL find_window			; \X R8/R9
 ADD R1,R11,#60			; filename
 STMFD R13!,{R2-R5}		; preserve output regs from SWI
 MOV R0,#17
 SWI XOS_File
 MOV R0,R2			; load address
 LDMFD R13!,{R2-R5}
 BL find_file_mode		; \E R0=load addr, R1=>filename, \X R10=mode
 MOV R0,R10
 BL new_mode			; \E R0,R8/R9

 LDR R0,opensessionack$l
 MOV R1,R11			; original message block
 BL message_reply
 FNRTS

zapname$l
 = "Zap",0
opensessionack$l
 DCD &80E22

reopen$l
 ; R11 is wimp message block, R7 taskhandle, R8 session number
 BL find_ole_file		; returns R9, preserves R7, R8, R11
 FNRTS CS

 BL find_window			; \X R8
 MOV R1,R8
 SWI XWimp_GetWindowState	; get current position
 MOV R0,#3			; to front
 BL open_a_window
 LDR R0,opensessionack$l
 MOV R1,R11
 BL message_reply
 FNRTS

find_ole_file
 ; /E R7 task handle, R8 session number
 ; /X R9 or CS
 FNJSR
 FNLDR R0,file_num		; the number of valid file numbers
 SUB R10,R0,#1			; limit
 MOV R2,#0			; counter
find$l
 CMP R2,R10
 BGT bad$l

 MOV R0,R2			; for conv_file_off
 ADD R2,R2,#1			; increment now before we loop
 BL conv_file_off
 LDR R3,[R9,#f_cmode]
 CMP R3,#0			; owned by text mode?
 BNE find$l

 LDR R3,[R9,#f_source]
 LDR R4,[R3,#ole_ole]
 CMP R4,#1			; OLE file?
 BNE find$l

 LDR R4,[R3,#ole_taskhandle]
 LDR R3,[R3,#ole_session]
 CMP R4,R7
 CMPEQ R3,R8
 BNE find$l

 ADDS R0,R0,#0			; clc
 FNRTS				; found it

bad$l
 SUBS R0,R0,#0			; sec
 FNRTS

 LOCAL

OLE_CloseSession
 FNJSR
 LDR R7,[R11,#4]		; task handle
 LDR R8,[R1,#24]		; session number
 CMP R8,#1			; all sessions
 BEQ allsessions$l
 BL find_ole_file
 FNRTS CS			; didn't find it
 MOV R0,#-1
 STR R0,[R9,#f_cmode]		; we don't own it any more
 LDR R0,[R9,#f_source]
 BL heap_free			; free up block
 BL discard_file
 FNRTS
allsessions$l
 FNLDR R0,file_num
 SUB R10,R0,#1			; limit
 MOV R2,#0			; counter
find$l
 CMP R2,R10
 FNRTS GT

 MOV R0,R2			; for conv_file_off
 ADD R2,R2,#1			; increment now before we loop
 BL conv_file_off
 LDR R3,[R9,#f_cmode]
 CMP R3,#0			; owned by text mode?
 BNE find$l

 LDR R3,[R9,#f_source]
 LDR R4,[R3,#ole_ole]
 CMP R4,#1			; OLE file?
 BNE find$l

 LDR R4,[R3,#ole_taskhandle]
 CMP R4,R7			; does the task handle match?
 BNE find$l

 MOV R0,#-1
 STR R0,[R9,#f_cmode]		; we don't own it any more
 LDR R0,[R9,#f_source]
 BL heap_free			; free up block
 BL discard_file

 B find$l

 LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; External edit protocol				 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; External edit protocol files are owned by text mode (0).
; f_source points to a block of format:
; #0	0 (=> EE)
; #4	Job handle (Zap's part if file block offset +1)
; #8	Task handle of client task
; #12	Flags provided by client task (initially on EditRq)
; #16	Window offset of main window
;
; See also Object Linking and Embedding, above.

 LOCAL

Edit_Rq
 FNJSR "R3"
 LDR R0,[R11,#20]		; data type
 MOV R0,R0,LSL#20
 MOV R0,R0,LSR#20		; clear extension in top 20 bits
 BL calc_load			; get load/execute address
 MOVVC R0,R2
 MOVVC R1,#1<<31		; don't load the mode yet
 BLVC find_file_mode
 FNRTS VS
 LDR R0,[R0,#4]
 TST R0,#1<<31			; do we load this type of file?
 FNRTS EQ			; don't auto load this file
 MOV R4,R2			; save the load address
 FNLDR R1,wimp_data		; buffer to put filename
 MOV R0,#'('
 STRB R0,[R1],#1
 ADD R2,R11,#32
 BL strcpy			; parent name
 MOV R0,#')'
 STRB R0,[R1],#1
 MOV R0,#'.'
 STRB R0,[R1],#1
 ADD R2,R11,#52			; leaf name
 BL strcopy			; complete title
 MOV R0,#0			; empty
 FNLDR R1,wimp_data
 MOV R2,R4			; load address
 BL create_file_block		; create empty file in R9
;  FNRTS VS
;  BL create_window_block		; open an editing window
;  FNRTS VS
;  BL get_file_off		; R0=file pointer
;  ADD R0,R0,#1			; add 1 as handles must be non 0
;  LDR R1,[R11,#24]		; job handle
;  ORR R1,R1,R0,LSL#16		; complete the job handle
;  STR R1,[R11,#24]		; write new job handle
;  MOV R0,#32
;  BL heap_claim			; claim info block for this mode
;  FNRTS VS
;  STR R0,[R9,#f_source]		; info block address
;  MOV R10,R0			; save info block
;  STR R1,[R10,#ee_jobhandle]	; job handle
;  MOV R0,#0
;  STR R0,[R10,#ee_ee]		; I'm an EE thingumy
;  LDR R0,[R11,#4]		; was 4
;  STR R0,[R10,#ee_taskhandle]	; task handle of client
;  LDR R0,[R11,#28]
;  STR R0,[R10,#ee_flags]		; flags word
;  BL get_wind_off
;  STR R0,[R10,#ee_windoffset]	; offset of associated window
;  MOV R0,#0
;  STR R0,[R9,#f_cmode]		; now owned by text mode
;  LDR R0,d$l
;  MOV R1,R11
;  MOV R5,#0			; deal with replies as if they were normal
;  BL message_reply		; acknowledge the message
;  FNRTS VS
;  MOV R0,#0
;  BL put_caret			; put the caret at the file start
;  FNRTS
; d$l DCD &45D81+(9<<28)	; Edit ack + want reply
;  BL create_file_block		; create empty file in R9
;  BLVC create_window_block	; open an editing window

; BLVC get_file_off		; R0=file pointer (X gets R9)
; MOVVC R1,#-513
; ADRVC R2,go_create_window_block$l
; MOVVC R3,R0			; was R9
; BLVC call_back			; open window on next null poll

 BLVC get_file_off		; R0=file pointer
 ADDVC R0,R0,#1			; add 1 as handles must be non 0
 LDRVC R1,[R11,#24]		; job handle
 ORRVC R1,R1,R0,LSL#16		; complete the job handle
 STRVC R1,[R11,#24]		; write new job handle
 MOVVC R0,#32
 BLVC heap_claim		; claim info block for this mode
 STRVC R0,[R9,#f_source]	; info block address
 MOVVC R10,R0			; save info block
 STRVC R1,[R10,#ee_jobhandle]	; job handle

; BLVC get_file_off		; R0=file pointer (X gets R9)
; MOVVC R0,R3
; BLVC ee_create_window_block$l	; this seems to work.

; BLVC create_window_block		; returns R8...
; MOVVC R0,#0
; BLVC put_caret			; put the caret at the file start
; BLVC get_wind_off
; LDRVC R10,[R9,#f_source]	; info block address
; MOVVC R0,#-1
; STRVC R0,[R10,#ee_windoffset]	; offset of associated window
; LDRVC R14,[R8,#w_flags]
; ORRVC R14,R14,#1<<14		; unlink cursor
; STRVC R14,[R8,#w_flags]

; LDRVC R3,[R10,#ee_windoffset]
; ; BL get_wind_off
 BLVC get_file_off		; R0=file pointer
 MOVVC R1,#-32			; delay = 1/3 seconds.
 ADRVC R2,ee_create_window_block$l; go_create_window_block2$l
 MOVVC R3,R0			; was found from R9 ... now -> R11...
 BLVC call_back			; open window on next null poll

 MOVVC R0,#0
 STRVC R0,[R10,#ee_ee]		; I'm an EE thingumy
 LDRVC R0,[R11,#4]
 STRVC R0,[R10,#ee_taskhandle]	; task handle of client
 LDRVC R0,[R11,#28]
 STRVC R0,[R10,#ee_flags]	; flags word

 MOVVC R0,#-1			; !?!?!?!?!?!
 STRVC R0,[R10,#ee_windoffset]	; offset of associated window

 MOVVC R0,#0
 STRVC R0,[R9,#f_cmode]		; now owned by text mode
 LDRVC R0,d$l
 MOVVC R1,R11
 MOVVC R5,#0			; deal with replies as if they were normal
 BLVC message_reply		; acknowledge the message
;  MOVVC R0,#0
;  BLVC put_caret			; put the caret at the file start
 FNRTS
d$l DCD &45D81+(9<<28)	; Edit ack + want reply

;go_create_window_block$l	; for EE files
; STMFD R13!,{R1-R11,R14}
; MOV R0,R11
; BL conv_file_off
; CMP R9,#0
; LDMLEFD R13!,{R1-R11,PC}^
;
; BL create_window_block
;
; MOVVC R0,#0
; BLVC put_caret			; put the caret at the file start
; BLVC get_wind_off
; LDRVC R10,[R9,#f_source]		; info block address
; STRVC R0,[R10,#ee_windoffset]	; offset of associated window
; LDMFD R13!,{R1-R11,PC}

; go_create_window_block2$l	; for EE files
;  STMFD R13!,{R1-R11,R14}
;  MOV R0,R11
;  BL conv_wind_off
;  CMP R8,#0
;  LDRGE R14,[R8,#w_flags]
;  BICGE R14,R14,#1<<14		; unlink
;  STRGE R14,[R8,#w_flags]
;  LDRGE R9,[R8,#w_file]
;  MOVGE R1,#1
;  MOVGE R2,#0
;  BLGE Cup
;  LDMFD R13!,{R1-R11,PC}

ee_create_window_block$l
 STMFD R13!,{R1-R11,R14}
; SWI &107
 MOV R0,R11
 BL conv_file_off
 TEQ R9,#0
 LDMEQFD R13!,{R1-R11,PC}
 BL create_window_block		; returns R8...
 MOVVC R0,#0
 BLVC put_caret		; put the caret at the file start
 BLVC get_wind_off
 LDRVC R10,[R9,#f_source]	; info block address
 STRVC R0,[R10,#ee_windoffset]	; offset of associated window
 MOVVC R0,#0
 BLVC put_caret			; put the caret at the file start
 LDMFD R13!,{R1-R11,PC}

 LOCAL

Edit_Return
 FNJSR
 LDR R0,[R11,#24]		; job handle
 BL convert_job_handle		; get R8/R9
 FNRTS CS			; no good
 MOV R2,#0			; use default name
 LDR R3,[R11,#24]		; job handle
 LDR R4,[R11,#4]		; task to send to
 MOV R7,#0			; no window to update
 LDR R1,[R11,#28]		; flags
 TST R1,#2
 MOVNE R8,#0			; selection only
 TST R1,#1
 ADREQ R7,sub$l			; delete the file (not continue)
 MOV R10,#1			; external edit
 MOV R11,R9			; file is the data to pass
 BL send_data_save
 TSTVC R1,#1
 FNRTS				; Don't kill file - isn't saved yet!
sub$l
 FNJSR	"R9"
 MOV	R9,R11
 MOV	R0,#-1
 STR	R0,[R9,#f_cmode]		; no longer an external edit file
 LDR	R0,[R9,#f_source]		; SJA (was missing)
 BL	heap_free			; free the buffer - SJA (was missing)
 BL	discard_file		; delete
 FNRTS

Edit_Abort
 FNJSR
 LDR	R0,[R11,#24]		; job handle
 BL	convert_job_handle		; get R8/R9
 FNRTS	CS			; no good
 MVN	R0,#0
 STR	R0,[R9,#f_cmode]		; disown mode
 LDR	R0,[R9,#f_source]
 BL	heap_free			; free the buffer
 BLVC	discard_file		; kill the file
 FNRTS

Edit_Cursor
 FNJSR
 LDR	R0,[R11,#24]		; job handle
 BL	convert_job_handle		; get R8/R9
 FNRTS	CS			; no good
 MVN	R4,#0			; cursor
 MVN	R5,#0			; sel start
 MVN	R6,#0			; sel end
 FNLDR	R10,car_cursor
 BL	test_cblk
 LDREQ	R4,[R10,#c_off]
 STMFD	R13!,{R8-R9}
 BL	get_selection
 MOV	R3,R8
 LDMFD	R13!,{R8-R9}
 FNRTS	VS
 BCS	ec1			; no valid selection
 TEQ	R3,R8
 MOVEQ	R5,R1			; selction start
 ADDEQ	R6,R1,R2			; selection end
ec1
 STR	R4,[R11,#44]
 STR	R5,[R11,#48]
 STR	R6,[R11,#52]		; save old values
 LDR	R0,[R11,#32]		; new cursor posn
 BL	edit_cur_off
 BMI	ec2			; read only
 FNLDR	R10,car_cursor
 BL	goto_offset			; jump to the new cursor posn
 FNRTS	VS
ec2
 LDR	R0,[R11,#36]		; new sel start
 BL	edit_cur_off
 MOVMI	R0,R5			; old value
 MOV	R2,R0			; sel start
 LDR	R0,[R11,#40]		; new sel end
 BL	edit_cur_off
 MOVMI	R0,R6			; old end
 MOV	R3,R0			; sel end
 TEQ	R2,R5
 TEQEQ	R3,R6
 BEQ	ec3			; haven't moved
 BL	select_region
 FNRTS	VS
ec3
 MOV	R0,#56			; message length
 STR	R0,[R11]
 LDR	R0,[R11,#16]
 BL	message_reply		; reply with same message number
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Edit protocol subs					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=-1 for read -2 for file end >=0 to set position
;X PL R0=new (clipped) position / MI if read. |

edit_cur_off
 FNJSR
 LDR	R14,[R9,#f_len]
 CMP	R0,R14
 MOVGE	R0,R14			; clip to file end
 CMN	R0,#2			; is it -2
 MOVEQ	R0,R14			; if so place cursor at file end
 CMP	R0,#0			; check for read (-1).
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Message sending replying subs				    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=message block
;X Message acknowledged preserving my_ref (reason code 19)

message_ack
 STMFD	R13!,{R1-R4,R14}
 LDMIB	R1,{R2,R4}		; task handle of sender, my_ref
 STR	R4,[R1,#12]		; copy
 MOV	R0,#19
 MOV	R3,#0
 STMFD	R13!,{R2}
 SWI	XWimp_SendMessage
 LDMFD	R13!,{R2}
 STMIB	R1,{R2,R4}		; restore refs
 LDMFD	R13!,{R1-R4,PC}

;E R0=message action number (as for message_send)
;  R1=message block (with ref etc)
;  R5/R6=rountine to handle the reply if b28 of R0 (as for send message)
;X Message replied to #

message_reply
 FNJSR	"R1-R3"
 BL	message_setup
 STR	R0,[R1,#16]		; message action
 LDR	R0,[R1,#8]
 STR	R0,[R1,#12]		; fill in your ref
 MOV	R0,R3			; send code
 LDR	R2,[R1,#4]			; task handle of sender
 MOV	R3,#0
 SWI	XWimp_SendMessage
 BLVC	message_log
 FNRTS

 LOCAL

;E R0=b0-b27 message action number (to go in R1,#16)
;     b28    set if you are interested in the reply.
;     b29    set if you want to be called when message deleted
;     b30-31 00 => Just send the message (with code 17)
;	     01 => Just acknowledge the message (with code 19)
;	     10 => Send the message recorded (with code 18) and call the
;		   reply code if the message replied to.
;	     11 => Send the message recorded (with code 18) and call the
;		   reply code if the message replied to or bounces.
;  R1=message block or 0
;  R2=dest task handle/window handle/0 to broadcast
;  R3=b31 clear => This is the message length (is rounded up to next word)
;     b31 set	=> This is the offset of a string ending the message.
;  R4=icon handle if R2=-2 (iconbar) [not used otherwise]
;  R5=address of routine to call when message replied to [if b28 of R0]
;     (zero as a value means that you want any replies to be dealt with
;      as if they were normal messages and not a reply)
;  R6=private word to pass to routine on a reply [if b28 of R0]
;X The message is sent as an original message. Hence the my_ref, length
;  and message action fields are filled in for you. R0=task handle of the
;  dest task (R2 on exit from Wimp_SendMessage)
;	Routine in R5 called with:
;		;E R0=message type
;			0 => message being removed from log list (see b29)
;			17 => message replied to as normal
;			19 => message bounced
;		   R1=message block
;		   R2=message number (R1!16) R11=private word R12=Zap's etc
;		;X You can corrupt R0-R11 if R0=17,19
;		   You should save R1-R11 if R0=0

message_send
 FNJSR	"R1-R3,R5"
 TST	R3,#1<<31
 BEQ	a$l
 STMFD	R13!,{R0}
 BIC	R3,R3,#1<<31		; offset of string
 ADD	R0,R1,R3			; address of string
 BL	str_len			; R0=length of string
 ADD	R3,R3,R0
 ADD	R3,R3,#1			; and terminator
 LDMFD	R13!,{R0}
a$l				; R3=length of the message
 ADD	R3,R3,#3
 BIC	R3,R3,#3			; word align length
 STR	R3,[R1]			; save message length
 MOV	R3,#0
 STR	R3,[R1,#12]		; original message
 BL	message_setup		; get message action in R0
 STR	R0,[R1,#16]		; message action
 MOV	R0,R3			; send code
 MOV	R3,R4			; icon handle
 SWI	XWimp_SendMessage
 BLVC	message_log		; log message for reply
 MOVVC	R0,R2			; return dest task handle
 FNRTS

;E R1=message action number
;  R2=address of routine to call when message received
;  R3=private word to pass to routine on a reply
;X Interest in this message is logged. When received, the routine in R2 is
;  called with:
;	;E R1=message block
;	   R2=message number (R1!16) R11=private word R12=Zap's etc
;	;X R0=0 if not interested (log entry left alone)
;	      else non-0 (log entry will be removed)
;	   R1-R11 corrupt

message_interested
 MOV	R0,#-2
 B	wimp_log

;E R0=message action number (b0-b27) +flags (b28-b31)
;  R5=reply routine (if b28) R6=reply private word (if b28)
;X R0=message action number with flags clear
;  R3=send code (b31 set then R3=18, b30 set then R3=19, else R3=17)
;  R5=reply routine (if b28) with b31 set if interested in bounces
;     b30 set if want to know when it's deletd or -1 if b28 clear

message_setup
 MOV	R3,R0,LSR#30
 TEQ	R3,#3
 ORREQ	R5,R5,#1<<31		; it is interested in bounces
 MOV	R3,#17			; all clear
 TST	R0,#1<<30
 MOVNE	R3,#19			; bit 30 set
 TST	R0,#1<<31
 MOVNE	R3,#18			; bit 31 set and b30 arbitrary
 TST	R0,#1<<29
 ORRNE	R5,R5,#1<<30		; wants to be called when message deleted
 TST	R0,#1<<28
 MOVEQ	R5,#-1			; no reply routine
 BIC	R0,R0,#&F0000000		; clear flags
 MOV	PC,R14

;E R1=message block after Wimp_SendMessage has been called
;  R5=address of routine to call on a reply or 0 if none
;     b31 set of wants bounces b30 set if wants to know when being deleted
;  R6=private word to use on reply (if R5<>0)
;X Message logged so replies can be dealt with.

message_log
 FNJSR	"R1-R3"
 CMP	R5,#-1
 FNRTS	EQ			; don't bother logging
 SWI	XOS_ReadMonotonicTime	; R0=current time (message sent)
 LDRVC	R2,[R1,#8]		; message reference
 MOVVC	R1,R0
 MOVVC	R0,R2
 MOVVC	R2,R5
 MOVVC	R3,R6
 BLVC	wimp_log
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Mode changed						    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

mode_changed
 FNJSR				; NB Can't use mode numbers any more
 FNLDR	R1,scn_magx
 FNSTR	R1,scn_magxold
 FNLDR	R2,scn_magy
 FNSTR	R2,scn_magyold		; save old magnification
 FNLDR	R3,scn_bpp		; save old bpp
 BL	check_scn_valid		; update mode variables
 FNRTS	VS
 FNLDR	R0,scn_magx
 TEQ	R0,R1
 FNLDR	R0,scn_magy,EQ
 TEQEQ	R0,R2
 FNLDR	R0,scn_bpp,EQ
 TEQEQ	R0,R3
 FNRTS	EQ			; mode aspects &bpp haven't changed

 BL	reload_templates

; BL read_font_info		; recache fonts

; FNLDR R2,font_charw
; FNLDR R3,font_charh
; FNSTR R2,red_charw
; FNSTR R3,red_charh		; for ensure_workarea_sprite

; BL correct_font

; BL font_resetcache ; ?????
 ADR	R10,sub$l
 BL	do_allwindow		; update all windows
 BLVC	minimise_font_memory	; remove old fonts
 BLVC	read_font_info
; MOVVC R14,#0
; FNSTR R14,font_cachedto,VC
 FNRTS
sub$l
 FNJSR
 BL	create_palette		; update the palette block

 LDRVC	R0,[R8,#w_flags]
 ORRVC	R0,R0,#1<<31		; mark window to be altered
 STRVC	R0,[R8,#w_flags]		; on next open... (bug...!)

; LDRVC R0,[R8,#w_format]	; don't ignore redraws...
; BICVC R0,R0,#1<<29
; STRVC R0,[R8,#w_format]

; BLVC alter_window ; doesn't work...

 LDRVC	R2,[R8,#w_font]		; font cache not valid any more
 MOVVC	R3,#font_data0
 MOVVC	R1,#-1
 BLVC	fill_words		; clear the entries in the cached font block
 BLVC	blat_cache_of_this_window
; BLVC Updatewindow		; this doesn't work here.
; new bit...
; MOVVC R1,R8
; SWI XWimp_GetWindowState
; BLVC open_window
; BLVC ccd_workxy			; R2,R3=max x,min y
; MOVVC R0,R2
; MOVVC R2,R3
; MOVVC R3,R0
; MOVVC R1,#0
; MOVVC R4,#0
; LDRVC R0,[R8,#w_handle]
; SWIVC XWimp_ForceRedraw	; invalidate area (/should/ already be on
 FNRTS

 LOCAL

palette_changed			; called before a mode change + doesn't
 FNJSR				; redraw itself (contrary to the manual!)
 ADR	R10,sub$l
 BL	do_allwindow
 FNRTS
sub$l				; R8,R9=next window
 FNJSR	"R1-R4"
 BL	create_palette		; regenerate the palette
; new bit...
 MOVVC	R1,R8
 SWIVC	XWimp_GetWindowState
 BLVC	open_window
 BLVC	ccd_workxy			; R2,R3=max x,min y
 MOVVC	R0,R2
 MOVVC	R2,R3
 MOVVC	R3,R0
 MOVVC	R1,#0
 MOVVC	R4,#0
 LDRVC	R0,[R8,#w_handle]
 SWIVC	XWimp_ForceRedraw	; invalidate area (/should/ already be on
 FNRTS				; a mode change...)

;X opt_flags and opt_format set up for current opt_mode
;  also checks opt_mode exists
;  will have to be one of Zaps internal modes or a permanently loaded mode

init_opts
 FNJSR	"R1,R8-R11"
 FNLDR	R0,default_mode
 LDRB	R1,[R0]
 TEQ	R1,#0
 BLNE	test_mode_name
 CMP	R0,#256
 MOVHS	R10,#0
 MOVLO	R10,R0
 FNSTRB	R10,opt_format
 MOV	R8,#0
 MOV	R9,#0			; opt menu
 MOV	R11,#e_start		; set up entry point
 BL	call_given_mode		; set up opts for this mode
 FNRTS

 END
