; Contains redraw related code.
; $Id: Redraw,fff,v 2.14 2005/02/21 14:29:03 christian Exp $
; -*- armasm -*-

 GET h.ZapHeader

 GET h.Messages
 GET h.MiniBuff
 GET h.Heap
 GET h.ModeBits
 GET h.Strings
 GET h.Cursors
 GET h.CreateWind
 GET h.CreateFile
 GET h.AlterTxt
 GET h.Fonts
 GET h.TMTVars
 GET h.KeyBits
 GET h.SoftWrap

 IMPORT wimp_passon
 IMPORT redraw_leaf_window
 IMPORT zephyr

 EXPORT blat_redraw_cache
 EXPORT check_scn_valid
 EXPORT colour_chars
 EXPORT colour_chars_both
 EXPORT create_palette
 EXPORT ccd_xpix_xpair
 EXPORT ccd_ypix_ypair
 EXPORT ccd_xypix_xyos
 EXPORT ccd_xypix_xyline
 EXPORT ccd_xpair_xos
 EXPORT ccd_ypair_yos
 EXPORT ccd_ypair_ypix
 EXPORT ccd_xyline_xyos
 EXPORT ccd_xyline_xypix
 EXPORT ccd_yline_yos
 EXPORT ccd_yos_yline
 EXPORT ccd_yos_ypair
 EXPORT ccd_blk_xrow
 EXPORT ccd_blk_xrow_vis
 EXPORT ccd_blk_xrow_vis_margin
 EXPORT ccd_blk_yrow
 EXPORT ccd_blk_yrow_vis
 EXPORT ccd_workxy
 EXPORT colons
 EXPORT colon
 EXPORT convert_coords
 EXPORT ensure_redblk
 EXPORT pnt_fit_pages
 EXPORT pnt_get_pagesize
 EXPORT print_file
 EXPORT quick_print
 EXPORT red_overflow
 EXPORT redraw_request
 EXPORT redraw_window
 EXPORT redraw_all
 EXPORT tidy_cache_line
 EXPORT update_area
 EXPORT update_between_offsets
 EXPORT update_cache
 EXPORT update_region
 EXPORT update_window
 EXPORT update_whole_window
 EXPORT update_whole_window_bar_title
 EXPORT redraw_print_line_number


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Handle the redraw request message				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

	FNAME	redraw_request
redraw_request
	FNJSR
	LDR	R0,[R1]			; window handle
	BL	convert_wind_handle
	BCC	text$l			; a text window
	BL	convert_leaf_wind_handle
	BCC	leaf$l
	MOV	R0,#1			; redraw request
	BL	wimp_passon
	FNRTS

leaf$l	ADR	R10,b$l
	MOV	R7,R0			; window index in R7
	B	loop$l

text$l	ADRL	R10,redraw_window	; sub to redraw main windows
	BL	conv_wind_off		; set up R8/R9

	LDR	R0,[R8,#w_format]
	TST	R0,#format_IgnoreRedraw
	BICNE	R0,R0,#format_IgnoreRedraw
	STRNE	R0,[R8,#w_format]
	ADRNE	R10,null$l

loop$l	SWI	XWimp_RedrawWindow	; R10=address of sub to do the redraw
	FNRTS	VS
	TEQ	R0,#0
	FNRTS	EQ

a$l	MOV	R14,PC
	MOV	PC,R10			; redraw the rectangle
	SWIVC	XWimp_GetRectangle	; get next rectangle
	FNRTS	VS
	TEQ	R0,#0
	BNE	a$l
	FNRTS

b$l	B	redraw_leaf_window	; call the leaf redraw

null$l  MOV	PC,R14



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		R E D R A W   R E C T A N G L E			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;; Redraw Area ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E
;X Area redrawn via ZapRedraw_RedrawArea SWI
;  Must set up red_flags/screen/bpl/caddr/cbpl/cbpc/palette
;  Must NOT use wimp block.
;  (charh,charw,linesp already set up - see redraw_to_red)
	FNAME	redraw_area
redraw_area
	FNJSR	"R1"
	LDR	R0,[R8,#w_palette]
	FNSTR	R0,red_palette
	LDR	R0,[R8,#w_font]
	FNSTR	R0,red_caddr

	LDR	R0,[R8,#w_encodinghandle]
	FNSTR	R0,red_encoding

	MOV	R1,#rf_extend ; rf_realvdu	; temporarily disabled for Iyonix ; init r_flags
	ORR	R1,R1,#rf_smallcolours
	LDR	R0,[R8,#w_flags]
	AND	R0,R0,#redraw_font_mask

	TEQ	R0,#redraw_vdu_system	; set VDU flag
	TEQNE	R0,#redraw_vdu_font
	ORREQ	R1,R1,#rf_vdu

	TEQ	R0,#redraw_dsa_system_doubleheight ; set doubleheight flag
	ORREQ	R1,R1,#rf_doubleheight

	TEQ	R0,#redraw_dsa_system_scaled ; auto scaling flag
	ORREQ	R1,R1,#rf_autoscale

	LDR	R0,[R8,#w_info]		; for enable ss bit
	TST	R0,#bit_nosubstyles
	ORREQ	R1,R1,#rf_substyles

	FNSTR	R1,red_flags
	ADD	R1,R12,#red_flags
	SWI	XZapRedraw_RedrawArea

	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CHAR DEFS						      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;X Reads vdu variables to scn_* #
	FNAME	check_scn_valid
check_scn_valid
	FNJSR	"R1-R4"
	ADD	R1,R12,#red_flags
	SWI	XZapRedraw_ReadVduVars
	FNLDR	R0,red_xsize,VC
	FNLDR	R1,scn_magx,VC
	MOVVC	R0,R0,LSL R1
	FNSTR	R0,scn_xos,VC		; width in os coords
	FNLDR	R0,red_ysize,VC
	FNLDR	R1,scn_magy,VC
	MOVVC	R0,R0,LSL R1
	FNSTR	R0,scn_yos,VC		; height in os coords
	FNLDR	R0,scn_bpp,VC
	FNSTR	R0,scn_vf_bpp,VC
	FNRTS	VS
	SWI	XZapRedraw_ReadModeBPP
	FNSTR	R0,scn_vf_bpp,VC
	CMP	R0,R0
	FNRTS



;;;;;;;;;;; keep blank line buffer updated ;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=size of buffer required
;X red_blkbuf buffer enlarged to this size with spaces #
	FNAME	ensure_redblk
ensure_redblk
	FNJSR	"R1-R2"
	ADD	R1,R0,#3		; size required
	BIC	R1,R1,#3		; rounded up to word boundry
	FNLDR	R2,red_blklen		; current size
	FNLDR	R0,red_blkbuf		; start of buffer
	CMP	R2,R1
	FNRTS	CS			; buffer large enough
	BL	heap_ensure		; ensure new size
	FNRTS	VS
	FNSTR	R1,red_blklen		; save new length
	FNSTR	R0,red_blkbuf		; save new ptr
	ADD	R2,R0,R2		; start of unblanked area (word al)
	ADD	R1,R0,R1		; end of buffer (word al)
	MOV	R14,#&20
	ADD	R14,R14,R14,LSL#8
	ADD	R14,R14,R14,LSL#16	; 4 spaces
en1
	STR	R14,[R2],#4
	CMP	R2,R1
	BCC	en1			; clear extra buffer space
	FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; E N D	  O F	R E D R A W   R E C T A N G L E	  S U B S	  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; REDRAW WINDOW BLOCK						    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=redraw window block (as given by wimp) R8/R9
;X this area redrawn #
	FNAME	redraw_window
redraw_window
	FNJSR	"R1-R4"
	BL	redraw_to_red		; convert coords to pixels
	BLVC	update_cache		; update cache entries
	BLVC	create_redraw_data	; create new style redraw data
	BLVC	invert_carets		; add in the caret data
	BLVC	redraw_area		; display on screen area
	FNRTS


;E R1=redraw block as returned by wimp R8/R9
;X R1 corrupted
;  R2-R3=lines to cache clipped to the file #
;  Fills in the type independent red_* variables

;   red_minx/miny/maxx/maxy/bpp/charw/charh/linesp
;   red_scrollx/scrolly.
;  Note red_for/red_bac are constant and should already be filled
	FNAME	redraw_to_red
redraw_to_red
	FNJSR	"R4-R6"
	MOV	R0,R1			; wimp redraw block
	ADD	R1,R12,#red_flags
	SWI	XZapRedraw_GetRectangle
	FNRTS	VS
	FNLDR	R3,red_scrolly		; y scroll from file top
	MOV	R5,R3			; save first line
	BL	ccd_ypix_ypair		; R3=line R6=raster off
	FNSTR	R6,red_scrolly		; offset in line
	MOV	R2,R3			; first line to cache

	FNLDR	R3,red_maxy
	FNLDR	R0,red_miny
	SUB	R3,R3,R0
	ADD	R3,R3,R5		; last pix row (exclusive)
	BL	ccd_ypix_ypair
	TEQ	R6,#0
	ADDNE	R3,R3,#1		; last line to cache (+1)
	LDR	R0,[R8,#w_height]
	CMP	R3,R0
	MOVCS	R3,R0			; clip to file end
	CMP	R2,R3
	MOVCS	R2,R3			; ensure R2<=R3
	LDR	R0,[R8,#w_linesp]
	FNSTR	R0,red_linesp
	LDR	R0,[R8,#w_font]
	FNSTR	R0,red_caddr
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SCREEN COORDS CONVERSION TO WORK AREA COORDS SUBS		  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=window block R2=xos R3=yos on screen
;X R2/R3=pix of posn in work area |
	FNAME	convert_coords
convert_coords
	LDR	R0,[R1,#4]		; x min
	SUB	R2,R2,R0		; x os offset in vis area
	LDR	R0,[R1,#w_scrollx]	; x scroll
	ADD	R2,R2,R0		; x os offset in work area
	LDR	R0,[R1,#16]		; y max
	SUB	R3,R3,R0		; y os offset in vis area
	LDR	R0,[R1,#w_scrolly]	; y scroll
	ADD	R3,R3,R0		; y os offset in work area
	RSB	R3,R3,#0		; y os downward
	FNLDR	R0,scn_magx
	MOV	R2,R2,ASR R0		; x pix signed
	FNLDR	R0,scn_magy
	MOV	R3,R3,ASR R0		; y pix signed
	MOV	PC,R14


;E R2/R3=xypix R8
;X R2/R3=xycol |
	FNAME	ccd_xypix_xyline
ccd_xypix_xyline
	FNJSR
	BL	ccd_xpix_xline
	BL	ccd_ypix_yline
	FNRTS


;E R3=ypix R8
;X R3=yline |
	FNAME	ccd_ypix_yline
ccd_ypix_yline
	LDR	R0,[R8,#w_rl]
	TEQ	R0,#8
	MOVEQ	R3,R3,LSR#3
	MOVEQ	PC,R14			; special case
	FNJSR	"R1,R2"
	MOV	R1,R0			; denominator
	MOV	R0,R3			; numerator
	SWI	XZapRedraw_Divide
	MOV	R3,R0
	FNRTS


;E R2=xpix R8
;X R2=xcol |
	FNAME	ccd_xpix_xline
ccd_xpix_xline
	LDR	R0,[R8,#w_rw]
	TEQ	R0,#8
	MOVEQ	R2,R2,LSR#3
	MOVEQ	PC,R14			; special case
	FNJSR	"R1,R3"
	MOV	R1,R0			; denominator
	MOV	R0,R2			; numerator
	SWI	XZapRedraw_Divide
	MOV	R2,R0
	FNRTS


;E R3=yos R8
;X R3=yline |
	FNAME	ccd_yos_yline
ccd_yos_yline
	RSB	R3,R3,#0
	FNLDR	R0,scn_magy
	MOV	R3,R3,LSR R0
	B	ccd_ypix_yline


;E R2=xos R8
;X R2=xcol |
	FNAME	ccd_xos_xline
ccd_xos_xline
	FNLDR	R0,scn_magx
	MOV	R2,R2,LSR R0
	B	ccd_xpix_xline


;E R3=yos R8
;X R3=yline R6=yrast |
	FNAME	ccd_yos_ypair
ccd_yos_ypair
	RSB	R3,R3,#0
	FNLDR	R0,scn_magy
	MOV	R3,R3,LSR R0		; convert y to pix
	B	ccd_ypix_ypair


;E R3=ypix R8
;X R3=yline R6=yrast |
	FNAME	ccd_ypix_ypair
ccd_ypix_ypair
	LDR	R0,[R8,#w_rl]
	TEQ	R0,#8
	ANDEQ	R6,R3,#7
	MOVEQ	R3,R3,LSR#3
	MOVEQ	PC,R14
	FNJSR	"R1-R2"
	MOV	R1,R0			; denominator
	MOV	R0,R3			; numerator
	SWI	XZapRedraw_Divide	; BL div_mod
	MOV	R3,R0			; DIV (line)
	MOV	R6,R2			; MOD (pix off)
	FNRTS


;E R3=xpix R8
;X R3=xcol R6=xoff |
	FNAME	ccd_xpix_xpair
ccd_xpix_xpair
	LDR	R0,[R8,#w_rw]
	TEQ	R0,#8
	ANDEQ	R6,R3,#7
	MOVEQ	R3,R3,LSR#3
	MOVEQ	PC,R14
	FNJSR	"R1-R2"
	MOV	R1,R0			; denominator
	MOV	R0,R3			; numerator
	SWI	XZapRedraw_Divide	; BL div_mod
	MOV	R3,R0			; DIV (line)
	MOV	R6,R2			; MOD (pix off)
	FNRTS


;E R2/R3=xycol R8
;X R2/R3=xyos |
	FNAME	ccd_xyline_xyos
ccd_xyline_xyos
	LDR	R0,[R8,#w_rw]
	TEQ	R0,#8
	MOVEQ	R2,R2,LSL#3
	MULNE	R2,R0,R2
	FNLDR	R0,scn_magx
	MOVS	R2,R2,LSL R0		; convert x to work os
	FNLDR	R2,wimp_leftgap,EQ	; DS fix.
	RSBEQ	R2,R2,#0		; DS fix.
	LDR	R0,[R8,#w_rl]
	TEQ	R0,#8
	MOVEQ	R3,R3,LSL#3
	MULNE	R3,R0,R3		; convert y to pix
	FNLDR	R0,scn_magy
	MOV	R3,R3,LSL R0
	RSB	R3,R3,#0		; convert y pix to work os
	MOV	PC,R14


;E R2/R3=xycol R8
;X R2/R3=xypix |
	FNAME	ccd_xyline_xypix
ccd_xyline_xypix
	LDR	R0,[R8,#w_rw]
	TEQ	R0,#8
	MOVEQ	R2,R2,LSL#3
	MULNE	R2,R0,R2
	LDR	R0,[R8,#w_rl]
	TEQ	R0,#8
	MOVEQ	R3,R3,LSL#3
	MULNE	R3,R0,R3		; convert y to pix
	MOV	PC,R14


;E R3=yline R8
;X R3=yos |
	FNAME	ccd_yline_yos
ccd_yline_yos
	LDR	R0,[R8,#w_rl]
	TEQ	R0,#8
	MOVEQ	R3,R3,LSL#3
	MULNE	R3,R0,R3
	FNLDR	R0,scn_magy
	MOV	R3,R3,LSL R0
	RSB	R3,R3,#0
	MOV	PC,R14


;E R3=yline R6=yrast R8
;X R3=yos |
	FNAME	ccd_ypair_yos
ccd_ypair_yos
	LDR	R0,[R8,#w_rl]
	TEQ	R0,#8
	ADDEQ	R3,R6,R3,LSL#3
	MLANE	R3,R0,R3,R6		; include raster offset
	FNLDR	R0,scn_magy
	MOV	R3,R3,LSL R0
	RSB	R3,R3,#0
	MOV	PC,R14


;E R3=xline R6=xrast R8
;X R3=xos |
	FNAME	ccd_xpair_xos
ccd_xpair_xos
	LDR	R0,[R8,#w_rw]
	TEQ	R0,#8
	ADDEQ	R3,R6,R3,LSL#3
	MLANE	R3,R0,R3,R6		; include raster offset
	FNLDR	R0,scn_magx
	MOV	R3,R3,LSL R0
	CMP	R3,#0			; TT fix.
	FNLDR	R3,wimp_leftgap,LE	; TT fix.
	RSBLE	R3,R3,#0		; TT fix.
	MOV	PC,R14


;E R3=yline R6=yrast R8
;X R3=ypix |
	FNAME	ccd_ypair_ypix
ccd_ypair_ypix
	LDR	R0,[R8,#w_rl]
	TEQ	R0,#8
	ADDEQ	R3,R6,R3,LSL#3
	MLANE	R3,R0,R3,R6		; include raster offset
	MOV	PC,R14


;E R3=xline R6=xrast
;X R3=xpix |
	FNAME	ccd_xpair_xpix
ccd_xpair_xpix
	LDR	R0,[R8,#w_rw]
	TEQ	R0,#8
	ADDEQ	R3,R6,R3,LSL#3
	MLANE	R3,R0,R3,R6		; include raster offset
	MOV	PC,R14


;E R11=window block R8 (y window edge in work area)
;X R3=min y line R5=max y line R6=min y rast R7=max y rast |
	FNAME	ccd_blk_yrow
ccd_blk_yrow
	FNJSR
	FNLDR	R0,scn_magy
	LDR	R7,[R11,#w_scrolly]	; scroll offset (min y line work)
	LDR	R3,[R11,#8]		; min y os (+ve usually)
	LDR	R5,[R11,#16]		; max y os (+ve usually)
	RSB	R7,R7,#0
	MOV	R7,R7,ASR R0		; scroll pix offset
	MOV	R3,R3,ASR R0		; min scn y pix (from bot of scn)
	MOV	R5,R5,ASR R0		; max scn y pix (from bot of scn)
	SUBS	R3,R5,R3		; height in pix
	MOVMI	R3,#0			; none
	ADD	R3,R7,R3		; end work pix
	BL	ccd_ypix_ypair
	MOV	R5,R3
	MOV	R3,R7
	MOV	R7,R6
	BL	ccd_ypix_ypair		; convert to line/offsets
	FNRTS


;E R11=window block R8 (y visible edge in work area)
;X R3=min y line R5=max y line R6=min y rast R7=max y rast |
	FNAME	ccd_blk_yrow_vis
ccd_blk_yrow_vis
	FNJSR
	FNLDR	R0,scn_magy
	LDR	R7,[R11,#24]		; scroll offset (min y line work)
	LDR	R3,[R11,#8]		; min y os (+ve usually)
	LDR	R5,[R11,#16]		; max y os (+ve usually)
	RSB	R7,R7,#0
	MOV	R7,R7,ASR R0		; scroll pix offset
	MOV	R3,R3,ASR R0		; min scn y pix (from bot of scn)
	MOV	R5,R5,ASR R0		; max scn y pix (from bot of scn)
	FNLDR	R14,scn_yos
	MOV	R14,R14,ASR R0		; screen height in pixels
	CMP	R3,#0
	MOVMI	R3,#0			; clip at bottom of screen
	SUBS	R0,R5,R14		; amount off the top of the screen
	ADDGT	R7,R7,R0		; add this to the scroll offset
	MOVGT	R5,R14			; clip at top of screen
	SUBS	R3,R5,R3		; height in pix
	MOVMI	R3,#0			; none
	ADD	R3,R7,R3		; end work pix
	BL	ccd_ypix_ypair
	MOV	R5,R3
	MOV	R3,R7
	MOV	R7,R6
	BL	ccd_ypix_ypair		; convert to line/offsets
	FNRTS


;E R11=window block R8 (find x window edged in work area)
;X R3=min x line R5=max x line R6=min x rast R7=max x rast |
	FNAME	ccd_blk_xrow
ccd_blk_xrow
	FNJSR
	FNLDR	R0,scn_magx
	LDR	R7,[R11,#20]		; scroll offset (min x work)
	LDR	R3,[R11,#4]		; min x os
	CMP	R3,#0			; new...
	MOVMI	R3,#0
	CMP	R7,#0
	MOVMI	R7,#0			; new TT
	LDR	R5,[R11,#12]		; max x os
	MOV	R7,R7,ASR R0		; scroll pix offset
	MOV	R3,R3,ASR R0		; min x pix
	MOV	R5,R5,ASR R0		; max x pix
	SUBS	R5,R5,R3		; width in pix
	MOVMI	R5,#0
	ADD	R3,R7,R5		; end work pix
	BL	ccd_xpix_xpair
	MOV	R5,R3
	MOV	R3,R7
	MOV	R7,R6
	BL	ccd_xpix_xpair		; convert to line/offsets
	FNRTS


;E R11=window block R8 (find visible edges in work area)
;X R3=min x line R5=max x line R6=min x rast R7=max x rast |
	FNAME	ccd_blk_xrow_vis
ccd_blk_xrow_vis
	FNJSR
	FNLDR	R0,scn_magx
	LDR	R7,[R11,#20]		; scroll offset (min x work)
	LDR	R3,[R11,#4]		; min x os
	LDR	R5,[R11,#12]		; max x os
	MOV	R7,R7,ASR R0		; scroll pix offset
	MOV	R3,R3,ASR R0		; min x pix
	MOV	R5,R5,ASR R0		; max x pix
	FNLDR	R14,scn_xos
	MOV	R14,R14,ASR R0
	CMP	R5,R14
	MOVGT	R5,R14			; clip to screen border
	SUBS	R5,R5,R3		; width in pix
	MOVMI	R5,#0
	ADD	R3,R7,R5		; end work pix
	BL	ccd_xpix_xpair
	MOV	R5,R3
	MOV	R3,R7
	MOV	R7,R6
	BL	ccd_xpix_xpair		; convert to line/offsets
	FNRTS


;E R2/R3=xypix
;X R2/R3=xyos |
	FNAME	ccd_xypix_xyos
ccd_xypix_xyos
	FNLDR	R0,scn_magx
	MOV	R2,R2,LSL R0
	FNLDR	R0,scn_magy
	MOV	R3,R3,LSL R0
	RSB	R3,R3,#0
	CMP	R2,#0			; TT fix.?
	FNLDR	R2,wimp_leftgap,EQ	; TT fix.?
	RSBEQ	R2,R2,#0		; TT fix.?
	MOV	PC,R14


;E R8
;X R2=work max x os R3=work min y os |
	FNAME	ccd_workxy
ccd_workxy
	FNJSR
	LDR	R2,[R8,#w_width]
	LDR	R3,[R8,#w_height]
	FNLDR	R0,wimp_bottomgap	; number of lines gap at bottom
	ADD	R3,R3,R0
	BL	ccd_xyline_xyos		; get width/height in os
	FNLDR	R0,wimp_rightgap
	ADD	R2,R2,R0		; add side pixels
	FNLDR	R0,scn_yos		; height in screen in os pixels
	CMN	R3,R0			; cmp R3 with -R0
	RSBGT	R3,R0,#0		; if R3>-R0 then R3=-R0 (ie clip to screen)
	FNRTS


;E R11=window block R8 (find visible edges in work area)
;X R3=min x line R5=max x line R6=min x rast R7=max x rast |
	FNAME	ccd_blk_xrow_vis_margin
ccd_blk_xrow_vis_margin
	FNJSR
	FNLDR	R0,scn_magx
	LDR	R3,[R11,#4]		; min x os
	LDR	R5,[R11,#12]		; max x os
	LDR	R7,[R11,#w_scrollx]	; scroll offset (min x work)
	CMP	R7,#0
	SUBMI	R3,R3,R7
	FNLDR	R14,wimp_leftgap	; TT fix.
	ADD	R3,R3,R14
	ADD	R5,R5,R14
	ADD	R7,R7,R14
	MOV	R7,R7,ASR R0		; scroll pix offset
	MOV	R3,R3,ASR R0		; min x pix
	MOV	R5,R5,ASR R0		; max x pix
	FNLDR	R14,scn_xos
	MOV	R14,R14,ASR R0
	CMP	R5,R14
	MOVGT	R5,R14			; clip to screen border
	SUBS	R5,R5,R3		; width in pix
	MOVMI	R5,#0
	ADD	R3,R7,R5		; end work pix
	BL	ccd_xpix_xpair
	MOV	R5,R3
	MOV	R3,R7
	MOV	R7,R6
	BL	ccd_xpix_xpair		; convert to line/offsets
	CMP	R3,#0
	MOVMI	R3,#0
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INVERT CARET						       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=first unused red_data offset R2-R3 redraw lines R8/R9
;X R1=new first unused offset #
	FNAME	invert_carets
invert_carets
	FNJSR	"R4,R10"
	FNLDR	R10,car_mode
	FNLDR	R4,opt_cursor
	ADD	R10,R10,#2
	CMP	R10,#8
	ADDCC	PC,PC,R10,LSL#2
	FNRTS				; out of range
	FNRTS				; mode -2 don't draw any
	B	inv_car_point		; mode -1 draw point only
	B	inv_car_point		; mode 0 draw point only
	B	inv_car_1		; mode 1
	B	inv_car_2		; mode 2
	FNRTS				; mode 3
	FNRTS				; mode 4
	B	inv_car_5		; mode 5

inv_car_1
	FNLDR	R10,car_cursor
	BL	test_cblk
	BNE	inv_car_point
	BL	invert_caret
	FNRTS

inv_car_2
	MOV	R4,R4,ROR#16		; get split 2 type
	FNLDR	R10,car_cursor
	BL	test_cblk
	BLEQ	test_then_invert_caret  ; draw if in window
	FNRTS	VS
	MOV	R4,R4,ROR#16		; restore
	FNLDR	R10,car_input
	BL	test_cblk
	BNE	inv_car_point		; input not in this window
	MOV	R4,R4,LSR#8
	BL	invert_caret		; split 1 caret
	FNRTS

inv_car_5
	FNLDR	R10,car_input
	BL	test_cblk
	BLEQ	invert_caret
	FNRTS

inv_car_point
	MOV	R4,R4,LSR#24		; get left type
	ADD	R10,R8,#w_pwind
	BL	invert_caret
	FNRTS

test_then_invert_caret
	FNJSR
	LDR	R14,[R8,#w_pwind]
	LDR	R0,[R10,#c_wind]
	CMP	R0,R14
	BNE	ok$l
	LDR	R14,[R8,#w_poff]
	LDR	R0,[R10,#c_off]
	CMP	R0,R14
ok$l	BLNE	invert_caret
	FNRTS


;E R1=first unused r_data offset R2-R3 redraw lines
;  R4=cursor type in bits 0-7
;  R8/R9 R10=caret block for caret to draw
;X R1=new first unused offset & caret inserted into redraw data #
	FNAME	invert_caret
invert_caret
	AND	R0,R4,#&FF		; cursor type
	TEQ	R0,#4
	MOVEQ	PC,R14			; type 4=none
	LDR	R0,[R10,#c_line]
	CMP	R0,R3
	MOVGE	PC,R14			; off screen top
	SUBS	R0,R0,R2		; offset from first line
	MOVMI	PC,R14			; off screen bottom
	FNJSR	"R2-R11"
	FNLDR	R11,red_data
	FNLDR	R7,red_datasize
	ADD	R6,R11,R1		; set up buffer pointers
	LDR	R5,[R11,R0,LSL#2]	; offset for first line
	STR	R1,[R11,R0,LSL#2]	; new offset
	MVN	R0,#0
	ADD	R1,R11,R5		; address of first line
	SUB	R9,R1,#2		; save start-2
	PUSH	"R4,R5"
	SWI	XZapRedraw_FindCharacter
	PULL	"R4,R5"
	FNRTS	VS
	SUB	R0,R1,R9		; length of the line + 0,2 term
	LDR	R3,[R10,#c_width]
	ADD	R0,R0,R3,LSL#4		; amount we need spare
	LDR	R2,[R10,#c_col]
	LDR	R14,[R8,#w_width]
	CMP	R2,R14
	MOVHI	R2,R14			; \/\/ display clipping
	ADD	R0,R0,R2		; and incase line blank
	BL	ensure_red_data
	FNRTS	VS
	ADD	R5,R11,R5		; source string
	BL	get_caret_string	; set up R3/R4/R7
	FNRTS	VS
	MOV	R0,R6			; current pointer
	ADD	R1,R12,#red_flags

; We used to swap on the foreground colour, but this fails with control characters
; ZapRedraw 0.39 [TEST 2] introduces a new SWI which should enable us to fix this.
; Note that this may be a little unstable - it hasn't been tested a huge amount yet.
; MOV R6,#syscol_SelFg
; SWI XZapRedraw_AddCursor
	MOV	R6,#syscol_SelFg
	ORR	R6,R6,#(syscol_SelBg :SHL: 8)
	ORR	R6,R6,#(1:SHL:31):OR:(1:SHL:30)
	SWI	XZapRedraw_AddCursorSmart
	FNRTS	VS
	SUB	R1,R0,R11		; new last used offset
	MOV	R0,R4			; free the cursor characters
	BL	heap_free
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the cursor string (dependent on length)		    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R4=b0-b8=caret type (0-4) R3=cursor length
;X R7=colour+high byte and R4 -> heap block containing the string #
;  R3>=1 updated length of caret

; What we're doing here is to prepare all the relevant data for ZapRedraw_AddCursor.
; We need to set up a cursor string full of either &7Fs (block cursor, the inverting
; one), or &00-&05 (plus putting &1 as the high byte to construct the actual chars
; to use). In addition, we set up the rest of R7 to ZapRedraw_AddCursor, which gives
; the fg/bg of the cursor, plus the what type of merge to use to add the cursor into
; the r_data line.
	FNAME	get_caret_string
get_caret_string
	FNJSR	"R1-R2"
	ADD	R0,R3,#1
	BL	heap_claim
	FNRTS	VS
	MOV	R1,R0
	MOV	R2,R3			; copy length
	AND	R0,R4,#&FF		; get type
	MOV	R4,R1			; copy dest
	MOV	R7,#(syscol_CurFg:SHL:16)
	ORR	R7,R7,#(syscol_CurBg:SHL:24)
	ORR	R7,R7,#(8:SHL:8)	; use 'merge cursors' (not 'merge characters')
	CMP	R0,#(gc_end-gc_start)/4
	ADDCC	PC,PC,R0,LSL#2
	FNRTS
gc_start
	B	get_caret_0		; block
	B	get_caret_1		; square
	B	get_caret_2		; underscore
	B	get_caret_3		; bar
	B	get_caret_4		; none
gc_end

get_caret_0
	MOV	R0,#&7F
get_caret_00
	STRB	R0,[R1],#1
	SUBS	R2,R2,#1
	BGT	get_caret_00
	FNRTS

get_caret_1
	;ORR	R7,R7,#1
	SUBS	R2,R2,#2		; length - ends
	MOVMI	R0,#3
	STRMIB  R0,[R1]
	FNRTS	MI
	MOV	R0,#0
	STRB	R0,[R1],#1		; left end
	MOV	R0,#2
	STRB	R0,[R1,R2]		; right end
	MOV	R0,#1
	BGT	get_caret_00
	FNRTS

get_caret_2
	;ORR	R7,R7,#1
	MOV	R0,#4
	B	get_caret_00

get_caret_3
	;ORR	R7,R7,#1
	MOV	R0,#5
	STRB	R0,[R1]
	MOV	R3,#1
	FNRTS

get_caret_4
	MOV	R3,#1			; not there
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create redraw data in new format			    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=start of cached data (within file) / 0 if all outside
;  R2=start line R3=end line(+1) clipped to file
;  R8/R9
;X red_data updated to hold new format text #
;  R1=first free offset in r_data buffer
	FNAME	create_redraw_data
create_redraw_data
	FNJSR	"R2-R11"
	LDR	R10,[R8,#w_info]	; setup flags
	FNLDR	R14,red_flags		;
	TST	R10,#info_DisableFontSubStyles
	BICNE	R14,R14,#rf_substyles	;
	ORREQ	R14,R14,#rf_substyles	;
	TST	R10,#info_WideRedraw	;
	ORRNE	R14,R14,#rf_char32	;
	BICEQ	R14,R14,#rf_char32	;
	ORR	R14,R14,#rf_extend+rf_smallcolours	;
	FNSTR	R14,red_flags		;

	LDR	R9,[R8,#w_txtw]		; width of text bit of cache line (in columns)
	TST	R10,#info_WideRedraw	;
	MOVEQ	R5,R9			;   in bytes
	MOVNE	R5,R9,LSL #2		;

	LDR	R14,[R8,#w_encodinghandle] ; add the encoding
	FNSTR	R14,red_encoding

	SUB	R10,R3,R2		; number of lines to do
	ADD	R10,R10,#1		; add terminating offset
	MOV	R2,R0			; data to start with
	FNLDR	R7,red_datasize		; length of it
	FNLDR	R11,red_data		; start of red_data
	MOV	R6,R11			; current pointer in red_data
	MOV	R0,R10,LSL#2		; number of bytes for offsets
	BL	ensure_red_data
	BVS	error$l
	ADD	R6,R6,R10,LSL#2		; move to start of area to redraw
	MOV	R4,#0			; number of current line
	ADD	R3,R9,R9,LSL #2
	MOV	R3,R3,LSL#1		; R3=10*ncolumns
	SUBS	R10,R10,#1
	BLE	cr18			; subtract the terminating line
cr17	SUB	R0,R6,R11		; current offset
	STR	R0,[R11,R4,LSL#2]	; save offset of line
	ADD	R0,R3,#16		; need 10*R5+16 bytes free
	BL	ensure_red_data		; make sure enough room free
	BVS	error$l

	PUSH	"R3-R5,R7"

	; add the line number
	LDR	R0,[R8,#w_format]
	TST	R0,#format_ShowLineNumbers
	BEQ	nonum$l

	LDR	R0,[R2]
	MOV	R1,#0			; set the colour
	STRB	R1,[R6],#1		;
	MOV	R1,#10			;
	STRB	R1,[R6],#1		;
	MOV	R1,#syscol_Linenums	; FIXME - check for selection
	STRB	R1,[R6],#1		;
	MOV	R1,#syscol_BgEditable	;
	STRB	R1,[R6],#1		;
	MOV	R1,#0			; FIXME - use line number style
	STRB	R1,[R6],#1		;

	LDRB	R1,[R2,#4]
	BL	print_line_numbers

nonum$l	LDR	R0,[R8,#w_mwidth]
	MOV	R14,#' '
nloop$l	SUBS	R0,R0,#1
	STRPLB	R14,[R6],#1
	BPL	nloop$l

	ADD	R2,R2,#8		; skip over line number
	MOV	R0,#syscol_Ctrls	; colour for ctrl chars
	ADD	R3,R2,R5		; fg
	ADD	R4,R3,R9		; bg
	ADD	R7,R4,R9		; style

	ADD	R1,R12,#red_flags	; redraw block
	SWI	XZapRedraw_PrepareDataLine
	ADDVC	R6,R6,R5		; new buffer position
	PULL	"R3-R5,R7"
	BVS	error$l

	ADD	R2,R2,R5
	ADD	R2,R2,R9,LSL #1
	ADD	R2,R2,R9		; next line
	ADD	R4,R4,#1		; increment line number
	CMP	R4,R10
	BCC	cr17
cr18	MOV	R0,#0
	STR	R0,[R11,R4,LSL#2]	; add terminating 0
	SUB	R1,R6,R11		; first free offset
	FNRTS

error$l	MOV	R7,R0
	MOV	R1,#14
	MOV	R11,#e_init
	BL	call_mode
	MOV	R0,R7
	FNRTV

	LOCAL

;E R11=red_data R6=current pointer in red_data block
;  R7=red_datasize R0=amount must have free
;X amount ensured (R6/R7/R11 may change) #
	FNAME	ensure_red_data
ensure_red_data
	ADD	R0,R6,R0		; new end
	SUB	R0,R0,R11		; new length
	CMP	R0,R7
	MOVLE	PC,R14			; already claimed
	FNJSR	"R1"
	MOV	R1,R0			; amount to claim
	SUB	R7,R6,R11		; save offset in block
	MOV	R0,R11
	BL	heap_ensure
	FNRTS	VS
	FNSTR	R0,red_data		; new block pointer
	FNSTR	R1,red_datasize		; new length
	MOV	R11,R0
	ADD	R6,R11,R7
	MOV	R7,R1
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; UPDATE CACHE							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R2=start line R3=end line(+1) R8/R9
;  First line should be within the file but the last line may
;  be off the end. Blank lines will be added.
;X Lines within the file cached
;  R0=start of cached data (or 0 if first line was off end)
	FNAME	update_cache
update_cache
	FNJSR	"R1-R11"
	LDR	R11,[R8,#w_height]	; number of lines in file
	LDR	R4,[R8,#w_cline]	; line num of first cached line
	LDR	R5,[R8,#w_txtn]		; number of lines cached
	SUB	R10,R3,R2		; number of lines to cache
	LDR	R1,[R8,#w_txth]		; find number of lines in cache
	CMP	R10,R1			; is cache too small?
	BLS	update_c0		; if ok then continue
	LDR	R0,[R8,#w_txtlen]	; width of cache lines
	MUL	R1,R0,R10		; size cache needs to be
	LDR	R0,[R8,#w_txt]
	BL	heap_ensure		; ensure cache big enough
	FNRTS	VS
	STR	R0,[R8,#w_txt]		; note need NOT mark cache invalid as heap
	STR	R10,[R8,#w_txth]	; manager copies data
update_c0
	TEQ	R2,R3
	FNRTS	EQ
	CMP	R2,R11			; is first line off end of file
	BCS	update_c6		; 'error'
	ADD	R5,R4,R5		; line number of last cached line (+1)
	TEQ	R4,R5
	BEQ	update_c4		; nothing in the cache
	CMP	R4,R3
	BCS	update_c4		; entire cache too late
	CMP	R2,R5
	BCS	update_c4		; entire cache too early
	CMP	R2,R4
	BCC	update_c2		; cache intersects region
	CMP	R5,R3
	BCC	update_c1
	SUB	R0,R2,R4		; offset in cache (data already there)
	LDR	R1,[R8,#w_txt]
	LDR	R2,[R8,#w_txtlen]
	MLA	R0,R2,R0,R1
	FNRTS

	; cache ends before desired line
update_c1
	SUB	R10,R5,R2
	SUB	R6,R2,R4
	MOV	R7,#0
	BL	move_cache_lines
	SUB	R10,R3,R5
	MOV	R7,R5
	SUB	R6,R5,R2
	BL	red_cache_lines
	FNRTS	VS
	MOV	R0,R2
	BL	cln_phy
	FNRTS	VS
	B	update_c5

	; cache starts after desired line
update_c2
	CMP	R5,R3
	BCS	update_c3
	SUB	R10,R5,R4
	MOV	R6,#0
	SUB	R7,R4,R2
	BL	move_cache_lines
	SUB	R10,R3,R5
	MOV	R7,R5
	SUB	R6,R5,R2
	BL	red_cache_lines
	FNRTS	VS
	SUB	R10,R4,R2
	MOV	R7,R2
	MOV	R6,#0
	BL	red_cache_lines
	FNRTS	VS
	B	update_c5

update_c3
	SUB	R10,R3,R4
	MOV	R6,#0
	SUB	R7,R4,R2
	BL	move_cache_lines
	SUB	R10,R4,R2
	MOV	R7,R2
	MOV	R6,#0
	BL	red_cache_lines
	FNRTS	VS
	B	update_c5

	; cache contains no desired lines
update_c4
	SUB	R10,R3,R2
	MOV	R7,R2
	MOV	R6,#0
	BL	red_cache_lines
	FNRTS	VS

update_c5
	LDR	R14,[R9,#f_len]
	CMP	R0,R14
	BCS	update_c7
	STR	R0,[R8,#w_coff]		; save file offset
	STR	R1,[R8,#w_clogl]	; save log ln
	SUB	R0,R3,R2		; number of lines cached
	STR	R0,[R8,#w_txtn]
	STR	R2,[R8,#w_cline]	; line number of first cached line
	LDR	R0,[R8,#w_txt]
	FNRTS

update_c6
	MOV	R0,#0			; first line off end
	FNRTS

update_c7
	MOV	R0,#0
	STR	R0,[R8,#w_txtn]		; preserve old cached point
	LDR	R0,[R8,#w_txt]
	FNRTS


;E R6=source cache line R7=dest cache line R8/R9 R10=num of lines to move
;X R2-R5 & R8-R9 saved and cache lines moved
	FNAME	move_cache_lines
move_cache_lines
	TEQ	R6,R7
	TEQNE	R10,#0
	MOVEQ	PC,R14
	LDR	R11,[R8,#w_txtlen]
	LDR	R0,[R8,#w_txt]
	MLA	R6,R11,R6,R0
	MLA	R7,R11,R7,R0
	MUL	R10,R11,R10
	CMP	R6,R7
	BCC	move_cache_down
move_cache_up
	LDMIA	R6!,{R0,R1}
	STMIA	R7!,{R0,R1}
	SUBS	R10,R10,#8
	BHI	move_cache_up
	MOV	PC,R14
move_cache_down
	ADD	R6,R6,R10
	ADD	R7,R7,R10
move_cache_d0
	LDMDB	R6!,{R0,R1}
	STMDB	R7!,{R0,R1}
	SUBS	R10,R10,#8
	BHI	move_cache_d0
	MOV	PC,R14

; X no more cache
blat_redraw_cache
	FNJSR
	MOV	R2,#0
	MOV	R3,#0
	BL	update_cache		; saves R8/R9 R0=cached data
	FNRTS


;E R6=cache loff  R7=file loff  R8/R9  R10 num of lines to do
;X R0=file off/R1=log ln of first line. R2-R5,R8-R9 saved
	FNAME	red_cache_lines
red_cache_lines
	FNJSR	"R2-R5"
	MOV	R0,R7			; phy ln of first line
	BL	cln_phy			; file offset & log ln of first line
	FNRTS	VS
	MOV	R3,R0			; save file offset
	MOV	R5,R1			; save log ln
	TEQ	R10,#0
	FNRTS	EQ			; return if no lines to draw
	ADD	R4,R7,R10		; phy ln of final line
	MOV	R10,R7			; phy ln of first line
	PUSH	"R3,R5"			; save off/log of first line
	MOV	R1,#einit_RedrawStart
	MOV	R2,R7
	MOV	R3,R4
	BL	calle_init
	MOV	R11,R5			; log ln of first line
	MOV	R7,R0			; offset in file of first line
	LDR	R2,[R8,#w_txtlen]	; byte width of cache lines
	LDR	R0,[R8,#w_txt]
	MLA	R6,R2,R6,R0		; address of line in cache
	MVN	R5,#0			; region lines
	FNLDR	R1,car_selection	; selection caret
	BL	get_wind_off
	LDR	R14,[R1,#c_wind]	; window with caret
	TEQ	R14,R0
	BNE	red_cl_l0		; selection not in this window
	LDR	R3,[R1,#c_line]
	LDR	R5,[R1,#c_oline]	; get start and end
	CMP	R3,R5
	MOVGT	R0,R5
	MOVGT	R5,R3
	MOVGT	R3,R0			; ensure R3<=R5
red_cl_l0
	BL	redraw_cache_line	; redraw the line
	BVS	red_cl_11
	BL	generate_cache_font_data

	CMP	R10,R3
	BLT	red_cl_12		; before the region start
	CMP	R10,R5
	BLLE	redraw_cache_selection  ; it's in the selected region
	BVS	red_cl_11
red_cl_12
	ADD	R6,R6,R2		; move onto next cache line
	ADD	R10,R10,#1		; move onto next phy line
	CMP	R10,R4			; reached end line?
	BCC	red_cl_l0		; do next line if not
	MOV	R1,#einit_RedrawEnd
	BL	calle_init
	STRVS	R0,[R13]
	PULL	"R0,R1"
	FNRTS
red_cl_11
	STR	R0,[R13,#-4]!
	MOV	R1,#einit_RedrawEnd
	BL	calle_init
	ADDVS	R13,R13,#4
	LDRVC	R0,[R13],#4
	FNRTV				; escape


; E R6 -> cache line
	FNAME	generate_cache_font_data
generate_cache_font_data
	FNJSR	"R0-R7,R11"
	MOV	R0,#11
	MOV	R11,#e_interrogate
	BL	call_mode

	ADD	R6,R6,#8		; skip line number

	LDR	R3,[R8,#w_info]		;
	TST	R3,#info_WideRedraw	;
	LDR	R3,[R8,#w_txtw]		;
	ADDEQ	R4,R6,R3		;
	ADDNE	R4,R6,R3,LSL #2		; R4 = fg colours
	ADD	R1,R4,R3		; R1 = bg colours
	ADD	R2,R1,R3		; R2 = substyles
	SUB	R3,R3,#1
	BL	get_mode_colours_ptr

	ADR	R14,ret$l
	CMP	R0,#2
	ADDLO	PC,PC,R0,LSL #2
	B	perform_block_copy
	B	fg_and_bg_hijacked
	B	fg_and_bg_hijacked_with_style_info
ret$l	FNRTS

; \E R6 = ? R3 = ?
perform_block_copy
	LDRB	R5,[R4,R3]		; colour data...
	CMP	R5,R6,LSR #2		; /should/ always be true...? danger
	LDRLOB  R5,[R7,R5,LSL #2]	; FONT DATA!!!! - LO for safety...
	AND	R5,R5,#&E9
	STRB	R5,[R2,R3]
	SUBS	R3,R3,#1
	BPL	perform_block_copy
	MOV	PC,R14


fg_and_bg_hijacked
	LDRB	R0,[R4,R3]		; read fg colour
	MOV	R5,#0
	CMP	R0,R6,LSR #2		; range check
	LDRLOB  R5,[R7,R0,LSL #2]	; load zap palette entry
	LDRB	R0,[R1,R3]		; read bg colour
	CMP	R0,#9
	MVNLO	R0,#0			; ignore system colours
	CMP	R0,R6,LSR #2
	LDRLOB  R0,[R7,R0,LSL #2]	; load zap palette entry
	ORRLO	R5,R5,R0		; merge substyles
	AND	R5,R5,#&E9		; remove invalid bits
	STRB	R5,[R2,R3]		; store in style buffer
	SUBS	R3,R3,#1
	BPL	fg_and_bg_hijacked
	MOV	PC,R14


fg_and_bg_hijacked_with_style_info
	LDRB	R5,[R2,R3]		; as above, but merge the
	LDRB	R0,[R4,R3]		; mode provided style as well
	CMP	R0,R6,LSR #2
	LDRLOB  R0,[R7,R0,LSL #2]
	ORRLO	R5,R5,R0
	LDRB	R0,[R1,R3]
	CMP	R0,#9
	MVNLO	R0,#0
	CMP	R0,R6,LSR #2
	LDRLOB  R0,[R7,R0,LSL #2]
	ORRLO	R5,R5,R0
	AND	R5,R5,#&E9
	STRB	R5,[R2,R3]
	SUBS	R3,R3,#1
	BPL	fg_and_bg_hijacked_with_style_info
	MOV	PC,R14


;X R6=number of colours
;  R7=pointer to colours
	FNAME	get_mode_colours_ptr
get_mode_colours_ptr
	FNJSR
	LDR	R6,[R8,#w_modedata]
	LDRB	R7,[R8,#w_format]
	LDR	R7,[R6,R7,LSL #2]	; pointer to data for this mode
	LDR	R6,[R7],#4		; length word
	MOV	R14,R6,LSR #24
	ADD	R7,R7,R14,LSL #2
	BIC	R6,R6,#&FF000000	; total block length
	SUB	R6,R6,R14,LSL #2	; colour data length
	SUB	R6,R6,#4
	FNRTS


	LOCAL

;Internal R11=log line number		R10=end of current buffer
;	  R7=address in buffer		R6=addr in cache line
;	  R5=apparant start of file
;E R6=cache addr R7=file off R8/R9 R10=phy ln R11=log ln
;X R7/R11 updated to start of next phy line. R2-R6,R8-R10 saved
	FNAME	redraw_cache_line
redraw_cache_line
	FNJSR	"R2-R6,R10"
	BL	print_blank		; fill line with spaces
	LDR	R0,[R8,#w_height]	; height of work area
	CMP	R10,R0			; is this line off end of file
	FNRTS	CS			; return if so

	LDR	R5,[R8,#w_format]	; line format
	TST	R5,#format_ShowLineNumbers ; (clears C)
	TEQEQ	R0,R0			; sets C and keeps Z set
	BLNE	get_linenumber
	MOVCS	R1,#0
	MOVCC	R1,#1
	STRB	R1,[R6,#4]		; keep the line number
	STR	R0,[R6],#8

	MOV	R4,R5			; full draw type
	LDR	R5,[R9,#f_ptr]		; start of file
	LDR	R0,[R9,#f_splito]	; offset of split
	CMP	R7,R0
	ADDCC	R10,R5,R0		; end of first half of buffer
	LDRCS	R1,[R9,#f_bufl]
	ADDCS	R10,R5,R1		; end of second half of buffer
	LDRCS	R1,[R9,#f_splits]
	ADDCS	R5,R5,R1		; inc apparant start of file
	ADD	R7,R5,R7		; address of next byte
	AND	R1,R4,#format_ModeNumber
	ADD	R0,R12,#(mode_store+4):AND:&FF00
	ADD	R0,R0, #(mode_store+4):AND:&00FF ; start of list+4
	LDR	R0,[R0,R1,LSL#3]	; dispatch table
	LDR	R14,[R8,#w_format]
	TST	R14,#format_SoftWrap
	BNE	sw_redrawline
	MOV	R14,PC
	LDR	PC,[R0,#2*e_redrawline] ; call the redraw line sub
	SUB	R7,R7,R5		; file offset
	FNRTS

sw_redrawline
	PUSH	"R1-R11"
	MOVS	R14,PC
	LDR	PC,[R0,#2*e_redrawline] ; call the redraw line sub
	PULL	"R1-R11"
	BL	modesw_redrawline
	SUBVC	R7,R7,R5		; file offset
	FNRTS

calle_init
	FNJSR
	MOV	R11,#e_init
	BL	call_mode
	FNRTS


;E R5=w_format R7=phy line file offset R10=phy line R11=log line
;X R0=line number to show CC / CS if none
	FNAME	get_linenumber
get_linenumber
	FNJSR
	TST	R5,#format_LinesAreLines
	BEQ	ge13			; address
	TST	R5,#format_LinesPhysical
	BNE	ge14			; phy
	AND	R0,R5,#format_ModeNumber
	ADD	R1,R12,#(mode_store+4):AND:&FF00
	ADD	R1,R1, #(mode_store+4):AND:&00FF ; start of list+4
	LDR	R1,[R1,R0,LSL#3]	; dispatch table
	MOVS	R14,PC
	LDR	PC,[R1,#2*e_redrawlnum]
	FNRTS	CS			; no linenumber
	LDR	R2,[R8,#w_stline]	; first line number
	ADD	R0,R11,R2		; logical
	ADDS	R0,R0,#0		; clc
	FNRTS				; and return

ge13	LDR	R2,[R8,#w_addr]
	ADD	R0,R7,R2		; add start of file address
	ADDS	R0,R0,#0		; clc
	FNRTS

ge14	LDR	R2,[R8,#w_stline]	; first line number
	ADD	R0,R10,R2		; physical
	ADDS	R0,R0,#0		; clc
	FNRTS				; and return


; print line numbers to a buffer
; E R0 -> cache line  R1= output buffer  R8
; X line number printed, R1 updated
	FNAME	redraw_print_line_number
redraw_print_line_number
	FNJSR	"R2,R6"
	LDR	R2,[R8,#w_format]	; check whether to show them at all
	TST	R0,#format_ShowLineNumbers
	FNRTS	EQ

	MOV	R6,R1
	LDRB	R1,[R0,#4]              ; presence flag
	LDR	R0,[R0]			; number
	BL	print_line_numbers	; stick them in
	MOV	R1,R6
	FNRTS


; E R0 = number  R1 = 0 to plot spaces / 1 to plot number  R6 -> line  R8
; X R6 updated
print_line_numbers
	TEQ	R1,#0
	BEQ	line_number_spaces
	LDR	R1,[R8,#w_format]
	TST	R1,#format_LinesBase
	BEQ	print_decimal
	;B	print_hex

	; FALL THROUGH


;E R0=line number R6=cache line
;X Hex number written R0-R1 corrupted  R6 updated
print_hex
	FNJSR	"R2-R4,R11"
	MOV	R11,R6
	ADR	R6,linenumberbuffer	; print hex into temp buffer
	BL	hex8
	MOV	R6,R11
	ADR	R2,linenumberbuffer
	LDR	R14,[R8,#w_info]	; check for zero width
	ANDS	R0,R14,#info_LineNumberWidth
	MOVEQ	R2,#'>'                 ;
	STREQB  R2,[R6],#1              ;
	BEQ	zero$l			;
	ADD	R2,R2,#7
	SUB	R2,R2,R0
lnloop$l				; copy into line buffer
	LDRB	R1,[R2],#1
	STRB	R1,[R6],#1
	SUBS	R0,R0,#1
	BPL	lnloop$l
zero$l	BL	linenumbercolons	; add _:_
	FNRTS


; As for print_hex
	FNAME	print_decimal
print_decimal
	FNJSR	"R2-R4,R10,R11"
	MOV	R11,R6
	MOV	R10,R0			; save number
	BL	print_nulls		; print spaces and right align
	MOV	R6,R11
	LDR	R14,[R8,#w_info]
	ANDS	R14,R14,#info_LineNumberWidth
	BEQ	one$l
	ADD	R6,R6,R14
	ADD	R6,R6,#1
	MOV	R4,R6			; end of digits
	BL	linenumbercolons	; add _:_
	MOVS	R10,R10
	MOVPL	R3,#0
	MOVMI	R3,#'-'
	RSBMI	R10,R10,#0
	BICMI	R10,R10,#&800000
	BIC	R10,R10,#&FF000000	; ensure line num in range

re3	MOV	R1,R10,LSL#8		; fixed point at bit 8
	MOV	R2,   R1,LSR#4
	ADD	R2,R2,R1,LSR#5
	ADD	R2,R2,R1,LSR#8
	ADD	R2,R2,R1,LSR#9
	ADD	R2,R2,R1,LSR#12
	ADD	R2,R2,R1,LSR#13
	ADD	R2,R2,R1,LSR#16
	ADD	R2,R2,R1,LSR#17
	ADD	R2,R2,R1,LSR#20
	ADD	R2,R2,R1,LSR#21
	ADD	R2,R2,R1,LSR#24
	ADD	R2,R2,R1,LSR#25
	ADD	R2,R2,R1,LSR#28
	ADD	R2,R2,R1,LSR#29		; divide by 10 (mult by 0.0001 1001 10..)
	AND	R0,R2,#&FF		; get bottom bits
	MOVS	R2,R2,LSR#8		; quotient
	CMP	R0,#231
	ADDCS	R2,R2,#1		; round up if needed
	ADD	R1,R2,R2,LSL#2		; quot*5
	SUB	R0,R10,R1,LSL#1		; R10-quot*10
	ADD	R0,R0,#'0'
	CMP	R4,R11
	BLE	exitlinenumberloop
	STRB	R0,[R4,#-1]!		; write digit
	MOVS	R10,R2			; new quotient
	BNE	re3			; loop if non zero
	CMP	R4,R11
	BLE	exitlinenumberloop
	TEQ	R3,#0
	STRNEB  R3,[R4,#-1]!		; add sign if needed
exitlinenumberloop
	FNRTS

one$l	MOV	R0,#'*'
	STRB	R0,[R6],#1
	BL	linenumbercolons
	FNRTS


linenumberbuffer
	DCD	0
	DCD	0
	DCD	0

line_number_spaces
	FNJSR
	BL	print_nulls
	MOV	R0,#0			; set the colour
	STRB	R0,[R6],#1		;
	MOV	R0,#10			;
	STRB	R0,[R6],#1		;
	MOV	R0,#syscol_Fg		;
	STRB	R0,[R6],#1		;
	MOV	R0,#syscol_BgEditable	;
	STRB	R0,[R6],#1		;
	MOV	R0,#0			; FIXME
	STRB	R0,[R6],#1		;
	FNRTS


	FNAME	print_nulls
print_nulls
	LDR	R1,[R8,#w_info]
	AND	R0,R1,#info_LineNumberWidth
	ADD	R0,R0,#1
	TST	R1,#info_LineNumberColons
	ADDNE	R0,R0,#2
	MOV	R1,#' '
looppnull$l
	STRB	R1,[R6],#1
	SUBS	R0,R0,#1
	BPL	looppnull$l
	MOV	PC,R14


	LOCAL


;E R0=colour R1=offset in cache line of first char
;  R2=num of chars to colour>0 R6=start of cache line R8
;X R0 preserved, R1 preserved, R2-R3 corrupted
;  Background colour set to syscol_BgEditable
	FNAME	colour_chars_both
colour_chars_both
	FNJSR	"R1"
	LDR	R14,[R8,#w_txtw]
	ADD	R3,R6,R14		; start of the line
	ADD	R3,R3,R1		; first char to colour
	ADD	R14,R3,R14
	MOV	R1,#syscol_BgEditable
co26a	STRB	R0,[R3],#1
	STRB	R1,[R14],#1
	SUBS	R2,R2,#1
	BGT	co26a
	FNRTS


;E R0=colour R1=offset in cache line of first char
;  R2=num of chars to colour>0 R6=start of cache line R8
;X R0 preserved, R1 preserved, R2-R3 corrupted
	FNAME	colour_chars
colour_chars
	LDR	R3,[R8,#w_txtw]
	ADD	R3,R6,R3		; start of the line
	ADD	R3,R3,R1		; first char to colour
co26	STRB	R0,[R3],#1
	SUBS	R2,R2,#1
	BGT	co26
	MOV	PC,R14


;E R6=cache line  R8
;X R0-R5 corrupted. Line blanked to spaces.
;  Foreground mask set to 2's, background to 0's.
	FNAME	print_blank
print_blank
	LDR	R0,[R8,#w_info]
	TST	R0,#info_WideRedraw
	LDR	R4,[R8,#w_txtw]		; width (multiple of 8)
	ADD	R3,R6,#8		; start of cache line (skipping line number)
	MOV	R0,#&20
	ORREQ	R0,R0,R0,LSL#8
	ORREQ	R0,R0,R0,LSL#16		; 4 spaces
	MOVEQ	R1,R4			; count
	MOVNE	R1,R4,LSL #2
	MOV	R2,R0			; 4 spaces
re2	STMIA	R3!,{R0,R2}		; blank 8 chars
	SUBS	R1,R1,#8
	BHI	re2			; blank the line
	MOV	R0,#2			; foreground mask
	ADD	R0,R0,R0,LSL#8
	ADD	R0,R0,R0,LSL#16
	MOV	R1,R4			; count
	MOV	R2,R0
re5	STMIA	R3!,{R0,R2}
	SUBS	R1,R1,#8
	BHI	re5
	MOV	R0,#0			; background mask
	MOV	R1,R4			; count
	MOV	R2,R0
re6	STMIA	R3!,{R0,R2}
	SUBS	R1,R1,#4		; do style buffer too...
	BHI	re6
	MOV	PC,R14			; return


red_overflow
	FNJSR
	LDR	R0,[R9,#f_ptr]
	LDR	R14,[R9,#f_bufl]
	ADD	R0,R0,R14		; end of buffer
	CMP	R10,R0
	BCS	ov1			; end is off end of buffer=overflow
	MOV	R10,R0			; end of second buffer
	LDR	R0,[R9,#f_splits]	; split size
	ADD	R5,R5,R0
	ADD	R7,R7,R0		; move into second buffer
	CMP	R7,R10			; is it off the end of the second buf
	FNRTS	CC			; return if not
ov1	FNRTV				; return with overflow



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Selection redraw					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R6=start of buffer
;  R8/S9
;  R10=line number currently on already in the selection
;X Selection coloured #
	FNAME	redraw_cache_selection
redraw_cache_selection
	FNJSR	"R1-R6"
	FNLDR	R1,car_selection
	LDR	R2,[R1,#c_line]
	LDR	R3,[R1,#c_oline]
	LDR	R4,[R1,#c_col]
	LDR	R5,[R1,#c_ocol]
	CMP	R2,R3
	BGT	rs10			; swap over
	BLT	rs11			; finished
	CMP	R4,R5
	BLE	rs11
rs10	MOV	R0,R2
	MOV	R2,R3
	MOV	R3,R0
	MOV	R0,R4
	MOV	R4,R5
	MOV	R5,R0
rs11	LDR	R1,[R8,#w_margin]

	SUBS	R4,R4,R1
	MOVLE	R4,#0
	SUBS	R5,R5,R1
	MOVLE	R5,#0
	;CMP	R4,R1
	;MOVLE	R4,#0
	;CMP	R5,R1
	;MOVLE	R5,#0			; pull to left hand edge

	ADD	R6,R6,#8		; skip the line number

	LDR	R1,[R8,#w_txtw]		; buffer width
	CMP	R10,R2
	MOVGT	R4,#0			; start col 0 if not first line
	CMP	R10,R3
	MOVLT	R5,R1			; end col if not last line
	SUBS	R5,R5,R4		; num of chars to write
	FNRTS	LE
	ADD	R4,R6,R4		; first col
	LDR	R2,[R8,#w_info]
	TST	R2,#info_WideRedraw
	ADDEQ	R2,R4,R1		;
	ADDNE	R2,R4,R1,LSL #2		; foreground mask
	ADD	R3,R2,R1		; background mask
	MOV	R0,#syscol_SelFg
	MOV	R1,#syscol_SelBg
rs12	LDRB	R14,[R2],#1		; fg colour
	TEQ	R14,#syscol_Ctrls	; is it a 'fake' control character (-> tab)
	STRNEB  R0,[R2,#-1]		; fg colour blatted
	STRB	R1,[R3],#1		; bg colour blatted
	SUBS	R5,R5,#1
	BGT	rs12
	FNRTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; REDRAW LINE SUBS (PRINT HEX NUMBERS ETC)		    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

colons	ADD	R6,R6,#1
colon	MOV	R0,#':'
	STRB	R0,[R6],#2
	MOV	PC,R14

linenumbercolons
	MOV	R0,#0			; set the colour
	STRB	R0,[R6],#1		;
	MOV	R0,#10			;
	STRB	R0,[R6],#1		;
	MOV	R0,#syscol_Fg		;
	STRB	R0,[R6],#1		;
	MOV	R0,#syscol_BgEditable	;
	STRB	R0,[R6],#1		;
	MOV	R0,#0			; FIXME
	STRB	R0,[R6],#1		;

	MOV	R0,#' '
	STRB	R0,[R6],#1
	STRB	R0,[R6,#1]
	LDR	R0,[R8,#w_info]
	TST	R0,#info_LineNumberColons
	MOV	R0,#':'
	STRNEB  R0,[R6],#2
	MOV	PC,R14


;E R1=window blk of area in chars (handle ...) R8/R9
;X the coords changed to os and area redrawn (using update window) #
	FNAME	update_area
update_area
	FNJSR	"R1-R4"
	LDR	R2,[R1,#4]		; xmin
	LDR	R3,[R1,#8]		; ymin
	BL	ccd_xyline_xyos
	STR	R2,[R1,#4]		; new xmin
	MOV	R14,R3			; new ymax
	LDR	R2,[R1,#12]		; xmax
	LDR	R3,[R8,#w_bpl]
	SUBS	R3,R3,#1
	CMP	R2,R3
	LDR	R3,[R1,#16]		; ymax
	STR	R14,[R1,#16]		; new ymax ...???
	MOVLO	R4,#0
	FNLDR	R4,wimp_rightgap,HS
	BL	ccd_xyline_xyos
	ADD	R2,R2,R4
	STR	R2,[R1,#12]		; new xmax
	STR	R3,[R1,#8]		; new ymin
	BL	update_window		; update window
	FNRTS


;E R1=window blk of area in os (handle ...) R8/R9
;X window area updated using Wimp_UpdateWindow #
	FNAME	update_window
update_window
	FNJSR	"R1"
	SWI	XWimp_UpdateWindow	; update the window
	TEQ	R0,#0
	FNRTS	EQ			; return if no more
up1	BLVC	redraw_window		; redraw the rectangle
	SWIVC	XWimp_GetRectangle	; get next rectangle
	FNRTS	VS
	TEQ	R0,#0
	BNE	up1			; loop if more to do
	FNRTS


;X All windows redrawn (eg palette/char set change)
	FNAME	redraw_all
redraw_all
	FNJSR	"R10"
	ADR	R10,update_whole_window
	MOV	R0,#0
	BL	do_allwindow		; update windows
	FNRTS


;E R8/R9=window to update
;X whole work area redrawn and title updated & redrawn CB #
	FNAME	update_whole_window
update_whole_window
	FNJSR	"R1-R3"
	BL	update_whole_window_bar_title
	BLVC	new_title		; redraw title
	FNRTS


	FNAME	update_whole_window_bar_title
update_whole_window_bar_title
	FNJSR
	FNLDR	R1,car_block
	LDR	R0,[R8,#w_handle]
	STR	R0,[R1]
	FNLDR	R0,wimp_leftgap
	RSB	R0,R0,#0
	STR	R0,[R1,#w_minx]
	MOV	R0,#0
	STR	R0,[R1,#w_maxy]
	BL	ccd_workxy
	STR	R2,[R1,#w_maxx]
	STR	R3,[R1,#w_miny]
	BL	update_window		; redraw whole window
	FNRTS


	LOCAL

;E R8=window block
;X palette (of current mode) copied into palette block & converted to
;  masks if in DSA mode #
	FNAME	create_palette
create_palette
	FNJSR	"R1-R4"
	MOV	R0,#-1
	LDRB	R1,[R8,#w_format]	; current mode
	BL	mode_colour_num		; read the number of colours
	FNRTS	VS
	MOVVC	R4,R0			; save number of colours for this mode
	LDRVC	R0,[R8,#w_palette]
	MOVVC	R1,R4,LSL#2
	BLVC	heap_ensure		; ensure palette big enough
	STR	R0,[R8,#w_palette]
	LDRB	R1,[R8,#w_format]	; current mode
	MOV	R2,#0			; colour number
	MOV	R3,R0			; palette to write
a$l	MOV	R0,#-1			; read
	BL	mode_colour		; read the colour
	FNRTS	VS
	STR	R0,[R3,R2,LSL#2]	; save
	ADD	R2,R2,#1
	CMP	R2,R4
	BCC	a$l			; fill them all in
	LDR	R0,[R8,#w_flags]
	AND	R0,R0,#redraw_font_mask
	TEQ	R0,#redraw_vdu_system
	TEQNE	R0,#redraw_vdu_font
	BLNE	create_dsa_palette
	FNRTS


;E R8 palette set up
;X palette converted to DSA-style palette
	FNAME	create_dsa_palette
create_dsa_palette
	FNJSR	"R1-R3"
	ADD	R1,R12,#red_flags	; redraw block
	LDR	R2,[R8,#w_palette]	; source
	MOV	R3,R2			; dest
	MOV	R0,#2			; transform to DSA (R4 already set)
	SWI	XZapRedraw_CreatePalette ; set up DSA colour masks
	FNRTS


;E R0=region start R1=region end R0<R1 or R0>R1 R8/R9
;X screen updated (R0,R1 may be either way round) #
	FNAME	update_between_offsets
update_between_offsets
	TEQ	R0,R1
	MOVEQ	PC,R14			; nothing to update
	FNJSR	"R1-R5"
	MOV	R5,R1			; save end
	BL	offset_line_column	; R2/R3=start
	MOVVC	R0,R5			; end
	MOVVC	R4,R2
	MOVVC	R5,R3			; R4/R5=start
	BLVC	offset_line_column	; R2/R3=end
	BLVC	correct_region		; doesn't matter which way
	ADDVC	R5,R5,#1		; last line.  Hmmm.  Pity.
	BLVC	update_region
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Printout subs							   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;X page size set up in wimp_print / error if no printer driver #
	FNAME	pnt_get_pagesize
pnt_get_pagesize
	FNJSR	"R1-R6"
	SWI	XPDriver_PageSize
	FNLDR	R0,wimp_print		; buffer
	MOVVS	R3,#0
	MOVVS	R4,#0
	LDRVS	R5,default_width$l
	LDRVS	R6,default_height$l
	SUB	R5,R5,R3
	SUB	R6,R6,R4
	STMIA	R0,{R3-R6}		; x, y, width, height of printable area
	SUBS	R0,R0,#0		; CLV? Unnecessary?
	FNRTS
default_width$l
	&	595275			; 21cm
default_height$l
	&	841889			; 29.7cm


;E R0=window width in chars & wimp_print number of pages/sheet paper size
;X lines per page/x scale/y scale filled in wimp_print #
	FNAME	pnt_fit_pages
pnt_fit_pages
	FNJSR	"R1-R11"
	MOV	R6,R0			; save width in chars
	BL	pnt_find_font
	FNRTS	VS
	FNLDR	R10,wimp_print
	FNLDR	R11,opt_flags
	TST	R11,#1<<15		; sideways print
	LDREQ	R4,[R10,#print_width]	; width mps
	LDREQ	R5,[R10,#print_height]  ; height mps
	LDRNE	R5,[R10,#print_width]	; (swapped)
	LDRNE	R4,[R10,#print_height]
	MOV	R0,R4			; R4 = sheet width in mps ; (new 4)
	LDR	R1,[R10,#print_columns_per_page]
	ADD	R0,R0,R1,ASR #1
	SWI	XZapRedraw_Divide	; BL div_mod
	STR	R0,[R10,#print_column_gap]
	MOV	R4,R0			; page width
	FNLDR	R0,pnt_charw		; font width in pixels
	FNLDR	R14,scn_magx		; x os scaling
	MOV	R0,R0,LSL R14		; font width in os coords
	MOV	R14,#400
	MUL	R0,R14,R0		; font width in mps @ b0
	MUL	R1,R0,R6		; window width in mps @ b0
	MOV	R1,R1,ASR#8		; window width mps/256 @ b0
	MOV	R0,R4,LSL#8		; paper  width mps/256 @ b16
	ADD	R0,R0,R1,ASR #1
	SWI	XZapRedraw_Divide	; BL div_mod
	MOV	R6,R0			; R6=x scaling @ b16
	CMP	R6,#&14000		; max scaling 5/4
	MOVGT	R6,#&14000
	STR	R6,[R10,#print_xscale]
	STR	R6,[R10,#print_yscale]
	MOV	R0,R5,LSL#8		; paper height mps / 256 @ b16
	MOV	R1,#400
	SWI	XZapRedraw_Divide	; paper height os / 256 @ b16
	FNLDR	R1,scn_magy
	MOV	R0,R0,LSR R1		; paper height pix / 256 @ b16
	MOV	R0,R0,LSL#8		; paper height pix @ b16
	LDR	R1,[R10,#print_xscale]  ; x scaling @ b16
	SWI	XZapRedraw_Divide	; height in pixels after scaling
	FNLDR	R1,pnt_charh
	SWI	XZapRedraw_Divide	; height in chars
	MOV	R3,R0
	TST	R11,#1<<16
	SUBEQ	R3,R3,#3		; subtract room for title
	STR	R3,[R10,#print_lines_per_column]
	BL	pnt_lose_font
	FNRTS


;E R0=use colour R8/R9=file
;X pages printed using wimp_print #
	FNAME	print_file
print_file
	FNJSR	"R1-R5,R7,R8,R10"
	FNSTR	R0,opt_temporary	; colour flag
	BL	pnt_find_font
	FNRTS	VS
	LDR	R1,[R8,#w_rl]
	LDR	R2,[R8,#w_rw]
	LDR	R3,[R8,#w_rh]
	LDR	R4,[R8,#w_linesp]	; save old redraw vals
	FNLDR	R0,pnt_charw
	STR	R0,[R8,#w_rw]
	FNLDR	R0,pnt_charh
	STR	R0,[R8,#w_rl]
	STR	R0,[R8,#w_rh]		; set up font ones
	MOV	R14,#0
	STR	R14,[R8,#w_linesp]
	ADR	R10,print_file_sub
	BL	do_longop		; print the pages
	STR	R1,[R8,#w_rl]
	STR	R2,[R8,#w_rw]
	STR	R3,[R8,#w_rh]
	STR	R4,[R8,#w_linesp]
	MOV	R14,#0
	FNSTR	R14,opt_temporary
	BL	pnt_lose_font		; this copes with VS
	FNRTS				; may be VS and error...


	FNAME	print_file_sub
print_file_sub
	FNJSR	"R1-R11"
	MOV	R0,#&8F			; Openout with errors
	ADR	R1,print_file_s0
	MOV	R2,#0
	SWI	XOS_Find		; open printer file
	FNRTS	VS
	MOVS	R11,R0			; save handle
	FNRTS	EQ			; file not opened !
	FNSTR	R11,wimp_print_job
	LDR	R1,[R9,#f_name]		; title
	SWI	XPDriver_SelectJob
	BVS	pn8			; close file and error
	FNSTR	R0,wimp_print_prevjob
	FNLDR	R10,wimp_print
	BL	pnt_matrix
	LDR	R1,[R10,#print_start_page] ; start page(from 0)
	LDR	R2,[R10,#print_stop_page] ; end page(+1)
	LDR	R3,[R10,#print_total_num_pages]
	CMP	R2,R3
	MOVGE	R2,R3			; clip end page
	LDR	R3,[R10,#print_columns_per_page]
pn3	CMP	R1,R2
	BGE	pn7			; none left so finish
	BL	pnt_send_title		; send title if there is one
	MOVVC	R4,#0			; column offset
pn4	MOVVC	R0,R4
	BLVC	pnt_send_column		; give the column
	BVS	pn6			; error
	ADD	R4,R4,#1		; next column
	CMP	R4,R3
	BCC	pn4
	BL	print_page		; print the page
	ADDVC	R1,R1,#1		; next page
	BVC	pn3
	B	pn6

pn7	FNLDR	R0,wimp_print_job
	SWI	XPDriver_EndJob
	BVS	pn6
	MOV	R0,#0
	FNLDR	R1,wimp_print_job
	FNSTR	R0,wimp_print_job
	SWI	XOS_Find		; close file
	FNLDR	R0,wimp_print_prevjob,VC ; previous Job
	MOV	R11,#0
	FNSTR	R11,wimp_print_prevjob
	SWIVC	XPDriver_SelectJob
	FNRTS

pn6	PUSH	"R0"
	FNLDR	R0,wimp_print_job
	SWI	XPDriver_AbortJob
	FNLDR	R0,wimp_print_prevjob	; previous Job
	MOV	R11,#0
	FNSTR	R11,wimp_print_prevjob
	SWI	XPDriver_SelectJob
	PULL	"R0"

pn8	PUSH	"R0"
	MOV	R0,#0
	FNLDR	R1,wimp_print_job
	FNSTR	R0,wimp_print_job
	SWI	XOS_Find		; close file
	PULL	"R0"
	FNRTV				; return with error

print_file_s0
	FNS	("printer:")


;E R8-R9=file R10=wimp_print
;X os rectangles (R1) and transformation matrices (R2) set up |
	FNAME	pnt_matrix
pnt_matrix
	FNJSR	"R1-R3"
	ADD	R1,R10,#print_column_rectangle
	MOV	R0,#0
	STR	R0,[R1,#0]		; min x
	STR	R0,[R1,#4]		; min y
	LDR	R2,[R8,#w_width]	; window width in chars
	LDR	R3,[R10,#print_lines_per_column]
	BL	ccd_xyline_xyos
	STR	R2,[R1,#8]		; max x
	RSB	R3,R3,#0
	STR	R3,[R1,#12]		; max y
	ADD	R1,R10,#print_title_rectangle
	MOV	R0,#0
	STR	R0,[R1,#0]		; min x
	STR	R0,[R1,#4]		; min y
	MOV	R2,#&50			; max title width
	MOV	R3,#1			; number of lines
	BL	ccd_xyline_xyos
	STR	R2,[R1,#8]		; max x
	RSB	R3,R3,#0
	STR	R3,[R1,#12]		; max y
	ADD	R1,R10,#print_column_matrix
	MOV	R0,#0
	STR	R0,[R1]
	STR	R0,[R1,#4]
	STR	R0,[R1,#8]
	STR	R0,[R1,#12]		; clear matrix
	FNLDR	R14,opt_flags
	LDR	R2,[R10,#print_xscale]
	LDR	R3,[R10,#print_yscale]
	TST	R14,#1<<15
	BNE	pn10			; not upright
	STR	R2,[R1]			;  (b 0)
	STR	R3,[R1,#12]		;  (0 c)
	B	pn1

pn10	RSB	R2,R2,#0
	STMIB	R1,{R2,R3}		; matrix (0  c) (-b 0)
pn1	ADD	R2,R10,#print_title_matrix
	MOV	R3,#4			; count
pn2	LDR	R0,[R1],#4
	ADD	R0,R0,R0,ASR#3		; *1.125
	STR	R0,[R2],#4
	SUBS	R3,R3,#1
	BHI	pn2			; create title matrix
	FNRTS


;E R0=column offset in sheet R1=page number R8-R9 file R10=wimp_print
;X column sent to printer #
	FNAME	pnt_send_column
pnt_send_column
	FNJSR	"R1-R11"
	MOV	R7,R0			; save col offset
	MOV	R6,R1			; page number
	FNLDR	R11,opt_flags
	ADD	R1,R10,#print_column_rectangle
	ADD	R2,R10,#print_column_matrix
	ADD	R3,R10,#print_plot_position
	LDR	R4,[R10,#print_width]
	LDR	R5,[R10,#print_height]
	LDR	R0,[R10,#print_column_gap]
	MUL	R0,R7,R0		; col offset in mps
	TST	R11,#flags_FancyPrintSideways
	MOVEQ	R4,R0
	MOVEQ	R5,#0			; xy for upright
	MOVNE	R4,#0
	SUBNE	R5,R5,R0		; xy for sideways
	LDR	R0,[R10,#print_xoff]
	ADD	R4,R4,R0		; add x margin
	LDR	R0,[R10,#print_yoff]
	ADD	R5,R5,R0		; add y margin
	STMIA	R3,{R4,R5}		; plot position
	MVN	R4,#&FF			; colour &FFFFFF00 (bg colour = white...)
	BL	add_fudge_factors
	LDR	R0,[R10,#print_columns_per_page]
	MLA	R0,R6,R0,R7		; total column offset as ID
	SWI	XPDriver_GiveRectangle
	FNRTS


;E R10=wimp_print
;X title rectangle sent to printer driver if necessary #
	FNAME	pnt_send_title
pnt_send_title
	FNJSR	"R1-R11"
	FNLDR	R11,opt_flags
	TST	R11,#flags_FancyPrintNoTitle
	FNRTS	NE			; no need to add title
	ADD	R1,R10,#print_title_rectangle
	ADD	R2,R10,#print_title_matrix
	ADD	R3,R10,#print_plot_position
	LDR	R4,[R10,#print_width]
	LDR	R5,[R10,#print_height]
	FNLDR	R0,pnt_charw		; font height in pixels
	FNLDR	R14,scn_magy
	MOV	R0,R0,LSL R14		; font height in os
	MOV	R14,#400
	MUL	R0,R14,R0		; font height in mps
	LDR	R14,[R10,#print_yscale]
	MUL	R0,R14,R0		; height mps @ b16
	MOV	R0,R0,LSR#16		; height mps
	TST	R11,#flags_FancyPrintSideways
	MOVEQ	R4,#0
	SUBEQ	R5,R5,R0		; xy for upright
	SUBNE	R4,R4,R0		; xy for sideways
	LDR	R0,[R10,#print_xoff]
	ADD	R4,R4,R0		; add x margin
	LDR	R14,[R8,#w_rl]		; font height in pixels
	MOV	R14,R14,LSL #10
	CMP	R5,R14
	MOVLT	R5,R14			; position fudge...
	LDR	R0,[R10,#print_yoff]
	ADD	R5,R5,R0		; add y margin
	STMIA	R3,{R4,R5}		; plot position
	BL	add_fudge_factors
	MVN	R4,#&FF			; colour &FFFFFF00
	MVN	R0,#0			; -1 as ID
	SWI	XPDriver_GiveRectangle
	FNRTS


add_fudge_factors
	FNJSR
	LDR	R14,[R1,#&0]		; minx
	SUB	R14,R14,#2
	STR	R14,[R1,#&0]		; minx
	LDR	R14,[R1,#&4]		; miny
	SUB	R14,R14,#2
	STR	R14,[R1,#&4]		; miny
	LDR	R14,[R1,#&8]		; maxx
	ADD	R14,R14,#2
	STR	R14,[R1,#&8]		; maxx
	LDR	R14,[R1,#&C]		; maxy
	ADD	R14,R14,#2
	STR	R14,[R1,#&C]		; maxy
	FNRTS


;E R1=page num R8-R9=file R10=wimp_print and rectangles sent to printer
;X Rectangles got from printer driver and plotted WB KB WD #
	FNAME	print_page
print_page
	FNJSR	"R1-R11"
	MOV	R7,R1			; save page number
	ADD	R0,R7,#1		; page
	LDR	R1,[R8,#w_txtw]		; cached line width
	BL	create_heading		; heading to wimp_data
	FNLDR	R11,wimp_kbdbuf,VC	; block for 'screen update'
	LDRVC	R0,[R8]
	STRVC	R0,[R11]		; window handle
	ADDVC	R0,R7,#1		; page number (from 1)
	ADDVC	R1,R11,#44
	MOVVC	R2,#16
	SWIVC	XOS_ConvertInteger4	; get page number string
	MOVVC	R0,#1			; 1 copy
	ADDVC	R1,R11,#28		; rectangle block (for data)
	ADDVC	R2,R7,#1		; page
	ADDVC	R3,R11,#44		; page number string
	SWIVC	XPDriver_DrawPage
	FNRTS	VS
pn12	TEQ	R0,#0
	FNRTS	EQ			; finished
	CMP	R2,#0			; is ID<0
	ADDPL	R0,R10,#print_column_rectangle
	ADDMI	R0,R10,#print_title_rectangle
	LDMIA	R0,{R4-R7}
	STMIB	R11,{R4-R7}		; 'visible area of window'
	MOV	R1,R11
	BL	redraw_clip		; clip given rectangle to boundry
	CMP	R2,#0
	BMI	pn14			; print title
	LDR	R4,[R10,#print_lines_per_column]
	MUL	R3,R2,R4		; y scroll offset in lines
	MOV	R2,#0			; x scroll offset
	BL	ccd_xyline_xyos
	STR	R2,[R11,#w_scrollx]
	STR	R3,[R11,#w_scrolly]	; current scroll for this column
	MOV	R1,R11
	BL	print_rectangle		; print the rectangle
	FNRTS	VS
pn13	ADD	R1,R11,#28
	SWI	XPDriver_GetRectangle
	BVC	pn12			; do next rectangle
	FNRTS

pn14	MOV	R0,#0
	STR	R0,[R11,#w_scrollx]
	STR	R0,[R11,#w_scrolly]	; no scrolls
	PUSH	"R10-R11"
	MOV	R1,R11
	BL	redraw_to_red
	PULL	"R10-R11"
	MOV	R0,#100
	FNSTR	R0,red_linesp		; make sure don't get onto second line
	FNLDR	R0,wimp_data
	FNLDR	R1,red_data
	SUB	R0,R0,R1		; offset to the text to draw
	STR	R0,[R1]
	MOV	R0,#0
	STR	R0,[R1,#4]		; only one line
	BL	print_area_font
	BVC	pn13			; next rectangle
	FNRTS


;E R1=area to redraw (as for Wimp_Redraw) R8-R9
;X Area printed by vdu redraw #
	FNAME	print_rectangle
print_rectangle
	FNJSR	"R1-R4,R8"
	BL	redraw_to_red		; convert coords to pixels
	BLVC	update_cache		; update cache entries
	BLVC	create_redraw_data	; create new style redraw data
	BLVC	print_area_font		; display on screen area
	FNRTS


	LOCAL

;E Redraw block set up except for palette/font name/flags/size etc
;X Text printed by font vdu call #
	FNAME	print_area_font
print_area_font
	FNJSR	"R1,R8"
	MOV	R14,#9+rf_extend		; vdu redraw + sub-styles + |vdu background|
	FNSTR	R14,red_flags
	FNLDR	R14,pnt_font
	FNSTR	R14,red_caddr

	BL	set_up_print_palette
	FNSTR	R0,red_palette,VC

	ADDVC	R1,R12,#red_flags
	SWIVC	XZapRedraw_RedrawArea
	FNRTS


	FNAME	set_up_print_palette
set_up_print_palette
	FNJSR	"R1-R8,R11"
	FNLDR	R7,wimp_data
	ADD	R7,R7,#&C0		; &40 free at least...
	MOV	R0,#-1
	LDRB	R1,[R8,#w_format]
	BL	mode_colour_num
	MOVVC	R6,R0
	SUBVC	R6,R6,#1
colourloop$l
	MOVVC	R0,#-1
	MOVVC	R2,R6
	LDRVCB  R1,[R8,#w_format]
	BLVC	mode_colour
	FNRTS	VS
	MOV	R5,R0
	FNLDR	R0,opt_temporary	; set up in print_file
	TEQ	R0,#0
	BNE	usingcolour$l
	CMP	R6,#9
	BCC	systemcase$l
	MOV	R0,#15
	MOV	R1,R6
	MOV	R11,#e_interrogate
	BL	call_mode
	FNRTS	VS			; oh dear...
	TST	R0,#1
backfromsystemcase$l
	ANDNE	R5,R5,#&FF
	ORREQ	R5,R5,#&FF000000
	ORREQ	R5,R5,#&00FF0000
	ORREQ	R5,R5,#&0000FF00
usingcolour$l
	STR	R5,[R7,R6,LSL #2]
	SUBS	R6,R6,#1
	BPL	colourloop$l
	MOV	R0,R7
	FNRTS

systemcase$l
	TEQ	R6,#0
	TEQNE	R6,#1
	TEQNE	R6,#3
	TEQNE	R6,#5
	B	backfromsystemcase$l


;E R1=rectangle to clip (minx,miny,maxx,maxy) R2=rectangle to clip to
;X rectangle clipped |
	FNAME	rectangle_clip
rectangle_clip
	FNJSR
	LDR	R0,[R1,#&0]
	LDR	R14,[R2,#&0]
	CMP	R0,R14
	STRLT	R14,[R1,#&0]		; minx
	LDR	R0,[R1,#&4]
	LDR	R14,[R2,#&4]
	CMP	R0,R14
	STRLT	R14,[R1,#&4]		; miny
	LDR	R0,[R1,#&8]
	LDR	R14,[R2,#&8]
	CMP	R0,R14
	STRGT	R14,[R1,#&8]		; maxx
	LDR	R0,[R1,#&C]
	LDR	R14,[R2,#&C]
	CMP	R0,R14
	STRGT	R14,[R1,#&C]		; maxy
	FNRTS


;E R1=redraw block
;X graphics window 28-40 clipped to visible area 4-16 |
	FNAME	redraw_clip
redraw_clip
	FNJSR	"R1,R2"
	ADD	R2,R1,#4
	ADD	R1,R1,#28
	BL	rectangle_clip
	FNRTS


; get the font to be used during printing
; E R8
; X pnt_font, pnt_charw, pnt_charh setup
	FNAME	pnt_find_font
pnt_find_font
	FNJSR
	BL	read_vdu_font_name
	LDR	R2,[R8,#w_vdufontsize]
	MOV	R3,R2,LSR #16		; aspect ratio
	MOV	R2,R2,LSL #16
	MOV	R2,R2,LSR #12		; font size (points / 16)
	ADD	R4,R12,#font_leftred
	MOV	R1,#3			; VDU mode, reduction block present
	SWI	XZapRedraw_FindFont

	FNSTR	R0,pnt_font,VC
	ADDVC	R1,R12,#red_flags
	MOVVC	R2,#0			; pixels, ignore r_linesp, don't scale
	SWIVC	XZapRedraw_ReadCharSize
	FNSTR	R2,pnt_charw,VC
	FNSTR	R3,pnt_charh,VC
	FNRTS


; lose the font used during printing
; E possibly VS and R0 = error
; X
	FNAME	pnt_lose_font
pnt_lose_font
	FNJSR	"R11"
	MOVVC	R11,#0
	ADDVSS  R11,R0,#0		; keep the error and CLV
	ADD	R1,R12,#pnt_font
	MOV	R0,#0
	SWP	R0,R0,[R1]		; get font and clear it
	TEQ	R0,#0
	SWINE	XZapRedraw_LoseFont
	FNRTS	VS

	MOVS	R0,R11			; see if we had an error
	FNRTS	EQ
	FNRTV


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Quick print subs						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R8-R9 & wimp_print set up
;X file printed by direct output of ascii #
	FNAME	quick_print
quick_print
	FNJSR	"R10"
	ADR	R10,quick_print_sub
	BL	do_longop
	FNRTS

	FNAME	quick_print_sub
quick_print_sub
	FNJSR	"R1-R11"
	SWI	XOS_WriteC + &102
	FNLDR	R11,opt_flags
	FNLDR	R10,wimp_print
	TST	R11,#1<<18
	BNE	pr3			; no title
	MVN	R0,#0			; no page number
	MOV	R1,#&80			; cache width
	BL	create_heading
	MOVVC	R2,R1			; cache width
	FNLDR	R1,wimp_data,VC
	MOVVC	R0,#2_1111		; leave in ff (12)
	MOVVC	R3,#0			; fake w_info: not wide, not UTF-8
	BLVC	tidy_cache_line
	MOVVC	R0,R1
	BLVC	printer_string		; output title
	BLVC	printer_newline		; and blank line
	BLVC	printer_startoffile
	FNRTS	VS

pr3	LDR	R1,[R10,#print_start_line]
	LDR	R2,[R10,#print_stop_line]
	LDR	R3,[R8,#w_height]
	CMP	R2,R3
	MOVGE	R2,R3			; clip end line

pr4	CMP	R1,R2
	BGE	printeofstring
	BL	printer_cache_line	; CORRUPTS LOTS
	FNRTS	VS
	ADD	R1,R1,#1
	B	pr4

printeofstring
	BL	printer_endoffile
	SWI	XOS_WriteC + &103
	FNRTS				; finished


;E R1=line R8/R9
;X line cached and printed, R1-R2,R8-R9 only saved #
	FNAME	printer_cache_line
printer_cache_line
	FNJSR	"R1-R2"
	MOV	R2,R1
	ADD	R3,R1,#1
	BL	update_cache		; saves R8/R9 R0=cached data
	MOVVC	R1,R0			; cached data
	LDRVC	R2,[R8,#w_txtw]		; cache width
	MOVVC	R0,#7
	LDRVC	R3,[R8,#w_info]
	BLVC	tidy_cache_line		; to buffer
	MOVVC	R0,R1
	BLVC	printer_string
	FNRTS


;E R0=page num/-1 for none R1=cache line width R8/R9
;X wimp_data filled with cache line for heading WB KB WD #
	FNAME	create_heading
create_heading
	FNJSR	"R1-R4,R10-R11"
	MOV	R10,R0			; save page number
	MOV	R4,R1			; save cache width
	FNLDR	R0,wimp_data
	BL	heap_ensure		; ensure wimp_data big enough
	FNRTS	VS
	FNSTR	R0,wimp_data
	MOV	R11,R0			; cache data buffer
	MOV	R0,#&20
	MOV	R1,R11
	MOV	R2,R4
	BL	strstr			; clear buffer to spaces
	CMN	R10,#1
	BEQ	cr13			; no page heading
	ADR	R0,cr_s0
	BL	cr_sc			; Page
	MOV	R0,R10
	MOV	R2,#12
	SWI	XOS_ConvertCardinal4
	FNRTS	VS
	MOV	R0,#&20
	STRB	R0,[R1]			; remove null
	ADD	R11,R11,#12		; move onto next column
cr13	ADR	R0,cr_s1
	BL	cr_sc
	LDR	R0,[R9,#f_name]
	BL	find_leaf_name
	MOV	R2,R0
	BL	strcpy			; copy in filename
	ADD	R11,R11,#18		; next col
	ADR	R0,cr_s2
	BL	cr_sc
	FNLDR	R0,wimp_dateformat
	BL	read_date
	FNRTS	VS
	FNLDR	R2,wimp_kbdbuf
	BL	strcpy
	ADD	R11,R11,#32
	ADR	R0,cr_s3
	BL	cr_sc
	FNLDR	R0,wimp_timeformat
	BL	read_date
	FNRTS	VS
	FNLDR	R2,wimp_kbdbuf
	BL	strcpy			; no terminating 0 for cache lines
	FNRTS

cr_sc	MOV	R2,R14
	BL	lookup_token_R0
	MOV	R14,R2
	MOV	R2,R0
	MOV	R1,R11
	B	strcpy

cr_s0	=	"zap_P_page",0
cr_s1	=	"zap_P_file",0
cr_s2	=	"zap_P_date",0
cr_s3	=	"zap_P_time",0
	ALIGN


;E R0=pointer to string ending in 0A
;X string output to printer (inc 0A) #
	FNAME	printer_string
printer_string
	FNJSR	"R1"
	MOV	R1,R0
pr1	LDRB	R0,[R1],#1
	TEQ	R0,#&0A
	BEQ	pr2
	SWI	XOS_PrintChar		; output character
	FNRTS	VS
	B	pr1

pr2	BL	printer_newline
	FNRTS


;X newline sent to printer #
	FNAME	printer_newline
printer_newline
	FNJSR	"R1-R3"
	FNLDR	R0,wimp_eolstring	; end of line GS string
	MOV	R2,#0
	SWI	XOS_GSInit
pr10	SWIVC	XOS_GSRead
	FNRTS	VS
	FNRTS	CS			; reached end
	MOV	R3,R0			; save R0
	MOV	R0,R1			; character
	SWI	XOS_PrintChar
	MOVVC	R0,R3
	B	pr10


;X sof string sent to printer #
	FNAME	printer_startoffile
printer_startoffile
	FNJSR	"R1-R3"
	FNLDR	R0,wimp_sofstring	; end of line GS string
	MOV	R2,#0
	SWI	XOS_GSInit
prsoflp$l
	SWIVC	XOS_GSRead
	FNRTS	VS
	FNRTS	CS			; reached end
	MOV	R3,R0			; save R0
	MOV	R0,R1			; character
	SWI	XOS_PrintChar
	MOVVC	R0,R3
	B	prsoflp$l


;X eof string sent to printer #
	FNAME	printer_endoffile
printer_endoffile
	FNJSR	"R1-R3"
	FNLDR	R0,wimp_eofstring	; end of line GS string
	MOV	R2,#0
	SWI	XOS_GSInit
preoflp$l
	SWIVC	XOS_GSRead
	FNRTS	VS
	FNRTS	CS			; reached end
	MOV	R3,R0			; save R0
	MOV	R0,R1			; character
	SWI	XOS_PrintChar
	MOVVC	R0,R3
	B	preoflp$l


;E R0=flags   b0 => leave form feeds (asc 12) in
;	      b1 => don't allow &80-&9F (for printers)
;	      b2 => don't allow conversion to UTF-8
;	      b3 => don't skip cache line number
;  R1=address of cache line
;  R2=length of cache lines (w_txtw)
;  R3=w_info (for WideRedraw and UTF8 flags)
;X R1=wimp_cacheline R2=length (exc 0A)
;  ctrl/end spaces gone 0A added #
	FNAME	tidy_cache_line
tidy_cache_line
	FNJSR	"R3-R5"
	MOV	R5,R3			; keep w_info flags
	EOR	R4,R0,#1<<2		; save the flags & invert UT8 flag
	TST	R4,#1<<3
	ADDEQ	R1,R1,#8		; skip the line number
	BL	get_cache_line
	MOV	R3,R1			; source
	MOV	R2,R0			; line length
	FNLDR	R0,wimp_cacheline
	ADD	R1,R2,#4
	BL	heap_ensure
	FNRTS	VS
	FNSTR	R0,wimp_cacheline
	MOV	R1,R0			; destination
	ADD	R2,R2,R3		; end
ge11	CMP	R3,R2
	BHS	ge12			; none left
	TST	R5,#info_WideRedraw
	LDREQB	R0,[R3],#1
	LDRNE	R0,[R3],#4
	CMP	R0,#&A0
	BCS	ge19
	TST	R0,#1<<8
	TSTNE	R4,#2
	BNE	ge18
	TEQ	R0,#&7F
	BEQ	ge18
	CMP	R0,#&20
	BCS	ge19
	TST	R4,#1
	BEQ	ge18
	TEQ	R0,#12
	BNE	ge18
ge19	TST	R5,#info_UTF8
	TSTNE	R4,#1<<2
	BNE	utf$l
	TST	R5,#info_UTF8		; clears C
	CMPNE	R0,#&7F
	MOVHS	R0,#'.'
	STRB	R0,[R1],#1		; output
	B	ge11

utf$l	BL	ucs4_to_utf8
	B	ge11

ge18	MOV	R0,#'.'
	STRB	R0,[R1],#1
	B	ge11

ge12	MOV	R0,#&0A
	STRB	R0,[R1]			; add terminator
	MOV	R2,R1
	FNLDR	R1,wimp_cacheline
	SUB	R2,R2,R1		; length
	FNRTS


;E R1=address of cache line (past line number)  R2=length of cache lines (w_txtw)  R3 = w_info
;X R0=actual length with end spaces removed |
	FNAME	get_cache_line
get_cache_line
	FNJSR
	TST	R3,#info_WideRedraw
	BNE	wide$l
	ADD	R14,R1,R2
ge10	CMP	R14,R1
	MOVLE	R0,#0
	FNRTS	LE
	LDRB	R0,[R14,#-1]!
	TEQ	R0,#&20
	BEQ	ge10
	ADD	R14,R14,#1
	SUB	R0,R14,R1
	FNRTS

wide$l	ADD	R14,R1,R2,LSL #2
wl$l	CMP	R14,R1
	MOVLE	R0,#0
	FNRTS	LE
	LDR	R0,[R14,#-4]!
	TEQ	R0,#' '
	BEQ	wl$l
	ADD	R14,R14,#4
	SUB	R0,R14,R1
	FNRTS


;E R2-R5 region R8/R9 (correct way around)
;X Region updated (uses caret block) #
;  Cache blatted as now selection stored there
	FNAME	update_region
update_region
	FNJSR	"R1-R4,R10-R11"
	FNLDR	R1,car_block		; workspace
	MOV	R11,R4			; save last col
	LDR	R10,[R8,#w_width]	; window width
	ADD	R10,R10,#1		; last column
up2	SUBS	R0,R5,R3		; number of lines to do
	FNRTS	LE
	TEQ	R0,#1
	MOVEQ	R4,R11			; on last line so correct last col
	BEQ	up3
	MOV	R4,R10			; to end of line
	TEQ	R2,#0			; starts at start?
	MOVNE	R0,#1
	BNE	up3			; if not then do one line
	TEQ	R11,R10			; is last line full width
	SUBNE	R0,R0,#1		; if not then don't do in this block
up3	STR	R2,[R1,#w_minx]
	STR	R3,[R1,#w_miny]
	STR	R4,[R1,#w_maxx]
	ADD	R3,R3,R0		; inc start line
	STR	R3,[R1,#w_maxy]
	LDR	R0,[R8,#w_handle]
	STR	R0,[R1]
	MOV	R0,#0
	STR	R0,[R8,#w_txtn]
	BL	update_area		; update the rectangle
	FNRTS	VS
	MOV	R2,#0			; new start column
	CMP	R3,R5
	BCC	up2			; more lines to do
	FNRTS


	LOCAL

deprecated_update_area
	FNJSR	"R0,R1"
	ADR	R0,msg_update_area
	MOV	R1,#warn_DontBeep
	BL	warn_user
	FNPULL
	B	update_area

deprecated_update_window
	FNJSR	"R0,R1"
	ADR	R0,msg_update_window
	MOV	R1,#warn_DontBeep
	BL	warn_user
	FNPULL
	B	update_window

msg_update_area
	=	"deprecated: Zap_UpdateArea",0
msg_update_window
	=	"deprecated: Zap_UpdateWindow",0
	ALIGN




 END
