; Contains redraw related code.
; $Id: Redraw,fff,v 2.0 2000/02/22 15:51:50 james Exp $
; -*- armasm -*-

 GET h.ZapHeader

 GET h.Messages
 GET h.MiniBuff
 GET h.Heap
 GET h.ModeBits
 GET h.Strings
 GET h.Cursors
 GET h.CreateWind
 GET h.CreateFile
 GET h.AlterTxt
 GET h.Fonts
 GET h.TMTVars
 GET h.KeyBits
 GET h.SoftWrap

 IMPORT wimp_passon
 IMPORT redraw_leaf_window
 IMPORT zephyr

 EXPORT blat_redraw_cache
 EXPORT check_scn_valid
 EXPORT colour_chars
 EXPORT colour_chars_both
 EXPORT create_palette
 EXPORT ccd_xpix_xpair
 EXPORT ccd_ypix_ypair
 EXPORT ccd_xypix_xyos
 EXPORT ccd_xypix_xyline
 EXPORT ccd_xpair_xos
 EXPORT ccd_ypair_yos
 EXPORT ccd_ypair_ypix
 EXPORT ccd_xyline_xyos
 EXPORT ccd_xyline_xypix
 EXPORT ccd_yline_yos
 EXPORT ccd_yos_yline
 EXPORT ccd_yos_ypair
 EXPORT ccd_blk_xrow
 EXPORT ccd_blk_xrow_vis
 EXPORT ccd_blk_xrow_vis_margin
 EXPORT ccd_blk_yrow
 EXPORT ccd_blk_yrow_vis
 EXPORT ccd_workxy
 EXPORT check_font_manager
 EXPORT colons
 EXPORT colon
 EXPORT convert_coords
 EXPORT ensure_redblk
 EXPORT font_ensure
 EXPORT font_resetcache
 EXPORT font_readinfo
 EXPORT pnt_fit_pages
 EXPORT pnt_get_pagesize
 EXPORT print_file
 EXPORT quick_print
 EXPORT read_font_info
 EXPORT redraw_cache_line
 EXPORT red_overflow
 EXPORT redraw_request
 EXPORT redraw_window
 EXPORT redraw_all
 EXPORT setup_multiple_fonts
 EXPORT tidy_cache_line
 EXPORT update_area
 EXPORT update_between_offsets
 EXPORT update_cache
 EXPORT update_region
 EXPORT update_window
 EXPORT update_whole_window
 EXPORT update_whole_window_bar_title

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Handle the redraw request message				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

redraw_request
 FNJSR
 LDR R0,[R1]			; window handle
 BL convert_wind_handle
 BCC text$l			; a text window
 BL convert_leaf_wind_handle
 BCC leaf$l
 MOV R0,#1			; redraw request
 BL wimp_passon
 FNRTS
leaf$l
 ADR R10,b$l
 MOV R7,R0			; window index in R7
 B loop$l
text$l
 ADRL R10,redraw_window		; sub to redraw main windows
 BL conv_wind_off		; set up R8/R9

;  LDR R0,[R8,#w_flags]
;  TST R0,#1<<31
;  SWINE &107
;
;  LDR R0,[R8,#w_flags]
;  TST R0,#1<<31
;  BLNE alter_window		; alter window for mode change!!!!!!???

 LDR R0,[R8,#w_format]
 TST R0,#1<<29			; ignore redraw?
 BICNE R0,R0,#1<<29
 STRNE R0,[R8,#w_format]
 ADRNE R10,null$l
loop$l				; R10=address of sub to do the redraw
 SWI XWimp_RedrawWindow
 FNRTS VS
 ; LDR R14,[R1,#28]
 ; CMP R14,#0
 ; MOVMI R14,#0
 ; STRMI R14,[R1,#28]		; kludge... :-(
 ; SWIMI &107
 TEQ R0,#0
 FNRTS EQ
a$l
 MOVS R14,PC
 MOV PC,R10			; redraw the rectangle
 SWIVC XWimp_GetRectangle	; get next rectangle
 FNRTS VS
 ; LDR R14,[R1,#28]
 ; CMP R14,#0
 ; MOVMI R14,#0
 ; STRMI R14,[R1,#28]		; kludge...
 ; SWIMI &107
 TEQ R0,#0
 BNE a$l
 FNRTS
b$l B redraw_leaf_window	; call the leaf redraw
null$l MOV PC,R14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		R E D R A W   R E C T A N G L E			;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;; Redraw Area ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R4=largest character used R8/R9 red_*
;X Area redrawn (dispatches according to w_flags & w_rh) #
;  Area redrawn via ZapRedraw_RedrawArea SWI
;  Must set up red_flags/screen/bpl/caddr/cbpl/cbpc/palette
;  Must NOT use wimp block.
;  (charh,charw,linesp already set up - see redraw_to_red)
;  NB red_workarea already 64 + sprite size so that's ok

redraw_area
 ; FNLDR R0,red_minx
 ; CMP R0,#&400
 ; MOVCS R0,#0
 ; FNSTR R0,red_minx,CS
 ; SWICS &107
 LDR R0,[R8,#w_flags]		; get flags
 ANDS R0,R0,#&00320000		; font bits
 BEQ redraw_area_1to1		; standard non scaled redraw
 TEQ R0,#&00220000
 BEQ redraw_area_1to2		; double height redraw
 TEQ R0,#&00020000
 BEQ redraw_area_vdu		; redraw via vdu drivers
 TEQ R0,#&00120000
 BEQ redraw_area_fontvdu	; uncached font redraw
 TEQ R0,#&00200000
 BEQ redraw_area_fontfast	; cached font redraw
 LDR R0,[R8,#w_format]
 TST R0,#1<<28
 BEQ redraw_area_1to1		; 1 to 1 scale
 B redraw_area_1to2		; 1 to 2 scale

redraw_area_1to1
 FNJSR "R1-R3"
 ; LDR R0,[R8,#w_font]
 ; LDR R0,[R0,#font_cache0]
 ; CMP R0,#-1
 ; BLEQ setup_fontmc		; make sure w_fontc valid...
 BLVC setup_multiple_fonts
 FNLDR R0,scn_bpp,VC
 FNLDR R2,red_charw,VC
 FNLDR R3,red_charh,VC
 SWIVC XZapRedraw_CachedCharSize	; doesn't need R1.
 FNRTS VS
 FNSTR R2,red_cbpl
 FNSTR R3,red_cbpc
 LDR R14,[R8,#w_info]		; for enable ss bit
 TST R14,#bit_nosubstyles
 MOVEQ R0,#&C ; 6
 MOVNE R0,#&4
; MOV R0,#&C ; 6
 FNSTR R0,red_flags
 LDR R0,[R8,#w_palette]
 FNSTR R0,red_palette
 ADD R1,R12,#red_flags
 ADR R2,main_fastfont_extension
 SWI XZapRedraw_RedrawArea
 FNRTS

redraw_area_1to2
 FNJSR "R1-R3"
 ; LDR R0,[R8,#w_font]
 ; LDR R0,[R0,#font_cache0]
 ; CMP R0,#-1
 ; BLEQ setup_fontmc		; make sure w_fontc valid...
 BLVC setup_multiple_fonts
 FNLDR R0,red_linesp,VC
 MOVVC R0,R0,LSR#1		; halve line spacing
 FNSTR R0,red_linesp,VC
 FNLDR R0,scn_bpp,VC
 FNLDR R2,red_charw,VC
 LDRVC R3,[R8,#w_rh]		; height taken from window
 MOVVC R3,R3,LSR#1
 FNSTR R3,red_charh,VC		; halve the height
 SWIVC XZapRedraw_CachedCharSize
 FNRTS VS			; NB calls setup_red_blk so corrupts
 FNSTR R2,red_cbpl
 FNSTR R3,red_cbpc
 LDR R14,[R8,#w_info]		; for enable ss bit
 TST R14,#bit_nosubstyles
 MOVEQ R0,#&E ; 6
 MOVNE R0,#&6
; MOV R0,#&E ; 6
 FNSTR R0,red_flags
 LDR R0,[R8,#w_palette]
 FNSTR R0,red_palette
 ADD R1,R12,#red_flags
 ADR R2,main_fastfont_extension
 SWI XZapRedraw_RedrawArea
 FNRTS

redraw_area_fontfast
 STMFD R13!,{R1-R3,R14}
; CMP R4,#255
; MOVCS R4,#255
 MOV R0,#1
 BL font_ensure			; ensure set up for fast redraw
 ;LDMVSFD R13!,{R1-R3,PC}
 ;SWI &107			; called OK.
 BLVC font_cachefont		; ensure relevant characters cached
 ;LDMVSFD R13!,{R1-R3,PC}
 ;SWI &107			; called OK.
 ;FNLDR R14,scn_bpp		; Bits per pixel...
 ;MOV R14,#6
 ;CMP R14,#3			; In > 256 colours?
 FNLDR R0,font_cmain,VC
 ;FNLDR R0,font_cache,CS
 MOVVC R14,#1<<2		; extension sub given
 ;MOV R14,#0			; extension sub NOT given!
 ;MOVCS R14,#0			; extension sub NOT given!
 FNSTR R14,red_flags,VC
 FNSTR R0,red_caddr,VC
 FNLDR R0,font_bpl,VC
 FNSTR R0,red_cbpl,VC
 FNLDR R0,font_bpc,VC
 FNSTR R0,red_cbpc,VC
 LDRVC R0,[R8,#w_palette]
 FNSTR R0,red_palette,VC
 FNLDR R0,opt_switches,VC
 ANDVC R0,R0,#switch_SuppressAntialiasedDSA
 STRVC R0,local_aliasing_defeat
 ADDVC R1,R12,#red_flags
 ADRVC R2,fastfont_extension
 MOVVC R3,R12
 SWIVC XZapRedraw_RedrawArea
 LDMFD R13!,{R1-R3,PC}

local_aliasing_defeat
 DCD 0

 LOCAL

; do this every time redraw area is called :-(
setup_multiple_fonts
 FNJSR "R1-R6"
 MOV R0,#0
 FNLDR R2,font_list			; red_charw/charh
 FNLDR R3,font_start
 LDR R4,[R8,#w_font]
 MOV R1,R4
 MOV R5,#(font_number - 1)		; number of fonts-1 - hardwired?
 ADR R6,local_font_wspace + 4
loop$l
 LDR R14,[R4],#4
 CMP R14,#-1
 LDREQ R14,[R1]				; base sub style if not present.
 LDR R0,[R2,R14,LSL#5]			; problems here...?
 ADD R14,R3,R0
 STR R14,[R6],#4
 SUBS R5,R5,#1
 BPL loop$l
 LDR R14,local_font_wspace + 4
 FNSTR R14,red_caddr			; address of the bitmaps (FF:eeek?)
 FNRTS

local_font_wspace
 % (font_number * 4 + 4)

 LOCAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tim's first attempt at font styles ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

main_fastfont_extension
 TEQ R4,#0
 MOVEQ PC,R14			; in line spacing
 TEQ R0,#0
 BEQ linestart$l
 TEQ R0,#10			; font and colour change
 TEQNE R0,#9			; font change
 MOVNE PC,R14

 FNJSR "R2"
 ADR R2,local_font_wspace + 4
 LDRB R14,[R3,#-1]
incolour$l
 ORR R14,R14,R14,LSL #8
 AND R14,R14,#&1E0
 LDR R0,[R2,#-4]		; what's wrong with using R2...?
 SUB R4,R4,R0			; offset in cache
 LDR R0,[R2,R14,LSR #3]
 STR R0,[R2,#-4]
 ADD R4,R4,R0
 FNRTS
linestart$l
 FNJSR "R2"
 ADR R2,local_font_wspace + 4
 LDR R0,[R1,#r_caddr]
 STR R0,[R2,#-4]		; font is reset(?)
 MOV R14,R9,LSR#24		; new entry conditon...! (normally 0?)
 B incolour$l

;  ADR R2,local_font_wspace
;  LDRB R14,[R3,#-1]
; incolour$l
; ; MOV R0,R14
; ; LDR R8,[R2,#20]
; ; BL quick_read_mode_colour
; ; AND R14,R14,#&E0
;  ORR R14,R14,R14,LSL #8
;  AND R14,R14,#&1E0
; ; CMP R14,#&10
; ; MOVCS R14,
;  LDR R0,[R2,#-4]		; what's wrong with using R2...?
;  SUB R4,R4,R0			; offset in cache
;  LDR R0,[R2,R14,LSR #3]
;  STR R0,[R2,#-4]
;  ADD R4,R4,R0
;  FNRTS
; linestart$l
;  FNJSR "R2,R8"
;  ADR R2,local_font_wspace + 4
;  LDR R0,[R1,#r_caddr]
;  STR R0,[R2,#-4] ; ,#4			; font is reset(?)
;  MOV R14,R9,LSR#24		; new entry conditon...! (normally 0)
;  B incolour$l



;  ADR R2,local_font_wspace
;  LDRB R14,[R3,#-1]
; incolour$l
;  BIC R14,R14,#&1F
; ; ADR R0,cases$l
; ; LDRB R14,[R0,R14,LSR #5]
;  LDR R0,[R2]			; what's wrong with using R2..; .?
;  SUB R4,R4,R0			; offset in cache
;  ADD R14,R2,R14,LSR #3
;  LDR R0,[R14,#4]
;  STR R0,[R2]
;  ADD R4,R4,R0
;  FNRTS
; linestart$l
;  FNJSR "R2,R8"
;  ADR R2,local_font_wspace
;  LDR R0,[R1,#r_caddr]
;  STR R0,[R2]			; font is reset
;  MOV R14,R9,LSR#24		; new entry conditon...! (normally 0)
;  B incolour$l

; cases$l
;  DCB 0				; regular        1
;  DCB 4				; bold           2
;  DCB 8				; italic         4
;  DCB 8				; bold italuc    8
;  DCB 12				; underlined    16
;  DCB 12				;               32
;  DCB 12				;               64
;  DCB 12				;              128

;fgcolour$l
; SWI &107
; LDRB R14,[R3,#-1]
; B incolour$l

;bgcolour$l
; SWI &107
; LDRB R14,[R3,#-1]
; B incolour$l

;merge$l
; FNRTS

;cursor$l
; FNRTS

;colour$l
; LDRB R14,[R3,#-2]
; B incolour$l

 LOCAL

;ofstmtlat$l
; DCD tmt_offsets

;E As for a redraw area extension
;   R0=control code 0=line start 1=colour change 4=merge etc
;   R4=0 if in line spacing or cache address+row
;X Changes the address of the font to deal with the colours etc.
;  Uses scratch work space font_wspace which has format:
;   #0 Current font being used
;   #4 Current foregound mask
;   #8 Current background mask

fastfont_extension
 TEQ R4,#0
 MOVEQ PC,R14			; in line spacing
 FNJSR "R2"
 FNLDR R2,font_wspace		; work area
 TEQ R0,#0
 BEQ linestart$l
 TEQ R0,#1
 BEQ colour$l
 TEQ R0,#4
 BEQ merge$l
 TEQ R0,#8
 BEQ cursor$l
; TEQ R0,#9
; BEQ font$l ; colourandfont$l
 TEQ R0,#10
 BEQ colour$l
 FNRTS

font$l
 FNRTS

colourandfont$l
 FNRTS

linestart$l			; start of a line
 LDR R0,[R1,#r_caddr]
 STR R0,[R2]			; font is reset
colour$l			; colour change
 LDR R0,[R2]
 SUB R4,R4,R0			; offset in cache
 STR R10,[R2,#4]		; Save actual foregound mask
 STR R11,[R2,#8]		; Save actual background mask
 FNLDR R0,font_formask
 FNLDR R14,font_bacmask
 TEQ R0,R10
 TEQEQ R14,R11
 BEQ aliased$l			; matches anti-aliased cache font
 TEQ R0,R11
 TEQEQ R14,R10
 BEQ inverse$l			; matches inverse anti-alias
 FNLDR R0,scn_bpp		; Bits per pixel...
 CMP R0,#3			; In > 256 colours?
 BCC justendallthis
 LDR R0,local_aliasing_defeat
 ;FNADR R0,ofstmtlat$l
 ;LDR R0,[R0,#aliasing_defeat]
 CMP R0,#0
 BNE justendallthis
 FNLDR R0,scn_bpp		; Bits per pixel...
 CMP R0,#3			; In 256 colours?
 BEQ twofivesixcols		; In 256 colours?
 CMP R0,#4			; In 256 colours?
 BEQ thirtytwokcols		; In 256 colours?

sixteenmcols			; In 16M colours.
 EOR R0,R10,R11
 TST R0,#&80
 TSTEQ R0,#&8000
 TSTEQ R0,#&800000
 BEQ justendallthis		; the *very* worst cases...
 FNLDR R0,font_cache
 STR R0,[R2]
 ADD R4,R4,R0
 FNRTS

thirtytwokcols			; In 32K colours.
 EOR R0,R10,R11
 TST R0,#&4200
 TSTEQ R0,#&10
 BEQ justendallthis		; the *very* worst cases...
 FNLDR R0,font_cache
 STR R0,[R2]
 ADD R4,R4,R0
 FNRTS

twofivesixcols			; In 256 colours.
 EOR R0,R10,R11
 TST R0,#&F0
 BEQ justendallthis		; the *very* worst cases...
 FNLDR R0,font_cache
 STR R0,[R2]
 ADD R4,R4,R0
 FNRTS

justendallthis
 FNLDR R0,font_cmain		; use non aliased bitmaps
 STR R0,[R2]
 ADD R4,R4,R0
 FNRTS

aliased$l			; cols are cached in anti-alias cache
 FNLDR R0,font_cache
 STR R0,[R2]
 ADD R4,R4,R0
 MOV R10,#-1			; copy the cache values
 MOV R11,#0
 FNRTS
inverse$l			; cols are the inverse of anti-alias cache
 FNLDR R0,font_cache
 STR R0,[R2]
 ADD R4,R4,R0
 EOR R11,R10,R11		; correct masks to invert the
 MVN R10,R11			; colours - calculate cases
 FNRTS
merge$l
 LDR R10,[R2,#4]
 LDR R11,[R2,#8]		; restore
 LDR R0,[R2]
 SUB R4,R4,R0			; offset
 FNLDR R0,font_cmain		; not changing font - stacked!!
 ADD R4,R4,R0			; always use main font
 FNRTS
cursor$l			; doing a cursor merge
 CMP R7,#&100
 BCC swap$l			; just swap over colours (&7F=a block)
 LDR R0,[R2]
 SUB R0,R4,R0			; offset in cache
 FNPULL
 FNLDR R2,font_cmain		; use this for the mask character
 ADD R2,R2,R0			; add character offset
 MOV PC,R14
swap$l				; cursor is a block (&7F) so cols will swap
 LDR R0,[R2]
 SUB R4,R4,R0			; offset in cache
 FNLDR R0,font_formask
 FNLDR R14,font_bacmask
 TEQ R0,R8
 TEQEQ R14,R9
 BEQ swapaliased$l		; matches anti-aliased cache font
 TEQ R0,R9
 TEQEQ R14,R8
 BEQ swapinverse$l		; matches inverse anti-alias
 FNLDR R0,font_cmain		; Selections...?
 ADD R4,R4,R0			; swap to main cache
 FNRTS
swapaliased$l
 FNLDR R0,font_cache
 ADD R4,R4,R0
 MOV R8,#-1
 MOV R9,#0
 FNRTS
swapinverse$l
 FNLDR R0,font_cache
 ADD R4,R4,R0
 EOR R9,R8,R9			; correct masks to invert the
 MVN R8,R9			; colours - calculate cases
 FNRTS

;;;;;;;;;;;;; end of fast font extension ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

redraw_area_vdu
 STMFD R13!,{R1,R14}
 MOV R0,#1+(1<<4)		; vdu redraw + fast rectangles :-)
 FNSTR R0,red_flags
 MOV R0,#0			; system font
 FNSTR R0,red_caddr
 FNSTR R0,red_cbpl		; x offset
 FNLDR R0,red_charh
 FNLDR R1,scn_magy
 MOV R0,R0,LSL R1
 SUB R0,R0,#1
 FNSTR R0,red_cbpc		; y offset
 LDR R0,[R8,#w_palette]
 FNSTR R0,red_palette
 ADD R1,R12,#red_flags
 SWI XZapRedraw_RedrawArea
 LDMFD R13!,{R1,PC}

redraw_area_fontvdu
 STMFD R13!,{R1,R14}
 LDR R14,[R8,#w_info]		; for enable ss bit
 TST R14,#bit_nosubstyles
 FNLDR R14,red_flags
 MOVNE R14,#1+(1<<4)		; vdu redraw + fast rectangles :-)
 MOVEQ R14,#9+(1<<4)		; vdu redraw + sub-styles...
; MOV R14,#9+(1<<4)		; vdu redraw + sub-styles...
 FNSTR R14,red_flags
 FNLDR R0,font_name
 FNSTR R0,red_caddr
 FNLDR R0,font_xoff
 FNSTR R0,red_cbpl		; x offset
 FNLDR R0,font_yoff
 FNSTR R0,red_cbpc		; y offset
 FNLDR R0,font_size
 FNLDR R1,red_workarea
 ;;BIC R0,R0,#&FF000000
 ;;BIC R0,R0,#&FF0000		; ????????????????????
 STR R0,[R1]
 LDR R0,[R8,#w_palette]
 FNSTR R0,red_palette
 ADD R1,R12,#red_flags
 SWI XZapRedraw_RedrawArea
 LDMFD R13!,{R1,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CHAR DEFS						      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;X Reads vdu variables to scn_* #

check_scn_valid
 FNJSR "R1-R4"
; BL checkseeifzapredrawloaded
; BVS nozapredrawyet
 ADD R1,R12,#red_flags
 SWI XZapRedraw_ReadVduVars
 FNLDR R0,red_xsize,VC
 FNLDR R1,scn_magx,VC
 MOVVC R0,R0,LSL R1
 FNSTR R0,scn_xos,VC		; width in os coords
 FNLDR R0,red_ysize,VC
 FNLDR R1,scn_magy,VC
 MOVVC R0,R0,LSL R1
 FNSTR R0,scn_yos,VC		; height in os coords
 FNRTS
;nozapredrawyet
; SUBS R14,R14,R14
; FNRTS

;E scn_& setup for new mode
;X font info updated according to font_cache -1/0/cache WB #

read_font_info
 FNLDR R0,font_cache
 TEQ R0,#0
 MOVEQ PC,R14			; doesn't want fonts
 FNJSR "R1"
 BL font_findfont		; get font handle
 FNRTS VS
 MOV R1,R0			; save handle
 BL font_readinfo		; bounding box in font_[xy]off, font_char[wh]
 BVS re38
 FNLDR R0,font_cache
 CMP R0,#0
 BLGT font_resetcache
 BVS re38
 ;SWI &107			; ?????????? gets here...
 MOV R0,R1
 SWI XFont_LoseFont
 FNRTS
re38
 PUSH "R0"
 MOV R0,R1			; handle
 MOV R14,#-1
 FNSTR R14,font_cache		; cache no longer valid
 MOV R14,#10
 FNSTR R14,font_size		; go back to reasonable font size
 SWI XFont_LoseFont
 PULL "R0"			; restore error
 FNRTV

;E font_charw/charh/xoff/yoff set up
;X Cache ensured, font_bpl/bpc/cachedto set up #

font_resetcache
 FNJSR "R1-R5"
 MOV R0,#&1F			; last char cached =&1F
 FNSTR R0,font_cachedto
 FNLDR R0,scn_bpp
 FNLDR R2,font_charw
 FNLDR R3,font_charh
 FNSTR R2,red_charw
 FNSTR R3,red_charh		; for ensure_workarea_sprite
 SWI XZapRedraw_CachedCharSize  ; R3=number of bytes per main character
 MOVVC R5,R3			; save number of bytes per character
 FNSTR R2,font_bpl,VC
 FNSTR R3,font_bpc,VC
 BLVC ensure_workarea_sprite	; ensure enough room for caching
 FNRTS VS			; eg called by new_font
 MOV R1,R3,LSL#8		; &100 chars
 ADD R1,R1,R3,LSL#4		; &110 chars
 FNLDR R0,font_cache
 CMP R0,#0
 FNRTS EQ
 BLVC heap_ensure			; check cache big enough
 FNSTR R0,font_cache,VC
 FNLDR R0,font_cmain,VC
 BLVC heap_ensure		; check main cache big enough
 FNSTR R0,font_cmain,VC
 MOVVC R0,#0
 FNLDR R2,font_charw,VC
 FNLDR R3,font_charh,VC
 SWIVC XZapRedraw_CachedCharSize; R3=number of bytes per init character
 MOVVC R1,R3,LSL#8		; &100 chars
 ADDVC R1,R1,R3,LSL#4		; &110 chars
 FNLDR R0,font_cinit,VC
 BLVC heap_ensure		; check initial cache big enough
 FNSTR R0,font_cinit,VC
 MOVVC R4,#'z'
 BLVC font_cachefont		; cache letters up to 'z' in all 3 caches
; FNRTS VS
 FNLDR R2,font_cache,VC
 ADDVC R1,R2,R5,LSL#6		; source is character 64
 MOVVC R3,R5,LSL#5		; copy 32 chars
 BLVC move_bytes			; fill in ctrl A-ctrl Z in aa cache
 FNLDR R2,font_cache,VC
 ADDVC R1,R2,R5,LSL#5		; source is character 48
 ADDVC R1,R1,R5,LSL#4
 MOVVC R3,R5			; copy 1 char
 BLVC move_bytes			; fill in ctrl 0
 ADDVC R1,R12,#red_flags
 MOVVC R2,#0
 MOVVC R3,#&110
 SUBVC R3,R3,#1
 FNLDR R4,font_cinit,VC
 SWIVC XZapRedraw_AddVduBitmaps	; add ctrl letters etc initial keymap
 MOVVC R2,#&100
 SWIVC XZapRedraw_ConvertBitmap	; convert &100+
 MOVVC R2,#&7F
 MOVVC R3,#&7F
 SWIVC XZapRedraw_ConvertBitmap	; convert the delete character
 MOVVC R2,#0
 MOVVC R3,#&1F
 SWIVC XZapRedraw_ConvertBitmap	; convert the control letters
 FNRTS

;E R4=char to cache up to. font_* set up and cached claimed.
;  workarea ensured big enough for the sprite
;X font cache updated #
;  redraw block set up for bitmap conversion

font_cachefont
 FNLDR R0,font_cachedto
 CMP R4,R0
 MOVLE PC,R14			; already cached
 FNJSR "R1-R7"
 ADD R6,R0,#1			; first character to cache
 MOV R7,R4			; last character to cache
 MOV R0,#2			; possibly in current mode ... :-)
 BL cachefont_setup		; set up for full caching
; BLVC soutofofs_red
; BLVC tmt_getxpos_redlow	; TMT kludge (doesn't work?)
; BLVC tmt_getypos_redlow	; TMT kludge (doesn't work)
 FNLDR R0,red_charh,VC
 FNLDR R14,scn_magx,VC
 MOVVC R0,R0,LSL R14		; convert x to work os
 ADDVC R5,R5,R0,LSR #2		; y offsets (os)...

 FNLDR R14,red_workarea,VC
 STRVC R4,[R14,#28]		; a_stack1
 STRVC R5,[R14,#32]		; a_stack2
; MOVVC R0,#2			; WAS 2
; BL cachefont_setup		; set up for 1-1

 MOVVC R0,#2			; In mode 0 :-(
 SWIVC XZapRedraw_CacheFontChars;
 ;BVS asinglebeep
 FNRTS VS
 MOV R0,#1			; possibly in current mode ... :-)
 BL cachefont_setup		; set up for full caching
; BLVC soutofofs_red
; BLVC tmt_getxpos_red		; TMT kludge (works)
; BLVC tmt_getypos_red		; TMT kludge (works)
 FNLDR R14,red_workarea,VC
 STRVC R4,[R14,#28]		; a_stack1
 STRVC R5,[R14,#32]		; a_stack2
 MOVVC R0,#1			; in the normal screen mode... :-)
 SWIVC XZapRedraw_CacheFontChars
 FNRTS VS
 FNLDR R0,font_cmain
 FNSTR R0,red_caddr
 MOV R2,R6
 MOV R3,R7
 FNLDR R4,font_cinit
 SWI XZapRedraw_ConvertBitmap
 FNSTR R7,font_cachedto,VC	; actually cached to
 FNRTS

;asinglebeep
; BL Beep
 ;SWI &107
 FNRTS

;E R0=type of call 1/2
;X R1=redraw block with workarea ensured and r_caddr,r_cbpl
;  r_cbpc,r_charw,r_charh,r_palette setup
;  R2=fontname R3=fontsize R4/R5=font os offsets

cachefont_setup
 STMFD R13!,{R8,R14}
 MOV R8,#0			; use default option colours
 MOV R5,R0			; save type of call
 TEQ R5,#1
 FNLDR R0,font_cache,EQ
 FNLDR R0,font_cinit,NE
 FNSTR R0,red_caddr
 FNLDR R2,font_charw
 FNLDR R3,font_charh
 FNSTR R2,red_charw
 FNSTR R3,red_charh
 TEQ R5,#1
 FNLDR R0,scn_bpp,EQ
 MOVNE R0,#0
 SWI XZapRedraw_CachedCharSize
; LDMVSFD R13!,{R8,PC}
 FNSTR R2,red_cbpl
 FNSTR R3,red_cbpc
 FNLDR R3,font_wspace
 FNSTR R3,red_palette
 MVNVC R0,#0			; read
 MOVVC R1,#0			; mode 0
 MOVVC R2,#1			; background
 BLVC mode_colour
; LDMVSFD R13!,{R8,PC}
 STRVC R0,[R3]
 STRVC R0,[R3,#4]			; backgrounds (24 bit)
 MVNVC R0,#0
 MOVVC R2,#2			; foreground
 BLVC mode_colour
; LDMVSFD R13!,{R8,PC}
 STRVC R0,[R3,#8]			; foreground (24 bit)
 ADDVC R1,R12,#red_flags
 MOVVC R2,R3			; source palette=dest
 MOVVC R4,#3			; 3 entries (0,1,2)
; MOV R0,#1			 ; convert to 24 bit
; SWI XZapRedraw_CreatePalette
; LDMVSFD R13!,{R8,PC}
 MOVVC R0,#2			; get masks
 ADDVC R3,R3,#12			; dest palette
 SWIVC XZapRedraw_CreatePalette
; LDMVSFD R13!,{R8,PC}
 LDRVC R0,[R3]
 FNSTR R0,font_bacmask,VC
 LDRVC R0,[R3,#8]
 FNSTR R0,font_formask,VC
 FNLDR R2,font_name,VC
 FNLDR R3,font_size,VC
 FNLDR R4,font_xoff,VC
 FNLDR R5,font_yoff,VC
 ;BIC R3,R3,#&FF000000
 ;BIC R3,R3,#&FF0000		; ????????????????????
 LDMFD R13!,{R8,PC}

;;;;;;;;;;; keep blank line buffer updated ;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=size of buffer required
;X red_blkbuf buffer enlarged to this size with spaces #

ensure_redblk
 STMFD R13!,{R1-R2,R14}
 ADD R1,R0,#3			; size required
 BIC R1,R1,#3			; rounded up to word boundry
 FNLDR R2,red_blklen		; current size
 FNLDR R0,red_blkbuf		; start of buffer
 CMP R2,R1
 LDMCSFD R13!,{R1-R2,PC}	; buffer large enough
 BL heap_ensure			; ensure new size
 LDMVSFD R13!,{R1-R2,PC}
 FNSTR R1,red_blklen		; save new length
 FNSTR R0,red_blkbuf		; save new ptr
 ADD R2,R0,R2			; start of unblanked area (word al)
 ADD R1,R0,R1			; end of buffer (word al)
 MOV R14,#&20
 ADD R14,R14,R14,LSL#8
 ADD R14,R14,R14,LSL#16		; 4 spaces
en1
 STR R14,[R2],#4
 CMP R2,R1
 BCC en1			; clear extra buffer space
 LDMFD R13!,{R1-R2,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; E N D	  O F	R E D R A W   R E C T A N G L E	  S U B S	  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; REDRAW WINDOW BLOCK						    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=redraw window block (as given by wimp) R8/R9
;X this area redrawn #

redraw_window
 FNJSR "R1-R4"
 BL redraw_to_red		; convert coords to pixels
 BLVC update_cache		; update cache entries
 BLVC create_redraw_data	; create new style redraw data
 FNRTS VS			; R1=first unused buffer offset
 MOV R4,R0			; largest character used
 BL invert_carets		; add in the caret data
 BLVC redraw_area		; display on screen area
 FNRTS

;E R1=redraw block as returned by wimp R8/R9
;X R1 corrupted
;  R2-R3=lines to cache clipped to the file #
;  Fills in the type independent red_* variables

;   red_minx/miny/maxx/maxy/bpp/charw/charh/linesp
;   red_scrollx/scrolly.
;  Note red_for/red_bac are constant and should already be filled

redraw_to_red
 STMFD R13!,{R4-R6,R14}
 MOV R0,R1			; wimp redraw block
 ADD R1,R12,#red_flags
 SWI XZapRedraw_GetRectangle
 LDMVSFD R13!,{R4-R6,PC}
 FNLDR R3,red_scrolly		; y scroll from file top
 MOV R5,R3			; save first line
 BL ccd_ypix_ypair		; R3=line R6=raster off
 FNSTR R6,red_scrolly		; offset in line
 MOV R2,R3			; first line to cache

 ;FNLDR R0,red_minx
 ;CMP R0,#&400
 ;MOVCS R0,#0
 ;FNSTR R0,red_minx,CS
 ;SWICS &107

 FNLDR R3,red_maxy
 FNLDR R0,red_miny
 SUB R3,R3,R0
 ADD R3,R3,R5			; last pix row (exclusive)
 BL ccd_ypix_ypair
 TEQ R6,#0
 ADDNE R3,R3,#1			; last line to cache (+1)
 LDR R0,[R8,#w_height]
 CMP R3,R0
 MOVCS R3,R0			; clip to file end
 CMP R2,R3
 MOVCS R2,R3			; ensure R2<=R3
 LDR R5,[R8,#w_rh]		; character height
 FNSTR R5,red_charh		; save character height in pixels
 LDR R0,[R8,#w_rl]
 SUB R0,R0,R5			; line spacing
 FNSTR R0,red_linesp
 LDR R0,[R8,#w_rw]
 FNSTR R0,red_charw		; char horizontal size in pixs
 LDMFD R13!,{R4-R6,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SCREEN COORDS CONVERSION TO WORK AREA COORDS SUBS		  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=window block R2=xos R3=yos on screen
;X R2/R3=pix of posn in work area |

convert_coords
 LDR R0,[R1,#4]			; x min
 SUB R2,R2,R0			; x os offset in vis area
 LDR R0,[R1,#w_scrollx]		; x scroll
 ADD R2,R2,R0			; x os offset in work area
 LDR R0,[R1,#16]		; y max
 SUB R3,R3,R0			; y os offset in vis area
 LDR R0,[R1,#w_scrolly]		; y scroll
 ADD R3,R3,R0			; y os offset in work area
 RSB R3,R3,#0			; y os downward
 FNLDR R0,scn_magx
 MOV R2,R2,ASR R0		; x pix signed
 FNLDR R0,scn_magy
 MOV R3,R3,ASR R0		; y pix signed
 MOV PC,R14

;E R2/R3=xypix R8
;X R2/R3=xycol |

ccd_xypix_xyline
 FNJSR
 BL ccd_xpix_xline
 BL ccd_ypix_yline
 FNRTS

;E R3=ypix R8
;X R3=yline |

ccd_ypix_yline
 LDR R0,[R8,#w_rl]
 TEQ R0,#8
 MOVEQ R3,R3,LSR#3
 MOVEQ PC,R14			; special case
 STMFD R13!,{R1,R2,R14}
 MOV R1,R0			; denominator
 MOV R0,R3			; numerator
 SWI XZapRedraw_Divide ; BL div_mod	; divide
 MOV R3,R0			; DIV answer
 LDMFD R13!,{R1,R2,PC}

;E R2=xpix R8
;X R2=xcol |

ccd_xpix_xline
 LDR R0,[R8,#w_rw]
 TEQ R0,#8
 MOVEQ R2,R2,LSR#3
 MOVEQ PC,R14			; special case
 STMFD R13!,{R1,R3,R14}
 MOV R1,R0			; denominator
 MOV R0,R2			; numerator
 SWI XZapRedraw_Divide ; BL div_mod	; divide
 MOV R2,R0			; DIV answer
 LDMFD R13!,{R1,R3,PC}

;E R3=yos R8
;X R3=yline |

ccd_yos_yline
 RSB R3,R3,#0
 FNLDR R0,scn_magy
 MOV R3,R3,LSR R0
 B ccd_ypix_yline

;E R2=xos R8
;X R2=xcol |

ccd_xos_xline
 FNLDR R0,scn_magx
 MOV R2,R2,LSR R0
 B ccd_xpix_xline

;E R3=yos R8
;X R3=yline R6=yrast |

ccd_yos_ypair
 RSB R3,R3,#0
 FNLDR R0,scn_magy
 MOV R3,R3,LSR R0		; convert y to pix
 B ccd_ypix_ypair

;E R3=ypix R8
;X R3=yline R6=yrast |

ccd_ypix_ypair
 LDR R0,[R8,#w_rl]
 TEQ R0,#8
 ANDEQ R6,R3,#7
 MOVEQ R3,R3,LSR#3
 MOVEQ PC,R14
 STMFD R13!,{R1-R2,R14}
 MOV R1,R0			; denominator
 MOV R0,R3			; numerator
 SWI XZapRedraw_Divide ; BL div_mod
 MOV R3,R0			; DIV (line)
 MOV R6,R2			; MOD (pix off)
 LDMFD R13!,{R1-R2,PC}

;E R3=xpix R8
;X R3=xcol R6=xoff |

ccd_xpix_xpair
 LDR R0,[R8,#w_rw]
 TEQ R0,#8
 ANDEQ R6,R3,#7
 MOVEQ R3,R3,LSR#3
 MOVEQ PC,R14
 STMFD R13!,{R1-R2,R14}
 MOV R1,R0			; denominator
 MOV R0,R3			; numerator
 SWI XZapRedraw_Divide ; BL div_mod
 MOV R3,R0			; DIV (line)
 MOV R6,R2			; MOD (pix off)
 LDMFD R13!,{R1-R2,PC}

;E R2/R3=xycol R8
;X R2/R3=xyos |

ccd_xyline_xyos
 LDR R0,[R8,#w_rw]
 TEQ R0,#8
 MOVEQ R2,R2,LSL#3
 MULNE R2,R0,R2
 FNLDR R0,scn_magx
 MOVS R2,R2,LSL R0		; convert x to work os
 FNLDR R2,wimp_leftgap,EQ	; DS fix.
 RSBEQ R2,R2,#0			; DS fix.
 LDR R0,[R8,#w_rl]
 TEQ R0,#8
 MOVEQ R3,R3,LSL#3
 MULNE R3,R0,R3			; convert y to pix
 FNLDR R0,scn_magy
 MOV R3,R3,LSL R0
 RSB R3,R3,#0			; convert y pix to work os
; CMP R2,#4			; TT fix.
; MOVGT PC,R14
; FNLDR R2,wimp_leftgap		; TT fix.
; RSB R2,R2,#0			; TT fix.
 MOV PC,R14

;E R2/R3=xycol R8
;X R2/R3=xypix |

ccd_xyline_xypix
 LDR R0,[R8,#w_rw]
 TEQ R0,#8
 MOVEQ R2,R2,LSL#3
 MULNE R2,R0,R2
 LDR R0,[R8,#w_rl]
 TEQ R0,#8
 MOVEQ R3,R3,LSL#3
 MULNE R3,R0,R3			; convert y to pix
 MOV PC,R14

;E R3=yline R8
;X R3=yos |

ccd_yline_yos
 LDR R0,[R8,#w_rl]
 TEQ R0,#8
 MOVEQ R3,R3,LSL#3
 MULNE R3,R0,R3
 FNLDR R0,scn_magy
 MOV R3,R3,LSL R0
 RSB R3,R3,#0
 MOV PC,R14

;E R3=yline R6=yrast R8
;X R3=yos |

ccd_ypair_yos
 LDR R0,[R8,#w_rl]
 TEQ R0,#8
 ADDEQ R3,R6,R3,LSL#3
 MLANE R3,R0,R3,R6		; include raster offset
 FNLDR R0,scn_magy
 MOV R3,R3,LSL R0
 RSB R3,R3,#0
 MOV PC,R14

;E R3=xline R6=xrast R8
;X R3=xos |

ccd_xpair_xos
 LDR R0,[R8,#w_rw]
 TEQ R0,#8
 ADDEQ R3,R6,R3,LSL#3
 MLANE R3,R0,R3,R6		; include raster offset
 FNLDR R0,scn_magx
 MOV R3,R3,LSL R0
 CMP R3,#0			; TT fix.
 FNLDR R3,wimp_leftgap,LE	; TT fix.
 RSBLE R3,R3,#0			; TT fix.
 MOV PC,R14

;E R3=yline R6=yrast R8
;X R3=ypix |

ccd_ypair_ypix
 LDR R0,[R8,#w_rl]
 TEQ R0,#8
 ADDEQ R3,R6,R3,LSL#3
 MLANE R3,R0,R3,R6		; include raster offset
 MOV PC,R14

;E R3=xline R6=xrast
;X R3=xpix |

ccd_xpair_xpix
 LDR R0,[R8,#w_rw]
 TEQ R0,#8
 ADDEQ R3,R6,R3,LSL#3
 MLANE R3,R0,R3,R6		; include raster offset
 MOV PC,R14

;E R11=window block R8 (y window edge in work area)
;X R3=min y line R5=max y line R6=min y rast R7=max y rast |

ccd_blk_yrow
 FNJSR
 FNLDR R0,scn_magy
 LDR R7,[R11,#w_scrolly]		; scroll offset (min y line work)
 LDR R3,[R11,#8]		; min y os (+ve usually)
 LDR R5,[R11,#16]		; max y os (+ve usually)
 RSB R7,R7,#0
 MOV R7,R7,ASR R0		; scroll pix offset
 MOV R3,R3,ASR R0		; min scn y pix (from bot of scn)
 MOV R5,R5,ASR R0		; max scn y pix (from bot of scn)
 SUBS R3,R5,R3			; height in pix
 MOVMI R3,#0			; none
 ADD R3,R7,R3			; end work pix
 BL ccd_ypix_ypair
 MOV R5,R3
 MOV R3,R7
 MOV R7,R6
 BL ccd_ypix_ypair		; convert to line/offsets
 FNRTS

;E R11=window block R8 (y visible edge in work area)
;X R3=min y line R5=max y line R6=min y rast R7=max y rast |

ccd_blk_yrow_vis
 FNJSR
 FNLDR R0,scn_magy
 LDR R7,[R11,#24]		; scroll offset (min y line work)
 LDR R3,[R11,#8]		; min y os (+ve usually)
 LDR R5,[R11,#16]		; max y os (+ve usually)
 RSB R7,R7,#0
 MOV R7,R7,ASR R0		; scroll pix offset
 MOV R3,R3,ASR R0		; min scn y pix (from bot of scn)
 MOV R5,R5,ASR R0		; max scn y pix (from bot of scn)
 FNLDR R14,scn_yos
 MOV R14,R14,ASR R0		; screen height in pixels
 CMP R3,#0
 MOVMI R3,#0			; clip at bottom of screen
 SUBS R0,R5,R14			; amount off the top of the screen
 ADDGT R7,R7,R0			; add this to the scroll offset
 MOVGT R5,R14			; clip at top of screen
 SUBS R3,R5,R3			; height in pix
 MOVMI R3,#0			; none
 ADD R3,R7,R3			; end work pix
 BL ccd_ypix_ypair
 MOV R5,R3
 MOV R3,R7
 MOV R7,R6
 BL ccd_ypix_ypair		; convert to line/offsets
 FNRTS

;E R11=window block R8 (find x window edged in work area)
;X R3=min x line R5=max x line R6=min x rast R7=max x rast |

ccd_blk_xrow
 FNJSR
 FNLDR R0,scn_magx
 LDR R7,[R11,#20]		; scroll offset (min x work)
 LDR R3,[R11,#4]		; min x os
 CMP R3,#0			; new...
 MOVMI R3,#0
 CMP R7,#0
 MOVMI R7,#0			; new TT
 LDR R5,[R11,#12]		; max x os
 MOV R7,R7,ASR R0		; scroll pix offset
 MOV R3,R3,ASR R0		; min x pix
 MOV R5,R5,ASR R0		; max x pix
 SUBS R5,R5,R3			; width in pix
 MOVMI R5,#0
 ADD R3,R7,R5			; end work pix
 BL ccd_xpix_xpair
 MOV R5,R3
 MOV R3,R7
 MOV R7,R6
 BL ccd_xpix_xpair		; convert to line/offsets
 FNRTS

;E R11=window block R8 (find visible edges in work area)
;X R3=min x line R5=max x line R6=min x rast R7=max x rast |

ccd_blk_xrow_vis
 FNJSR
 FNLDR R0,scn_magx
 LDR R7,[R11,#20]		; scroll offset (min x work)
 LDR R3,[R11,#4]		; min x os
 LDR R5,[R11,#12]		; max x os
 MOV R7,R7,ASR R0		; scroll pix offset
 MOV R3,R3,ASR R0		; min x pix
 MOV R5,R5,ASR R0		; max x pix
 FNLDR R14,scn_xos
 MOV R14,R14,ASR R0
 CMP R5,R14
 MOVGT R5,R14			; clip to screen border
 SUBS R5,R5,R3			; width in pix
 MOVMI R5,#0
 ADD R3,R7,R5			; end work pix
 BL ccd_xpix_xpair
 MOV R5,R3
 MOV R3,R7
 MOV R7,R6
 BL ccd_xpix_xpair		; convert to line/offsets
 FNRTS

;E R2/R3=xypix
;X R2/R3=xyos |

ccd_xypix_xyos
 FNLDR R0,scn_magx
 MOV R2,R2,LSL R0
 FNLDR R0,scn_magy
 MOV R3,R3,LSL R0
 RSB R3,R3,#0
 CMP R2,#0			; TT fix.?
 FNLDR R2,wimp_leftgap,EQ	; TT fix.?
 RSBEQ R2,R2,#0			; TT fix.?
 MOV PC,R14

;E R8
;X R2=work max x os R3=work min y os |

ccd_workxy
 FNJSR
 LDR R2,[R8,#w_width]
 LDR R3,[R8,#w_height]
 FNLDR R0,wimp_bottomgap	; number of lines gap at bottom
 ADD R3,R3,R0
 BL ccd_xyline_xyos		; get width/height in os
 FNLDR R0,wimp_rightgap
 ;FNLDR R0,wimp_leftgap		; not needed...
 ;ADD R2,R2,R0			; add side pixels
 ADD R2,R2,R0			; add side pixels
 FNLDR R0,scn_yos		; height in screen in os pixels
 CMN R3,R0			; cmp R3 with -R0
 RSBGT R3,R0,#0			; if R3>-R0 then R3=-R0 (ie clip to screen)
 FNRTS

;E R11=window block R8 (find visible edges in work area)
;X R3=min x line R5=max x line R6=min x rast R7=max x rast |

ccd_blk_xrow_vis_margin
 FNJSR
 FNLDR R0,scn_magx
 LDR R3,[R11,#4]		; min x os
 LDR R5,[R11,#12]		; max x os
 LDR R7,[R11,#w_scrollx]	; scroll offset (min x work)
 CMP R7,#0
 SUBMI R3,R3,R7 ; MOVMI R3,#0
 FNLDR R14,wimp_leftgap		; TT fix.
 ADD R3,R3,R14
 ADD R5,R5,R14
 ADD R7,R7,R14
 MOV R7,R7,ASR R0		; scroll pix offset
 MOV R3,R3,ASR R0		; min x pix
 MOV R5,R5,ASR R0		; max x pix
 FNLDR R14,scn_xos
 MOV R14,R14,ASR R0
 ;CMP R3,#0
 ;SUBMI R7,R7,R3		; add onto scroll offset
 ;MOVMI R3,#0			; and zero vis offset
 CMP R5,R14
 MOVGT R5,R14			; clip to screen border
 SUBS R5,R5,R3			; width in pix
 MOVMI R5,#0
 ADD R3,R7,R5			; end work pix
 BL ccd_xpix_xpair
 MOV R5,R3
 MOV R3,R7
 MOV R7,R6
 BL ccd_xpix_xpair		; convert to line/offsets
 CMP R3,#0
 MOVMI R3,#0
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INVERT CARET						       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=first unused red_data offset R2-R3 redraw lines R8/R9
;X R1=new first unused offset #

invert_carets
 STMFD R13!,{R4,R10,R14}
 FNLDR R10,car_mode
 FNLDR R4,opt_cursor
 ADD R10,R10,#2
 CMP R10,#8
 ADDCC PC,PC,R10,LSL#2
 LDMFD R13!,{R4,R10,PC}		; out of range
 LDMFD R13!,{R4,R10,PC}		; mode -2 don't draw any
 B inv_car_point		; mode -1 draw point only
 B inv_car_point		; mode 0 draw point only
 B inv_car_1			; mode 1
 B inv_car_2			; mode 2
 LDMFD R13!,{R4,R10,PC}		; mode 3
 LDMFD R13!,{R4,R10,PC}		; mode 4
 B inv_car_5			; mode 5

inv_car_1
 FNLDR R10,car_cursor
 BL test_cblk
 BNE inv_car_point
 BL invert_caret
 LDMFD R13!,{R4,R10,PC}

inv_car_2
 MOV R4,R4,ROR#16		; get split 2 type
 FNLDR R10,car_cursor
 BL test_cblk
 BLEQ test_then_invert_caret	; draw if in window
 LDMVSFD R13!,{R4,R10,PC}
 MOV R4,R4,ROR#16		; restore
 FNLDR R10,car_input
 BL test_cblk
 BNE inv_car_point		; input not in this window
 MOV R4,R4,LSR#8
 BL invert_caret		; split 1 caret
 LDMFD R13!,{R4,R10,PC}

inv_car_5
 FNLDR R10,car_input
 BL test_cblk
 BLEQ invert_caret
 LDMFD R13!,{R4,R10,PC}

inv_car_point
 MOV R4,R4,LSR#24		; get left type
 ADD R10,R8,#w_pwind
 BL invert_caret
 LDMFD R13!,{R4,R10,PC}

test_then_invert_caret
 FNJSR
 LDR R14,[R8,#w_pwind]
 LDR R0,[R10,#c_wind]
 CMP R0,R14
 BNE ok$l
 LDR R14,[R8,#w_poff]
 LDR R0,[R10,#c_off]
 CMP R0,R14
; FNRTS EQ
ok$l
 BLNE invert_caret
 FNRTS

;E R1=first unused r_data offset R2-R3 redraw lines
;  R4=cursor type in bits 0-7
;  R8/R9 R10=caret block for caret to draw
;X R1=new first unused offset & caret inserted into redraw data #

invert_caret
 AND R0,R4,#&FF			; cursor type
 TEQ R0,#4
 MOVEQ PC,R14			; type 4=none
 LDR R0,[R10,#c_line]
 CMP R0,R3
 MOVGE PC,R14			; off screen top
 SUBS R0,R0,R2			; offset from first line
 MOVMI PC,R14			; off screen bottom
 STMFD R13!,{R2-R11,R14}
 FNLDR R11,red_data
 FNLDR R7,red_datasize
 ADD R6,R11,R1			; set up buffer pointers
 LDR R5,[R11,R0,LSL#2]		; offset for first line
 STR R1,[R11,R0,LSL#2]		; new offset
 MVN R0,#0
 ADD R1,R11,R5			; address of first line
 SUB R9,R1,#2			; save start-2
 PUSH "R4"
 SWI XZapRedraw_FindCharacter	; corrupts R2/R3 (...and R4...?)
 PULL "R4"
 LDMVSFD R13!,{R2-R11,PC}
 SUB R0,R1,R9			; length of the line + 0,2 term
 LDR R3,[R10,#c_width]
 ADD R0,R0,R3,LSL#4		; amount we need spare
 LDR R2,[R10,#c_col]
	LDR	R14,[R8,#w_width]
	CMP	R2,R14
	MOVHI	R2,R14		; \/\/ display clipping
 ADD R0,R0,R2			; and incase line blank
 BL ensure_red_data
 LDMVSFD R13!,{R2-R11,PC}
 ADD R5,R11,R5			; source string
 BL get_caret_string		; set up R3/R4/R7
 LDMVSFD R13!,{R2-R11,PC}
 MOV R0,R6			; current pointer
 ADD R1,R12,#red_flags
 MOV R6,#4			; selection foreground
 SWI XZapRedraw_AddCursor
 LDMVSFD R13!,{R2-R11,PC}
 SUB R1,R0,R11			; new last used offset
 LDMFD R13!,{R2-R11,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the cursor string (dependent on length)		    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R4=b0-b8=caret type (0-4) R3=cursor length
;X R7=colour+high byte and R4=r_workarea contains the string #
;  R3>=1 updated length of caret

get_caret_string
 STMFD R13!,{R1-R2,R14}
 MOV R0,R3
 BL ensure_workarea
 LDMVSFD R13!,{R1-R2,PC}
 MOV R2,R3			; copy length
 AND R0,R4,#&FF			; get type
 FNLDR R4,red_workarea
 MOV R1,R4			; copy dest
 MOV R7,#6<<16		; for
 ORR R7,R7,#5<<24		; bac
 ORR R7,R7,#8<<8		; use control code 8
 CMP R0,#(gc_end-gc_start)/4
 ADDCC PC,PC,R0,LSL#2
 LDMFD R13!,{R1-R2,PC}
gc_start
 B get_caret_0
 B get_caret_1
 B get_caret_2
 B get_caret_3
 B get_caret_4
gc_end

get_caret_0
 MOV R0,#&7F
get_caret_00
 STRB R0,[R1],#1
 SUBS R2,R2,#1
 BGT get_caret_00
 LDMFD R13!,{R1-R2,PC}

get_caret_1
 ORR R7,R7,#1
 SUBS R2,R2,#2			; length - ends
 MOVMI R0,#3
 STRMIB R0,[R1]
 LDMMIFD R13!,{R1-R2,PC}
 MOV R0,#0
 STRB R0,[R1],#1		; left end
 MOV R0,#2
 STRB R0,[R1,R2]		; right end
 MOV R0,#1
 BGT get_caret_00
 LDMFD R13!,{R1-R2,PC}

get_caret_2
 ORR R7,R7,#1
 MOV R0,#4
 B get_caret_00

get_caret_3
 ORR R7,R7,#1
 MOV R0,#5
 STRB R0,[R1]
 MOV R3,#1
 LDMFD R13!,{R1-R2,PC}

get_caret_4
 MOV R3,#1			; not there
 LDMFD R13!,{R1-R2,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create redraw data in new format			    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=start of cached data (within file) / 0 if all outside
;  R2=start line R3=end line(+1) clipped to file
;  R8/R9
;X red_data updated to hold new format text #
;  R1=first free offset in r_data buffer
;  R0=largest character used

create_redraw_data
 STMFD R13!,{R2-R11,R14}
 SUB R10,R3,R2			; number of lines to do
 ADD R10,R10,#1			; add terminating offset
; MOV R7,R0			; data to start with
 MOV R2,R0			; data to start with
 LDR R5,[R8,#w_txtw]		; width of text bit of cache line
 FNLDR R7,red_datasize		; length of it
 FNLDR R11,red_data		; start of red_data
 MOV R6,R11			; current pointer in red_data
 MOV R0,R10,LSL#2		; number of bytes for offsets
 BL ensure_red_data
 BVS error$l
 ADD R6,R6,R10,LSL#2		; move to start of area to redraw
 MOV R4,#0			; number of current line
 ;ADD R3,R5,R5,LSL#1		; R3=3*R5 ; length of 1 cache 'line'
 MOV R3,R5,LSL #2
 MOV R3,R3,LSL#1		; R3=6*R5
 ADD R1,R12,#red_flags		; redraw block
 MOV R9,#&20			; largest character
 SUBS R10,R10,#1
 BLE cr18			; subtract the terminating line
cr17
 SUB R0,R6,R11			; current offset
 STR R0,[R11,R4,LSL#2]		; save offset of line
 ADD R0,R3,#16			; need 6*R5+16 bytes free
 BL ensure_red_data		; make sure enough room free
 BVS error$l
 STMFD R13!,{R3-R5,R7}
 MOV R0,#8			; colour for ctrl chars
 ADD R3,R2,R5
 ADD R4,R3,R5
; PUSH "R7"
 ADD R7,R4,R5
 ;
 LDR R14,[R8,#w_info]		; for enable ss bit
 TST R14,#bit_nosubstyles
 FNLDR R14,red_flags
 BICNE R14,R14,#8
 ORREQ R14,R14,#8
 FNSTR R14,red_flags
; ORR R14,R14,#8
; FNSTR R14,red_flags
 ;
 LDR R14,[R7]
 CMN R14,#1			;flag to say no special font data.
 MOVEQ R7,R3
 SWI XZapRedraw_PrepareDataLine
; PULL "R7"
 CMP R0,R9
 MOVCS R9,R0			; new largest character
 ADD R6,R6,R5			; new buffer position
 LDMFD R13!,{R3-R5,R7}
 BVS error$l
 ADD R2,R2,R3,LSR#1		; all 3*R5 to get to next line
 ADD R4,R4,#1			; increment line number
 CMP R4,R10
 BCC cr17
cr18
 MOV R0,#0
 STR R0,[R11,R4,LSL#2]		; add terminating 0
 SUB R1,R6,R11			; first free offset
; MOV R1,#14
; MOV R11,#e_init
; BL call_mode
; MOV R1,R6
 MOV R0,R9			; largest character
 LDMFD R13!,{R2-R11,PC}

error$l
 MOV R7,R0
 MOV R1,#14
 MOV R11,#e_init
 BL call_mode
 MOV R0,R7
 FNRTV

 LOCAL

; ;E R2,R3 buffers - R5 size of these...
; ;X address of font data in R7  Data in R3 buffer 'cleaned' based on R4=4
;
; clean_selection_for_fonts
;  FNJSR "R0,R5"
;  FNLDR R7,wimp_data
;  MOV R0,#4
; loop$l
;  SUBS R5,R5,#1
;  FNRTS MI
;  LDRB R14,[R3,R5]
;  STRB R14,[R7,R5]
;  LDRB R14,[R4,R5]
;  CMP R14,#3
;  STREQB R0,[R3,R5]
;  B loop$l
; ; MOV R2,R7
; ; MOV R1,R3
; ; MOV R3,R5
; ; BL move_bytes
; ; ;MOV R7,R3			; faked up font data...
; ; FNRTS
;
;  LOCAL

;E R11=red_data R6=current pointer in red_data block
;  R7=red_datasize R0=amount must have free
;X amount ensured (R6/R7/R11 may change) #

ensure_red_data
 ADD R0,R6,R0			; new end
 SUB R0,R0,R11			; new length
 CMP R0,R7
 MOVLE PC,R14			; already claimed
 STMFD R13!,{R1,R14}
 MOV R1,R0			; amount to claim
 SUB R7,R6,R11			; save offset in block
 MOV R0,R11
 BL heap_ensure
 LDMVSFD R13!,{R1,PC}
 FNSTR R0,red_data		; new block pointer
 FNSTR R1,red_datasize		; new length
 MOV R11,R0
 ADD R6,R11,R7
 MOV R7,R1
 LDMFD R13!,{R1,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; UPDATE CACHE							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R2=start line R3=end line(+1) R8/R9
;  First line should be within the file but the last line may
;  be off the end. Blank lines will be added.
;X Lines within the file cached
;  R0=start of cached data (or 0 if first line was off end)
;  R1-R7 & R10-R11 corrupted #

update_cache
 STMFD R13!,{R1-R11,R14}
 LDR R11,[R8,#w_height]		; number of lines in file
 LDR R4,[R8,#w_cline]		; line num of first cached line
 LDR R5,[R8,#w_txtn]		; number of lines cached
 SUB R10,R3,R2			; number of lines to cache
 LDR R1,[R8,#w_txth]		; find number of lines in cache
 CMP R10,R1			; is cache too small?
 BLS update_c0			; if ok then continue
 LDR R0,[R8,#w_txtlen]		; width of cache lines
 MUL R1,R0,R10			; size cache needs to be
 LDR R0,[R8,#w_txt]
 BL heap_ensure			; ensure cache big enough
 LDMVSFD R13!,{R1-R11,PC}
 STR R0,[R8,#w_txt]		; note need NOT mark cache invalid as heap
 STR R10,[R8,#w_txth]		; manager copies data
update_c0
 TEQ R2,R3
 LDMEQFD R13!,{R1-R11,PC}
 CMP R2,R11			; is first line off end of file
 BCS update_c6			; 'error'
 ADD R5,R4,R5			; line number of last cached line (+1)
 TEQ R4,R5
 BEQ update_c4
 CMP R4,R3
 BCS update_c4
 CMP R2,R5
 BCS update_c4
 CMP R2,R4
 BCC update_c2
 CMP R5,R3
 BCC update_c1
 SUB R0,R2,R4			; offset in cache (data already there)
 LDR R1,[R8,#w_txt]
 LDR R2,[R8,#w_txtlen]
 MLA R0,R2,R0,R1
 LDMFD R13!,{R1-R11,PC}
update_c1
 SUB R10,R5,R2
 SUB R6,R2,R4
 MOV R7,#0
 BL move_cache_lines
 SUB R10,R3,R5
 MOV R7,R5
 SUB R6,R5,R2
 BL red_cache_lines
 LDMVSFD R13!,{R1-R11,PC}
 MOV R0,R2
 BL cln_phy
 LDMVSFD R13!,{R1-R11,PC}
 B update_c5
update_c2
 CMP R5,R3
 BCS update_c3
 SUB R10,R5,R4
 MOV R6,#0
 SUB R7,R4,R2
 BL move_cache_lines
 SUB R10,R3,R5
 MOV R7,R5
 SUB R6,R5,R2
 BL red_cache_lines
 LDMVSFD R13!,{R1-R11,PC}
 SUB R10,R4,R2
 MOV R7,R2
 MOV R6,#0
 BL red_cache_lines
 LDMVSFD R13!,{R1-R11,PC}
 B update_c5
update_c3
 SUB R10,R3,R4
 MOV R6,#0
 SUB R7,R4,R2
 BL move_cache_lines
 SUB R10,R4,R2
 MOV R7,R2
 MOV R6,#0
 BL red_cache_lines
 LDMVSFD R13!,{R1-R11,PC}
 B update_c5
update_c4
 SUB R10,R3,R2
 MOV R7,R2
 MOV R6,#0
 BL red_cache_lines
 LDMVSFD R13!,{R1-R11,PC}
update_c5
 LDR R14,[R9,#f_len]
 CMP R0,R14
 BCS update_c7
 STR R0,[R8,#w_coff]		; save file offset
 STR R1,[R8,#w_clogl]		; save log ln
 SUB R0,R3,R2			; number of lines cached
 STR R0,[R8,#w_txtn]
 STR R2,[R8,#w_cline]		; line number of first cached line
 LDR R0,[R8,#w_txt]
 LDMFD R13!,{R1-R11,PC}
update_c6
 MOV R0,#0			; first line off end
 LDMFD R13!,{R1-R11,PC}
update_c7
 MOV R0,#0
 STR R0,[R8,#w_txtn]		; preserve old cached point
 LDR R0,[R8,#w_txt]
 LDMFD R13!,{R1-R11,PC}

;E R6=source cache line R7=dest cache line R8/R9 R10=num of lines to move
;X R2-R5 & R8-R9 saved and cache lines moved

move_cache_lines
 TEQ R6,R7
 TEQNE R10,#0
 MOVEQ PC,R14
 LDR R11,[R8,#w_txtlen]
 LDR R0,[R8,#w_txt]
 MLA R6,R11,R6,R0
 MLA R7,R11,R7,R0
 MUL R10,R11,R10
 CMP R6,R7
 BCC move_cache_down
move_cache_up
 LDMIA R6!,{R0,R1}
 STMIA R7!,{R0,R1}
 SUBS R10,R10,#8
 BHI move_cache_up
 MOV PC,R14
move_cache_down
 ADD R6,R6,R10
 ADD R7,R7,R10
move_cache_d0
 LDMDB R6!,{R0,R1}
 STMDB R7!,{R0,R1}
 SUBS R10,R10,#8
 BHI move_cache_d0
 MOV PC,R14

; X no more cache
blat_redraw_cache
 FNJSR
 MOV R2,#0
 MOV R3,#0
 BL update_cache		; saves R8/R9 R0=cached data
 FNRTS


;E R6=cache loff R7=file loff R8/R9 R10 num of line
;X R0=file off/R1=log ln of first line. R2-R5,R8-R9 saved

red_cache_lines
 FNJSR "R2-R5"
 MOV R0,R7			; phy ln of first line
 BL cln_phy			; file offset & log ln of first line
 FNRTS VS
 MOV R3,R0			; save file offset
 MOV R5,R1			; save log ln
 TEQ R10,#0
 FNRTS EQ			; return if no lines to draw
 ADD R4,R7,R10			; phy ln of final line
 MOV R10,R7			; phy ln of first line
 STMFD R13!,{R3,R5}		; save off/log of first line
 MOV R1,#13
 MOV R2,R7
 MOV R3,R4
 BL calle_init			; e_init 13 (as described in the docs)
 MOV R11,R5			; log ln of first line
 MOV R7,R0			; offset in file of first line
 LDR R2,[R8,#w_txtlen]		; byte width of cache lines
 LDR R0,[R8,#w_txt]
 MLA R6,R2,R6,R0		; address of line in cache
 MOV R3,#0
 STR R3,local_ss_info_word
 MVN R5,#0			; region lines
 FNLDR R1,car_selection		; selection caret
 BL get_wind_off
 LDR R14,[R1,#c_wind]		; window with caret
 TEQ R14,R0
 BNE red_cl_l0			; selection not in this window
 LDR R3,[R1,#c_line]
 LDR R5,[R1,#c_oline]		; get start and end
 CMP R3,R5
 MOVGT R0,R5
 MOVGT R5,R3
 MOVGT R3,R0			; ensure R3<=R5
red_cl_l0
 BL redraw_cache_line		; redraw the line
 BVS red_cl_11
 BL generate_cache_font_data	; ...

 LDR R14,local_ss_info_word
 CMP R14,#2
 LDR R14,[R8,#w_info]		; for enable ss bit
 BICCS R14,R14,#bit_nosubstyles
; ORRCC R14,R14,#bit_nosubstyles
 STR R14,[R8,#w_info]		; for enable ss bit

 CMP R10,R3
 BLT red_cl_12			; before the region start
 CMP R10,R5
 BLLE redraw_cache_selection	; it's in the selected region
 BVS red_cl_11
red_cl_12
 ADD R6,R6,R2			; move onto next cache line
 ADD R10,R10,#1			; move onto next phy line
 CMP R10,R4			; reached end line?
 BCC red_cl_l0			; do next line if not
; LDMFD R13!,{R3,R5}		; pull back off/log
; MOV R0,R3			; file offset of first line drawn
; MOV R1,R5			; log ln of this line
 MOV R1,#14
 BL calle_init			; e_init 14 (as described in docs)
 LDR R0,local_ss_info_word
; TEQ R0,#0
 BL setup_fontmc_with_extras	; slow and maybe not even needed :-)
; BLVC setup_multiple_fonts
 STRVS R0,[R13]
 LDMFD R13!,{R0,R1}
 FNRTS
red_cl_11
 STR R0,[R13,#4]!
 MOV R1,#14
 BL calle_init			; e_init 14 (as described in docs)
 LDR R0,local_ss_info_word
 BL setup_fontmc_with_extras
; BLVC setup_multiple_fonts
 ADDVS R13,R13,#4
 LDRVC R0,[R13],#4
 FNRTV				; escape

local_ss_info_word
 & 0

generate_cache_font_data
 FNJSR "R0,R11"
 MOV R0,#11
 MOV R11,#e_interrogate
 BL call_mode
 BL call_cache_font_data
 FNRTS
call_cache_font_data
 CMP R0,#2
 ADDLO PC,PC,R0,LSL #2
 B perform_block_copy
 B fg_and_bg_hijacked
 B fg_and_bg_hijacked_with_style_info

 ;CMP R10,R3
 ;BLT red_skipfdata		; before the region start
 ;CMP R10,R5
 ;BGT red_skipfdata		; it's in the selected region

; \E R6 = ? R3 = ?
perform_block_copy
 FNJSR "R1-R3,R5-R7"
; LDR R3,[R8,#w_txtw]
; ADD R1,R6,R3
; ADD R2,R1,R3,LSL#1
; BL move_bytes			; the good old days...
 LDR R3,[R8,#w_txtw]
 ADD R1,R6,R3			; R1 = fg colours.
 ADD R2,R1,R3,LSL#1		; R2 = font data.
 SUB R3,R3,#1
 BL get_mode_colours_ptr
 LDR R14,local_ss_info_word
looping$l			; unravel?
 LDRB R5,[R1,R3]		; colour data...
 CMP R5,R6,LSR #2		; /should/ always be true...? danger
 LDRLOB R5,[R7,R5,LSL #2]	; FONT DATA!!!! - LO for safety...
; LDRB R5,[R7,R5,LSL #2]
 STRB R5,[R2,R3]

 ORR R5,R5,R5,LSL #8
 AND R5,R5,#&1E0
 MOV R5,R5,LSR #5
 MOV R0,#1
 ORR R14,R14,R0,LSL R5

 SUBS R3,R3,#1
 BPL looping$l
 STR R14,local_ss_info_word
 FNRTS

;red_skipfdata
; FNJSR "R0-R1"
; LDR R0,[R8,#w_txtw]
; ADD R1,R6,R0
; MOV R14,#-1
; STR R14,[R1,R0,LSL#1]
; FNRTS

 LOCAL

fg_and_bg_hijacked
 FNJSR "R0-R7"
 LDR R3,[R8,#w_txtw]
 ADD R4,R6,R3			; fg
 ADD R1,R4,R3			; bg
 ADD R2,R1,R3			; dest
 SUB R3,R3,#1
 BL get_mode_colours_ptr
 LDR R14,local_ss_info_word
loop$l
 LDRB R0,[R4,R3]		;
 MOV R5,#0
 CMP R0,R6,LSR #2
 LDRLOB R5,[R7,R0,LSL #2]	;
 LDRB R0,[R1,R3]
 CMP R0,#9
 MVNLO R0,#0
 CMP R0,R6,LSR #2
 LDRLOB R0,[R7,R0,LSL #2]	;
 ORRLO R5,R5,R0
 STRB R5,[R2,R3]		;
 ORR R5,R5,R5,LSL #8
 AND R5,R5,#&1E0
 MOV R5,R5,LSR #5
 MOV R0,#1
 ORR R14,R14,R0,LSL R5
 SUBS R3,R3,#1
 BPL loop$l
 STR R14,local_ss_info_word
 FNRTS

 LOCAL

fg_and_bg_hijacked_with_style_info
 FNJSR "R0-R7"
 LDR R3,[R8,#w_txtw]
 ADD R4,R6,R3			; fg
 ADD R1,R4,R3			; bg
 ADD R2,R1,R3			; dest
 SUB R3,R3,#1
 BL get_mode_colours_ptr
 LDR R14,local_ss_info_word
loop$l
 LDRB R5,[R2,R3]
 LDRB R0,[R4,R3]
 CMP R0,R6,LSR #2
 LDRLOB R0,[R7,R0,LSL #2]
 ORRLO R5,R5,R0
 LDRB R0,[R1,R3]
 CMP R0,#9
 MVNLO R0,#0
 CMP R0,R6,LSR #2
 LDRLOB R0,[R7,R0,LSL #2]
 ORRLO R5,R5,R0
 STRB R5,[R2,R3]
 ORR R5,R5,R5,LSL #8
 AND R5,R5,#&1E0
 MOV R5,R5,LSR #5
 MOV R0,#1
 ORR R14,R14,R0,LSL R5
 SUBS R3,R3,#1
 BPL loop$l
 STR R14,local_ss_info_word
 FNRTS

;X R6=number of colours
;  R7=pointer to colours
get_mode_colours_ptr
 FNJSR
 LDR R6,[R8,#w_modedata]
 LDRB R7,[R8,#w_format]
 LDR R7,[R6,R7,LSL #2]		; pointer to data for this mode
 LDR R6,[R7],#4			; length word
 MOV R14,R6,LSR #24
 ADD R7,R7,R14,LSL #2
 BIC R6,R6,#&FF000000		; total block length
 SUB R6,R6,R14,LSL #2		; colour data length
 SUB R6,R6,#4
 FNRTS

 LOCAL

;Internal R11=log line number		R10=end of current buffer
;	  R7=address in buffer		R6=addr in cache line
;	  R5=apparant start of file
;E R6=cache addr R7=file off R8/R9 R10=phy ln R11=log ln
;X R7/R11 updated to start of next phy line. R2-R6,R8-R10 saved

redraw_cache_line
 FNJSR "R2-R6,R10"
 BL print_blank			; fill line with spaces
 LDR R0,[R8,#w_height]		; height of work area
 CMP R10,R0			; is this line off end of file
 FNRTS CS			; return if so
; MOV R1,#13
; BL calle_init			; [old broken call to e_init 13]
 LDR R5,[R8,#w_format]		; line format
 TST R5,#format_ShowLineNumbers
 BEQ re1			; if not then re1
 BL get_linenumber
 BCS re1			; none to draw
 TST R5,#1<<10			; hex or decimal
 BEQ print_decimal
 BNE print_hex
re1
 MOV R4,R5			; full draw type
 LDR R0,[R8,#w_margin]
 ADD R6,R6,R0			; add in margin
 LDR R5,[R9,#f_ptr]		; start of file
 LDR R0,[R9,#f_splito]		; offset of split
 CMP R7,R0
 ADDCC R10,R5,R0		; end of first half of buffer
 LDRCS R1,[R9,#f_bufl]
 ADDCS R10,R5,R1		; end of second half of buffer
 LDRCS R1,[R9,#f_splits]
 ADDCS R5,R5,R1			; inc aparant start of file
 ADD R7,R5,R7			; address of next byte
 AND R1,R4,#&FF			; draw mode
 ADD R0,R12,#(mode_store+4):AND:&FF00
 ADD R0,R0, #(mode_store+4):AND:&00FF; start of list+4
 LDR R0,[R0,R1,LSL#3]		; dispatch table
 LDR R14,[R8,#w_format]
 TST R14,#1 << 27
 BNE sw_redrawline
 MOVS R14,PC
 LDR PC,[R0,#2*e_redrawline]	; call the redraw line sub
 SUB R7,R7,R5			; file offset
; MOV R1,#14
; BL calle_init			; [old broken call to e_init 14]
 FNRTS

sw_redrawline
 STMFD R13!,{R1-R11}
 MOVS R14,PC
 LDR PC,[R0,#2*e_redrawline]	; call the redraw line sub
 LDMFD R13!,{R1-R11}
 BL modesw_redrawline
 SUBVC R7,R7,R5			; file offset

; MOVVC R1,#14
; BLVC calle_init		; [old broken call to e_init 14]
 FNRTS

;errorend$l
; MOV R1,#14
; BL calle_init
; FNRTV

calle_init
 FNJSR
 MOV R11,#e_init
 BL call_mode
 FNRTS

;E R5=w_format R7=phy line file offset R10=phy line R11=log line
;X R0=line number to show CC / CS if none

get_linenumber
 FNJSR
 TST R5,#1<<9
 BEQ ge13			; address
 TST R5,#1<<11			; log or phy line nos?
 BNE ge14			; phy
 AND R0,R5,#&FF			; draw mode
 ADD R1,R12,#(mode_store+4):AND:&FF00
 ADD R1,R1, #(mode_store+4):AND:&00FF; start of list+4
 LDR R1,[R1,R0,LSL#3]		; dispatch table
 MOVS R14,PC
 LDR PC,[R1,#2*e_redrawlnum]
 FNRTS CS			; no linenumber
 LDR R2,[R8,#w_stline]		; first line number
 ADD R0,R11,R2			; logical
 ADDS R0,R0,#0			; clc
 FNRTS				; and return
ge13
 LDR R2,[R8,#w_addr]
 ADD R0,R7,R2			; add start of file address
 ADDS R0,R0,#0			; clc
 FNRTS
ge14
 LDR R2,[R8,#w_stline]		; first line number
 ADD R0,R10,R2			; physical
 ADDS R0,R0,#0			; clc
 FNRTS				; and return

;E R0=line number R6=cache line
;X Hex number written R0-R4 corrupted

linenumberbuffer
 DCD 0
 DCD 0
 DCD 0

print_nulls
 AND R2,R14,#7
 LDR R14,[R8,#w_info]
 AND R0,R14,#7
 ADD R2,R2,#2
 TST R14,#8
 ADDNE R2,R2,#2
 MOV R14,#' '
looppnull$l
 STRB R14,[R6],#1
 SUBS R2,R2,#1
 BPL looppnull$l

print_hex
 PUSH "R6"
 ADR R6,linenumberbuffer
 BL hex8
 ADR R2,linenumberbuffer
 LDR R14,[R8,#w_info]
 AND R0,R14,#7
 PULLS "R6"
 ADD R2,R2,#7
 SUB R2,R2,R0
lnloop$l
 LDRB R1,[R2],#1
 STRB R1,[R6],#1
 SUBS R0,R0,#1
 BPL lnloop$l
 BL linenumbercolons		; add _;_
 PULL "R6"			; back to start
 LDR R14,[R8,#w_info]
 ANDS R14,R14,#&F
 MOVEQ R2,#'>'
 STREQB R2,[R6]
 AND R2,R14,#7
 ADD R2,R2,#2
 TST R14,#8
 ADDNE R2,R2,#2
 MOV R0,#7			; colour...
 MOV R1,#0
 BL colour_chars
 B re1

; As for print_hex

print_decimal
 PUSH "R6"
 MOV R10,R0			; save number
 LDR R14,[R8,#w_info]
 AND R14,R14,#7
 ADD R6,R6,R14
 ADD R6,R6,#1
 MOV R4,R6			; end of digits
 BL linenumbercolons		; add _;_
 PULLS "R6"
 MOVS R10,R10
 MOVPL R3,#0
 MOVMI R3,#'-'
 RSBMI R10,R10,#0
 BICMI R10,R10,#&800000
 BIC R10,R10,#&FF000000		; ensure line num in range
re3
 MOV R1,R10,LSL#8		; fixed point at bit 8
 MOV R2	  ,R1,LSR#4
 ADD R2,R2,R1,LSR#5
 ADD R2,R2,R1,LSR#8
 ADD R2,R2,R1,LSR#9
 ADD R2,R2,R1,LSR#12
 ADD R2,R2,R1,LSR#13
 ADD R2,R2,R1,LSR#16
 ADD R2,R2,R1,LSR#17
 ADD R2,R2,R1,LSR#20
 ADD R2,R2,R1,LSR#21
 ADD R2,R2,R1,LSR#24
 ADD R2,R2,R1,LSR#25
 ADD R2,R2,R1,LSR#28
 ADD R2,R2,R1,LSR#29		; divide by 10 (mult by 0.0001 1001 10..)
 AND R0,R2,#&FF			; get bottom bits
 MOVS R2,R2,LSR#8		; quotient
 CMP R0,#231
 ADDCS R2,R2,#1			; round up if needed
 ADD R1,R2,R2,LSL#2		; quot*5
 SUB R0,R10,R1,LSL#1		; R10-quot*10
 ADD R0,R0,#'0'
 CMP R4,R6
 BLE exitlinenumberloop
 STRB R0,[R4,#-1]!		; write digit
 MOVS R10,R2			; new quotient
 BNE re3			; loop if non zero
 CMP R4,R6
 BLE exitlinenumberloop
 TEQ R3,#0
 STRNEB R3,[R4,#-1]!		; add sign if needed
exitlinenumberloop
 PULL "R6"			; back to start
 LDR R14,[R8,#w_info]
 ANDS R14,R14,#&F
 MOVEQ R2,#'*'
 STREQB R2,[R6]
 AND R2,R14,#7
 ADD R2,R2,#2
 TST R14,#8
 ADDNE R2,R2,#2
 MOV R0,#7			; colour...
 MOV R1,#0
 BL colour_chars
 B re1

;E R0=colour R1=offset in cache line of first char
;  R2=num of chars to colour>0 R6=start of cache line R8
;X R0 preserved, R1 preserved, R2-R3 corrupted

colour_chars_both
 FNJSR "R1"
 LDR R14,[R8,#w_txtw]
 ADD R3,R6,R14			; start of the line
 ADD R3,R3,R1			; first char to colour
 ADD R14,R3,R14
 MOV R1,#1
co26a
 STRB R0,[R3],#1
 STRB R1,[R14],#1
 SUBS R2,R2,#1
 BGT co26a
 FNRTS

;E R0=colour R1=offset in cache line of first char
;  R2=num of chars to colour>0 R6=start of cache line R8
;X R0 preserved, R1 preserved, R2-R3 corrupted

colour_chars
 LDR R3,[R8,#w_txtw]
 ADD R3,R6,R3			; start of the line
 ADD R3,R3,R1			; first char to colour
co26
 STRB R0,[R3],#1
 SUBS R2,R2,#1
 BGT co26
 MOV PC,R14


;E R6=cache line
;X R0-R5 corrupted. Line blanked to spaces.
;  Foreground mask set to 2's, background to 0's.

print_blank
 LDR R4,[R8,#w_txtw]		; width (multiple of 8)
 MOV R3,R6			; start of cache line
 MOV R0,#&20
 ADD R0,R0,R0,LSL#8
 ADD R0,R0,R0,LSL#16		; 4 spaces
 MOV R1,R4			; count
 MOV R2,R0			; 4 spaces
re2
 STMIA R3!,{R0,R2}		; blank 8 chars
 SUBS R1,R1,#8
 BHI re2			; blank the line
 MOV R0,#2			; foreground mask
 ADD R0,R0,R0,LSL#8
 ADD R0,R0,R0,LSL#16
 MOV R1,R4			; count
 MOV R2,R0
re5
 STMIA R3!,{R0,R2}
 SUBS R1,R1,#8
 BHI re5
 MOV R0,#0			; background mask
 MOV R1,R4			; count
 MOV R2,R0
re6
 STMIA R3!,{R0,R2}
 SUBS R1,R1,#4			; do style buffer too...
; SUBS R1,R1,#8
 BHI re6
 MOV PC,R14			; return

red_overflow
 FNJSR
 LDR R0,[R9,#f_ptr]
 LDR R14,[R9,#f_bufl]
 ADD R0,R0,R14			; end of buffer
 CMP R10,R0
 BCS ov1			; end is off end of buffer=overflow
 MOV R10,R0			; end of second buffer
 LDR R0,[R9,#f_splits]		; split size
 ADD R5,R5,R0
 ADD R7,R7,R0			; move into second buffer
 CMP R7,R10			; is it off the end of the second buf
 FNRTS CC			; return if not
ov1
 FNRTV				; return with overflow

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Selection redraw					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R6=start of buffer
;  R8/S9
;  R10=line number currently on already in the selection
;X Selection coloured #

redraw_cache_selection
 STMFD R13!,{R1-R5,R14}
 FNLDR R1,car_selection
 LDR R2,[R1,#c_line]
 LDR R3,[R1,#c_oline]
 LDR R4,[R1,#c_col]
 LDR R5,[R1,#c_ocol]
 CMP R2,R3
 BGT rs10			; swap over
 BLT rs11			; finished
 CMP R4,R5
 BLE rs11
rs10
 MOV R0,R2
 MOV R2,R3
 MOV R3,R0
 MOV R0,R4
 MOV R4,R5
 MOV R5,R0
rs11
 LDR R1,[R8,#w_margin]
 CMP R4,R1
 MOVLE R4,#0
 CMP R5,R1
 MOVLE R5,#0			; pull to left hand edge
 LDR R1,[R8,#w_txtw]		; buffer width
 CMP R10,R2
 MOVGT R4,#0			; start col 0 if not first line
 CMP R10,R3
 MOVLT R5,R1			; end col if not last line
 SUBS R5,R5,R4			; num of chars to write
 LDMLEFD R13!,{R1-R5,PC}
 ADD R4,R6,R4			; first col
 ADD R2,R4,R1			; foreground mask
 ADD R3,R2,R1			; background mask
; ADD R4,R3,R1			; fonts...?!
 MOV R0,#4
 MOV R1,#3
rs12
 LDRB R14,[R2],#1		; fg colour
 TEQ R14,#8			; is it a 'fake' control character (-> tab)
 STRNEB R0,[R2,#-1]		; fg colour blatted

; LDRB R14,[R4],#1		; font
; TST R14,#8			; is it inverted?
; BICNE R14,R14,#8		; make sure it's not...
; STRNEB R14,[R4,#-1]

 STRB R1,[R3],#1		; bg colour blatted
 SUBS R5,R5,#1
 BGT rs12
 LDMFD R13!,{R1-R5,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; REDRAW LINE SUBS (PRINT HEX NUMBERS ETC)		    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

colons
 ADD R6,R6,#1
colon
 MOV R0,#':'
 STRB R0,[R6],#2
 MOV PC,R14

linenumbercolons
 ADD R6,R6,#1
 LDR R0,[R8,#w_info]
 TST R0,#8

 MOV R0,#':'
 STRNEB R0,[R6],#2
 MOV PC,R14

;E R1=window blk of area in chars (handle ...) R8/R9
;X the coords changed to os and area redrawn (using update window) #

update_area
 FNJSR "R1-R4"
 LDR R2,[R1,#4]			; xmin
 LDR R3,[R1,#8]			; ymin
 BL ccd_xyline_xyos
 STR R2,[R1,#4]			; new xmin
 MOV R14,R3			; new ymax
 LDR R2,[R1,#12]		; xmax
 LDR R3,[R8,#w_bpl]
 SUBS R3,R3,#1
 CMP R2,R3
 LDR R3,[R1,#16]		; ymax
 STR R14,[R1,#16]		; new ymax ...???
 MOVLO R4,#0
 FNLDR R4,wimp_rightgap,HS
 BL ccd_xyline_xyos
 ADD R2,R2,R4
 STR R2,[R1,#12]		; new xmax
 STR R3,[R1,#8]			; new ymin
 BL update_window		; update window
; SWIVC &107
 FNRTS

;E R1=window blk of area in os (handle ...) R8/R9
;X window area updated using Wimp_UpdateWindow #

update_window
 STMFD R13!,{R1,R14}
 SWI XWimp_UpdateWindow		; update the window
; LDMVSFD R13!,{R1,PC}
 TEQ R0,#0
 LDMEQFD R13!,{R1,PC}		; return if no more
up1
 BLVC redraw_window		; redraw the rectangle
; LDMVSFD R13!,{R1,PC}
 SWIVC XWimp_GetRectangle		; get next rectangle
 LDMVSFD R13!,{R1,PC}
 TEQ R0,#0
 BNE up1			; loop if more to do
 LDMFD R13!,{R1,PC}

;X All windows redrawn (eg palette/char set change)

redraw_all
 STMFD R13!,{R10,R14}
 ADR R10,update_whole_window
 MOV R0,#0
 BL do_allwindow		; update windows
 LDMFD R13!,{R10,PC}

;E R8/R9=window to update
;X whole work area redrawn and title updated & redrawn CB #

update_whole_window
 STMFD R13!,{R1-R3,R14}
 BL update_whole_window_bar_title
; LDMVSFD R13!,{R1-R3,PC}
 BLVC new_title			; redraw title
 LDMFD R13!,{R1-R3,PC}

update_whole_window_bar_title
 STMFD R13!,{R14}
 FNLDR R1,car_block
 LDR R0,[R8,#w_handle]
 STR R0,[R1]
 FNLDR R0,wimp_leftgap
 RSB R0,R0,#0
 STR R0,[R1,#w_minx]
 MOV R0,#0
 STR R0,[R1,#w_maxy]
 BL ccd_workxy
 STR R2,[R1,#w_maxx]
 STR R3,[R1,#w_miny]
 BL update_window		; redraw whole window
 LDMFD R13!,{PC}

 LOCAL

;E R8=window block
;X palette (of current mode) copied into palette block & converted to
;  masks if in DSA mode #

create_palette
 FNJSR "R1-R4"
 MOV R0,#-1
 LDRB R1,[R8,#w_format]		; current mode
 BL mode_colour_num		; read the number of colours
 FNRTS VS
 MOVVC R4,R0			; save number of colours for this mode
 LDRVC R0,[R8,#w_palette]
 MOVVC R1,R4,LSL#2
 BLVC heap_ensure		; ensure palette big enough
 STR R0,[R8,#w_palette]
 LDRB R1,[R8,#w_format]		; current mode
 MOV R2,#0			; colour number
 MOV R3,R0			; palette to write
a$l
 MOV R0,#-1			; read
 BL mode_colour			; read the colour
 FNRTS VS
 STR R0,[R3,R2,LSL#2]		; save
 ADD R2,R2,#1
 CMP R2,R4
 BCC a$l			; fill them all in
 LDR R0,[R8,#w_flags]
 AND R0,R0,#&320000
 TEQ R0,#&020000		; VDU
 TEQNE R0,#&120000		; font VDU
 BLNE create_dsa_palette
 FNRTS

;E R8 palette set up
;X palette converted to DSA-style palette
create_dsa_palette
 FNJSR "R1-R3"
 ADD R1,R12,#red_flags		; redraw block
 LDR R2,[R8,#w_palette]		; source
 MOV R3,R2			; dest
 MOV R0,#2			; transform to DSA (R4 already set)
 SWI XZapRedraw_CreatePalette	; set up DSA colour masks
 FNRTS

;E R0=region start R1=region end R0<R1 or R0>R1 R8/R9
;X screen updated (R0,R1 may be either way round) #

update_between_offsets
 TEQ R0,R1
 MOVEQ PC,R14			; nothing to update
 STMFD R13!,{R1-R5,R14}
 MOV R5,R1			; save end
; STMFD R13!,{R0}
; MOV R0,#&99
; BL zephyr
; LDMFD R13!,{R0}
 BL offset_line_column		; R2/R3=start
 MOVVC R0,R5			; end
 MOVVC R4,R2
 MOVVC R5,R3			; R4/R5=start
; STMFD R13!,{R0}
; MOV R0,#&9900
; BL zephyr
; LDMFD R13!,{R0}
 BLVC offset_line_column	; R2/R3=end
 BLVC correct_region		; doesn't matter which way
 ADDVC R5,R5,#1			; last line.  Hmmm.  Pity.
 BLVC update_region
 LDMFD R13!,{R1-R5,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Font subs						   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;X font manager 2.42 and some cache / VS

check_font_manager
 STMFD R13!,{R1-R3,R14}
 SWI XFont_CacheAddr
 BLVS err$l
 LDMVSFD R13!,{R1-R3,PC}
 CMP R0,#242			; version number
 BLLT err$l
 LDMFD R13!,{R1-R3,PC}
err$l ERR "zap_e_needFM242"

;X R0=font handle of font_name scaled font_size #

font_findfont
 STMFD R13!,{R1-R5,R14}
 FNLDR R1,font_name
 FNLDR R14,font_size		; font size in points
 MOV R2,R14,LSL #16
 MOV R2,R2,LSR #12		; font size in 1/16 point
 TST R14,#&FF000000
 TSTEQ R14,#&FF0000
 MOVNE R3,R14,LSR #16
 MULNE R3,R2,R3
 ADDNE R14,R3,R3
 ADDNE R14,R14,R3,LSL #4
 ADDNE R14,R14,R3,LSL #6
 MOVNE R3,R14,LSR #13
 MOVEQ R3,R2			; x size = y size
 ;MOV R3,R2			; x size = y size ; ????????????
 MOV R4,#0
 MOV R5,#0
 SWI XFont_FindFont
 LDMFD R13!,{R1-R5,PC}

;E R0=font handle
;X bounding box info read to font_charw etc

font_readinfo
 FNJSR "R1-R6"
 BL font_charbbox
 FNRTS VS
 FNLDR R5,scn_magx
 FNLDR R6,scn_magy
 SUB R3,R3,R1			; os width
 RSB R1,R1,#0			; os x plot off
 SUB R4,R4,R2			; os height
 RSB R2,R2,#0			; os y plot off
 MOV R3,R3,LSR R5		; width in pixs
 MOV R4,R4,LSR R6		; height in pixs
 FNLDR R0,font_leftred
 SUB R3,R3,R0
 SUB R1,R1,R0,LSL R5
 FNLDR R0,font_botred
 SUB R4,R4,R0
 SUB R2,R2,R0,LSL R6
 FNLDR R0,font_rightred
 SUB R3,R3,R0
 FNLDR R0,font_topred
 SUB R4,R4,R0
 FNSTR R1,font_xoff		; os x offset
 FNSTR R2,font_yoff		; os y offset
 FNSTR R3,font_charw		; width in pixs
 FNSTR R4,font_charh		; height in pixs
; SWI &107 ; gets called...
 FNRTS

 LOCAL

;E R0=font handle
;X R1-R4=smallest box containg all the letters and numbers (in OS)
;  (As for Font_ReadInfo but 'silly' characters mess up the values there)

font_charbbox
 FNJSR "R5-R11"
 MOV R9,R0			; handle
 MOV R11,#&10			; use os
; BL getthevalues
; MOVVC R4,R8			; y size

 MOVVC R11,#&0			; use millipoints
 BLVC getthevalues

; MOVVC R5,R1			; x offset to plot within box
; MOVVC R6,R2			; y offset to plot within box

 ADDVC R1,R7,#200		; it rounds down (400mps=1os)
 ADDVC R2,R8,#800		; max x & max y
 SWIVC XFont_ConverttoOS
 MOVVC R3,R1
 MOVVC R4,R2
 ADDVC R1,R5,#200		; min x & min y
 ADDVC R2,R6,#200
 SWI XFont_ConverttoOS
 FNRTS

; MOV R3,R7			; x size
; MOV R4,R8			; y size
; MOV R1,R5			; x offset to plot within box
; MOV R2,R6			; y offset to plot within box
; FNRTS

getthevalues
 FNJSR "R1-R4"
 MOV R5,#0
 MOV R6,#0
 MOV R7,#0
 MOV R8,#0			; current smallest box
 MOV R10,#'0'			; current character
a$l
 MOV R0,R9
 MOV R1,R10
 MOV R2,R11			; use millipoints /or/ os units
 SWI XFont_CharBBox		; returns box in R1-R4
 FNRTS VS
 CMP R1,R5
 MOVLT R5,R1
 CMP R2,R6
 MOVLT R6,R2
 CMP R3,R7
 MOVGT R7,R3
 CMP R4,R8
 MOVGT R8,R4			; update box size
 ADD R10,R10,#1			; next character
 TEQ R10,#'9'+1
 MOVEQ R10,#'A'
 TEQ R10,#'Z'+1
 MOVEQ R10,#'a'
 CMP R10,#'z'
 BLE a$l
 FNRTS

;E R0=access state -1=VDU >0=Cached
;X ensures font_cache At Least in this state (-1<cache) #

font_ensure
 STMFD R13!,{R1,R14}
 MOV R1,R0			; save type
 BL check_font_manager
 LDMVSFD R13!,{R1,PC}
 FNLDR R0,font_cache
 CMP R0,#0			; already cached?
; BGT fo22
 LDMGTFD R13!,{R1,PC}
 CMP R1,#0			; requires caching?
 BGT fo20
 CMP R0,#0			; already set up for vdu?
 ;BMI fo22			; new by TT to set up offsets...
 LDMMIFD R13!,{R1,PC}
fo20
 CMP R1,#0
 BLE fo21			; don't need a cache
 MOV R0,#0
 BL heap_claim
 LDMVSFD R13!,{R1,PC}
 MOV R1,R0			; claimed cache
fo21
 FNSTR R1,font_cache		; new cache type
;fo22
; FNLDR R1,font_cache		; cache type
 BL read_font_info		; set up
 LDMFD R13!,{R1,PC}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Printout subs							   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 LOCAL

;X page size set up in wimp_print / error if no printer driver #

pnt_get_pagesize
 STMFD R13!,{R1-R6,R14}
 SWI &A0143			; XPDriver_PageSize
 FNLDR R0,wimp_print		; buffer
 MOVVS R3,#0
 MOVVS R4,#0
 LDRVS R5,default_width$l
 LDRVS R6,default_height$l
 SUB R5,R5,R3
 SUB R6,R6,R4
 STMIA R0,{R3-R6}		; x, y, width, height of printable area
 SUBS R0,R0,#0
 LDMFD R13!,{R1-R6,PC}
default_width$l  & 595275 ; 21cm
default_height$l & 841889 ; 29.7cm

;E R0=window width in chars & wimp_print number of pages/sheet paper size
;X lines per page/x scale/y scale filled in wimp_print #

pnt_fit_pages
 STMFD R13!,{R1-R11,R14}
 MOV R6,R0			; save width in chars
 MVN R0,#0
 BL font_ensure
 LDMVSFD R13!,{R1-R11,PC}	; set up font values
 FNLDR R10,wimp_print
 FNLDR R11,opt_flags
 TST R11,#1<<15			; sideways print
 LDREQ R4,[R10,#print_width]	; width mps
 LDREQ R5,[R10,#print_height]	; height mps
 LDRNE R5,[R10,#print_width]	; (swapped)
 LDRNE R4,[R10,#print_height]
 MOV R0,R4			; R4 = sheet width in mps ; (new 4)
 LDR R1,[R10,#print_columns_per_page]
;* ADD R0,R4,R1,ASR#1
 SWI XZapRedraw_Divide		; BL div_mod
 STR R0,[R10,#print_column_gap]
 MOV R4,R0			; page width
 FNLDR R0,font_charw		; font width in pixels
 FNLDR R14,scn_magx		; x os scaling
 MOV R0,R0,LSL R14		; font width in os coords
 MOV R14,#400
 MUL R0,R14,R0			; font width in mps @ b0
 MUL R1,R0,R6			; window width in mps @ b0
 MOV R1,R1,ASR#8		; window width mps/256 @ b0
 MOV R0,R4,LSL#8		; paper  width mps/256 @ b16
;* ADD R0,R0,R1,ASR#1
 SWI XZapRedraw_Divide		; BL div_mod
 MOV R6,R0			; R6=x scaling @ b16
 CMP R6,#&14000			; max scaling 5/4
 MOVGT R6,#&14000
 STR R6,[R10,#print_xscale]
; ADD R6,R6,R6,LSR #2	;!!!!!!!!!!!!!!!!!!!!!!!!
 STR R6,[R10,#print_yscale]
 MOV R0,R5,LSL#8		; paper height mps / 256 @ b16
 MOV R1,#400
;* ADD R0,R0,R1,ASR#1
 SWI XZapRedraw_Divide		; paper height os / 256 @ b16
 FNLDR R1,scn_magy
 MOV R0,R0,LSR R1		; paper height pix / 256 @ b16
 MOV R0,R0,LSL#8		; paper height pix @ b16
 LDR R1,[R10,#print_xscale]	; x scaling @ b16
;* ADD R0,R0,R1,ASR#1
 SWI XZapRedraw_Divide		; height in pixels after scaling
 FNLDR R1,font_charh
;* ADD R0,R0,R1,ASR#1
 SWI XZapRedraw_Divide		; height in chars
 MOV R3,R0
 TST R11,#1<<16
 SUBEQ R3,R3,#3			; subtract room for title
 STR R3,[R10,#print_lines_per_column]
 LDMFD R13!,{R1-R11,PC}

;E R0=use colour R8/R9=file
;X pages printed using wimp_print #

print_file
 FNJSR "R1-R5,R7,R8,R10"
; MVN R0,#0			; test!
 FNSTR R0,opt_temporary		; colour flag
 LDR R1,[R8,#w_rl]
 LDR R2,[R8,#w_rw]
 LDR R3,[R8,#w_rh]
 LDR R4,[R8,#w_linesp]		; save old redraw vals
 FNLDR R5,font_yoff ; red_cbpc		; obviously doesn't help
 FNLDR R0,font_charw
 STR R0,[R8,#w_rw]
 FNLDR R0,font_charh
; ADD R0,R0,R0,LSR #2		; !!!!!!!!! spaces things out a bit more :-(
 STR R0,[R8,#w_rl]
 STR R0,[R8,#w_rh]		; set up font ones
 MOV R14,#0
 STR R14,[R8,#w_linesp]
 FNSTR R5,font_yoff
; ADD R14,R5,#6			; !
; FNSTR R14,font_yoff		; red_cbpc
 ADR R10,print_file_sub
 BL do_longop			; print the pages
 STR R1,[R8,#w_rl]
 STR R2,[R8,#w_rw]
 STR R3,[R8,#w_rh]
 STR R4,[R8,#w_linesp]
 FNSTR R5,font_yoff ; red_cbpc
 MOV R14,#0
 FNSTR R14,opt_temporary
 FNRTS				; may be VS and error...

print_file_sub
 FNJSR "R1-R11"
 MOV R0,#&8F			; Openout with errors
 ADR R1,print_file_s0
 MOV R2,#0
 SWI XOS_Find			; open printer file
; BVS pn8			; ???
 FNRTS VS
 MOVS R11,R0			; save handle
 FNRTS EQ			; file not opened !
 FNSTR R11,wimp_print_job
 LDR R1,[R9,#f_name]		; title
 SWI &A0145			; PDriver_SelectJob
 BVS pn8			; close file and error
 FNSTR R0,wimp_print_prevjob
 FNLDR R10,wimp_print
 BL pnt_matrix
 LDR R1,[R10,#print_start_page]	; start page(from 0)
 LDR R2,[R10,#print_stop_page]	; end page(+1)
 LDR R3,[R10,#print_total_num_pages]
 CMP R2,R3
 MOVGE R2,R3			; clip end page
 LDR R3,[R10,#print_columns_per_page]
pn3
 CMP R1,R2
 BGE pn7			; none left so finish
 BL pnt_send_title		; send title if there is one
; BVS pn6
 MOVVC R4,#0			; column offset
pn4
 MOVVC R0,R4
 BLVC pnt_send_column		; give the column
 BVS pn6			; error
 ADD R4,R4,#1			; next column
 CMP R4,R3
 BCC pn4
 BL print_page			; print the page
 ADDVC R1,R1,#1			; next page
 BVC pn3
 B pn6
pn7
 FNLDR R0,wimp_print_job
 SWI &A0148			; XPDriver_EndJob
 BVS pn6
 MOV R0,#0
 FNLDR R1,wimp_print_job
 FNSTR R0,wimp_print_job
 SWI XOS_Find			; close file
; LDMVSFD R13!,{R1-R11,PC}
 FNLDR R0,wimp_print_prevjob,VC	; previous Job
 MOV R11,#0
 FNSTR R11,wimp_print_prevjob
 SWIVC &A0145			; XPDriver_SelectJob
 FNRTS
pn6
 PUSH "R0"
 FNLDR R0,wimp_print_job
 SWI &A0149			; XPDriver_AbortJob
 FNLDR R0,wimp_print_prevjob	; previous Job
 MOV R11,#0
 FNSTR R11,wimp_print_prevjob
 SWI &A0145			; XPDriver_SelectJob
 PULL "R0"
pn8
 PUSH "R0"
 MOV R0,#0
 FNLDR R1,wimp_print_job
 FNSTR R0,wimp_print_job
 SWI XOS_Find			; close file
 PULL "R0"
 FNRTV				; return with error

print_file_s0	FNS ("printer:")

;E R8-R9=file R10=wimp_print
;X os rectangles (R1) and transformation matrices (R2) set up |

pnt_matrix
 FNJSR "R1-R3"
 ADD R1,R10,#print_column_rectangle
 MOV R0,#0
 STR R0,[R1,#0]			; min x
 STR R0,[R1,#4]			; min y
 LDR R2,[R8,#w_width]		; window width in chars
 LDR R3,[R10,#print_lines_per_column]
 BL ccd_xyline_xyos
 STR R2,[R1,#8]			; max x
 RSB R3,R3,#0
 STR R3,[R1,#12]		; max y
 ADD R1,R10,#print_title_rectangle
 MOV R0,#0
 STR R0,[R1,#0]			; min x
 STR R0,[R1,#4]			; min y
 MOV R2,#&50			; max title width
 MOV R3,#1			; number of lines
 BL ccd_xyline_xyos
 STR R2,[R1,#8]			; max x
 RSB R3,R3,#0
 STR R3,[R1,#12]		; max y
 ADD R1,R10,#print_column_matrix
 MOV R0,#0
 STR R0,[R1]
 STR R0,[R1,#4]
 STR R0,[R1,#8]
 STR R0,[R1,#12]		; clear matrix
 FNLDR R14,opt_flags
 LDR R2,[R10,#print_xscale]
 LDR R3,[R10,#print_yscale]
 TST R14,#1<<15
 BNE pn10			; not upright
 STR R2,[R1]			;  (b 0)
 STR R3,[R1,#12]		;  (0 c)
 B pn1
pn10
 RSB R2,R2,#0
 STMIB R1,{R2,R3}		; matrix (0  c) (-b 0)
pn1
 ADD R2,R10,#print_title_matrix
 MOV R3,#4			; count
pn2
 LDR R0,[R1],#4
 ADD R0,R0,R0,ASR#3		; *1.125
 STR R0,[R2],#4
 SUBS R3,R3,#1
 BHI pn2			; create title matrix
 FNRTS

;E R0=column offset in sheet R1=page number R8-R9 file R10=wimp_print
;X column sent to printer #

pnt_send_column
 STMFD R13!,{R1-R11,R14}
 MOV R7,R0			; save col offset
 MOV R6,R1			; page number
 FNLDR R11,opt_flags
 ADD R1,R10,#print_column_rectangle
 ADD R2,R10,#print_column_matrix
 ADD R3,R10,#print_plot_position
 LDR R4,[R10,#print_width]
 LDR R5,[R10,#print_height]
 LDR R0,[R10,#print_column_gap]
; MOV R0,R0,LSR #2		; (new 4) !! irrelevant!
 MUL R0,R7,R0			; col offset in mps
; MOV R0,R0,LSR #2		; (new 4)
 TST R11,#1<<15
 MOVEQ R4,R0
 MOVEQ R5,#0			; xy for upright
 MOVNE R4,#0
 SUBNE R5,R5,R0			; xy for sideways
 LDR R0,[R10,#print_xoff]
 ADD R4,R4,R0			; add x margin
 LDR R0,[R10,#print_yoff]
 ADD R5,R5,R0			; add y margin
 STMIA R3,{R4,R5}		; plot position
 MVN R4,#&FF			; colour &FFFFFF00 (bg colour = white...)
 BL add_fudge_factors
 LDR R0,[R10,#print_columns_per_page]
 MLA R0,R6,R0,R7		; total column offset as ID
 SWI &A014B			; PDriver_GiveRectange
 LDMFD R13!,{R1-R11,PC}

;E R10=wimp_print
;X title rectangle sent to printer driver if necessary #

pnt_send_title
 STMFD R13!,{R1-R11,R14}
 FNLDR R11,opt_flags
 TST R11,#flags_FancyPrintNoTitle
 LDMNEFD R13!,{R1-R11,PC}	; no need to add title
 ADD R1,R10,#print_title_rectangle
 ADD R2,R10,#print_title_matrix
 ADD R3,R10,#print_plot_position
 LDR R4,[R10,#print_width]
 LDR R5,[R10,#print_height]
 FNLDR R0,font_charw		; font height in pixels
 FNLDR R14,scn_magy
 MOV R0,R0,LSL R14		; font height in os
 MOV R14,#400
 MUL R0,R14,R0			; font height in mps
 LDR R14,[R10,#print_yscale]
 MUL R0,R14,R0			; height mps @ b16
 MOV R0,R0,LSR#16		; height mps
 TST R11,#flags_FancyPrintSideways
 MOVEQ R4,#0
 SUBEQ R5,R5,R0			; xy for upright
 SUBNE R4,R4,R0			; xy for sideways
 LDR R0,[R10,#print_xoff]
 ADD R4,R4,R0			; add x margin
 LDR R14,[R8,#w_rl]		; font height in pixels
 MOV R14,R14,LSL #10
; MOV R0,#400
 CMP R5,R14
 MOVLT R5,R14			; position fudge...
 LDR R0,[R10,#print_yoff]
 ADD R5,R5,R0			; add y margin
 STMIA R3,{R4,R5}		; plot position
 BL add_fudge_factors
 MVN R4,#&FF			; colour &FFFFFF00
 MVN R0,#0			; -1 as ID
 SWI &A014B			; PDriver_GiveRectange
 LDMFD R13!,{R1-R11,PC}

add_fudge_factors
 FNJSR
 LDR R14,[R1,#&0]		; minx
 SUB R14,R14,#2
 STR R14,[R1,#&0]		; minx
 LDR R14,[R1,#&4]		; miny
 SUB R14,R14,#2
 STR R14,[R1,#&4]		; miny
 LDR R14,[R1,#&8]		; maxx
 ADD R14,R14,#2
 STR R14,[R1,#&8]		; maxx
 LDR R14,[R1,#&C]		; maxy
 ADD R14,R14,#2
 STR R14,[R1,#&C]		; maxy
 FNRTS

;E R1=page num R8-R9=file R10=wimp_print and rectangles sent to printer
;X Rectangles got from printer driver and plotted WB KB WD #


print_page
 FNJSR "R1-R11"
 MOV R7,R1			; save page number
 ADD R0,R7,#1			; page
 LDR R1,[R8,#w_txtw]		; cached line width
 BL create_heading		; heading to wimp_data
; LDMVSFD R13!,{R1-R11,PC}
 FNLDR R11,wimp_kbdbuf,VC		; block for 'screen update'
 LDRVC R0,[R8]
 STRVC R0,[R11]			; window handle
 ADDVC R0,R7,#1			; page number (from 1)
 ADDVC R1,R11,#44
 MOVVC R2,#16
 SWIVC XOS_ConvertInteger4	; get page number string
; LDMVSFD R13!,{R1-R11,PC}
 MOVVC R0,#1			; 1 copy
 ADDVC R1,R11,#28			; rectangle block (for data)
 ADDVC R2,R7,#1			; page
 ADDVC R3,R11,#44			; page number string
 SWIVC &A014C			; XPDriver_DrawPage
 FNRTS VS
pn12
 TEQ R0,#0
 FNRTS EQ			; finished
 CMP R2,#0			; is ID<0
 ADDPL R0,R10,#print_column_rectangle
 ADDMI R0,R10,#print_title_rectangle
 LDMIA R0,{R4-R7}
 STMIB R11,{R4-R7}		; 'visible area of window'
 MOV R1,R11
 BL redraw_clip			; clip given rectangle to boundry
 CMP R2,#0
 BMI pn14			; print title
 LDR R4,[R10,#print_lines_per_column]
 MUL R3,R2,R4			; y scroll offset in lines
 MOV R2,#0			; x scroll offset
 BL ccd_xyline_xyos
 STR R2,[R11,#w_scrollx]
 STR R3,[R11,#w_scrolly]	; current scroll for this column
 MOV R1,R11
 BL print_rectangle		; print the rectangle
 FNRTS VS
pn13
 ADD R1,R11,#28
 SWI &A014D			; XPDriver_GetRectangle
 BVC pn12			; do next rectangle
 FNRTS
pn14
 MOV R0,#0
 STR R0,[R11,#w_scrollx]
 STR R0,[R11,#w_scrolly]	; no scrolls
 STMFD R13!,{R10-R11}
 MOV R1,R11
 BL redraw_to_red
 LDMFD R13!,{R10-R11}
 MOV R0,#100
 FNSTR R0,red_linesp		; make sure don't get onto second line
 FNLDR R0,wimp_data
 FNLDR R1,red_data
 SUB R0,R0,R1			; offset to the text to draw
 STR R0,[R1]
 MOV R0,#0
 STR R0,[R1,#4]			; only one line
 BL print_area_font
 BVC pn13			; next rectangle
 FNRTS

;E R1=area to redraw (as for Wimp_Redraw) R8-R9
;X Area printed by vdu redraw #

print_rectangle
 FNJSR "R1-R4,R8"
 BL redraw_to_red		; convert coords to pixels
 BLVC update_cache		; update cache entries
 BLVC create_redraw_data		; create new style redraw data
 MOVVC R4,R0			; largest character used
 BLVC print_area_font		; display on screen area
 FNRTS

 LOCAL

;E Redraw block set up except for palette/font name/flags/size etc
;X Text printed by font vdu call #

print_area_font
 FNJSR "R1,R8"
; LDR R14,[R8,#w_info]		; for enable ss bit
; TST R14,#bit_nosubstyles
; MOVNE R0,#1			; vdu redraw + |vdu background|
 MOV R14,#9			; vdu redraw + sub-styles + |vdu background|
 FNSTR R14,red_flags
 FNLDR R14,font_name
 FNSTR R14,red_caddr
 FNLDR R14,font_xoff
 FNSTR R14,red_cbpl		; x offset
 FNLDR R14,font_yoff
 FNSTR R14,red_cbpc		; y offset
 FNLDR R14,font_size
 FNLDR R1,red_workarea
 STR R14,[R1]

 FNLDR R0,red_flags

 BL set_up_print_palette
 FNSTR R0,red_palette,VC

 ADDVC R1,R12,#red_flags
 SWIVC XZapRedraw_RedrawArea	; !?!?!? vdu-background...!
 FNRTS

set_up_print_palette
 FNJSR "R1-R8,R11"
 FNLDR R7,wimp_data
 ADD R7,R7,#&C0			; &40 free at least...
 MOV R0,#-1
 LDRB R1,[R8,#w_format]
 BL mode_colour_num
 MOVVC R6,R0
 SUBVC R6,R6,#1
colourloop$l
 MOVVC R0,#-1
 MOVVC R2,R6
 LDRVCB R1,[R8,#w_format]
 BLVC mode_colour
 FNRTS VS
 MOV R5,R0
 FNLDR R0,opt_temporary		; set up in print_file
 TEQ R0,#0
 BNE usingcolour$l
 CMP R6,#9
 BCC systemcase$l
 MOV R0,#15
 MOV R1,R6
 MOV R11,#e_interrogate
 BL call_mode
 FNRTS VS			; oh dear...
 TST R0,#1
backfromsystemcase$l
 ANDNE R5,R5,#&FF
 ORREQ R5,R5,#&FF000000
 ORREQ R5,R5,#&00FF0000
 ORREQ R5,R5,#&0000FF00
usingcolour$l
 STR R5,[R7,R6,LSL #2]
 SUBS R6,R6,#1
 BPL colourloop$l
 MOV R0,R7
 FNRTS

systemcase$l
 TEQ R6,#0
 TEQNE R6,#1
 TEQNE R6,#3
 TEQNE R6,#5
 B backfromsystemcase$l

;E R1=rectangle to clip (minx,miny,maxx,maxy) R2=rectangle to clip to
;X rectangle clipped |

rectangle_clip
 FNJSR
 LDR R0,[R1,#&0]
 LDR R14,[R2,#&0]
; SUB R14,R14,#2		; be liberal?
 CMP R0,R14
 STRLT R14,[R1,#&0]		; minx
 LDR R0,[R1,#&4]
 LDR R14,[R2,#&4]
; SUB R14,R14,#2		; be liberal?
 CMP R0,R14
 STRLT R14,[R1,#&4]		; miny
 LDR R0,[R1,#&8]
 LDR R14,[R2,#&8]
; ADD R14,R14,#2		; be liberal?
 CMP R0,R14
 STRGT R14,[R1,#&8]		; maxx
 LDR R0,[R1,#&C]
 LDR R14,[R2,#&C]
; ADD R14,R14,#2		; be liberal?
 CMP R0,R14
 STRGT R14,[R1,#&C]		; maxy
; LDR R14,[R1,#&0]		; minx
; SUB R14,R14,#2
; STR R14,[R1,#&0]		; minx
; LDR R14,[R1,#&4]		; minx
; SUB R14,R14,#2
; STR R14,[R1,#&4]		; minx
; LDR R14,[R1,#&8]		; minx
; ADD R14,R14,#2
; STR R14,[R1,#&8]		; minx
; LDR R14,[R1,#&C]		; minx
; ADD R14,R14,#2
; STR R14,[R1,#&C]		; minx
 FNRTS

;E R1=redraw block
;X graphics window 28-40 clipped to visible area 4-16 |

redraw_clip
 FNJSR "R1,R2"
 ADD R2,R1,#4
 ADD R1,R1,#28
 BL rectangle_clip
 FNRTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Quick print subs						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R8-R9 & wimp_print set up
;X file printed by direct output of ascii #

quick_print
 FNJSR "R10"
 ADR R10,quick_print_sub
 BL do_longop
 FNRTS

quick_print_sub
 STMFD R13!,{R1-R11,R14}
 SWI XOS_WriteC + &102
 FNLDR R11,opt_flags
 FNLDR R10,wimp_print
 TST R11,#1<<18
 BNE pr3			; no title
 MVN R0,#0			; no page number
 MOV R1,#&80			; cache width
 BL create_heading
; LDMVSFD R13!,{R1-R11,PC}
 MOVVC R2,R1			; cache width
 FNLDR R1,wimp_data,VC
 MOVVC R0,#3			; leave in ff (12)
 BLVC tidy_cache_line
; LDMVSFD R13!,{R1-R11,PC}
 MOVVC R0,R1
 BLVC printer_string		; output title
 BLVC printer_newline		; and blank line
 BLVC printer_startoffile
 LDMVSFD R13!,{R1-R11,PC}
pr3
 LDR R1,[R10,#print_start_line]
 LDR R2,[R10,#print_stop_line]
 LDR R3,[R8,#w_height]
 CMP R2,R3
 MOVGE R2,R3			; clip end line
pr4
 CMP R1,R2
 BGE printeofstring
 ;LDMGEFD R13!,{R1-R11,PC}	; finished
 BL printer_cache_line		; CORRUPTS LOTS
 LDMVSFD R13!,{R1-R11,PC}
 ADD R1,R1,#1
 B pr4

printeofstring
 BL printer_endoffile

 SWI XOS_WriteC + &103

 LDMFD R13!,{R1-R11,PC}		; finished

;E R1=line R8/R9
;X line cached and printed, R1-R2,R8-R9 only saved #

printer_cache_line
 STMFD R13!,{R1-R2,R14}
 MOV R2,R1
 ADD R3,R1,#1
 BL update_cache		; saves R8/R9 R0=cached data
; LDMVSFD R13!,{R1-R2,PC}
 MOVVC R1,R0			; cached data
 LDRVC R2,[R8,#w_txtw]		; cache width
 MOVVC R0,#3
 BLVC tidy_cache_line		; to buffer
; LDMVSFD R13!,{R1-R2,PC}
 MOVVC R0,R1
 BLVC printer_string
 LDMFD R13!,{R1-R2,PC}

;E R0=page num/-1 for none R1=cache line width R8/R9
;X wimp_data filled with cache line for heading WB KB WD #

create_heading
 STMFD R13!,{R1-R4,R10-R11,R14}
 MOV R10,R0			; save page number
 MOV R4,R1			; save cache width
 FNLDR R0,wimp_data
 BL heap_ensure			; ensure wimp_data big enough
 LDMVSFD R13!,{R1-R4,R10-R11,PC}
 FNSTR R0,wimp_data
 MOV R11,R0			; cache data buffer
 MOV R0,#&20
 MOV R1,R11
 MOV R2,R4
 BL strstr			; clear buffer to spaces
 CMN R10,#1
 BEQ cr13			; no page heading
 ADR R0,cr_s0
 BL cr_sc			; Page
 MOV R0,R10
 MOV R2,#12
 SWI XOS_ConvertCardinal4
 LDMVSFD R13!,{R1-R4,R10-R11,PC}
 MOV R0,#&20
 STRB R0,[R1]			; remove null
 ADD R11,R11,#12		; move onto next column
cr13
 ADR R0,cr_s1
 BL cr_sc
 LDR R0,[R9,#f_name]
 BL find_leaf_name
 MOV R2,R0
 BL strcpy			; copy in filename
 ADD R11,R11,#18		; next col
 ADR R0,cr_s2
 BL cr_sc
 FNLDR R0,wimp_dateformat
 BL read_date
 LDMVSFD R13!,{R1-R4,R10-R11,PC}
 FNLDR R2,wimp_kbdbuf
 BL strcpy
 ADD R11,R11,#32
 ADR R0,cr_s3
 BL cr_sc
 FNLDR R0,wimp_timeformat
 BL read_date
 LDMVSFD R13!,{R1-R4,R10-R11,PC}
 FNLDR R2,wimp_kbdbuf
 BL strcpy			; no terminating 0 for cache lines
 LDMFD R13!,{R1-R4,R10-R11,PC}
cr_sc
 MOV R2,R14
 BL lookup_token_R0
 MOV R14,R2
 MOV R2,R0
 MOV R1,R11
 B strcpy
cr_s0 = "zap_P_page",0
cr_s1 = "zap_P_file",0
cr_s2 = "zap_P_date",0
cr_s3 = "zap_P_time",0
 ALIGN

;E R0=pointer to string ending in 0A
;X string output to printer (inc 0A) #

printer_string
 STMFD R13!,{R1,R14}
 MOV R1,R0
pr1
 LDRB R0,[R1],#1
 TEQ R0,#&0A
 BEQ pr2
 SWI XOS_PrintChar		; output character
 LDMVSFD R13!,{R1,PC}
 B pr1
pr2
 BL printer_newline
 LDMFD R13!,{R1,PC}

;X newline sent to printer #

printer_newline
 STMFD R13!,{R1-R3,R14}
 FNLDR R0,wimp_eolstring	; end of line GS string
 MOV R2,#0
 SWI XOS_GSInit
pr10
 SWIVC XOS_GSRead
 LDMVSFD R13!,{R1-R3,PC}
 LDMCSFD R13!,{R1-R3,PC}	; reached end
 MOV R3,R0			; save R0
 MOV R0,R1			; character
 SWI XOS_PrintChar
 MOVVC R0,R3
 B pr10

;X sof string sent to printer #

printer_startoffile
 STMFD R13!,{R1-R3,R14}
 FNLDR R0,wimp_sofstring	; end of line GS string
 MOV R2,#0
 SWI XOS_GSInit
prsoflp$l
 SWIVC XOS_GSRead
 LDMVSFD R13!,{R1-R3,PC}
 LDMCSFD R13!,{R1-R3,PC}	; reached end
 MOV R3,R0			; save R0
 MOV R0,R1			; character
 SWI XOS_PrintChar
 MOVVC R0,R3
 B prsoflp$l

;X eof string sent to printer #

printer_endoffile
 STMFD R13!,{R1-R3,R14}
 FNLDR R0,wimp_eofstring	; end of line GS string
 MOV R2,#0
 SWI XOS_GSInit
preoflp$l
 SWIVC XOS_GSRead
 LDMVSFD R13!,{R1-R3,PC}
 LDMCSFD R13!,{R1-R3,PC}	; reached end
 MOV R3,R0			; save R0
 MOV R0,R1			; character
 SWI XOS_PrintChar
 MOVVC R0,R3
 B preoflp$l

;E R0=flags   b0 => leave form feeds (asc 12) in
;	      b1 => don't allow &80-&9F (for printers)
;  R1=address of cache line
;  R2=length of cache lines
;X R1=wimp_cacheline R2=length (exc 0A)
;  ctrl/end spaces gone 0A added #

tidy_cache_line
 STMFD R13!,{R3-R4,R14}
 MOV R4,R0			; save the flags
 BL get_cache_line
 MOV R3,R1			; source
 MOV R2,R0			; line length
 FNLDR R0,wimp_cacheline
 ADD R1,R2,#4
 BL heap_ensure
 LDMVSFD R13!,{R3-R4,PC}
 FNSTR R0,wimp_cacheline
 MOV R1,R0			; destination
ge11
 SUBS R2,R2,#1
 BLT ge12			; none left
 LDRB R0,[R3],#1
 CMP R0,#&A0
 BCS ge19
 TST R0,#1<<8
 TSTNE R4,#2
 BNE ge18
 TEQ R0,#&7F
 BEQ ge18
 CMP R0,#&20
 BCS ge19
 TST R4,#1
 BEQ ge18
 TEQ R0,#12
 BNE ge18
ge19
 STRB R0,[R1],#1		; output
 B ge11
ge18
 MOV R0,#'.'
 STRB R0,[R1],#1
 B ge11
ge12
 MOV R0,#&0A
 STRB R0,[R1]			; add terminator
 MOV R2,R1
 FNLDR R1,wimp_cacheline
 SUB R2,R2,R1			; length
 LDMFD R13!,{R3-R4,PC}

;E R1=address of cache line R2=length of cache lines
;X R0=actual length with end spaces removed |

get_cache_line
 FNJSR
 ADD R14,R1,R2
ge10
 CMP R14,R1
 MOVLE R0,#0
 FNRTS LE
 LDRB R0,[R14,#-1]!
 TEQ R0,#&20
 BEQ ge10
 ADD R14,R14,#1
 SUB R0,R14,R1
 FNRTS

;E R2-R5 region R8/R9 (correct way around)
;X Region updated (uses caret block) #
;  Cache blatted as now selection stored there

update_region
 STMFD R13!,{R1-R4,R10-R11,R14}
 FNLDR R1,car_block		; workspace
 MOV R11,R4			; save last col
 LDR R10,[R8,#w_width]		; window width
 ADD R10,R10,#1			; last column
up2
 SUBS R0,R5,R3			; number of lines to do
 LDMLEFD R13!,{R1-R4,R10-R11,PC}
 TEQ R0,#1
 MOVEQ R4,R11			; on last line so correct last col
 BEQ up3
 MOV R4,R10			; to end of line
 ;ADD R4,R10,#1			; ???????????????
 TEQ R2,#0			; starts at start?
 MOVNE R0,#1
 BNE up3			; if not then do one line
 TEQ R11,R10			; is last line full width
 SUBNE R0,R0,#1			; if not then don't do in this block
up3
 ;CMP R2,#0			; bug?
 ;MOVMI R2,#0			; bug?
 ;CMP R4,#			; bug?
 ;MOVMI R4,#0			; bug?
 STR R2,[R1,#w_minx]
 STR R3,[R1,#w_miny]
 STR R4,[R1,#w_maxx]
 ADD R3,R3,R0			; inc start line
 STR R3,[R1,#w_maxy]
 LDR R0,[R8,#w_handle]
 STR R0,[R1]
 MOV R0,#0
 STR R0,[R8,#w_txtn]
 BL update_area			; update the rectangle
 LDMVSFD R13!,{R1-R4,R10-R11,PC}
 MOV R2,#0			; new start column
 CMP R3,R5
 BCC up2			; more lines to do
 LDMFD R13!,{R1-R4,R10-R11,PC}

 LOCAL

;tmpstrofthestring
; DCD 0
; DCD 0
; DCD 0
; DCD 0
;tmpstrofthestringe
;
;ofstmtlat$l
; DCD tmt_offsets
; DCD 0
;
;soutofofs_red
; FNJSR "R0,R1,R2"
; FNADR R0,ofstmtlat$l
; LDR R0,[R0,#font_offsets]
; CMP R0,#0
; FNRTS EQ
; ADR R2,tmpstrofthestring
;loopx$l
; LDRB R1,[R0],#1
; TEQ R1,#','
; MOVEQ R1,#0
; STRB R1,[R2],#1
; ADR R1,tmpstrofthestringe
; CMP R2,R1
; BCC loopx$l
; FNRTS
;
;tmt_getxpos_red			; this rotine had better not return VS...
; FNJSR "R0,R1,R2"
; ADR R0,tmpstrofthestring
; LDR R1,[R0]
; CMP R1,#0
; FNRTS EQ
; ADR R1,ofstmtlat$l + 4
; MOV R2,#0
; SWI XOS_EvaluateExpression
; CMP R1,#0
; FNRTS NE
; ADD R4,R4,R2
; FNRTS
;
;tmt_getypos_red			; this rotine had better not return VS...
; FNJSR "R0,R1,R2"
; ADR R0,tmpstrofthestring
; LDR R1,[R0]
; CMP R1,#0
; FNRTS EQ
;loop$l
; LDRB R1,[R0],#1
; CMP R1,#31
; BGT loop$l
; ADR R1,ofstmtlat$l + 4
; MOV R2,#0
; SWI XOS_EvaluateExpression
; CMP R1,#0
; FNRTS NE
; ADD R5,R5,R2
; FNRTS
;
;tmt_getxpos_redlow		; this rotine had better not return VS...
; FNJSR "R0,R1,R2"
; ADR R0,tmpstrofthestring
; LDR R1,[R0]
; CMP R1,#0
; FNRTS EQ
; MOV R2,#2
;loop3$l
; LDRB R1,[R0],#1
; CMP R1,#31
; BGT loop3$l
; SUBS R2,R2,#1
; BNE loop3$l
; ADR R1,ofstmtlat$l + 4
; MOV R2,#0
; SWI XOS_EvaluateExpression
; CMP R1,#0
; FNRTS NE
; ADD R4,R4,R2
; FNRTS
;
;tmt_getypos_redlow		; this rotine had better not return VS...
; FNJSR "R0,R1,R2"
; ADR R0,tmpstrofthestring
; LDR R1,[R0]
; CMP R1,#0
; FNRTS EQ
; MOV R2,#3
;loop4$l
; LDRB R1,[R0],#1
; CMP R1,#31
; BGT loop4$l
; SUBS R2,R2,#1
; BNE loop4$l
; ADR R1,ofstmtlat$l + 4
; MOV R2,#0
; SWI XOS_EvaluateExpression
; CMP R1,#0
; FNRTS NE
; ADD R5,R5,R2
; FNRTS

deprecated_update_area
	STMFD	R13!,{R0,R1,R14}
	ADR	R0,msg_update_area
	MOV	R1,#1<<31
	BL	warn_user
	LDMFD	R13!,{R0,R1,R14}
	B	update_area

deprecated_update_window
	STMFD	R13!,{R0,R1,R14}
	ADR	R0,msg_update_window
	MOV	R1,#1<<31
	BL	warn_user
	LDMFD	R13!,{R0,R1,R14}
	B	update_window

msg_update_area   = "deprecated: Zap_UpdateArea",0
msg_update_window = "deprecated: Zap_UpdateWindow",0
	ALIGN

 END
