; Contains mode entry points for word mode.
; $Id: Mode2,fff,v 1.1.2.2 1999/01/12 00:28:10 ds Exp $

 GET h.ZapHeader
 GET h.Commands
 GET h.Execute
 GET h.Mode0
 GET h.Mode1
 GET h.Mode3
 GET h.Mode4
 GET h.AlterTxt
 GET h.ModeBits
 GET h.MiniBuff
 GET h.Menus
 GET h.Redraw
 GET h.Strings
 GET h.Heap
 GET h.KeyBits
 GET h.Cursors

 EXPORT mode_table_2
 EXPORT mode2_minus
 EXPORT mode2_plus
 EXPORT mode2_copy
 EXPORT mode2_aligncaret
 EXPORT storebackgroundforhex2
 EXPORT inmode2_return
 EXPORT mode2_returnword

 EXPORT CmdWORDctrlreplace
 EXPORT CmdWORDflagstoggle
 EXPORT CmdWORDgroupsize

mode_table_2
 DCD mode_table_2
 DCD mode2_title
 DCD mode1_author
 DCD 1
 DCD 2+(1<<11)
 DCD mode2_init
 DCD 0
 DCD mode2_table_end-mode_table_2

 DCD 0				; postload
 DCD 0
 DCD 0
 DCD mode2_start
 DCD mode2_end
 DCD mode2_width
 DCD mode2_linecol
 DCD mode2_lineoff
 DCD 0
 DCD 0
 DCD 0
 DCD 0
 DCD mode2_minus
 DCD mode2_plus
 DCD mode2_minus
 DCD mode2_plus
 DCD mode1_cminus
 DCD mode1_cplus
 DCD mode2_redrawline
 DCD 0
 DCD mode2_char
 DCD mode2_delete
 DCD 0
 DCD mode2_return
 DCD 0
 DCD 0
 DCD mode1_linestart
 DCD mode1_lineend
 DCD mode1_lineend
 DCD mode1_linestart
 DCD mode2_copy
 DCD 0
 DCD 0
 DCD mode2_aligncaret
 DCD command_primative
 DCD 0
 DCD 0
 DCD 0
 DCD 0			; runandquit
 DCD 0
 DCD 0
 DCD replace_area ; 0
 DCD 0			; selection
 DCD modes_click	; click
 DCD 0			; messages
 DCD mode4_setwidth
 DCD 0			; list fns
 DCD mode0_prevline
 DCD 0			; Open window
 DCD mode2_interrogate	; Answer all Zap's questions...
 DCD mode2_returnword	; for SG etc...
mode2_table_end

mode2_title
 FNS ("Word")

mode2_init
 FNJSR "R2"
 ADR R2,mode2_init_data
 BL mode1_2_init
 FNRTS

mode2_init_data
	=	2		; mode number
	=	6		; menu number
	ALIGN
	&	&042E0200	; default_mode_word
 				; 4 words to a group (16 bytes),
 				; group in number dump,
 				; and '.' as (disabled)
 				; control char replacement
mode2_cols
 = "ASCII chars"
 = 0
 = 0
 ALIGN

 LOCAL

 DCD (7) + (3:SHL:3) + (1:SHL:6) + (1:SHL:17)
 				; "No" R8-R10
 				; string argument
 				; call me before minibuffer
 				; can set up menu
CmdWORDgroupsize
 ADR R3,data$l
 B CmdBYTEWORDgroupsize

data$l
	=	2	; mode number
	=	1	; default group size
	ALIGN
	&	miniprompt$l-data$l
	&	menutitle$l-data$l

miniprompt$l	= "zap_p_wordgroupsize", 0
menutitle$l	= "zap_m_groupsize", 0
	ALIGN

 DCD (7) + (3:SHL:3) + (1:SHL:6) + (1:SHL:17)
 				; "No" R8-R10
 				; string argument
 				; call me before minibuffer
 				; can set up menu
CmdWORDctrlreplace
 MOV R1,#2			; mode number
 B CmdBYTEWORDctrlreplace

 LOCAL

 DCD (7) + (2:SHL:3) + (1:SHL:13) + (1:SHL:15)
 				; I'm lazy, and so multiple words only get done singly
CmdWORDflagstoggle
 MOV R1,#2			; mode number
 B CmdBYTEWORDflagstoggle

mode2_width
 FNJSR "R1-R6"
 MOV R2,#0
 BL modes_getmodeword

 MOV R0,R0,LSL#16
 MOV R0,R0,LSR#16		; bottom 16 bits
 CMP R0,#&FF
 MOVGT R0,#&FF
 CMP R0,#1
 MOVLT R0,#1
 MOV R6,R0

 MOV R14,R0,LSL#2		; 4*R0=num of bytes
 STR R14,[R8,#w_bpl]
 LDR R5,[R8,#w_mode2]
 BIC R5,R5,#&FF

 MOV R1,R5,LSR #24
 ANDS R1,R1,#&F			; r2 = 'n'
 MOVEQ R1,#16
 ; MOV R1,R4
 ; MOV R2,R1,LSR #24
 ; AND R2,R2,#&F		; r2 = 'n'
 ; R14 = #bytes, R0 = #words, R1 = mode word
 ; n, k want to be in words

 SWI XZapRedraw_Divide ; BL div_mod	; R0=phy line R2=col byte offset

 CMP R2,#0
 ADDGT R0,R0,#1 ; remainder...

 CMP R0,#&0
 MOVLE R0,#1
 CMP R0,#&FF
 MOVHI R0,#&FF			; more than this is not permitted

 ORR R1,R5,R0			; put the DIV value in
 STR R1,[R8,#w_mode2]

; MOV R1,R5			; mode word...
 MOV R0,R6			; as preserved above...

 BL mode2_calc_width
 MOV R0,R2			; result

 FNRTS

; \E R0 = words per line, R1 = mode word
; \X R2 = width in characters needed, R0,R1 preserved
;    R3 is "corrupted" (number of breaks - ie number of groups - 1)
mode2_calc_width
 FNJSR "R0,R4"

 AND R3,R1,#&FF			; k
 SUB R3,R3,#1			; # breaks

 MOV R2,#0
 TST R1,#(1:SHL:9)		; break hex/bin dump
 ADDNE R2,R2,R3			; 1 * = " "

 TST R1,#(1:SHL:10)		; break ascii dump
 ADDNE R2,R2,R3			; 1 * = " "

 ADD R4,R2,R0,LSL#2		; ascii bit (4 chs/wd) plus breaks
 TST R1,#(1:SHL:11)		; binary dump
 ADDNE R0,R0,R0,LSL#5		; R0*33 (32 + space)
 ADDEQ R0,R0,R0,LSL#3		; R0*9  (8  + space)

 ADD R0,R0,#2			; colon
 ADD R2,R4,R0			; add it all together

 FNRTS

localmodeword
 DCD &0				; temp storage space
localmoden
 DCD &0
localmode_colon
 DCD &0				; where the colon sits

; Probably best to look at the byte mode redraw to get a good handle
; on how all this works - sja
; NB: R11 stores w_format during processing. This means we have to
; push it at the beginning and pop it at the end.
mode2_redrawline
 FNJSR
 PUSH "R11"

 LDR R1,[R8,#w_mode2]
 STR R1,localmodeword

 MOV R11,R4			; store w_format

 LDR R0,[R8,#w_bpl]		; number of BYTES
 MOV R0,R0,LSR #2		; number of WORDS
 BL mode2_calc_width		;\X R3 = number of breaks
 TST R1,#(1:SHL:11)
 ADDEQ R4,R0,R0,LSL#3		; "xxxxxxxx "
 ADDNE R4,R0,R0,LSL#5		; "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb "
 TST R1,#(1:SHL:9)
 ADDNE R4,R4,R3			; Add " " for each break
 MOV R1,R4

 ; R1 is now the offset of where the colon sits / width of number dump
 ADD R3,R1,R6
 STR R3,localmode_colon
 SUB R2,R2,R1			; width of ascii stuff
 MOV R0,#9
 BL colour_chars		; set colour of foreground only

 PUSH "R5,R7,R10"		; save start of line
 LDR R2,[R8,#w_bpl]		; line width - number of bytes
 MOV R3,R2			; width count

 LDR R0,localmodeword		; get our mode word again
 TST R0,#(1:SHL:9)
 MOVEQ R4,#-1
 MOVNE R4,R0,LSR #24
 ANDNE R4,R4,#&F		; 'n'
 TEQ R4,#0
 MOVEQ R4,#16
 STR R4,localmoden

 TST R11,#(1:SHL:17)		; little endian?
 BNE red_c2_l1
 TST R0,#(1:SHL:11)		; binary dump?
 ADDNE R6,R6,#24
 ADDEQ R6,R6,#6			; move into place for first little endian byte

red_c2_l1
 CMP R7,R10
 BLCS red_overflow
 BVS red_c2_l4

 LDR R0,localmodeword
 TST R0,#(1:SHL:11)		; binary dump?
 BEQ red_c2_l1_hex

 ; binary

 LDRB R0,[R7],#1

 ; get background right
 PUSH "R2,R6"
 LDR R14,[R8,#w_txtw]
 ADD R6,R6,R14,LSL #1		; background area
 MOV R14,#1			; background 1
 MOV R2,#8
red_c2_l1_binbackground
 STRB R14,[R6],#1
 SUBS R2,R2,#1
 BPL red_c2_l1_binbackground
 PULL "R2,R6"

 BL bin8			; write eight char bin, r6 updated by 8
 B red_c2_l1_afterwrite

red_c2_l1_hex
 LDRB R0,[R7],#1
 BL storebackgroundforhex2	; background for two char hex (3 chars)
 BL hex2			; write two char hex, r6 updated by 2

red_c2_l1_afterwrite
 SUB R0,R7,R5			; file offset
 TST R0,#3			; is next byte at start of a word?
 BLEQ red_c2_eow		; do end of word stuff
 TST R11,#(1:SHL:17)
 BNE red_c2_l6			; big endian
 ; little endian, so have to move backwards
; SUB R0,R7,R5			; reload because red_c2_eow corrupts r0
 TST R0,#3
 MOVEQ R0,#12			; next word (move to end since little endian)
 MOVNE R0,#-4			; still in current, so move backwards

 ; I appear to have run out of registers :-(
 LDR R11,localmodeword
 TST R11,#(1:SHL:11)
 LDR R11,[R8,#w_format]

 ADDEQ R6,R6,R0			; hex
 ADDNE R6,R6,R0,LSL#2		; binary

red_c2_l6
 SUBS R3,R3,#1			; next byte
 BHI red_c2_l1
 B red_c2_l3_pre

red_c2_eow			; inc r6 and do word groups
 STMFD R13!,{R0,R1,R14}		; store the ones we corrupt
 ADD R6,R6,#1

 ; word groups
 SUB R4,R4,#1			; one word done
 CMP R4,#0
 MOVLT R4,#-1			; so it doesn't underflow
 LDMNEFD R13!,{R0,R1,PC}

 LDR R0,[R8,#w_txtw]
 ADD R0,R6,R0,LSL#1		; background position
 MOV R4,#0			; background colour 0

 TST R11,#(1:SHL:17)
 STRNEB R4,[R0,#-1]		; overwrite bg col 1 trailing
 BNE red_c2_eow_done

 LDR R1,localmodeword
 TST R1,#(1:SHL:11)
 STREQB R4,[R0,#5]		; hex (6 out from -1)
 STRNEB R4,[R0,#23]		; binary (24 out from -1)

red_c2_eow_done
 ADD R6,R6,#1			; " " - group separator
 LDR R4,localmoden		; reset

 LDMFD R13!,{R0,R1,PC}
;red_c2_eow			; inc r6 and do word groups
; STMFD R13!,{R0,R14}		; the only one we corrupt
; ADD R6,R6,#1
;
; ; word groups
; SUB R4,R4,#1			; one word done
; CMP R4,#0
; MOVLT R4,#-1			; so it doesn't underflow
; LDMNEFD R13!,{R0,PC}
;
; LDR R0,[R8,#w_txtw]
; ADD R0,R6,R0,LSL#1		; background position
; MOV R4,#0			; background colour 0
; STRB R4,[R0,#-1]		; overwrite bg col 1 trailing
;
; ADD R6,R6,#1			; " " - group separator
; LDR R4,localmoden		; reset
;
; LDMFD R13!,{R0,PC}

red_c2_l3_pre
 LDR R6,localmode_colon		; simplest way of getting there

red_c2_l3
 PULL "R5,R7,R10"		; get start of line
 MOV R3,R2			; width count

 LDR R0,[R8,#w_txtw]
 ADD R0,R6,R0,LSL #1		; background position
 MOV R4,#0			; background colour 0
 STRB R4,[R0,#-1]		; overwrite bg col 1 trailing

 BL colon			; write colon

 LDR R0,localmodeword		; get our mode word again
 TST R0,#(1:SHL:10)
 MOVEQ R4,#-1			; no breaks in this case
 MOVNE R4,R0,LSR #24
 ANDNE R4,R4,#&F
 TEQ R4,#0
 MOVEQ R4,#16
 MOV R4,R4,LSL#2		; in this case we're counting in bytes
 STR R4,localmoden

 PUSH "R4"			; store temp n
 MOV R4,R0			; local mode word

red_c2_l2
 CMP R7,R10
 BLCS red_overflow
 BVS red_c2_l5
 LDRB R0,[R7],#1

 CMP R0,#32			; is it a ctrl char?
 BGE red_c2_l2_writechar
 TST R4,#(1:SHL:8)		; are we replacing them?
 BEQ red_c2_l2_writechar

 MOV R0,#8			; write the 'ctrl char' colour
 LDR R1,[R8,#w_txtw]		; width of a cache line
 STRB R0,[R6,R1]		; store in foreground colour section

 MOV R0,R4,LSR #16
 AND R0,R0,#&FF			; replace with configured char

red_c2_l2_writechar
 STRB R0,[R6],#1		; write ascii char

 ; byte groups
 PULL "R0"
 SUB R0,R0,#1
 CMP R0,#0
 MOVLT R0,#-1			; so it doesn't underflow
 BNE red_c2_l2_no_group

 CMP R3,#1			; if we're going to stop here,
 BLS red_c2_l2_no_group		; don't write a break

 ADD R6,R6,#1			; " "
 LDR R0,localmoden		; reset

red_c2_l2_no_group
 PUSH "R0"
 LDR R4,localmodeword		; ready for the next pass

 SUBS R3,R3,#1
 BHI red_c2_l2

red_c2_l5
 PULL "R0"			; discard final bit
 PULL "R11"			; get R11
 ADD R11,R11,#1			; next log line
 FNRTSS				; return without error

red_c2_l4
 LDR R6,localmode_colon		; move to place to put colon
 ADDS R6,R6,#0			; clv
 B red_c2_l3			; ascii bit

mode2_lineoff
 FNJSR "R2-R6"
 LDR R4,[R8,#w_mode2]

 TST R4,#(1:SHL:11)		; binary or hex number dump
 MOVEQ R5,#9
 MOVNE R5,#33

 SUB R0,R1,R0			; offset of char in line
 MOV R0,R0,LSR#2		; convert into words

 MOV R1,R4,LSR #24
 ANDS R1,R1,#&F			; n
 MOVEQ R1,#16

 MOV R6,R0			; saved

 SWI XZapRedraw_Divide ; BL div_mod	; R0=phy line R2=col byte offset
 ;MOV R3,R0
 ;DIVIDE R3,R4,R1,R6		; R6 scratch
 ;MOV R3,R1			; (x/n)
 MOV R3,R0
 MUL R0,R5,R6			; {9,33} * x

 TST R4,#(1:SHL:9)
 ADDNE R0,R3,R0			; {9,33} * x + {1,0} * x/n

 SUB R1,R5,#1			; width of cursor
 FNRTS

;E R1 offset, R2 num, R6 buffer
storebackgroundforhex2
 FNJSR "R2,R6"
 LDR R14,[R8,#w_txtw]
 ADD R6,R6,R14,LSL #1
 MOV R14,#1
 MOV R2,#2
aloop$l
 STRB R14,[R6],#1
 SUBS R2,R2,#1
 BPL aloop$l
 FNRTS

mode2_linecol
 FNJSR "R1-R7"
 LDR R4,[R8,#w_mode2]
 MOV R2,#8			; hex width
 MOV R3,#4			; in bytes
 B modes_linecol_breaks		; sort it all out

mode2_plus
 MVN R2,#0
 ADD R1,R1,#4
 MOV PC,R14

mode2_minus
 MVN R2,#0
 SUB R1,R1,#4
 MOV PC,R14

mode2_aligncaret
 FNJSR
 LDR R0,[R10,#c_off]
 BIC R0,R0,#3
 STR R0,[R10,#c_off]
 BL mode1_aligncaret
 FNRTS

mode2_copy
 TEQ R0,#2
 MOVEQ R0,#1
 MOVEQ PC,R14			; ask copy to enter the text automatically
 STMFD R13!,{R1,R4-R7,R14}
 MOV R2,R1			; save number of times
 FNLDR R0,wimp_kbdbuf		; output buffer
 MOV R1,R2,LSL#2
 BL heap_ensure
 LDMVSFD R13!,{R1,R4-R7,PC}
 FNSTR R0,wimp_kbdbuf
 MOV R3,R0			; buffer
 MOV R4,#0			; number typed
 LDR R7,[R10,#c_off]		; file offset
 LDR R6,[R9,#f_len]		; end of file
co29
 CMP R7,R6
 BCS co30
 MOV R0,R7
 BL cln_readw
 STR R0,[R3,R4,LSL#2]
 ADD R7,R7,#4
 ADD R4,R4,#1
 CMP R4,R2
 BLT co29
co30
 MOV R2,R4,LSL#2		; number actually typed
 STR R7,[R10,#c_off]
 BL reflect_caret
 LDMFD R13!,{R1,R4-R7,PC}

; R4=w_flags R5=num bytes R6=w_format R7=data R8/R9/R10=input caret

mode2_char
 FNJSR
 TST R4,#1<<5			; is it in ascii mode
 FNRTS EQ
 FNLDR R0,car_hexold
 FNSTR R0,car_hex
 LDR R6,[R8,#w_mode2]
in30
 TST R6,#(1:SHL:11)
 BNE in34			; binary

 LDRB R0,[R7]
 BL hex_char
 BCS in31			; char no good
 ADR R14,k_char_w1
 STR R0,[R14]			; save the char
 FNLDR R0,car_hex
 TEQ R0,#0			; entering first nibble?
 BNE in32			; wrap round

 LDR R0,[R9,#f_len]
 BIC R0,R0,#3			; round down length
 LDR R1,[R10,#c_off]
 CMP R1,R0
 MOV R0,#&14			; replace block no inc
 MOVCS R0,#&11			; cursor at end of file

 TST R4,#2
 MOVEQ R0,#&11			; insert not overtype

 TEQ R0,#&11
 MVNEQ R11,#3			; -4 change
 MOVNE R11,#0			; set up caret change
 B in33

in32				; rotate and add new nibble
 LDR R0,[R10,#c_off]
 BIC R0,R0,#3			; nearest word
 BL cln_readw
 MOV R1,R0,LSL#4		; shift the lower nibbles
 ADR R14,k_char_w1
 LDR R0,[R14]
 ORR R0,R1,R0			; insert the new lowest nibble
 STR R0,[R14]			; return to buffer
 MOV R0,#&14			; replace block no inc
 MOV R11,#0			; no caret change

in33				; do alteration
 ADR R3,k_char_w1
 STMFD R13!,{R0,R6}
 LDR R6,[R8,#w_format]
 LDR R0,[R3]

 TST R6,#1<<17			; endianness
 BLNE reverse_word
 STR R0,[R3]

 LDMFD R13!,{R0,R6}		; restore

 LDR R1,[R10,#c_off]		; at the cursor
 BIC R1,R1,#3			; nearest word
 MOV R2,#4			; one byte
 BL execute_command		; do it
 FNRTS VS

 TST R6,#(1:SHL:11)		; binary
 BNE in37

 FNLDR R0,car_hex
 ADD R0,R0,#1
 ANDS R0,R0,#7
 FNSTR R0,car_hex		; update nibble position
 MOVEQ R11,#4			; inc cursor if start of new

in36				; update caret
 TEQ R11,#0
 BEQ in31			; carry on
 LDR R0,[R10,#c_off]
 ADD R0,R0,R11			; inc after last nibble, or dec
 STR R0,[R10,#c_off]		; if insert first nibble
 BL reflect_caret
 FNRTS VS
in31				; go on to next character
 ADD R7,R7,#1
 SUBS R5,R5,#1
 BGT in30			; do next char
 BL make_cursor_visible
 FNRTS

in34				; binary entry
 LDRB R0,[R7]
 ADR R14,k_char_w1
 CMP R0,#'0'
 BLT in31			; bad binary character
 MOVEQ R1,#0
 STREQ R1,[R14]
 CMP R0,#'1'
 BGT in31			; bad binary character
 MOVEQ R1,#1
 STREQ R1,[R14]

 FNLDR R0,car_hex
 TEQ R0,#0			; entering first bit?
 BNE in35

 LDR R0,[R9,#f_len]
 BIC R0,R0,#3			; round down length
 LDR R1,[R10,#c_off]
 CMP R1,R0
 MOV R0,#&14			; replace block no inc
 MOVCS R0,#&11			; cursor at end of file

 TST R4,#2
 MOVEQ R0,#&11			; insert not overtype

 TEQ R0,#&11
 MOVEQ R11,#-4			; -4 change
 MOVNE R11,#0
 B in33				; do it

in35				; rotate and add new bit
 LDR R0,[R10,#c_off]
 BIC R0,R0,#3			; nearest word
 BL cln_readw			; \X R0 = word at cursor
 MOV R1,R0,LSL #1		; shift the lower bits
 ADR R14,k_char_w1
 LDR R0,[R14]
 ORR R0,R1,R0			; insert the new lowest bit
 STR R0,[R14]			; return to buffer
 MOV R0,#&14			; replace block no inc
 MOV R11,#0			; no caret change
 B in33

in37				; update bit position
 FNLDR R0,car_hex
 ADD R0,R0,#1
 ANDS R0,R0,#31
 FNSTR R0,car_hex
 MOVEQ R11,#4			; inc cursor if start of new
 B in36

k_char_w1	    DCD 0

; ; R4=w_flags R5=num bytes R6=w_format R7=data R8/R9/R10=input caret
;
; mode2_char
;  FNJSR
;  TST R4,#1<<5			; is it in ascii mode
; ; BEQ mode3_char		; causes a prefetch abort???
;  FNRTS EQ
;  FNLDR R0,car_hexold
;  FNSTR R0,car_hex
; in30
;  LDRB R0,[R7]
;  BL hex_char
;  BCS in31			; char no good
;  ADR R14,k_char_w1
;  STR R0,[R14]			; save the char
;  FNLDR R0,car_hex
;  TEQ R0,#0
;  BNE in32			; wrap round
;  LDR R0,[R9,#f_len]
;  BIC R0,R0,#3			; round down length
;  LDR R1,[R10,#c_off]
;  CMP R1,R0
;  MOV R0,#&14			; replace block no inc
;  MOVCS R0,#&11
;  TST R4,#2
;  MOVEQ R0,#&11			; insert
;  TEQ R0,#&11
;  MVNEQ R11,#3			; -4 change
;  MOVNE R11,#0			; set up caret change
;  B in33
; in32
;  LDR R0,[R10,#c_off]
;  BIC R0,R0,#3			; nearest word
;  BL cln_readw
;  MOV R1,R0,LSL#4
;  ADR R14,k_char_w1
;  LDR R0,[R14]
;  ORR R0,R1,R0
;  STR R0,[R14]
;  MOV R0,#&14			; replace block no inc
;  MOV R11,#0
; in33
;  ADR R3,k_char_w1
;  STMFD R13!,{R0}
;  LDR R0,[R3]
;  TST R6,#1<<17
;  BLNE reverse_word
;  STR R0,[R3]
;  LDMFD R13!,{R0}
;  LDR R1,[R10,#c_off]
;  BIC R1,R1,#3
;  MOV R2,#4
;  BL execute_command
;  FNRTS VS
;  FNLDR R0,car_hex
;  ADD R0,R0,#1
;  ANDS R0,R0,#7
;  FNSTR R0,car_hex
;  MOVEQ R11,#4			; inc cursor
;  TEQ R11,#0
;  BEQ in31			; carry on
;  LDR R0,[R10,#c_off]
;  ADD R0,R0,R11
;  STR R0,[R10,#c_off]
;  BL reflect_caret
;  FNRTS VS
; in31
;  ADD R7,R7,#1
;  SUBS R5,R5,#1
;  BGT in30			; do next char
;  BL make_cursor_visible
;  FNRTS
;
; k_char_w1	    DCD 0

mode2_return
 FNJSR
 TEQ R0,#0
 BNE inmode4_return
inmode2_return
 ADR R0,mo_s0			; command to execute
 ORR R0,R0,#1 << 31		; don't learn
 BL command_string
 FNRTS
mo_s0
 FNS ("EDITWORD")

 LOCAL

; R5=num bytes R7=del type R8-R10=input caret

mode2_delete
 FNJSR
 MOV R5,R5,LSL#2		; each delete is 4 bytes
 BL word_align_caret
 BLVC mode1_delete
 FNRTS

mode2_end
 MOV R0,#2
 B modes_end

mode2_start
 MOV R0,#2
 B modes_start

mode2_returnword
; LDR R0,[R10,#c_off]
 BIC R0,R0,#3 ; round down to nearest word
 MOV R1,#4 ; one word long
 MOV PC,R14

 LOCAL

mode2_interrogate
 CMP R0,#14			; what sort of mode?
 CMPNE R0,#12			; line select?
 CMPNE R0,#13			; SAYT
 CMPNE R0,#23			; block editing?
 MOVEQ R0,#0			; binary
 CMPNE R0,#11			; elaborate font sub-style processing?
 MOVEQ PC,R14			; nope

 CMP R0,#2			; softwrap
 CMPNE R0,#5			; ConfineH
 CMPNE R0,#6			; ConfineV
 CMPNE R0,#7			; Free click
 CMPNE R0,#8			; Smart cursors
 MOVEQ R0,#-1			; none of the above

 CMP R0,#3			; what width is wanted for this mode?
 BEQ whatwidthplease		; divide by 4 (so it's in words)

 TEQ R0,#16			; binary
 BEQ binarytest$l
 CMP R0,#0			; what width is this window-wrapped window?
 MOVNE PC,R14

 SUB R1,R1,#2			; colon
 FNJSR "R4"			; store our R14, R4
 ADR R14,return$l		; where we come back to
 STMFD R13!,{R1-R3,R5-R7,R14}	; stack for procedure
 LDR R4,[R8,#w_mode2]
 MOV R2,#8			; hex width
 MOV R3,#4			; in bytes
 B modes_interrogate_width

return$l
 STR R4,[R8,#w_mode2]		; store result
 FNRTS

whatwidthplease			; \E R1=w_bpl, \X R0=width to send to e_setwidth
 MOV R0,R1,LSR#2
 MOV PC,R14

binarytest$l
 LDR R0,[R8,#w_mode2]		; load in our mode word
 TST R0,#1 << 11		; binary?
 MOVNE R0,#2
 MOVEQ R0,#16
 MOV PC,R14

 END
