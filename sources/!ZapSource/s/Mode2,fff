; Contains mode entry points for word and similar modes.
; $Id: Mode2,fff,v 1.1.2.8 1999/04/24 01:24:08 ds Exp $

 GET h.ZapHeader
 GET h.Commands
 GET h.Execute
 GET h.Mode0
 GET h.Mode1
 GET h.Mode3
 GET h.Mode4
 GET h.AlterTxt
 GET h.ModeBits
 GET h.MiniBuff
 GET h.Menus
 GET h.Redraw
 GET h.Strings
 GET h.Heap
 GET h.KeyBits
 GET h.Cursors

 EXPORT mode_table_2
 EXPORT mode2_minus
 EXPORT mode2_plus
 EXPORT mode2_copy
 EXPORT mode2_aligncaret
 EXPORT storebackgroundforhex2
 EXPORT inmode2_return
 EXPORT mode2_returnword

 EXPORT CmdWORDctrlreplace
 EXPORT CmdWORDflagstoggle
 EXPORT CmdWORDgroupsize

mode_table_2
 DCD mode_table_2
 DCD mode2_title
 DCD mode1_author
 DCD 1
 DCD 2+emode_BinaryMode+emode_UsesMessageTrans+emode_MayBeCloned
 DCD mode2_init
 DCD 0
 DCD mode2_table_end-mode_table_2

 DCD 0                          ; postload
 DCD 0
 DCD 0
 DCD modes_start
 DCD modes_end
 DCD mode2_width
 DCD mode2_linecol
 DCD mode2_lineoff
 DCD 0
 DCD 0
 DCD 0
 DCD 0
 DCD mode2_minus
 DCD mode2_plus
 DCD mode2_minus
 DCD mode2_plus
 DCD mode1_cminus
 DCD mode1_cplus
 DCD mode2_redrawline
 DCD 0
 DCD mode2_char
 DCD mode2_delete
 DCD 0
 DCD mode2_return
 DCD 0
 DCD 0
 DCD mode1_linestart
 DCD mode1_lineend
 DCD mode1_lineend
 DCD mode1_linestart
 DCD mode2_copy
 DCD 0
 DCD 0
 DCD mode2_aligncaret
 DCD command_primative
 DCD 0
 DCD 0
 DCD 0
 DCD 0                  ; runandquit
 DCD 0
 DCD 0
 DCD replace_area ; 0
 DCD 0                  ; selection
 DCD modes_click        ; click
 DCD 0                  ; messages
 DCD mode4_setwidth
 DCD 0                  ; list fns
 DCD mode0_prevline
 DCD 0                  ; Open window
 DCD mode2_interrogate  ; Answer all Zap's questions...
 DCD mode2_returnword   ; for SG etc...
mode2_table_end

mode2_title
 FNS ("Word")

mode2_init
 FNJSR "R2"
 ADR R2,mode2_init_data
 BL mode1_2_init
 FNRTS

mode2_init_data
        =       2               ; mode number
        =       12              ; menu number
        ALIGN
        &       &042E0200       ; default_mode_word
                                ; 4 words to a group (16 bytes),
                                ; group in number dump,
                                ; and '.' as (disabled)
                                ; control char replacement
mode2_cols
 = "zap_m_bytecols",0
 ALIGN

 LOCAL

 DCD c_NoR8 :OR: c_NoR9 :OR: c_Param_String :OR: c_PreMinibuffer :OR: c_CanSetupMenu
CmdWORDgroupsize
 ADR R3,data$l
 B CmdBYTEWORDgroupsize

data$l
        =       2       ; mode number
        =       1       ; default group size
        ALIGN
        &       miniprompt$l-data$l
        &       menutitle$l-data$l

miniprompt$l    = "zap_p_wordgroupsize", 0
menutitle$l     = "zap_m_groupsize", 0
        ALIGN

 DCD c_NoR8 :OR: c_NoR9 :OR: c_Param_String :OR: c_PreMinibuffer :OR: c_CanSetupMenu
CmdWORDctrlreplace
 MOV R1,#2                      ; mode number
 B CmdBYTEWORDctrlreplace

 LOCAL

 DCD c_NoR8 :OR: c_NoR9 :OR: c_Param_Words :OR: c_DecrementR1 :OR: c_TickableMenuEntry
                                ; I'm lazy, and so multiple words only get done singly
CmdWORDflagstoggle
 MOV R1,#2                      ; mode number
 B CmdBYTEWORDflagstoggle

mode2_width
 FNJSR "R1-R7"
 MOV R2,#0
 BL modes_getmodeword

 LDRB R5,[R8,#w_format]
 ADD R7,R8,#w_mode0
 LDR R5,[R7,R5,LSL #2]!         ; update R7 as base ...
 AND R14,R5,#mode2_Type
 BIC R5,R5,#&FF

 MOV R0,R0,LSL#16
 MOV R0,R0,LSR#16               ; bottom 16 bits
 CMP R0,#&FF
 MOVGT R0,#&FF
 CMP R0,#1
 MOVLT R0,#1
 MOV R6,R0

 TEQ R14,#mode2_Type_Word
 MOVEQ R14,R0,LSL#2		; 4*R0=num of bytes
 MOVNE R14,R0,LSL#1		; 2*R0=num of bytes
 STR R14,[R8,#w_bpl]

 MOV R1,R5,LSR #24
 ANDS R1,R1,#&F                 ; r2 = 'n'
 MOVEQ R1,#16
 ; R14 = #bytes, R0 = #words, R1 = mode word
 ; n, k want to be in words

 SWI XZapRedraw_Divide ; BL div_mod     ; R0=phy line R2=col byte offset

 CMP R2,#0
 ADDGT R0,R0,#1 ; remainder...

 CMP R0,#&0
 MOVLE R0,#1
 CMP R0,#&FF
 MOVHI R0,#&FF                  ; more than this is not permitted

 ORR R1,R5,R0                   ; put the DIV value in
 STR R1,[R7]

; MOV R1,R5                     ; mode word...
 MOV R0,R6                      ; as preserved above...

 BL mode2_calc_width
 MOV R0,R2                      ; result

 FNRTS

; \E R0 = words per line, R1 = mode word
; \X R2 = width in characters needed, R0,R1 preserved
;    R3 is "corrupted" (number of breaks - ie number of groups - 1)
mode2_calc_width
 FNJSR "R0,R4"

 AND R3,R1,#mode2_NumberOfGroups
 SUB R3,R3,#1                   ; # breaks

 MOV R2,#0
 TST R1,#mode2_GroupNumberDump
 ADDNE R2,R2,R3                 ; 1 * = " "

 TST R1,#mode2_GroupASCIIDump
 ADDNE R2,R2,R3                 ; 1 * = " "

 LDRB R14,[R8,#w_format]
 ADD R14,R8,R14,LSL #2
 LDR R14,[R14,#w_mode0]
 ANDS R14,R14,#mode2_Type
 ADDEQ R4,R2,R0,LSL#2		; ascii bit (4 chs/wd) plus breaks
 ADDNE R4,R2,R0,LSL#1		;	 or (2 chs/wd) plus breaks
 MOVEQ R2,#5			; 33 or 9 (word)
 MOVNE R2,#4			; 17 or 5 (half word)

 TST R1,#mode2_BinaryNumberDump
 SUBEQ R2,R2,#2
 ADD R0,R0,R0,LSL R2		; R0*(width + space)

 ADD R0,R0,#2                   ; colon
 ADD R2,R4,R0                   ; add it all together

 FNRTS

localmodeword
 DCD &0                         ; temp storage space
localmoden
 DCD &0
localmode_colon
 DCD &0                         ; where the colon sits

; Probably best to look at the byte mode redraw to get a good handle
; on how all this works - sja
; NB: R11 stores w_format during processing. This means we have to
; push it at the beginning and pop it at the end.
mode2_redrawline
 FNJSR
 PUSH "R11"

 LDRB R1,[R8,#w_format]
 ADD R14,R8,#w_mode0
 LDR R1,[R14,R1,LSL #2]
 STR R1,localmodeword

 MOV R11,R4                     ; store w_format

 ANDS R14,R1,#mode2_Type
 LDR R0,[R8,#w_bpl]             ; number of BYTES
 MOVEQ R0,R0,LSR #2		; number of WORDS
 MOVNE R0,R0,LSR #1		; number of HALFWORDS
 BL mode2_calc_width            ;\X R3 = number of breaks
 ANDS R14,R1,#mode2_Type
 MOVEQ R4,#5			; 8 hex digits, 32 binary digits
 MOVNE R4,#4			; 4 hex digits, 16 binary digits
 TST R1,#mode2_BinaryNumberDump
 SUBEQ R4,R4,#2			; not binary - divide by 4
 ADD R4,R0,R0,LSL R4
 TST R1,#mode2_GroupNumberDump
 ADDNE R4,R4,R3                 ; Add " " for each break
 MOV R1,R4

 ; R1 is now the offset of where the colon sits / width of number dump
 ADD R3,R1,R6
 STR R3,localmode_colon
 SUB R2,R2,R1                   ; width of ascii stuff
 MOV R0,#9
 BL colour_chars                ; set colour of foreground only

 PUSH "R5,R7,R10"               ; save start of line
 LDR R2,[R8,#w_bpl]             ; line width - number of bytes
 MOV R3,R2                      ; width count

 LDR R0,localmodeword           ; get our mode word again
 TST R0,#mode2_GroupNumberDump
 MOVEQ R4,#-1
 MOVNE R4,R0,LSR #24
 ANDNE R4,R4,#&F                ; 'n'
 TEQ R4,#0
 MOVEQ R4,#16
 STR R4,localmoden

 TST R11,#format_BigEndian
 BNE red_c2_l1
 ANDS R14,R0,#mode2_Type
 BNE red_c2_halfword
 ; word
 TST R0,#mode2_BinaryNumberDump
 ADDNE R6,R6,#24
 ADDEQ R6,R6,#6                 ; move into place for first little endian byte
 B red_c2_l1
red_c2_halfword
 TST R0,#mode2_BinaryNumberDump
 ADDNE R6,R6,#8
 ADDEQ R6,R6,#2                 ; move into place for first little endian byte

red_c2_l1
 CMP R7,R10
 BLCS red_overflow
 BVS red_c2_l4

 LDR R0,localmodeword
 TST R0,#mode2_BinaryNumberDump
 BEQ red_c2_l1_hex

 ; binary

 LDRB R0,[R7],#1

 ; get background right
 PUSH "R2,R6"
 LDR R14,[R8,#w_txtw]
 ADD R6,R6,R14,LSL #1           ; background area
 MOV R14,#1                     ; background 1
 MOV R2,#8
red_c2_l1_binbackground
 STRB R14,[R6],#1
 SUBS R2,R2,#1
 BPL red_c2_l1_binbackground
 PULL "R2,R6"

 BL bin8                        ; write eight char bin, r6 updated by 8
 B red_c2_l1_afterwrite

red_c2_l1_hex
 LDRB R0,[R7],#1
 BL storebackgroundforhex2      ; background for two char hex (3 chars)
 BL hex2                        ; write two char hex, r6 updated by 2

red_c2_l1_afterwrite
 LDR R14,localmodeword
 SUB R0,R7,R5                   ; file offset
 ANDS R14,R14,#mode2_Type
 MOVEQ R14,#3			; word align
 MOVNE R14,#1			; half word align
 TST R0,R14			; is next byte at start of a word?
 BLEQ red_c2_eow                ; do end of word stuff
 TST R11,#format_BigEndian
 BNE red_c2_l6                  ; big endian
 ; little endian, so have to move backwards
; SUB R0,R7,R5                  ; reload because red_c2_eow corrupts r0
 LDR R14,localmodeword
 ANDS R14,R14,#mode2_Type
 BNE red_c2_l1_afterwrite_halfword
 ; word
 TST R0,#3
 MOVEQ R0,#12                   ; next word (move to end since little endian)
 MOVNE R0,#-4                   ; still in current, so move backwards
 B red_c2_l1_afterwrite_gotmove
red_c2_l1_afterwrite_halfword
 TST R0,#1
 MOVEQ R0,#4                    ; next word (move to end since little endian)
 MOVNE R0,#-4                   ; still in current, so move backwards

red_c2_l1_afterwrite_gotmove
 ; I appear to have run out of registers :-(
 LDR R11,localmodeword
 TST R11,#mode2_BinaryNumberDump
 LDR R11,[R8,#w_format]

 ADDEQ R6,R6,R0                 ; hex
 ADDNE R6,R6,R0,LSL#2           ; binary

red_c2_l6
 SUBS R3,R3,#1                  ; next byte
 BHI red_c2_l1
 B red_c2_l3_pre

red_c2_eow                      ; inc r6 and do word groups
 STMFD R13!,{R0,R1,R14}         ; store the ones we corrupt
 ADD R6,R6,#1

 ; word groups
 SUB R4,R4,#1                   ; one word done
 CMP R4,#0
 MOVLT R4,#-1                   ; so it doesn't underflow
 LDMNEFD R13!,{R0,R1,PC}

 LDR R0,[R8,#w_txtw]
 ADD R0,R6,R0,LSL#1             ; background position
 MOV R4,#0                      ; background colour 0

 TST R11,#format_BigEndian
 STRNEB R4,[R0,#-1]             ; overwrite bg col 1 trailing
 BNE red_c2_eow_done

 LDR R1,localmodeword
 ANDS R14,R1,#mode2_Type
 BNE red_c2_eow_halfword
 ; word
 TST R1,#mode2_BinaryNumberDump
 STREQB R4,[R0,#5]              ; hex (6 out from -1)
 STRNEB R4,[R0,#23]             ; binary (24 out from -1)
 B red_c2_eow_done
red_c2_eow_halfword
 TST R1,#mode2_BinaryNumberDump
 STREQB R4,[R0,#1]              ; hex (2 out from -1)
 STRNEB R4,[R0,#7]              ; binary (8 out from -1)

red_c2_eow_done
 ADD R6,R6,#1                   ; " " - group separator
 LDR R4,localmoden              ; reset

 LDMFD R13!,{R0,R1,PC}

red_c2_l3_pre
 LDR R6,localmode_colon         ; simplest way of getting there

red_c2_l3
 PULL "R5,R7,R10"               ; get start of line
 MOV R3,R2                      ; width count

 LDR R0,[R8,#w_txtw]
 ADD R0,R6,R0,LSL #1            ; background position
 MOV R4,#0                      ; background colour 0
 STRB R4,[R0,#-1]               ; overwrite bg col 1 trailing

 BL colon                       ; write colon

 LDR R0,localmodeword           ; get our mode word again
 TST R0,#mode2_GroupASCIIDump
 MOVEQ R4,#-1                   ; no breaks in this case
 ANDNE R4,R0,#mode2_WordsPerGroup
 MOVNE R4,R4,LSR #mode2_WordsPerGroup_shift
 TEQ R4,#0
 MOVEQ R4,#16
 ANDS R14,R0,#mode2_Type	; in this case we're counting in bytes
 MOVEQ R4,R4,LSL#2		; (word)
 MOVNE R4,R4,LSL#1		; (half word)
 STR R4,localmoden

 PUSH "R4"                      ; store temp n
 MOV R4,R0                      ; local mode word

red_c2_l2
 CMP R7,R10
 BLCS red_overflow
 BVS red_c2_l5
 LDRB R0,[R7],#1

 CMP R0,#32                     ; is it a ctrl char?
 BGE red_c2_l2_writechar
 TST R4,#mode2_SuppressControlCharacters
 BEQ red_c2_l2_writechar

 MOV R0,#8                      ; write the 'ctrl char' colour
 LDR R1,[R8,#w_txtw]            ; width of a cache line
 STRB R0,[R6,R1]                ; store in foreground colour section

 AND R0,R4,#mode2_ReplacementControlChar
 MOV R0,R0,LSR #mode2_ReplacementControlChar_shift

red_c2_l2_writechar
 STRB R0,[R6],#1                ; write ascii char

 ; byte groups
 PULL "R0"
 SUB R0,R0,#1
 CMP R0,#0
 MOVLT R0,#-1                   ; so it doesn't underflow
 BNE red_c2_l2_no_group

 CMP R3,#1                      ; if going to stop here, don't write break
 ADDHI R6,R6,#1                 ; " "
 LDRHI R0,localmoden            ; reset

red_c2_l2_no_group
 PUSH "R0"
 LDR R4,localmodeword           ; ready for the next pass

 SUBS R3,R3,#1
 BHI red_c2_l2

red_c2_l5
 PULL "R0"                      ; discard final bit
 PULL "R11"                     ; get R11
 ADD R11,R11,#1                 ; next log line
 FNRTSS                         ; return without error

red_c2_l4
 LDR R6,localmode_colon         ; move to place to put colon
 ADDS R6,R6,#0                  ; clv
 B red_c2_l3                    ; ascii bit

mode2_lineoff
 FNJSR "R2-R6"
 LDRB R4,[R8,#w_format]
 ADD R14,R8,#w_mode0
 LDR R4,[R14,R4,LSL #2]
 ANDS R14,R4,#mode2_Type
 BNE mode2_lineoff_halfword

;mode2_lineoff_word
 TST R4,#mode2_BinaryNumberDump
 MOVEQ R5,#9
 MOVNE R5,#33
 SUB R0,R1,R0                   ; offset of char in line
 MOV R0,R0,LSR#2                ; convert into words

 ANDS R1,R4,#mode2_WordsPerGroup
 MOV R1,R1,LSR #mode2_WordsPerGroup_shift
 MOVEQ R1,#16

 MOV R6,R0                      ; saved

 SWI XZapRedraw_Divide ; BL div_mod     ; R0=phy line R2=col byte offset

 MOV R3,R0
 MUL R0,R5,R6                   ; {9,33} * x

 TST R4,#mode2_GroupNumberDump
 ADDNE R0,R3,R0                 ; {9,33} * x + {1,0} * x/n

 SUB R1,R5,#1                   ; width of cursor
 FNRTS

mode2_lineoff_halfword
 TST R4,#mode2_BinaryNumberDump
 MOVEQ R5,#5
 MOVNE R5,#17
 SUB R0,R1,R0                   ; offset of char in line
 MOV R0,R0,LSR#1                ; convert into words

 ANDS R1,R4,#mode2_WordsPerGroup
 MOV R1,R1,LSR #mode2_WordsPerGroup_shift
 MOVEQ R1,#16

 MOV R6,R0                      ; saved

 SWI XZapRedraw_Divide ; BL div_mod     ; R0=phy line R2=col byte offset

 MOV R3,R0
 MUL R0,R5,R6                   ; {5,17} * x

 TST R4,#mode2_GroupNumberDump
 ADDNE R0,R3,R0                 ; {5,17} * x + {1,0} * x/n

 SUB R1,R5,#1                   ; width of cursor
 FNRTS

;E R1 offset, R2 num, R6 buffer
storebackgroundforhex2
 FNJSR "R2,R6"
 LDR R14,[R8,#w_txtw]
 ADD R6,R6,R14,LSL #1
 MOV R14,#1
 MOV R2,#2
aloop$l
 STRB R14,[R6],#1
 SUBS R2,R2,#1
 BPL aloop$l
 FNRTS

mode2_linecol
 FNJSR "R1-R7"
 LDRB R2,[R8,#w_format]
 ADD R2,R8,R2,LSL #2
 LDR R2,[R2,#w_mode0]
 ANDS R2,R2,#mode2_Type
 MOVEQ R2,#8			; hex width (word)
 MOVNE R2,#4			; hex width (half word)
 MOV R3,R2,LSR #1		; in bytes
 B modes_linecol_breaks         ; sort it all out

mode2_plus
 LDRB R2,[R8,#w_format]
 ADD R2,R8,R2,LSL #2
 LDR R2,[R2,#w_mode0]
 ANDS R2,R2,#mode2_Type
 MVN R2,#0
 ADDEQ R1,R1,#4			; word
 ADDNE R1,R1,#2			; half word
 MOV PC,R14

mode2_minus
 LDRB R2,[R8,#w_format]
 ADD R2,R8,R2,LSL #2
 LDR R2,[R2,#w_mode0]
 ANDS R2,R2,#mode2_Type
 MVN R2,#0
 SUBEQ R1,R1,#4			; word
 SUBNE R1,R1,#2			; half word
 MOV PC,R14

mode2_aligncaret
 FNJSR
 LDRB R14,[R8,#w_format]
 LDR R0,[R10,#c_off]
 ADD R14,R8,R14,LSL #2
 LDR R14,[R14,#w_mode0]
 ANDS R14,R14,#mode2_Type
 BICEQ R0,R0,#3			; word align
 BICNE R0,R0,#1			; half word align
 STR R0,[R10,#c_off]
 FNPULL
 B mode1_aligncaret

mode2_copy
 TEQ R0,#2
 MOVEQ R0,#1
 MOVEQ PC,R14                   ; ask copy to enter the text automatically
 FNJSR "R1,R4-R7"
 MOV R2,R1                      ; save number of times
 LDRB R14,[R8,#w_format]
 FNLDR R0,wimp_kbdbuf           ; output buffer
 ADD R14,R8,R14,LSL #2
 LDR R14,[R14,#w_mode0]
 ANDS R14,R14,#mode2_Type
 MOVEQ R1,R2,LSL#2		; words
 MOVNE R1,R2,LSL#1		; half words
 BL heap_ensure
 FNRTS VS
 FNSTR R0,wimp_kbdbuf
 MOV R3,R0                      ; buffer
 MOV R4,#0                      ; number typed
 LDR R7,[R10,#c_off]            ; file offset
 LDR R6,[R9,#f_len]             ; end of file
 LDR R0,[R8,#w_format]
 PUSH "R0"
 BIC R0,R0,#format_BigEndian
 STR R0,[R8,#w_format]
 LDRB R14,[R8,#w_format]
 ADD R14,R8,R14,LSL #2
 LDR R14,[R14,#w_mode0]
 AND R14,R14,#mode2_Type
 PUSH "R14"
co29
 CMP R7,R6
 BCS co30
 MOV R0,R7
 BL cln_readw
 LDR R14,[R13]
 TEQ R14,#mode2_Type_Word
 STREQ R0,[R3,R4,LSL#2]		; word
 ADDEQ R7,R7,#4
 ADDNE R14,R3,R4,LSL #1		; half word
 STRNEB R0,[R14],#1
 MOVNE R0,R0,LSR #8
 STRNEB R0,[R14]
 ADDNE R7,R7,#2
 ADD R4,R4,#1
 CMP R4,R2
 BLT co29
co30
 PULL "R14"
 PULL "R0"
 TEQ R14,#mode2_Type_Word
 STR R0,[R8,#w_format]
 MOVEQ R2,R4,LSL#2		; number actually typed (from words)
 MOVNE R2,R4,LSL#1		; number actually typed (from half words)
 STR R7,[R10,#c_off]
 BL reflect_caret
 FNRTS

; R4=w_flags R5=num bytes R6=w_format R7=data R8/R9/R10=input caret

mode2_char
 FNJSR
 TST R4,#flags_HexEntry
 FNRTS EQ
 FNLDR R0,car_hexold
 FNSTR R0,car_hex
 LDRB R6,[R8,#w_format]
 ADD R6,R8,R6,LSL #2
 LDR R6,[R6,#w_mode0]
in30
 TST R6,#mode2_BinaryNumberDump
 BNE in34                       ; binary
 LDRB R0,[R7]
 BL hex_char
 BCS in31                       ; char no good
 ADR R14,k_char_w1
 STR R0,[R14]                   ; save the char
 FNLDR R0,car_hex
 TEQ R0,#0                      ; entering first nibble?
 BNE in32                       ; wrap round

in33a
 LDR R0,[R9,#f_len]
 ANDS R14,R6,#mode2_Type	; round down length:
 BICEQ R0,R0,#3			; word
 BICNE R0,R0,#1			; half word
 LDR R1,[R10,#c_off]
 CMP R1,R0
 MOV R0,#&14                    ; replace block no inc
 MOVCS R0,#&11                  ; cursor at end of file

 TST R4,#2
 MOVEQ R0,#&11                  ; insert not overtype

 ANDS R14,R6,#mode2_Type
 MOVEQ R11,#-4			; -4 change (word)
 MOVNE R11,#-2                  ; -2 change (half word)
 TEQ R0,#&11
 MOVNE R11,#0                   ; set up caret change
 B in33

in32                            ; rotate and add new nibble
 LDR R0,[R10,#c_off]
 ANDS R14,R6,#mode2_Type
 BNE in32_halfword
 BIC R0,R0,#3			; nearest word
 BL cln_readw
 B in32_got_atom
in32_halfword
 BIC R0,R0,#1			; nearest half word
 BL cln_readw
 LDR R14,[R8,#w_format]
 TST R14,#format_BigEndian	; big endian?
 MOVNE R0,R0,LSR #16		; ...yes
in32_got_atom
 MOV R1,R0,LSL#4                ; shift the lower nibbles
 ADR R14,k_char_w1
 LDR R0,[R14]
 ORR R0,R1,R0                   ; insert the new lowest nibble
 STR R0,[R14]                   ; return to buffer
 MOV R0,#&14                    ; replace block no inc
 MOV R11,#0                     ; no caret change

in33                            ; do alteration
 ADR R3,k_char_w1
 STMFD R13!,{R0,R6}
 ANDS R14,R6,#mode2_Type
 LDR R6,[R8,#w_format]
 LDR R0,[R3]
 TSTNE R6,#format_BigEndian	; big endian half word?
 MOVNE R0,R0,LSL #16		; ...yes

 TST R6,#format_BigEndian
 BLNE reverse_word
 STR R0,[R3]
 ADR R3,k_char_w1

 LDMFD R13!,{R0,R6}		; restore

 LDR R1,[R10,#c_off]            ; at the cursor
 ANDS R2,R6,#mode2_Type
 MOVEQ R2,#3			; word
 MOVNE R2,#1			; half word
 BIC R1,R1,R2			; nearest atom
 ADD R2,R2,#1			; one atom
 BL execute_command             ; do it
 FNRTS VS

 TST R6,#mode2_BinaryNumberDump
 BNE in37

 FNLDR R0,car_hex
 ANDS R14,R6,#mode2_Type
 ADD R0,R0,#1
 ANDEQ R0,R0,#7			; word
 MOVEQ R14,#4
 ANDNE R0,R0,#3			; half word
 MOVNE R14,#2
 FNSTR R0,car_hex               ; update nibble position
 TEQ R0,#0
 MOVEQ R11,R14			; inc cursor if start of new

in36                            ; update caret
 TEQ R11,#0
 BEQ in31                       ; carry on
 LDR R0,[R10,#c_off]
 ADD R0,R0,R11                  ; inc after last nibble, or dec
 STR R0,[R10,#c_off]            ; if insert first nibble
 BL reflect_caret
 FNRTS VS
in31                            ; go on to next character
 ADD R7,R7,#1
 SUBS R5,R5,#1
 BGT in30                       ; do next char
 BL make_cursor_visible
 FNRTS

in34                            ; binary entry
 LDRB R0,[R7]
 ADR R14,k_char_w1
 CMP R0,#'0'
 BLT in31                       ; bad binary character
 MOVEQ R1,#0
 STREQ R1,[R14]
 CMP R0,#'1'
 BGT in31                       ; bad binary character
 MOVEQ R1,#1
 STREQ R1,[R14]

 FNLDR R0,car_hex
 TEQ R0,#0                      ; entering first bit?
 BEQ in33a

in35                            ; rotate and add new bit
 LDR R0,[R10,#c_off]
 ANDS R14,R6,#mode2_Type
 BICEQ R0,R0,#3			; nearest word
 BICNE R0,R0,#1			; nearest half word
 BL cln_readw                   ; \X R0 = word at cursor
 MOV R1,R0,LSL #1               ; shift the lower bits
 ADR R14,k_char_w1
 LDR R0,[R14]
 ORR R0,R1,R0                   ; insert the new lowest bit
 STR R0,[R14]                   ; return to buffer
 MOV R0,#&14                    ; replace block no inc
 MOV R11,#0                     ; no caret change
 B in33

in37                            ; update bit position
 FNLDR R0,car_hex
 ANDS R14,R6,#mode2_Type
 ADD R0,R0,#1
 ANDEQ R0,R0,#31		; word
 MOVEQ R14,#4
 ANDNE R0,R0,#15		; half word
 MOVNE R14,#2
 FNSTR R0,car_hex
 TEQ R0,#0
 MOVEQ R11,R14			; inc cursor if start of new
 B in36

k_char_w1           DCD 0

mode2_return
 FNJSR
 TEQ R0,#0
 BNE inmode4_return
inmode2_return
 ADR R0,mo_s0                   ; command to execute
 ORR R0,R0,#command_DontLearn
 BL command_string
 FNRTS
mo_s0
 FNS ("EDITWORD")

 LOCAL

; R5=num bytes R7=del type R8-R10=input caret

mode2_delete
 FNJSR
 LDRB R14,[R8,#w_format]
 ADD R14,R8,R14,LSL #2
 LDR R14,[R14,#w_mode0]
 ANDS R14,R14,#mode2_Type
 MOVEQ R5,R5,LSL#2		; each delete is 4 bytes
 MOVEQ R0,#3
 MOVNE R5,R5,LSL#1		; each delete is 2 bytes
 MOVNE R0,#1
 BL word_align_caret_variable
 BLVC mode1_delete
 FNRTS

mode2_returnword
 LDRB R1,[R8,#w_format]
 ADD R1,R8,R1,LSL #2
 LDR R1,[R1,#w_mode0]
 ANDS R1,R1,#mode2_Type
 BICEQ R0,R0,#3			; round down to nearest word
 MOVEQ R1,#4			; one word long
 BICNE R0,R0,#1			; round down to nearest half word
 MOVNE R1,#2			; one half word long
 MOV PC,R14

 LOCAL

mode2_interrogate
 CMP R0,#einterrogate_ModeType
 CMPNE R0,#einterrogate_LineSelect
 CMPNE R0,#einterrogate_SpellAsYouType
 CMPNE R0,#einterrogate_BlockEdit
 MOVEQ R0,#0                    ; binary (ModeType) / "no" (others)
 CMPNE R0,#einterrogate_ElaborateSubStyles
 MOVEQ PC,R14                   ; nope

 CMP R0,#einterrogate_SoftWrap
 CMPNE R0,#einterrogate_ConfineH
 CMPNE R0,#einterrogate_ConfineV
 CMPNE R0,#einterrogate_FreeClick
 CMPNE R0,#einterrogate_SmartCursor
 MOVEQ R0,#-1                   ; none of the above

 CMP R0,#einterrogate_PreSetWidth
 BEQ whatwidthplease            ; divide by 4 (so it's in words)

 TEQ R0,#einterrogate_BinaryBase
 BEQ binarytest$l
 CMP R0,#einterrogate_WindowWrapWidth
 MOVNE PC,R14

 SUB R1,R1,#2                   ; colon
 FNJSR "R4"                     ; store our R14, R4
 ADR R14,return$l               ; where we come back to
 STMFD R13!,{R1-R3,R5-R7,R14}   ; stack for procedure
 LDRB R14,[R8,#w_format]
 ADD R14,R8,R14,LSL #2
 LDR R14,[R14,#w_mode0]
 ANDS R14,R14,#mode2_Type
 MOVEQ R2,#8			; hex width (word)
 MOVNE R2,#4			; hex width (half word)
 MOV R3,R2,LSR #1		; in bytes
 B modes_interrogate_width

return$l
 LDRB R14,[R8,#w_format]
 ADD R14,R8,R14,LSL #2
 STR R4,[R14,#w_mode0]          ; store result
 FNRTS

whatwidthplease                 ; \E R1=w_bpl, \X R0=width to send to e_setwidth
 LDRB R0,[R8,#w_format]
 ADD R0,R8,R0,LSL #2
 LDR R0,[R0,#w_mode0]
 ANDS R0,R0,#mode2_Type
 MOVEQ R0,R1,LSR#2		; word
 MOVNE R0,R1,LSR#1		; half word
 MOV PC,R14

binarytest$l
 LDRB R0,[R8,#w_format]
 ADD R0,R8,R0,LSL #2
 LDR R0,[R0,#w_mode0]           ; load in our mode word
 TST R0,#mode2_BinaryNumberDump
 MOVNE R0,#2
 MOVEQ R0,#16
 MOV PC,R14

 END
