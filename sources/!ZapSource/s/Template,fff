; Contains template/leaf window related code including redraw and subs
; uses by the Boxes file.
; $Id: Template,fff,v 2.12 2004/05/22 15:11:39 ds Exp $

 GET h.ZapHeader
 GET h.Messages
 GET h.CreateFile
 GET h.CreateWind
 GET h.AlterTxt
 GET h.Strings
 GET h.Heap
 GET h.ModuleBits
 GET h.MiniBuff
 GET h.Cursors
 GET h.Redraw
 GET h.ModeBits
 GET h.KeyBits
 GET h.Menus
 GET h.Undo
 GET h.Search
 GET h.StartCode
 GET h.Boxes
 GET h.TMTVars

 IMPORT err3
 IMPORT Cdown

 EXPORT init_templates
 EXPORT reload_templates
 EXPORT create_leaf_window
 EXPORT process_leaf_key
 EXPORT process_leaf_click
 EXPORT process_leaf_drag
 EXPORT delete_old_leafs
 EXPORT leaf_update
 EXPORT update_leaf_window
 EXPORT delete_swap_window
 EXPORT cw_indtxt
 EXPORT new_read_disc
 EXPORT create_open_leaf
 EXPORT conv_index_offs
 EXPORT close_leaf_window
 EXPORT redraw_ColourBox
 EXPORT drag_Box
 EXPORT show_authors
 EXPORT open_leaf_com
 EXPORT leaf_next_icon
 EXPORT conv_addr_sht
 EXPORT conv_sht_addr
 EXPORT call_filecore
 EXPORT read_disc
 EXPORT read_memory
 EXPORT colour_percent
 EXPORT initiate_drag
 EXPORT initiate_sprite_drag
 EXPORT conv_addr_str
 EXPORT key_to_click
 EXPORT free_font_handles
 EXPORT window_info

 EXPORT icon_getind
 EXPORT icon_getflags
 EXPORT icon_select
 EXPORT icon_alter
 EXPORT icon_clear
 EXPORT icon_redraw
 EXPORT icon_update
 EXPORT icon_drag
 EXPORT icon_get_coord
 EXPORT icon_checkcaret
 EXPORT icon_set
 EXPORT icon_buffertoken
 EXPORT icon_bufferstr
 EXPORT icon_bufferhex
 EXPORT icon_bufferhex16
 EXPORT icon_buffernum
 EXPORT icons_clear
 EXPORT icons_redraw
 EXPORT cw_buffernum
 EXPORT cw_bufferhex
 EXPORT cw_bufferstr
 EXPORT lc_buffernum
 EXPORT lc_radioon
 EXPORT lc_read


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Template index's                                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Each template has with it associated a block, usually pointed to by R7,
; called the index of the following format:
;
; #&00 Address of the window defn for this template
; #&04 Flags:	b0 => Not a menu leaf window but a static window
;		b1 => Down arrow key increases icon number
;		b2 => Up down arrow keys do not redraw all icons
;		b3 => Kill the file after saving (Save box etc)
;		b4 => Swap window after file discarded (Dying box etc)
;		b5 => Window will be deleted at next null poll
;		b7 unorthodox cursor keys...
;		b8 do give window the focus... /tab/u/d?
;		b9 don't place caret in window bg
;		   (but allow window's click handler to if it wants)
;		b10 adjuct-clicks gain the caret.
;		b11 interpret Tab/sTab as down/up
;		b12 reserved
;		b13 reserved
;		b14 reserved
;		b15 window is open (vague attempt to track this better)
;		b16-b31 Window specific (eg colour number)
; #&08 Window handle of the template / -1 if not created
; #&0C Window offset of associated Zap window (->R8) / -1 if none
; #&10 File offset of associated Zap file (->R9) / -1 if none
; #&14 Address of sub to call to create the window /0
; #&18 Address of sub to call when window clicked on /0
; #&1C Pointer to template name (for !Help)
;
; tem_list points to a list of such blocks and t_<name> gives the offset
; of a given template in the list


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Show mode authors					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;X Produce buffer containing list of authors. WB #
	FNAME	show_authors
show_authors
	FNJSR	"R1-R11"
	MOV	R0,#0			; len
	ADR	R1,au_s1
	MVN	R2,#0
	BIC	R2,R2,#&FF
	MOV	R3,#0
	BL	create_file_block	; get R9
	FNRTS	VS
	MOV	R8,#0			; no window yet
	ADR	R1,au_s0
	FNLDR	R2,wimp_kbdbuf
	MOV	R3,#kbdbuf_size
	BL	lookup_token_gs
	MOVVC	R0,R2
	ADRVS	R0,au_s0
	BL	insert_string
	FNRTS	VS
	FNADD	R7,R12,mode_store
	MOV	R6,#-1			; current mode

au10	ADD	R6,R6,#1
	CMP	R6,#max_mode
	BCS	au11			; finished
	LDR	R0,[R7],#8
	CMP	R0,#0			; no mode loaded?
	LDRGT	R5,[R7,#-4]		; linked table
	CMPGT	R5,#0
	BLE	au10			; no complied block
	MOV	R0,R6			; mode number
	FNLDR	R4,wimp_block
	MOV	R1,R4
	MOV	R2,#&80
	SWI	XOS_ConvertCardinal1
	FNRTS	VS
	MOV	R0,#&20
	MOV	R2,#&80
	BL	strstr			; clear buffer to spaces
	ADD	R1,R4,#4
	LDR	R2,[R5,#2*e_title]
	BL	strcpy			; mode name
	LDRB	R0,[R5,#d_clonebasemode]
	TEQ	R0,R6
	BEQ	au00
	BL	read_mode
	LDR	r0,arrow$l
	STR	r0,[r4,#16]
	LDR	R2,[R1,#2*e_title]
	ADD	R1,R4,#19
	B	au01
arrow$l	=	"-> "
core$l	=	"core",0
	ALIGN

au00	LDR	r2,[r5,#2*e_module]
	FNLDR	r1,env_modstart
	TEQ	r1,r2
	ADREQ	r2,core$l
	BEQ	gocp$l
	LDR	r1,[r2,#20]
	ADD	r2,r2,r1		; module help text address
	MOV	r1,#0
tab$l	LDRB	r0,[r2],#1		; find the version number
	TEQ	r0,#0
	BEQ	nover$l
	TEQ	r0,#9
	ADDNE	r1,r1,#1
	ADDEQ	r1,r1,#8
	BICEQ	r1,r1,#7
	CMP	r1,#16			; assume 16 characters (expand tabs)
	BLO	tab$l			; preceding the version number
gocp$l	ADD	r1,r4,#16
	MOV	r14,#0
cp$l	LDRB	r0,[r2],#1		; copy the version no. (max 6 chars)
	CMP	r0,#'('
	CMPNE	r0,#31
	SUBHI	r14,r14,#1		; counting down so that we can use
	CMNHI	r14,#6			; the same cond. code for both tests
	STRHIB	r0,[r1],#1
	BHI	cp$l
nover$l	ADD	r1,r4,#24
	LDR	R2,[R5,#2*e_author]

au01	BL	strcpy			; author
	MOV	R0,#&0A
	STRB	R0,[R1],#1
	MOV	R0,#0
	STRB	R0,[R1],#1
	MOV	R0,R4
	BL	insert_string
	B	au10			; onto next

au11	LDR	R0,[R9,#f_flags]
	BIC	R0,R0,#1<<3		; not altered
	ORR	R0,R0,#1<<4		; Read only
	ORR	R0,R0,#1<<8		; always
	STR	R0,[R9,#f_flags]
	BL	create_window_block
	LDR	R0,[R9,#f_len]
	BL	put_caret
	FNRTS

au_s0	FNS	("zap_m_authors")
au_s1	FNS	("Authors")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialise templates (claim buffers etc)	    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL


	FNAME	init_templates
init_templates
	FNJSR	"R1-R11"
	FNLDR	R0,tem_sprites		; free area if it exists -
	TEQ	R0,#0			; we may be reloading templates,
	BLNE	heap_free		; or something
	MOV	R0,#1			; init sprite area pointer to 1
	FNSTR	R0,tem_sprites		;  (wimp area)

	MOV	R0,#5
	ADR	R1,spr$l
	SWI	XOS_File		; get size
	ADDVC	R0,R4,#8
	BLVC	heap_claim
	BVS	badspr$l

	MOV	R10,R0
	MOV	R0,#10			; 'load sprite file'
	ADD	R0,R0,#&100
	MOV	R1,R10
	ADR	R2,spr$l
	SWI	XOS_SpriteOp
	FNSTR	R10,tem_sprites,VC	; all went well, store new pointer
	BVC	donespr$l
	ADDS	R0,R10,#0		; oops, couldn't load it, clv
	BL	heap_free		; so free buffer and ignore
badspr$l
	ADDS	R0,R0,#0		; clv

donespr$l
	MOV	R0,#5
	ADR	R1,file$l
	SWI	XOS_File		; get length in R4
	FNRTS	VS
	TST	R0,#1
	BLEQ	err$l			; file not found
	ADDVC	R0,R4,#4		; length +4
	BLVC	heap_claim		; make room for file to R0
	MOVVC	R10,R0			; save heap block
	MOVVC	R0,#&FF
	ADRVC	R1,file$l
	MOVVC	R2,R10
	MOVVC	R3,#0
	SWIVC	XOS_File		; load the file
	LDRVC	R14,[R10]
	ADDVC	R14,R14,R10
	STRVC	R14,fnthandleindex	; pointer to near first font...
	FNRTS	VS
	FNADR	R0,ext1$l		; list of templates
	MOV	R1,R10			; template file
	FNLDR	R2,env_modstart		; base of offsets
	BL	create_templates	; create the templates
	MOVVC	R0,R10
	BLVC	heap_free		; free the file
	FNRTS
ext1$l  DCD	template_list
file$l  FNS	("<":CC:|zap$|:CC:"$Templates>")
spr$l	FNS	("<":CC:|zap$|:CC:"$TileSprites>")
err$l	ERR	"zap_e_notemplates"


;E R0 = list of templates to read   R1 = template file   R2 = offsets base
;X templates unpaked to tem_list and tem_defn #
	FNAME	create_templates
create_templates
	FNJSR	"R1-R11"
	MOV	R10,R0			; save list pointer
	MOV	R11,R1			; save template file pointer
	MOV	R9,R2			; save offsets base
	BLVC	tem_count_list		; count number of templates in list
	FNSTR	R0,tem_num,VC		; store the number
	MOVVC	R0,R0,LSL#5		; number of bytes needed for tem_list
	ADDVC	R0,R0,#4		; and terminator
	BLVC	heap_claim
	FNSTR	R0,tem_list,VC		; create tem_list buffer
	MOVVC	R8,R0			; pointer to tem_list
	BLVC	tem_count_winds		; work out how much room we need
	BLVC	heap_claim
	FNSTR	R0,tem_defn,VC		; buffer for template defns
	MOVVC	R4,R0			; place to write defns
	BLVC	tem_create_winds
	FNRTS


;E R10 = list of templates
;X R0 = num of templates in list |
	FNAME	tem_count_list
tem_count_list
	FNJSR	"R10-R11"
	MOV	R11,#0			; count

te11	LDR	R0,[R10]
	TEQ	R0,#0
	MOVEQ	R0,R11
	FNRTS	EQ
	BL	tem_next
	ADD	R11,R11,#1
	B	te11


;E R10 = pointer in list of templates
;X R10 = next element of list |
	FNAME	tem_next
tem_next
	FNJSR
	MOV	R0,R10
	BL	str_len
	ADD	R0,R0,#16		; 1+3toalign+12data
	BIC	R0,R0,#3		; align
	ADD	R10,R10,R0
	FNRTS


;E R10 = template list   R11 = template data
;X R0 = number of bytes needed in total #
	FNAME	tem_count_winds
tem_count_winds
	FNJSR	"R1-R7,R10"
	MOV	R4,#0			; zero count
te12	LDR	R0,[R10]
	TEQ	R0,#0			; end of list?
	MOVEQ	R0,R4
	FNRTS	EQ
	BL	tem_find		; get hold of this template
	FNRTS	VS
	BL	tem_count_defn		; find number of bytes needed for this
	BL	tem_next
	B	te12


;E R4 = dest defns  R8 = dest index  R9 = off base
;  R10 = source index  R11 = tem file
;X templates copied into the buffers R0-R11 corrupted #
	FNAME	tem_create_winds
tem_create_winds
	FNJSR
te15	LDR	R0,[R10]
	TEQ	R0,#0
	STREQ	R0,[R8]			; finish index list
	FNRTS	EQ			; and return
	BL	tem_find		; set up R6/R7
	FNRTS	VS
	STR	R10,[R8,#28]		; save pointer to template name
	BL	tem_next		; goto next index so offsets -ve
	BL	tem_create_defn
	B	te15

	LOCAL

;E R10=list entry R11=template file
;X R7=index entry R6=wind defn / VS if not found #
	FNAME	tem_find
tem_find
	FNJSR	"R1-R2"
	ADD	R7,R11,#16		; skip header
te13	LDR	R0,[R7]
	TEQ	R0,#0
	BLEQ	err$l			; template not found
	FNRTS	VS
	ADD	R1,R7,#12		; identifier
	MOV	R2,R10			; template name
	BL	strcmp
	ADDNE	R7,R7,#24
	BNE	te13			; no match so try next one
	LDR	R0,[R7]			; file offset of window defn
	ADD	R6,R11,R0
	FNRTS
err$l	ERR	"zap_e_templatemissing"


;E R4=current count R6=window defn (may not be word aligned)
;X R4 inc by num of bytes needed. R0-R7 corrupt |
	FNAME	tem_count_defn
tem_count_defn
	FNJSR
	ADD	R1,R6,#84
	BL	read_word		; number of icons
	MOV	R5,R0			; save number of icons
	MOV	R0,R0,LSL#5		; room required for icons
	ADD	R0,R0,#88		; and window defn
	ADD	R4,R4,R0
	ADD	R1,R6,#56
	BL	read_word		; title icon flags
	ADD	R7,R6,#52		; aparent start of title icon
	BL	tem_count_icon
	ADD	R7,R6,#88		; first icon
te14	SUBS	R5,R5,#1		; previous icon
	FNRTS	MI
	ADD	R1,R7,#16
	BL	read_word		; read icon flags
	BL	tem_count_icon		; size needed for this icon
	ADD	R7,R7,#32
	B	te14


;E R4=dest defn R8=dest index R9=off base R10=next index R6=source defn
;X window defn created. R4 updated R8 updated R0-R7 corrupted |
	FNAME	tem_create_defn
tem_create_defn
	FNJSR
	STR	R4,[R8]			; address of defn
	LDR	R0,[R10,#-12]
	STR	R0,[R8,#4]		; flags
	MVN	R0,#0
	STR	R0,[R8,#8]		; window handle
	STR	R0,[R8,#12]		; window off
	STR	R0,[R8,#16]		; file off
	LDR	R0,[R10,#-8]
	CMP	R0,#0
	ADDGT	R0,R9,R0
	STR	R0,[R8,#20]		; create sub address
	LDR	R0,[R10,#-4]
	CMP	R0,#0
	ADDGT	R0,R9,R0
	STR	R0,[R8,#24]		; exec sub address
	ADD	R8,R8,#32		; next block
	ADD	R1,R6,#84
	BL	read_word		; num of icons
	MOV	R5,R0			; save number of icons
	MOV	R7,R4			; save window start
	MOV	R3,R0,LSL#5
	ADD	R3,R3,#88		; size of defn
	MOV	R1,R6			; source
	MOV	R2,R4			; dest
	ADD	R4,R4,R3		; new start of free mem
	BL	move_bytes
	LDR	R0,[R7,#56]		; title flags
	ADD	R7,R7,#52		; aparent icon start
	BL	tem_create_icon		; create title icon
	ADD	R7,R7,#36		; first icon (at+88)
te16	SUBS	R5,R5,#1
	FNRTS	MI			; finished
	LDR	R0,[R7,#16]		; flags
	BL	tem_create_icon		; create this icon
	ADD	R7,R7,#32		; move to next icon
	B	te16


;E R4=count R0=icon flags R7=icon R6=window defn (neither word aligned)
;X R4 incremented by amount needed for buffers R0-R3 corrupt
	FNAME	tem_count_icon
tem_count_icon
	FNJSR
	TST	R0,#1<<8		; is it indirected
	TSTNE	R0,#3
	FNRTS	EQ			; nothing in icon
	ADD	R1,R7,#28
	BL	read_word		; buffer length
	ADD	R0,R0,#3
	BIC	R0,R0,#3		; align
	ADD	R4,R4,R0
	ADD	R1,R7,#24
	BL	read_word		; valid string off
	CMP	R0,#10
	FNRTS	LE			; none  and no wimp sprite pointer
	ADD	R0,R6,R0		; address
	BL	str_len
	ADD	R0,R0,#4		; +1 for terminator
	BIC	R0,R0,#3		; align
	ADD	R4,R4,R0
	FNRTS


;E R0=flags R4=free space R6=source R7=icon to link R9=offset base
;X R0-R3 corrupted R4 updated
	FNAME	tem_create_icon
tem_create_icon
	FNJSR
	TST	R0,#1<<6
	BLNE	sortfonthandle$l
	FNRTS	VS
	TST	R0,#1<<8		; return if indirected
	ANDNES  R3,R0,#3		; text/sprite bits
	FNRTS	EQ			; icon empty
	LDR	R2,[R7,#20]		; buffer offset
	STR	R4,[R7,#20]		; new pointer
	ADD	R2,R6,R2		; buffer pointer
	MOV	R1,R4			; dest
	BL	strcopy			; copy string
	LDR	R0,[R7,#28]		; buffer length
	ADD	R0,R0,#3
	BIC	R0,R0,#3		; align
	ADD	R4,R4,R0		; new free space pointer
	TEQ	R3,#2
	BEQ	te17			; validation = sprite area
	LDR	R2,[R7,#24]		; validation string off
	CMP	R2,#10
	BLE	te18			; no validation string
	STR	R4,[R7,#24]		; new pointer
	ADD	R2,R6,R2		; validation string pointer
	MOV	R1,R4			; dest
	BL	strcopy
	ADD	R4,R1,#3
	BIC	R4,R4,#3		; align
	FNRTS
te17	MOV	R0,#1
	STR	R0,[R7,#24]		; force wimp sprite area
	FNRTS
te18	MOV	R0,#0
	STR	R0,[R7,#24]		; no validation string
	FNRTS


;E R0 = flags from #16 R7 = icon pointer...
;X Font handle sorted out...
sortfonthandle$l
	FNJSR	"R0-R6"
	MOV	R6,R0,LSR #24
	CMP	R6,#12			; overflow...?
	FNRTS	CS

	LDR	R14,fnthandleindex
	MOV	R1,R6,LSL#4
	ADD	R1,R1,R6,LSL#5
	ADD	R14,R14,R1
	SUB	R14,R14,#&30
	LDRB	R2,[R14]
	LDRB	R1,[R14,#1]
	ORR	R2,R2,R1,LSL #8
	LDR	R3,[R14,#4]
	LDRB	R1,[R14,#5]
	ORR	R3,R3,R1,LSL #8
	ADD	R1,R14,#8
	MOV	R4,#0
	MOV	R5,#0
	BL	findfont_if_needed
	STRVCB  R0,[R7,#19]		; font handle...
	ADRVC	R14,local_font_handles
	STRVCB  R0,[R14,R6]		; no/ maybe
	FNRTS


	FNAME	findfont_if_needed
findfont_if_needed
	FNJSR	"R1-R11"
	MOV	R9,R1
	MOV	R10,R2
	MOV	R11,R3
	MOV	R8,#0
loopa$l
	ADR	R14,local_font_handles
	LDRB	R0,[R14,R8]
	ADD	R8,R8,#1
	CMP	R8,#12			; number allowed :-(
	BEQ	readit$l
	CMP	R0,#255
	BEQ	loopa$l
	FNLDR	R1,wimp_data		; blank buffer ?
	SWI	XFont_ReadDefn
	FNRTS	VS
	CMP	R2,R10			; same X
	CMPEQ	R3,R11			; same Y
	BNE	loopa$l
	MOV	R2,R9
	BL	strCMP			; same title?
	BNE	loopa$l
	SUB	R8,R8,#1
	ADR	R14,local_font_handles
	LDRB	R0,[R14,R8]		; already found...
	FNRTS
readit$l
	FNPULL
	SWI	XFont_FindFont
	MOV	PC,R14


;  note that a maximum of 11 font handles is allowed...
	=	"WIBBLE",0,0
local_font_handles
	DCD	-1
	DCD	-1
	DCD	-1
new_local_font_handles			; <sigh>...
	DCD	-1
	DCD	-1
	DCD	-1
fnthandleindex
	DCD	0

	ALIGN


	FNAME	free_font_handles
free_font_handles
	FNJSR	"R1,R5,R6"
	MOV	R6,#11			; number allowed :-(
	ADR	R5,local_font_handles
loop1b$l
	LDRB	R0,[R6,R5]
	CMP	R0,#&FF
	SWINE	XFont_LoseFont
	FNRTS	VS
	SUBS	R6,R6,#1
	BNE	loop1b$l
	FNRTS

	LOCAL


	FNAME	set_up_new_fonts
set_up_new_fonts
	FNJSR	"R1-R10"
	MOV	R10,#11
	ADR	R8,local_font_handles
	ADR	R9,new_local_font_handles
	FNLDR	R1,wimp_block
loop$l  SUBS	R10,R10,#1
	FNRTS	MI
	LDRB	R0,[R8,R10]
	CMP	R0,#&FF
	BEQ	next$l

	SWI	XFont_ReadDefn
	SWI	XFont_LoseFont		; to avoid leaking (I think - sja)

	MOVVC	R4,#0
	MOVVC	R5,#0
	SWIVC	XFont_FindFont
	FNRTS	VS
next$l  STRB	R0,[R9,R10]
	B	loop$l

	LOCAL


	FNAME	changeto_new_fonts
changeto_new_fonts
	FNJSR	"R1-R4"
	BL	free_font_handles
	ADRVC	R0,local_font_handles
	ADRVC	R1,new_local_font_handles
	LDMVCIA R1,{R2,R3,R4}
	STMVCIA R0,{R2,R3,R4}
	FNRTS

	LOCAL


; E R1 = -> to template data
	FNAME	swapfonts_in_this_template
swapfonts_in_this_template
	FNJSR	"R1-R4,R10"
	LDR	R10,[R1,#84]
	ADD	R2,R1,#88		; first icon
loop$l  SUBS	R10,R10,#1
	FNRTS	MI
	ADD	R4,R2,R10,LSL #5	; nth icon
	LDR	R3,[R4,#16]		; icon flags
	TST	R3,#1<<6		; outline fonts?
	BEQ	nooutlinefont$l
	MOV	R0,R3,LSR #24
	BL	translatethisfonthandle$l
	BIC	R3,R3,#&FF000000
	ORR	R3,R3,R0,LSL #24
	STR	R3,[R4,#16]		; icon flags
nooutlinefont$l
	B	loop$l

translatethisfonthandle$l
	FNJSR	"R8,R9,R10"
	ADR	R8,local_font_handles
	ADR	R9,new_local_font_handles
	MOV	R10,#11
loop2$l LDRB	R14,[R8,R10]
	CMP	R14,R0
	LDREQB  R0,[R9,R10]
	FNRTS	EQ
	SUBS	R10,R10,#1
	BPL	loop2$l
	LDRB	R0,[R9]			; first font in emergency...!
	FNRTS				; problem! font not found...

	LOCAL


;E R1=address (not necessarily word aligned)
;X R0=word contents (of non aligned word) |
	FNAME	read_word
read_word
	FNJSR
	LDRB	R0,[R1]
	LDRB	R14,[R1,#1]
	ORR	R0,R0,R14,LSL#8
	LDRB	R14,[R1,#2]
	ORR	R0,R0,R14,LSL#16
	LDRB	R14,[R1,#3]
	ORR	R0,R0,R14,LSL#24
	FNRTS


;E R7=window index
;X R8=wind off/0 if none R9=file off/0 if none |
	FNAME	conv_index_offs
conv_index_offs
	LDR	R0,[R7,#12]		; wind off
	MOVS	R0,R0
	FNLDR	R8,wind_list,PL
	MOVMI	R8,#0
	ADDPL	R8,R8,R0,LSL #w_shift
	LDR	R0,[R7,#16]		; file offset
	MOVS	R0,R0
	FNLDR	R9,file_list,PL
	MOVMI	R9,#0
	ADDPL	R9,R9,R0,LSL #f_shift
	MOV	PC,R14



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CREATE A LEAF WINDOW					     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R7=index entry addr R1=0 Menu/1 o/w (R8=wind R9=file) or (R8=0 R9=file)
;X Window (re)created and contents updated. R0=window handle #
	FNAME	create_leaf_window
create_leaf_window
	FNJSR	"R1"
	LDR	R0,[R7,#8]		; window handle
	CMN	R0,#1
	BEQ	cr3			; already dead
	LDR	R0,[R7,#4]		; flags
	BIC	R0,R0,#1<<5		; don't delete at any time now
	STR	R0,[R7,#4]
	ADD	R1,R7,#8
	SWI	XWimp_DeleteWindow
	FNRTS	VS			; delete the window

cr3	MVN	R0,#0
	STR	R0,[R7,#8]		; mark deleted
	TEQ	R8,#0
	MVNEQ	R0,#0
	FNLDR	R0,wind_list,NE
	SUBNE	R0,R8,R0
	MOVNE	R0,R0,LSR#w_shift
	STR	R0,[R7,#12]		; save related window offset
	TEQ	R9,#0
	MVNEQ	R0,#0
	FNLDR	R0,file_list,NE
	SUBNE	R0,R9,R0
	MOVNE	R0,R0,LSR#f_shift
	STR	R0,[R7,#16]		; save related file offset
	BL	leaf_create
	FNRTS	VS

	LDR	R1,[R7]			; window data

	FNLDR	R14,opt_switches	; custom window tiles?
	TST	R14,#switch_CustomWindowTiles
	FNLDR	R0,tem_sprites, NE
	MOVEQ	R0,#1
	STR	R0,[R1,#64]

	SWI	XWimp_CreateWindow
	FNRTS	VS
	STR	R0,[R7,#8]		; window handle
	FNPULL
	LDR	R0,[R7,#4]
	TEQ	R1,#0
	BICEQ	R0,R0,#1
	ORRNE	R0,R0,#1		; mask in open type
	STR	R0,[R7,#4]		; save flags with opened type
	LDR	R0,[R7,#8]		; window handle
	MOV	PC,R14


;E R7=window index
;X leaf window contents updated (but icon not plotted) #
	FNAME	leaf_create
leaf_create
	FNJSR	"R1-R11"
	BL	conv_index_offs		; set up R8/R9
	LDR	R6,[R7]
	LDR	R0,[R7,#20]		; create sub (danger - processor mode crrpt?)
	CMP	R0,#0
	FNRTS	LE
	MOV	R14,PC
	MOV	PC,R0			; call the sub
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Close a leaf window						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R7=window index
;X if off menu then menu deleted / window closed (& leaf wind del) WB #
	FNAME	close_leaf_window
close_leaf_window
	FNJSR	"R1-R3"
	LDR	R0,[R7,#8]
	CMN	R0,#1
	FNRTS	EQ			; window already dead
	LDR	R0,[R7,#4]		; get flags
	BIC	R0,R0,#1<<3		; clear kill state
	BIC	R0,R0,#1<<15		; clear 'open' state
	STR	R0,[R7,#4]
	TST	R0,#1
	BNE	a$l			; not a menu window
	MVN	R1,#0
	SWI	XWimp_CreateMenu	; delete menu
	FNRTS
a$l	FNLDR	R1,wimp_block		; not off a menu
	SWI	XWimp_GetCaretPosition
	FNRTS	VS
	LDR	R0,[R1]			; window handle of window with input focus
	LDR	R14,[R7,#8]		; window handle of leaf window
	TEQ	R0,R14
	PUSH	"R7"
	BLEQ	restore_carets		; restore removed carets (in actual fact, R7 is
					; currently preserved, however the key word is
	PULL	"R7"			; 'currently' - lots happens)

b$l	LDRVC	R0,[R7,#4]		; hasn't got input focus
	ORRVC	R0,R0,#1<<5		; set 'delete when get a chance' flag
	STRVC	R0,[R7,#4]
	MOVVC	R1,#0
	ADRVCL  R2,delete_old_leafs
	BLVC	call_back		; call back to delete the window
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SET UP WINDOWS					     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R0=colour strength (0-&FF) R5=icon R6=window defn R7=window
;X icon written to with percentage in form xxx.y & icon updated #
	FNAME	colour_percent
colour_percent
	FNJSR	"R1-R2,R6"
	ADD	R6,R6,#88
	ADD	R6,R6,R5,LSL#5		; icon address
	LDR	R1,[R6,#20]		; text address
	LDR	R2,[R6,#28]		; length
	MOV	R14,#1004		; multiplier (want &FF->1000*&100)
	MUL	R0,R14,R0
	MOVS	R0,R0,LSR#8		; %*10 (ie 0-1000)
	MOVEQ	R0,#'0'
	BEQ	a$l
	SWI	XOS_ConvertInteger4	; bung in the number
	FNRTS	VS
	LDRB	R0,[R1,#-1]		; last digit
	MOV	R14,#'.'
	STRB	R14,[R1,#-1]
a$l	STRB	R0,[R1]
	MOV	R0,#0
	STRB	R0,[R1,#1]
	BL	icon_redraw
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create window subs						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=icon num R1=buffer pointer R6=window defn
;X indirected icon now points to this buffer |
	FNAME	cw_indtxt
cw_indtxt
	MOV	R0,R0,LSL#5		; icon blocks 32 bytes each
	ADD	R0,R0,#88		; offset of icon in window
	ADD	R0,R6,R0		; address of icon
	STR	R1,[R0,#20]		; indirected text
	MOV	PC,R14


;E R0=number R1=icon num R6=window defn
;X cardinal number inserted in icons indirected buffer #
	FNAME	cw_buffernum
cw_buffernum
	FNJSR	"R1-R2,R6"
	ADD	R6,R6,#88
	ADD	R6,R6,R1,LSL#5		; icon address
	LDR	R1,[R6,#20]
	LDR	R2,[R6,#28]
	SWI	XOS_ConvertInteger4
	FNRTS


;E R0=number R1=icon R6=window defn
;X hex number inserted in icons indirected buffer with & #
	FNAME	cw_bufferhex
cw_bufferhex
	FNJSR	"R1-R2,R6"
	ADD	R6,R6,#88
	ADD	R6,R6,R1,LSL#5		; icon address
	LDR	R1,[R6,#20]
	LDR	R2,[R6,#28]
	MOV	R14,#'&'
	STRB	R14,[R1],#1
	SUBS	R2,R2,#1
	SWI	XOS_ConvertHex8
	FNRTS


;E R0=string pointer/0 R1=icon R6=window defn
;X string copied into the buffer or buffer cleared if R0=0 |
	FNAME	cw_bufferstr
cw_bufferstr
	FNJSR	"R1-R4,R6"
	ADD	R6,R6,#88
	ADD	R6,R6,R1,LSL#5		; icon address
	LDR	R1,[R6,#20]		; buffer address
	MOVS	R2,R0			; source string
	STREQB  R0,[R1]			; end string if R0=0
	FNRTS	EQ
	LDR	R3,[R6,#28]		; buffer length
	MOV	R4,#&1F			; max terminating char
	BL	strmove
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PROCESS LEAF KEY SUBS						     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R0=key R5=icon with input focus R7=leaf window index
;X Action taken according to key & CS to request window be closed
;  R0-R11 corrupted
	FNAME	process_leaf_key
process_leaf_key
	FNJSR
	MOV	R1,R7
	BL	get_MiniBuf
	TEQ	R1,R7
	BEQ	mini$l			; minibuffer key
	MOV	R7,R1
	LDR	R6,[R7]			; window data
	LDR	R3,[R7,#4]		; window flags
	SUB	R14,R0,#&100		; key-&100
	MOV	R4,#1<<31		; this is an unkown key click so far
	TST	R3,#1<<11
	BEQ	nottab$l
	TEQ	R14,#&8A
	BEQ	tabdown$l
	TEQ	R14,#&9A
	BEQ	tabup$l
nottab$l
	TEQ	R0,#&1B
	BEQ	close$l			; escape so close window
	CMP	R5,#0
	BMI	maybeafkey$l		; was letter$l	; letter key
	TEQ	R14,#&8E
	BEQ	down$l
	TEQ	R14,#&8F
	BEQ	up$l
	TEQ	R14,#&9E
	TEQNE	R14,#&AE
	BEQ	sdown$l
	TEQ	R14,#&9F
	TEQNE	R14,#&AF
	BEQ	sup$l
	TEQ	R14,#&8A
	MOVEQ	R0,#9			; change tab key to 9 (ctrl I)
	TEQ	R0,#&0D			; enter
	BEQ	enter$l
	CMP	R0,#&100
	BCC	letter$l		; pass key to window
unknown$l
	SUB	R14,R0,#&100
	CMP	R14,#&80
	BCC	passon$l
	CMP	R14,#&CA
	BCC	fkey$l			; passon$l
	CMP	R14,#&CC
	BCC	end$l			; don't pass on F10/F11 (but do F12)
passon$l
	SWI	XWimp_ProcessKey
	B	end$l

mini$l	BL	process_minibuffer_key  ; closes the window itself
	FNRTS	VS			; pass back minibuffer errors!!!

end$l	CLC				; leave open
	FNRTS

enter$l	MOV	R0,#101			; inkey M
	BL	test_forkey
	MOVCS	R0,#'M'
	BCS	letter$l
	MOV	R4,#1			; adjust click instead
	MVN	R0,#0
	B	fromreturn$l

close$l	SEC
	FNRTS

maybeafkey$l
	CMP	R0,#&80
	BCS	fkey$l
letter$l
	CMP	R0,#&20
	ADDCC	R0,R0,#&40		; map ctrl-A to A & 'ctrl-\' to '\'
	CMP	R0,#'A'
	BCC	unknown$l
	CMP	R0,#'a'
	SUBCS	R0,R0,#'a'-'A'
	CMP	R0,#&60
	BCS	unknown$l		; not a letter or control code
	MOV	R2,#0
	MOV	R3,#0			; x,y
	MOV	R4,#4			; select click
	RSB	R5,R0,#0		; -key number
	BL	process_leaf_click	; letter click
	FNRTS

fkey$l	MOV	R2,#0
	MOV	R3,#0			; x,y
	MOV	R4,#4			; select click
	MOV	R5,R0			; plain key number
	BL	process_leaf_click	; letter click
	FNRTS

sup$l	TST	R3,#&80
	BNE	fkey$l
	LDR	R5,[R6,#84]		; last icon

down$l	MOV	R4,#4
	TST	R3,#2
	MVNEQ	R0,#0
	MOVNE	R0,#1
	B	move$l

tabdown$l
	MOV	R4,#5
	TST	R3,#2
	MVNEQ	R0,#0
	MOVNE	R0,#1
	B	fromreturn$l

tabup$l	MOV	R4,#5
	TST	R3,#2
	MOVEQ	R0,#1
	MVNNE	R0,#0
	B	fromreturn$l

sdown$l	TST	R3,#&80
	BNE	fkey$l
	LDR	R5,[R6,#84]

up$l	MOV	R4,#4
	TST	R3,#2
	MOVEQ	R0,#1
	MVNNE	R0,#0

move$l	ORR	R4,R4,#&800		; R0=direction to move (+/-1)
fromreturn$l
	STR	R4,local_click_flg_type
	MOV	R10,R0			; save the direction
	MOV	R2,#0
	MOV	R3,#0			; x,y
	BL	process_leaf_click	; simulate a click on this icon
	FNRTS	VS			; error
	FNRTS	CS			; window to be closed
	MOV	R0,R10			; restore direction
	LDR	R14,local_click_flg_type
	TST	R14,#&800
	BEQ	dont_chk_cursvals
	LDR	R3,[R7,#4]		; restore flags
	TST	R3,#1<<7
	BNE	end$l
dont_chk_cursvals
	BL	leaf_next_icon		; move
	FNRTS	VS
	LDR	R3,[R7,#4]		; restore flags
	TST	R3,#1<<2
	BLEQ	leaf_update		; update leaf window contents
	FNRTS	VS
	B	end$l

local_click_flg_type
	DCD	0

;E R0=dir (+1/-1) R5=current icon R6=wind data R7=wind index
;X input focus gained for next writable icon (if found)
;  otherwise input focus gained generally #
	FNAME	leaf_next_icon
leaf_next_icon
	FNJSR	"R1-R6"
	LDR	R4,[R6,#84]		; number of icons
	ADD	R6,R6,#88		; start of icons
	MOV	R3,R0			; direction
	MOV	R2,R5			; save initial icon (to prevent inf loops)

lk1	ADDS	R5,R5,R3		; next icon
	SUBMI	R5,R4,#1		; clip below
	CMP	R5,R4
	MOVCS	R5,#0			; clip above
	TEQ	R5,R2			; back to where we started ?
	BEQ	lk10
	ADD	R0,R6,R5,LSL#5		; address of icon
	LDR	R14,[R0,#16]		; icon flags
	AND	R14,R14,#&F000		; icon button type
	CMP	R14,#&E000		; writeable?
	BCC	lk1			; no so goto next icon
	LDR	R0,[R0,#20]		; string pointer
	BL	str_len
	MOV	R1,R5			; icon handle
	MOV	R5,R0			; string offset
	LDR	R0,[R7,#8]		; window handle
	MOV	R2,#0
	MOV	R3,#0
	MVN	R4,#0			; writeable icon (?)
	SWI	XWimp_SetCaretPosition
	FNRTS

lk10	ADD	R0,R6,R5,LSL#5		; address of this icon
	LDR	R14,[R0,#16]		; icon flags
	AND	R14,R14,#&F000		; icon button type
	CMP	R14,#&E000		; writeable?
	LDRCC	R0,[R7,#8]		; window handle
	BLCC	gain_focus_bg
	FNRTS


	FNAME	gain_focus_bg
gain_focus_bg
	FNJSR	"R1-R5"
	MVN	R1,#0			; no icon
	MOV	R2,#0
	MOV	R3,#0
	MOV	R4,#1<<25		; invisible
	MVN	R5,#0
	SWI	XWimp_SetCaretPosition
	FNRTS


;E R7=window index
;X leaf window contents updated and icons replotted WB #
	FNAME	leaf_update
leaf_update
	FNJSR
	BL	leaf_create		; call cw_subs
	BLVC	leaf_correct_caret	; move caret to end of string wherever
	FNRTS

	LOCAL


;E R0=list of ascii,icon (zero termianted)
;  R5=-ascii key number clicked
;X R5=icon number attatched to this key if there is one
;  MINUS flag set if work done.
	FNAME	key_to_click
key_to_click
	FNJSR
a$l	LDRB	R14,[R0],#2
	TEQ	R14,#0
	FNRTS	EQ
	CMN	R5,R14
	BNE	a$l
	LDRB	R5,[R0,#-1]
	MVNS	R14,#0
	FNRTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INTERPRET LEAF WINDOW CLICKS				   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R2=xos R3=yos R4=mouse buttons
;  R5=icon handle/minus key letter R7=index entry
;  If R5 is Tab or sTab, R4 b2..0 = 101
;  If R5 is Up or Down,  R4 b2..0 = 100
;  If R5 is Return,	 R4 b2..0 = 001
;X Leaf click dealt with CS to close window. #
	FNAME	process_leaf_click
process_leaf_click
	FNJSR	"R1-R11"
	BL	reclaim_caret		; reclaim caret posn
	BLVC	leaf_click		; act
	BLVC	declaim_caret		; restore posn if hasn't been set
	FNRTS				; declaim carry DOES NOT corrupt 'C' flag...


;E as for process_leaf_click
;X Action taken according to click & CS to request window be closed
;  R0-R11 corrupted
	FNAME	leaf_click
leaf_click
	FNJSR
	BL	conv_index_offs		; set up R8/R9
	LDR	R6,[R7]			; window data
	TST	R4,#1
	LDRNE	R14,[R7,#4]		; flags
	TSTNE	R14,#&400		; adjust clicks gain focus?
	BLNE	give_dbox_focus
	LDR	R0,[R7,#24]		; execute sub
	CMP	R0,#0
	MOVGT	PC,R0			; call the sub
	ADDS	R0,R0,#0		; clc
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; OTHER LEAF CLICK SUBS						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R0=ESG R6=window data R7=window index
;X update icons of this ESG R0=first selected icon ESG / -1 if none WB #
	FNAME	lc_radioon
lc_radioon
	FNJSR	"R1-R6"
	MOV	R4,R0			; ESG to match
	LDR	R2,[R6,#84]		; number of icons
	ADD	R6,R6,#88		; start of icons
	ADD	R6,R6,R2,LSL#5		; current icon
	FNLDR	R1,wimp_block
	LDR	R0,[R7,#8]
	STR	R0,[R1]			; window handle
	MVN	R5,#0			; current match (ie none)

lc1	SUB	R6,R6,#32
	SUBS	R2,R2,#1
	MOVMI	R0,R5
	FNRTS	MI
	LDR	R0,[R6,#16]		; icon flags
	MOV	R0,R0,LSR#16
	AND	R0,R0,#&1F
	TEQ	R0,R4
	BNE	lc1			; incorrect ESG
	STR	R2,[R1,#4]		; save icon handle
	SWI	XWimp_GetIconState
	FNRTS	VS
	LDR	R0,[R1,#24]		; get icon flags
	STR	R0,[R6,#16]		; save updated state
	TST	R0,#1<<21
	MOVNE	R5,R2			; selected icon
	B	lc1


;E R5=icon R6=wind data R7=wind index
;X R0=icon flags read from wimp and WB contains defn(+8) WB #
	FNAME	lc_read
lc_read	FNJSR	"R1"
	FNLDR	R1,wimp_block
	LDR	R0,[R7,#8]		; window handle
	STMIA	R1,{R0,R5}		; store it + icon handle
	SWI	XWimp_GetIconState
	LDRVC	R0,[R1,#24]		; read flags
	FNRTS


;E R5=icon num R6=wind data R7=wind index
;X R0=Eval of the indirected string / VS if not valid #
	FNAME	lc_buffernum
lc_buffernum
	FNJSR	"R1-R2"
	ADD	R0,R6,#88
	ADD	R0,R0,R5,LSL#5		; icon addr
	LDR	R0,[R0,#20]		; addr of string
	FNLDR	R1,wimp_block		; buffer
	MOV	R2,#0			; buf len
	SWI	XOS_EvaluateExpression
	FNRTS	VS
	MOV	R0,R2			; result
	TEQ	R1,#0			; check integer returned
	BLNE	err3
	FNRTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Icon specific								;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R5=icon R6=wind data
;X R0=address of indirected icon data |
	FNAME	icon_getind
icon_getind
	ADD	R0,R6,#88
	ADD	R0,R0,R5,LSL#5
	LDR	R0,[R0,#20]
	MOV	PC,R14


;E R5=icon R6=data
;X R0=icon flags
	FNAME	icon_getflags
icon_getflags
	ADD	R0,R6,#88
	ADD	R0,R0,R5,LSL#5
	LDR	R0,[R0,#16]
	MOV	PC,R14

	LOCAL


;E R0=pointer to list of icon numbers terminated by &FF R6=window data R7
;X icons cleared #
	FNAME	icons_clear
icons_clear
	FNJSR	"R4-R5"
	MOV	R4,R0
a$l	LDRB	R5,[R4],#1
	TEQ	R5,#&FF
	FNRTS	EQ
	BL	icon_clear
	B	a$l


;E R5=icon R6=wind data R7=wind
;X indirected string nulled & updated if on screen #
	FNAME	icon_clear
icon_clear
	FNJSR
	ADD	R0,R6,#88+20
	LDR	R0,[R0,R5,LSL#5]
	MOV	R14,#0
	STRB	R14,[R0]
	BL	icon_redraw
	FNRTS

	LOCAL


;E R0=pointer to list of icon number bytes (&FF terminated) R7=window data
;X These icons redrawn on the screen WB #
	FNAME	icons_redraw
icons_redraw
	FNJSR	"R5-R6"
	MOV	R6,R0
a$l	LDRB	R5,[R6],#1
	TEQ	R5,#&FF
	FNRTS	EQ
	BL	icon_redraw
	BVC	a$l
	FNRTS


;E R5=icon R7=window data
;X Icon updated on screen via set icon state if window open WB #
	FNAME	icon_redraw
icon_redraw
	FNJSR	"R1"
	LDR	R0,[R7,#8]		; window handle
	CMP	R0,#0
	FNRTS	LE			; no window to update
	FNLDR	R1,wimp_block
	STMIA	R1,{R0,R5}
	MOV	R0,#0
	STR	R0,[R1,#8]
	STR	R0,[R1,#12]
	SWI	XWimp_SetIconState
	FNRTS


;E R5=icon R7=window data
;X Icon updated on screen by Wimp_UpdateWindow (background not redrawn) WB #
;  (Checks if window open)
	FNAME	icon_update
icon_update
	FNJSR	"R1-R3,R6"
	FNLDR	R1,wimp_block
	LDR	R0,[R7,#8]
	CMP	R0,#0
	FNRTS	LE
	STR	R0,[R1]			; window handle
	LDR	R6,[R7]			; window data
	ADD	R6,R6,#88
	ADD	R6,R6,R5,LSL#5		; icon data
	LDMIA	R6,{R0,R2,R3,R14}
	STMIB	R1,{R0,R2,R3,R14}	; icon bounding box
	BL	update_leaf_window
	FNRTS


;E R0=mask R1=eor R5=icon R6=wind data R7=wind R2=&FF00; don't update...
;X icons flags =(old BIC R0) EOR R1 wind data updated
;  updated on screen as well if window open #
	FNAME	icon_alter
icon_alter
	FNJSR	"R1,R6"
	ADD	R6,R6,#88
	ADD	R6,R6,R5,LSL#5
	LDR	R14,[R6,#16]		; icon flags
	BIC	R14,R14,R0
	EOR	R14,R14,R1
	STR	R14,[R6,#16]		; update the flags in the data block
	LDR	R14,[R7,#8]
	CMP	R14,#0
	FNRTS	LE			; window not open
	CMP	R2,#&FF00
	FNRTS	EQ
	FNLDR	R14,wimp_block
	STR	R1,[R14,#8]
	MOV	R1,R14
	STR	R0,[R1,#12]
	STR	R5,[R1,#4]
	LDR	R0,[R7,#8]
	STR	R0,[R1]			; window handle
	SWI	XWimp_SetIconState
	FNRTS

	LOCAL


;E R5=icon R6=wind data R7=window
;X icon selected and all others of same ESG deselected (<>0)
;  updated on screen (via icon alter) if necessary.
	FNAME	icon_select
icon_select
	FNJSR	"R1-R6"
	MOV	R0,#1<<21
	MOV	R1,#1<<21
	BL	icon_alter		; select this icon
	FNRTS	VS
	BL	icon_getflags
	ANDS	R4,R0,#&1F0000		; get ESG
	FNRTS	EQ			; return if 0
	LDR	R2,[R6,#84]		; number of icons
	MOV	R3,R5			; save this icon
	MOV	R5,#0			; start at first icon
icon$l	TEQ	R3,R5
	BEQ	next$l			; skip this icon (we've selected it)
	BL	icon_getflags
	AND	R14,R0,#&1F0000		; ESG
	TEQ	R4,R14
	BNE	next$l			; different ESGs
	TST	R0,#1<<21
	MOVNE	R0,#1<<21
	MOVNE	R1,#0
	BLNE	icon_alter		; deselect it if not already
next$l	ADD	R5,R5,#1
	CMP	R5,R2
	BCC	icon$l
	FNRTS


;E R2=address of drag routine to call while dragging R3=routine data
;  R4=drag flags (b1=repeated call)
;  R5=icon handle R6=window data R7=window index
;X drag box called set up to drag a point inside the icon WB #
	FNAME	icon_drag
icon_drag
	FNJSR	"R1-R7"
	ADD	R6,R6,#88
	ADD	R6,R6,R5,LSL#5		; pointer to the icon
	FNLDR	R1,wimp_block
	LDR	R0,[R7,#8]
	STR	R0,[R1]			; window handle
	SWI	XWimp_GetWindowState
	FNRTS	VS
	LDR	R0,[R1,#16]
	LDR	R14,[R1,#24]
	SUB	R0,R0,R14		; work area 0 y
	LDR	R14,[R6,#4]		; miny
	ADD	R14,R14,R0
	STR	R14,[R1,#28]		; bounding box
	LDR	R14,[R6,#12]
	ADD	R14,R14,R0
	STR	R14,[R1,#36]		; done #28 #36
	LDR	R0,[R1,#4]
	LDR	R14,[R1,#20]
	SUB	R0,R0,R14		; work area 0 xcol
	LDR	R14,[R6]		; minx
	ADD	R14,R14,R0
	STR	R14,[R1,#24]		; bounding box
	LDR	R14,[R6,#8]
	ADD	R14,R14,R0
	STR	R14,[R1,#32]
	MOV	R0,#7
	STR	R0,[R1,#4]		; drag point
	MOV	R0,R4
	BL	drag_box
	FNRTS


;E R7
;X R0 = flags for that window...
	FNAME	window_getstate
window_getstate
	FNJSR	"R1"
	FNLDR	R1,wimp_block
	LDR	R0,[R7,#8]
	STR	R0,[R1]			; window handle
	SWI	XWimp_GetWindowState
	LDRVC	R0,[R1,#32]		; flags
	FNRTS


;E R2/R3=xy os of coord R5=icon handle R6=window data R7=window index
;X R2/R3=offset of coord from bottom left of icon WB #
	FNAME	icon_get_coord
icon_get_coord
	FNJSR	"R1,R6"
	ADD	R6,R6,#88
	ADD	R6,R6,R5,LSL#5		; pointer to the icon
	FNLDR	R1,wimp_block
	LDR	R0,[R7,#8]
	STR	R0,[R1]			; window handle
	SWI	XWimp_GetWindowState
	LDRVC	R0,[R1,#4]
	LDRVC	R14,[R1,#20]
	SUBVC	R0,R0,R14		; work area 0 xcol
	SUBVC	R2,R2,R0		; work xos
	LDRVC	R0,[R1,#16]
	LDRVC	R14,[R1,#24]
	SUBVC	R0,R0,R14		; work area 0 y
	SUBVC	R3,R3,R0		; work yos
	LDRVC	R0,[R6]
	SUBVC	R2,R2,R0
	LDRVC	R0,[R6,#4]		; icon miny
	SUBVC	R3,R3,R0
	FNRTS


;E R5=icon handle R6=window data R7=window index
;X R0 icon horizontal size
	FNAME	icon_get_size
icon_get_size
	FNJSR	"R1,R6"
	ADD	R6,R6,#88		; pointer to the icon data
	LDR	R1,[R6,R5,LSL #5]!	; icon min-x
	LDR	R0,[R6,#8]		; icon max-x
	SUB	R0,R0,R1
	FNRTS


;E R5=icon number R6=window data R7=window
;X checks the caret is not off the end of the icon WB #
	FNAME	icon_checkcaret
icon_checkcaret
	FNJSR	"R1-R6"
	ADD	R6,R6,#88
	ADD	R6,R6,R5,LSL#5
	LDR	R0,[R6,#16]		; icon flags
	AND	R0,R0,#&F<<12
	CMP	R0,#&E<<12
	FNRTS	CC			; not writable
	FNLDR	R1,wimp_block
	SWI	XWimp_GetCaretPosition
	FNRTS	VS
	LDR	R0,[R1]
	LDR	R14,[R7,#8]
	TEQ	R0,R14
	FNRTS	NE
	LDR	R0,[R1,#4]
	TEQ	R0,R5
	FNRTS	NE
	LDR	R0,[R6,#20]		; buffer pointer
	BL	str_len
	MOV	R5,R0
	MOV	R4,#-1
	LDMIA	R1,{R0-R3}
	SWI	XWimp_SetCaretPosition  ; move caret to the end
	FNRTS

	LOCAL


;E as icon_bufferstr, except R0=token pointer/0 to clear. No % subst. done.
	FNAME	icon_buffertoken
icon_buffertoken
	FNJSR
	TEQ	R0,#0
	BLNE	lookup_token_R0
	FNPULL
; drop into icon_bufferstr

;E R0=string pointer/0 to clear R5=icon num R6=window def R7=window
;X New text put in buffer and icon redrawn if window open #
	FNAME	icon_bufferstr,1
icon_bufferstr
	FNJSR	"R1-R4,R6"
	ADD	R6,R6,#88+20
	LDR	R1,[R6,R5,LSL#5]!	; buffer address
	MOVS	R2,R0			; source string
	STREQB  R0,[R1]			; end string if R0=0
	BEQ	end$l
	LDR	R3,[R6,#28-20]		; buffer length
	MOV	R4,#&1F			; max terminating char
	BL	strmove
end$l	BL	icon_redraw		; update on screen if open
	FNRTS


;E R0=number R5=icon num R6=window defn R7=window
;X cardinal number inserted in icons indirected buffer #
	FNAME	icon_buffernum
icon_buffernum
	FNJSR	"R1-R2,R6"
	ADD	R6,R6,#88+20
	ADD	R6,R6,R5,LSL#5		; icon address
	LDR	R1,[R6,#20-20]
	LDR	R2,[R6,#28-20]
	SWI	XOS_ConvertInteger4
	BLVC	icon_redraw
	FNRTS


;E R0=number R5=icon R6=window defn R7=window
;X hex number inserted in icons indirected buffer with & #
	FNAME	icon_bufferhex
icon_bufferhex
	FNJSR	"R1-R2,R6"
	ADD	R6,R6,#88+20
	LDR	R1,[R6,R5,LSL#5]!
	LDR	R2,[R6,#28-20]
	MOV	R14,#'&'
	STRB	R14,[R1],#1
	SUBS	R2,R2,#1
	SWI	XOS_ConvertHex8
	BLVC	icon_redraw
	FNRTS


;E R0=number (low) R4=number (high) R5=icon R6=window defn R7=window
;X hex number inserted in icons indirected buffer with & #
	FNAME	icon_bufferhex16
icon_bufferhex16
	FNJSR	"R1-R2,R6"
	ADD	R6,R6,#88+20
	LDR	R1,[R6,R5,LSL#5]!
	LDR	R2,[R6,#28-20]
	MOV	R14,#'&'
	STRB	R14,[R1],#1
	SUBS	R2,R2,#1
	SWI	XOS_ConvertHex8
	MOVVC	R0,R4
	SWIVC	XOS_ConvertHex8
	BLVC	icon_redraw
	FNRTS


;E R0=b0 is new icon state (set for selected icon) R5=icon R6=data R7=wind
;X Icon is selected or deselected according to the bit
;  Icon is updated if the window is open WB.
	FNAME	icon_set
icon_set
	FNJSR	"R1"
	TST	R0,#1
	MOVEQ	R1,#0
	MOVNE	R1,#1<<21
	MOV	R0,#1<<21
	BL	icon_alter
	FNRTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; place caret at end of string				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;E R7=wind index
;X if caret in this window then set to end of string WB #
	FNAME	leaf_correct_caret
leaf_correct_caret
	FNJSR	"R1-R5"
	FNLDR	R1,wimp_block
	SWI	XWimp_GetCaretPosition
	FNRTS	VS
	LDR	R0,[R1]
	LDR	R2,[R7,#8]
	TEQ	R0,R2
	FNRTS	NE			; window handles don't match
	LDR	R6,[R7]
	LDR	R5,[R1,#4]		; icon handle
	CMP	R5,#0
	FNRTS	MI			; no icon selected
	BL	icon_getind
	BL	str_len
	MOV	R5,R0			; new caret offset
	LDR	R0,[R1,#20]		; current index
	TEQ	R0,R5
	LDMNEIA R1,{R0-R1}
	MVNNE	R4,#0
	SWINE	XWimp_SetCaretPosition
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Disc Read/Write					    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R10=filecore sub to call 0=DiscOp 2=Drives 5=Describe disc
;  R0-R7=call values & disc record must be updated for R0=0
;X SWI called using wimp_dzap / VS if not found R0-R7 updated WB #
	FNAME	call_filecore
call_filecore
	FNJSR
	PUSH	"R0-R2,R11"
	FNLDR	R11,wimp_block		; wimp block
	MOV	R1,R11
	FNLDR	R2,wimp_dzap
	BL	strcpy			; fs name
	TEQ	R10,#0
	ADREQ	R2,call_filecore_s0
	TEQ	R10,#&40
	ADREQ	R2,call_filecore_s40
	TEQ	R10,#2
	ADREQ	R2,call_filecore_s2
	TEQ	R10,#5
	ADREQ	R2,call_filecore_s5
	BL	strcopy			; complete swi name
	MOV	R1,R11
	SWI	XOS_SWINumberFromString
	BVS	ca1			; swi name not found
	ORR	R0,R0,#&EF000000	; make into a SWI instruction
	ORR	R0,R0,#1<<17		; X-form of the SWI
	STR	R0,ca2			; strongarm problems...
	LDMFD	R13!,{R0-R2,R11}	; restore register values

ca2	DCD	&EF000000		; the swi instruction goes here
	FNRTS				; return after the swi

ca1	LDMFD	R13!,{R0-R2,R11}
	BL	err$l
	FNRTS

err$l	ERR	"zap_e_noswiinterface"

call_filecore_s0
	FNS	("_DiscOp")
call_filecore_s40
	FNS	("_SectorDiscOp")
call_filecore_s2
	FNS	("_Drives")
call_filecore_s5
	FNS	("_DescribeDisc")



;E R0=disc address
;X R0=-1 not valid / R0=off R1=sect R2=head R3=track |
	FNAME	conv_addr_sht
conv_addr_sht
	FNJSR	"R4-R5,R10"
	FNLDR	R10,wimp_dzap
	LDR	R1,[R10,#&28]
	TEQ	R1,#0
	MVNEQ	R0,#0
	FNRTS	EQ
	LDR	R1,[R10,#&28]
	TEQ	R1,#2
	MOVEQ	R1,#0
	LDRNEB  R1,[R10,#&40]		; log2 sector size
	MOV	R2,R0,LSR R1		; total sector number
	SUB	R4,R0,R2,LSL R1		; sector offset
	MOV	R0,R2
	LDRB	R1,[R10,#&41]		; sectors per track
	SWI	XZapRedraw_Divide	; BL div_mod
	MOV	R5,R2			; sector number
	LDRB	R1,[R10,#&42]		; heads
	SWI	XZapRedraw_Divide	; BL div_mod	; R0=track R2=head
	MOV	R3,R0			; track
	MOV	R1,R5			; sector
	MOV	R0,R4			; offset
	FNRTS


;E R0=off R1=sect R2=head R3=track
;X R0=-1 not valid / R0=disc address |
	FNAME	conv_sht_addr
conv_sht_addr
	FNJSR	"R3,R10"
	FNLDR	R10,wimp_dzap
	LDR	R14,[R10,#&28]
	TEQ	R14,#0
	MVNEQ	R0,#0
	FNRTS	EQ
	LDRB	R14,[R10,#&42]		; num heads
	MLA	R3,R14,R3,R2
	LDRB	R14,[R10,#&41]		; sects per trk
	MLA	R3,R14,R3,R1
	LDR	R14,[R10,#&28]
	TEQ	R14,#2
	MOVEQ	R0,R3
	LDRNEB  R14,[R10,#&40]		; log2 sect size
	ADDNE	R0,R0,R3,LSL R14	; disc address
	FNRTS

	LOCAL


;E R0=disc address and valid data block
;X wimp_block contains sht string #
	FNAME	conv_addr_str
conv_addr_str
	FNJSR	"R0-R5"
	BL	conv_addr_sht		; R0-R3=osht
	MOV	R4,R1
	MOV	R5,R2
	FNLDR	R1,wimp_block
	MOV	R2,#&F0			; buffer size - bits
	MOV	R0,#'c'
	STRB	R0,[R1],#1
	MOV	R0,R3			; cylinder
	SWI	XOS_ConvertInteger4
	MOVVC	R0,#'h'
	STRVCB  R0,[R1],#1
	MOVVC	R0,R5			; head
	SWIVC	XOS_ConvertInteger4
	MOVVC	R0,#'s'
	STRVCB  R0,[R1],#1
	MOVVC	R0,R4			; sector
	SWIVC	XOS_ConvertInteger4
	BVS	error$l
	MOV	R0,#' '
	STRB	R0,[R1],#1
	MOV	R0,#'&'
	STRB	R0,[R1],#1
	PULLS	"R0"			; address
	FNLDR	R4,wimp_dzap
	LDR	R5,[R4,#&28]
	TEQ	R5,#2
	BNE	notbigdisk$l
	LDRB	R5,[R4,#&40]		; log2 sector size
	MOV	R4,R0,LSL R5
	RSB	R5,R5,#32
	MOV	R0,R0,LSR R5
	SWI	XOS_ConvertHex8
	BVS	error$l
	MOV	R0,R4
notbigdisk$l
	SWI	XOS_ConvertHex8
error$l	STR	R0,[R13]
	FNRTS

;E R0=buffer address R1=disc address R2=length
;X data read to buffer if disc record valid #
	FNAME	read_disc
read_disc
	FNJSR	"R1-R4,R10-R11"
	FNLDR	R11,wimp_dzap
	LDR	R14,[R11,#&28]
	TEQ	R14,#0			; is disc record valid
	FNRTS	EQ
	MOV	R4,R2			; length
	MOV	R3,R0			; buffer
	MOV	R2,R1			; disc address
	ADD	R1,R11,#&40		; disc record
	MOV	R1,R1,LSL#6		; b8-15=b2-25 of disc record
	ORR	R1,R1,#1		; read sectors
	LDR	R0,[R11,#&20]		; current drive
	ORR	R2,R2,R0,LSL#29		; put in disc address
	LDR	R10,[R11,#&28]
	TEQ	R10,#2			; big disk?
	MOVEQ	R10,#&40		; _SectorDiscOp
	MOVNE	R10,#0			; _DiscOp
	BL	call_filecore
	FNRTS

	LOCAL


;E R0=number of times R1=sector change R2=head change R3=cylinder change
;  R8-R9=input
; ("Successive sides" formats such as ADFS L use (R2|R3)=track change)
;X new sector read if file dzap and unaltered #
	FNAME	new_read_disc
new_read_disc
	FNJSR	"R1-R11"
	MUL	R5,R1,R0		; save sector change
	MUL	R6,R2,R0		; save head change
	MUL	R7,R3,R0		; save track change
	LDR	R0,[R9,#f_cmode]
	TEQ	R0,#1			; is it a dzap created file?
	FNRTS	NE
	LDR	R0,[R9,#f_flags]
	TST	R0,#1<<3		; is the file altered
	FNRTS	NE
	LDR	R0,[R9,#f_len]
	MOV	R1,#0
	BL	split_buffer		; coagulate
	FNRTS	VS
	LDR	R0,[R9,#f_source]	; current disc address
	BL	conv_addr_sht
	CMN	R0,#1			; is block valid
	FNRTS	EQ
	ADD	R1,R1,R5
	ADD	R2,R2,R6
	ADD	R3,R3,R7
	BL	conv_sht_addr		; new disc address
	FNLDR	R10,wimp_dzap
	LDR	R3,[R10,#&50]		; disc size
	MOVS	R1,R0			; save disc address
	MOVMI	R1,#0			; new disc address
	LDR	R2,[R9,#f_len]		; buffer length
	ADD	R0,R1,R2
	CMP	R0,R3
	FNRTS	GT			; reading too many bytes
	ADR	R10,sub$l
	BL	do_eachwindow		; save windows on file
	LDRVC	R0,[R9,#f_ptr]		; buffer address
	BLVC	read_disc		; read new data
	STRVC	R1,[R9,#f_source]
	MOVVC	R0,R1
	BLVC	conv_addr_str		; get new title to wimp_block
	FNLDR	R0,wimp_block,VC
	BLVC	new_file_name
	ADRVC	R10,new_read_disc_sub
	BLVC	do_eachwindow		; update window and title
	FNRTS
sub$l	B	save_window_status


	FNAME	new_read_disc_sub
new_read_disc_sub
	FNJSR
	LDR	R0,[R9,#f_load]
	STR	R0,[R8,#w_addr]
	BL	new_window_status
	BLVC	new_title
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read memory subs					       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

; E R0 - start, R1 - end, R2 - task handle **R0<R1**
; X CS if range invalid.
	FNAME	validateaddress
validateaddress
	FNJSR	"R0-R2"
	BL	is_in_rom
	BHS	isROM$l
	SUB	R13,R13,#16
	CMP	R0,#&8000
	BLO	notapp$l
	FNLDR	R14,wimp_limit
	CMP	R1,R14
	BHS	notapp$l
	MOV	R14,R2,LSL #16
	MOV	R0,#0
app$l	TEQ	R0,#0
	BMI	notapp$l
	MOV	R1,R13
	MOV	R2,#16
	SWI	XTaskManager_EnumerateTasks
	LDR	R2,[R13]
	TEQ	R14,R2,LSL #16
	BNE	app$l
	LDR	R2,[R13,#8]
	ADD	R13,R13,#16
	LDR	R1,[R13,#4]
	ADD	R2,R2,#&8000
	ADD	R2,R2,#1
	CMP	R1,R2
	FNRTS

notapp$l
	ADD	R13,R13,#16
	LDMIA	R13,{R0,R1}
	SWI	XOS_ValidateAddress
	FNRTS

isROM$l CMP	R0,R1
	FNRTS

	LOCAL


; determine if a given address is in ROM
; E R0 -> start  R1 -> end   R0 < R1
; X CS if in ROM
	FNAME	is_in_rom
is_in_rom
	FNJSR	"R0-R8"
	MOV	R7,#-1			; minimum ROM address
	MOV	R8,#0			; maximum ROM

	MOV	R0,#19
	MOV	R1,#0
	MOV	R2,#-1			; System ROM section
loop$l  SWI	XOS_Module
	BVS	done$l
	CMP	R2,#-1			; still in ROM?
	BNE	done$l
	CMP	R3,R7			; find the address from the name
	MOVLO	R7,R3			; pointer, which is inside the module
	CMP	R3,R8
	MOVHS	R8,R3
	B	loop$l

done$l  MOV	R7,R7,LSR #20		; round to 1M boundary
	MOV	R7,R7,LSL #20
	ADD	R8,R8,#1
	MOV	R8,R8,LSR #20
	MOV	R8,R8,LSL #20

	LDMIA	R13,{R0,R1}
	CMP	R0,R7
	CMPHS	R8,R0
	FNRTS

	LOCAL


;E R0=buffer R1=start address R2=end address
;X memory read using wimp_mzap if needed and valid #
;  (!wimp_mzap contains the task handle of the task to read from)
	FNAME	read_memory
read_memory
	FNJSR	"R1-R4"
	CMP	R2,R1
	BLS	invalid$l		; negative interval
	PUSH	"R0-R2"
	MOV	R0,R1
	MOV	R1,R2
	FNLDR	R2,wimp_mzap
	LDR	R2,[R2]
	BL	validateaddress
	PULL	"R0-R2"
	BCS	invalid$l
	FNLDR	R14,wimp_limit
	CMP	R1,R14
	BHS	notapp$l
	CMP	R1,#&8000
	BCS	app$l			; application space read
	CMP	R2,#&8000
	BHS	invalid$l		; crosses boundary
	B	read$l			; direct read
notapp$l
	PUSH	"R0-R2"
	MOV	R0,R1
	MOV	R1,R2
	BL	is_in_rom
	PULL	"R0-R2"
	BCS	read$l			; ROM space - direct read
	B	logical$l		; other logical area

app$l	FNLDR	R14,wimp_mzap		; read application workspace
	MOV	R3,R0			; dest buffer
	SUB	R4,R2,R1		; buffer length
	LDR	R0,[R14]		; source task
	FNLDR	R2,wimp_task		; dest task
	SWI	XWimp_TransferBlock	; no validation... :-/
	FNRTS

invalid$l
	BL	err$l
	FNRTS

logical$l				; check address range as logical addresses
	PUSH	"R0-R1"
	MOV	R0,R1
	MOV	R1,R2
	SWI	XOS_ValidateAddress
	PULL	"R0-R1"
	BCS	invalid$l		; not ok
read$l					; R0=buffer R1=start addres R2=end address
	SUB	R3,R2,R1		; number of bytes
	MOV	R2,R0			; dest
	SWI	XZapRedraw_MoveBytes	; have ZapRedraw copy it in SVC mode
	FNRTS
err$l	ERR	"zap_e_badmemrange"



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INITIATE BOX DRAGGING					       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R5=icon R7=wind index
;X drag box initiated on this icon WB #
	FNAME	initiate_drag
initiate_drag
	FNJSR	"R1-R6"
	FNLDR	R1,wimp_block		; workspace
	LDR	R0,[R7,#8]		; window handle
	STR	R0,[R1]
	SWI	XWimp_GetWindowState	; WB+0=window state
	FNRTS	VS
	LDR	R2,[R1,#w_minx]
	LDR	R3,[R1,#w_maxy]
	LDR	R0,[R1,#w_scrollx]
	SUB	R2,R2,R0
	LDR	R0,[R1,#w_scrolly]
	SUB	R3,R3,R0		; R2/R3=screen os of window (0,0)
	LDR	R0,[R1],#&80		; window handle (keep icon data uncorrupted)
	STMIA	R1,{R0,R5}		; window & icon handles
	SWI	XWimp_GetIconState	; WB+&80=icon state
	FNRTS	VS
	MOV	R6,#0			; no sprite drag (or name pointer)
	LDR	R0,[R1,#24]		; icon flags
	AND	R14,R0,#3
	TEQ	R14,#2
	BNE	a$l			; not a sprite
	TST	R0,#1<<8
	ADD	R6,R1,#28		; start of icon data
	LDRNE	R6,[R6]			; indirected
	MOV	R0,#161
	PUSH	"R1-R2"
	MOV	R1,#28
	SWI	XOS_Byte		; read CMOS location 28
	MOVVC	R0,R2
	PULL	"R1-R2"
	FNRTS	VS
	TST	R0,#2
	MOVEQ	R6,#0			; don't use drag a sprite
a$l	LDR	R4,[R1,#16]		; not a sprite
	LDR	R5,[R1,#20]
	ADD	R4,R4,R2
	ADD	R5,R5,R3		; screen max x y of initial box
	LDR	R0,[R1,#8]
	ADD	R2,R0,R2
	LDR	R0,[R1,#12]
	ADD	R3,R0,R3		; screen min x y of initial box
	FNLDR	R1,wimp_block		; so R2-R5=initial box
	SWI	XWimp_GetPointerInfo	; find current posn
	FNRTS	VS			; #0=mouse x #4=mouse y
	ADD	R0,R1,#8
	STMIA	R0,{R2-R5}		; save initial box
	LDR	R0,[R1]			; mouse x
	SUB	R2,R2,R0		; min bounding x
	SUB	R4,R4,R0
	FNLDR	R14,scn_xos
	ADD	R4,R4,R14		; max bounding x
	LDR	R0,[R1,#4]		; mouse y
	SUB	R3,R3,R0
	SUB	R5,R5,R0
	FNLDR	R14,scn_yos
	ADD	R5,R5,R14		; R2-R5=bounding box
	ADD	R0,R1,#24
	STMIA	R0,{R2-R5}		; save 'parent' box
	LDR	R0,[R7,#8]
	STR	R0,[R1]			; window handle
	MOV	R0,#5
	STR	R0,[R1,#4]		; drag type (completes block)
	TEQ	R6,#0
	BNE	c$l			; drag a sprite
	SWI	XWimp_DragBox
	FNRTS	VS
b$l	ADR	R0,process_leaf_drag	; drag started
	FNSTR	R0,wimp_dragsub		; sub to handle end of drag
	LDR	R0,[R7,#8]		; window handle dragged from
	FNSTR	R0,wimp_dragdata	; save source window handle as drag data
	FNRTS

c$l					; try and drag the sprite
	ADD	R4,R1,#24		; bounding box
	ADD	R3,R1,#8		; inital box
	MOV	R2,R6			; name
	MOV	R1,#1			; wimp sprite area
	MOV	R0,#&A0			; flags
	SWI	XDragASprite_Start
	BVC	b$l			; found OK
	ADDS	R0,R0,#0		; clv
	SUB	R1,R3,#8		; start of drag block
	SWI	XWimp_DragBox		; try the old method
	BVC	b$l
	FNRTS

	LOCAL


;E R6=pointer to sprite name
;X drag box initiated on this icon WB #
	FNAME	initiate_sprite_drag
initiate_sprite_drag
	FNJSR	"R1-R6"
	FNLDR	R1,wimp_block		; workspace
	MOV	R0,#161
	PUSH	"R1-R2"
	MOV	R1,#28
	SWI	XOS_Byte		; read CMOS location 28
	MOVVC	R0,R2
	PULL	"R1-R2"
	FNRTS	VS
	TST	R0,#2
	MOVEQ	R6,#0			; don't use drag a sprite
a$l					; not a sprite
	FNLDR	R1,wimp_block		; so R2-R5=initial box
	SWI	XWimp_GetPointerInfo	; find current posn
	FNRTS	VS			; #0=mouse x #4=mouse y
	ADD	R0,R1,#8
	LDMIA	R1,{R2,R3}
	ADD	R4,R2,#32		; size of icon
	SUB	R2,R2,#32		; size of icon
	ADD	R5,R3,#32		; size of icon
	SUB	R3,R3,#32		; size of icon
	STMIA	R0,{R2-R5}		; save initial box
	LDR	R0,[R1]			; mouse x
	SUB	R2,R2,R0		; min bounding x
	SUB	R4,R4,R0
	FNLDR	R14,scn_xos
	ADD	R4,R4,R14		; max bounding x
	LDR	R0,[R1,#4]		; mouse y
	SUB	R3,R3,R0
	SUB	R5,R5,R0
	FNLDR	R14,scn_yos
	ADD	R5,R5,R14		; R2-R5=bounding box
	ADD	R0,R1,#24
	STMIA	R0,{R2-R5}		; save 'parent' box
	MOV	R0,#5
	STR	R0,[R1,#4]		; drag type (completes block)
	TEQ	R6,#0
	BNE	c$l			; drag a sprite
	SWI	XWimp_DragBox
	FNRTS	VS

b$l	ADR	R0,process_leaf_drag2	; drag started
	FNSTR	R0,wimp_dragsub		; sub to handle end of drag
	MVN	R0,#0
	FNSTR	R0,wimp_dragdata	; save -1 as drag data
	FNRTS

c$l					; try and drag the sprite
	ADD	R4,R1,#24		; bounding box
	ADD	R3,R1,#8		; inital box
	MOV	R2,R6			; name
	MOV	R1,#1			; wimp sprite area
	MOV	R0,#&A0			; flags
	SWI	XDragASprite_Start
	BVC	b$l			; found OK
	CLV
	SUB	R1,R3,#8		; start of drag block
	SWI	XWimp_DragBox		; try the old method
	BVC	b$l
	FNRTS


	FNAME	process_leaf_drag2
process_leaf_drag2
	FNJSR	"R0-R12"
	SWI	XDragASprite_Stop
	MOV	R0,#&70			; escape
	BL	test_forkey
	FNRTS	CS
	BL	get_SaveSelBox
	MOV	R7,R1
	MOV	R8,#0			; selection
	BL	drag_Box
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INTERPRET DRAG END					      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E as for normal drag finished sub
;X end of drag responed to WB #
	FNAME	process_leaf_drag
process_leaf_drag
	FNJSR	"R1-R11"
	MOV	R0,R11			; window handle passed as the data
	BL	convert_leaf_wind_handle
	MOVCC	R7,R0			; index entry
	BLCC	dispatch_drag		; corrupts all
	FNRTS

	LOCAL


; R8/R9=source file / R8=0 for selection
	FNAME	drag_Box
drag_Box
	FNJSR				; save to the task the wimp pointer is over
	LDR	R6,[R7]			; window data
	MOV	R5,#0
	BL	icon_getind		; R0=filename
	MOV	R2,R0			; filename
	LDRB	R0,[R2]
	CMP	R0,#32
	ADRCC	R2,fnameforselected
	FNLDR	R1,wimp_block
	SWI	XWimp_GetPointerInfo
	FNRTS	VS
	LDR	R3,[R1,#12]		; window
	LDR	R4,[R1,#16]		; icon
	LDMIA	R1,{R5,R6}		; mouse
	TEQ	R8,#0
	BEQ	send$l
	LDR	R10,[R9,#f_cmode]	; creation mode
	CMP	R10,#0
	BMI	send$l			; none
	MOV	R0,#0
	MOV	R1,#8
	MOV	R11,#e_init
	BL	call_given_mode		; warn the mode
	FNRTS	VS
send$l	BL	test_shiftctrl		; get shift status in b0 of R1
	TST	R1,#1
	FNLDR	R1,wimp_block
	PUSH	"R1-R9"
	BEQ	asnormalsavesel
	MOV	R0,#4
	STR	R0,[R1,#8]
	LDR	R0,[R1,#12]
	BL	convert_wind_handle
	BCS	asnormalsavesel
	BL	mouse_event		; default_click - should have set up R9...
asnormalsavesel
	PULL	"R1-R9"
	MOV	R10,#0			; zero flags
	MOV	R11,R7			; window to update
	LDRB	R14,[R2]
	CMP	R14,#32
	ADRCS	R7,sub$l		; call after finished
	ADRCC	R7,q_selsavedsub$l
	BL	send_data_save		; save to the task the wimp pointer is over
	FNRTS

sub$l	FNJSR	"R1,R7-R11"		; sub to call after saved (successfully)
	MOV	R7,R11			; window index
	BL	conv_index_offs		; set up R8/R9
	TEQ	R8,#0
	BEQ	update$l
	LDR	R10,[R9,#f_cmode]	; creation mode
	CMP	R10,#0
	BMI	update$l		; none
	MOV	R0,#1
	MOV	R1,#8
	MOV	R11,#e_init
	BL	call_given_mode		; warn the mode
	FNRTS	VS

update$l
	MOV	R11,R7			; window index
	BL	update_after_save	; needs R11=window index
	FNRTS	VS
	FNLDR	R0,wimp_menub
	TST	R0,#1
	BLEQ	close_leaf_window	; adjust not held
	FNRTS

q_selsavedsub$l
	MOV	PC,R14

fnameforselected
	=	"Selection",0
	ALIGN


;X All leaf windows which are set to be deleted (b5 of flags)
;  are deleted #
	FNAME	delete_old_leafs
delete_old_leafs
	FNJSR	"R10"
	ADR	R10,delete_old_leafs_sub
	BL	do_eachleaf
	FNRTS

delete_old_leafs_sub
	FNJSR	"R1"
	LDR	R0,[R7,#8]		; is window still existing?
	CMN	R0,#1
	FNRTS	EQ
	LDR	R0,[R7,#4]		; flags
	TST	R0,#1<<5		; should we delete this?
	FNRTS	EQ
	BIC	R0,R0,#1<<5
	STR	R0,[R7,#4]		; deleted
	ADD	R1,R7,#8		; window handle
	SWI	XWimp_DeleteWindow
	MVN	R1,#0
	STR	R1,[R7,#8]		; deleted
	FNRTS


;E R7=window index R8/R9
;X Leaf window created & opened & got input focus #
	FNAME	create_open_leaf
create_open_leaf
	FNJSR	"R1-R7"
	MOV	R1,#1			; not created by menu
	BL	create_leaf_window
	BLVC	open_leaf_window
	FNRTS	VS
	LDR	R6,[R7]
	LDR	R5,[R6,#84]		; number of icons
	SUBS	R5,R5,#1		; last icon
	FNRTS	LT			; return if no icons at all...!?
	LDR	R14,[R7,#4]		; (window flags)
	TST	R14,#&200
	FNRTS	NE
	TST	R14,#&100
	BNE	putinbg$l
	LDR	R6,[R7]			; set up R6 for leaf_next_iconm (window data)
	MOV	R0,#1			; increase
	BL	leaf_next_icon
	FNRTS
putinbg$l
	LDR	R0,[R7,#8]		; window handle...
	BL	gain_focus_bg
	FNRTS

	LOCAL


;E R1=window blk of area in os (handle w_minx .. w_maxy) R7=window index
;  (can use wimp block as it's sent to Wimp_UpdateWindow)
;X leaf window area updated using Wimp_UpdateWindow #
	FNAME	update_leaf_window
update_leaf_window
	FNJSR	"R1"
	SWI	XWimp_UpdateWindow	; update the window
	FNRTS	VS
	TEQ	R0,#0
	FNRTS	EQ			; return if no more
a$l	BL	redraw_leaf_window	; redraw the rectangle
	SWIVC	XWimp_GetRectangle	; get next rectangle
	FNRTS	VS
	TEQ	R0,#0
	BNE	a$l			; loop if more to do
	FNRTS


;E R7=window index
;X If delete swap window on dying bit set then window swapped #
	FNAME	delete_swap_window
delete_swap_window
	LDR	R0,[R7,#4]		; flags
	TST	R0,#1<<4
	MOVEQ	PC,R14			; don't bother
	FNJSR	"R8-R10"
	BL	get_input_caret
	BLCC	swap_window
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Other subs							;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;E R11 = Message_WindowInfo block.
	FNAME	window_info
window_info
	FNJSR	"R1-R12"
	SYSLOG  "Message: Message_WindowInfo", LOG_WINDOW

	LDR	R0,[R11,#20]		; window handle
	BL	convert_leaf_wind_handle
	FNRTS	CS			; I don't understand it

	LDR	R1,[R0,#zapwindow_handle]
	CMP	R0,#-1
	BEQ	dead$l			; already been deleted?!
	LDR	R1,[R0,#zapwindow_flags]
	TST	R1,#zapwindow_StaticWindow
	ORR	R1,R1,#zapwindow_StaticWindow
	STR	R1,[R0,#zapwindow_flags]
	MOVEQ	R1,#-1			; was a menu leaf window
	SWIEQ	XWimp_CreateMenu	; so kill the menu
	FNRTS

dead$l	SYSLOG  "Message: Message_WindowInfo on deleted window!", LOG_WINDOW
	FNRTS

	LOCAL


;E R0=t-index of the leaf window to open R2=code command called with R8/R9
;X If R2=0 then opens the window permanently
;  If R2=6 then opens the window and returns R0=1 (abort minbuffer)
;  If R2=16 then creates and returns R0 as the handle (for menu) #
	FNAME	open_leaf_com
open_leaf_com
	FNJSR	"R7"
	FNLDR	R7,tem_list		; address of the template list
	ADD	R7,R7,R0,LSL#5		; 32 bytes each entry
	TEQ	R2,#16
	BEQ	a$l
	TEQ	R2,#0
	TEQNE	R2,#6
	FNRTS	NE
	BL	create_open_leaf	; open it up
	MOVVC	R0,#1			; abort any minibuffer opening
	FNRTS
a$l	MOV	R1,#0
	BL	create_leaf_window	; create and get handle
	FNRTS

	LOCAL


;E R0=t-index of the leaf window to deal with
;X leaf deleted and recreated
	FNAME	delete_and_reopen_leaf_com
delete_and_reopen_leaf_com
	FNJSR	"R1,R7"
	FNLDR	R7,tem_list		; address of the template list
	ADD	R7,R7,R0,LSL#5		; 32 bytes each entry
	FNLDR	R1,wimp_data
	LDR	R0,[R7,#8]		; handle
	STR	R0,[R1]			; window handle
	CMP	R0,#-1
	SWINE	XWimp_DeleteWindow
	MOVVC	R0,#-1
	STRVC	R0,[R7,#8]		; handle
	LDRVC	R1,[R7]			; data
	BLVC	swapfonts_in_this_template
	FNRTS

	LOCAL


; redo the antialised fonts for all leafs
	FNAME	reload_templates
reload_templates
	FNJSR	"R1-R3"
	BL	set_up_new_fonts
	BL	delete_and_reopen_all
	FNRTS

	LOCAL


	FNAME	delete_and_reopen_all
delete_and_reopen_all
	FNJSR	"R1"
	FNLDR	R1,tem_num		; the number
loop$l  SUBS	R1,R1,#1
	BMI	lastthing$l
	MOV	R0,R1
	BL	delete_and_reopen_leaf_com
	B	loop$l
lastthing$l
	BL	changeto_new_fonts
	FNRTS

	LOCAL


;E R7=window index
;X leaf window opened at inset from window WB #
	FNAME	open_leaf_window
open_leaf_window
	FNJSR	"R1-R9"
	LDR	R6,[R7]			; window data
	BL	conv_index_offs
	FNLDR	R1,wimp_block
	LDR	R0,[R7,#8]		; window handle
	STR	R0,[R1]

	TEQ	R8,#0			; does a related window exist
	FNLDR	R0,scn_xos,EQ
	MOVEQ	R0,R0,LSR#1		; no - centre it
	FNLDR	R0,tem_xoff,NE
	LDRNE	R2,[R8,#w_minx]		; otherwise offset it
	ADDNE	R0,R2,R0
	LDR	R2,[R6]
	LDR	R3,[R6,#8]
	SUB	R3,R3,R2		; width of window
	SUBEQ	R0,R0,R3,LSR#1
	STR	R0,[R1,#w_minx]
	ADD	R0,R0,R3
	STR	R0,[R1,#w_maxx]		; set up x coords of window

	FNLDR	R0,scn_yos,EQ
	MOVEQ	R0,R0,LSR#1
	FNLDR	R0,tem_yoff,NE
	LDRNE	R2,[R8,#w_maxy]		; otherwise offset it
	SUBNE	R0,R2,R0
	LDR	R2,[R6,#4]
	LDR	R3,[R6,#12]
	SUB	R3,R3,R2		; height
	ADDEQ	R0,R0,R3,LSR#1
	STR	R0,[R1,#w_maxy]
	SUB	R0,R0,R3
	STR	R0,[R1,#w_miny]

	LDR	R0,[R6,#16]
	STR	R0,[R1,#w_scrollx]
	LDR	R0,[R6,#20]
	STR	R0,[R1,#w_scrolly]
	MVN	R0,#0
	STR	R0,[R1,#w_infront]	; create open block
	SWI	XWimp_OpenWindow	; open window
	LDR	R1,[R7,#4]		; flags
	ORR	R1,R1,#1<<15		; window is open
	STR	R1,[R7,#4]
	FNRTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Window user redraw						;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LOCAL

;;;;;;;;;;;;;;;;;;;; Colour box redraw ;;;;;;;;;;;;;;;;;;;;;;;;;

;E R1=window block R7=window index
	FNAME	redraw_ColourBox
redraw_ColourBox
	FNJSR	"R1-R7"
	LDR	R6,[R7]			; window defn
	FNLDR	R4,tem_colour		; current palette colour
	MOV	R5,#16			; red bar
	MOV	R3,#&0000FF00		; full red
	MOV	R2,R4,LSR#8
	BL	horizontal_fill_icon
	MOVVC	R5,#17
	MOVVC	R3,R3,LSL#8
	MOVVC	R2,R2,LSR#8
	BLVC	horizontal_fill_icon
	MOVVC	R5,#18
	MOVVC	R3,R3,LSL#8
	MOVVC	R2,R2,LSR#8
	BLVC	horizontal_fill_icon
	MOVVC	R5,#26
	MOVVC	R3,R4
	MOVVC	R2,#&FF
	BLVC	horizontal_fill_icon
	FNRTS

	LOCAL


;E R1=window redraw block (as given by wimp)
;  R2=proportion of icon to be filled in bottom 8 bits 0-&FF
;  R3=fill colour (as a palette entry)
;  R5=icon number R6=window defn
;X rectange drawn #
	FNAME	horizontal_fill_icon
horizontal_fill_icon
	FNJSR	"R1-R8"
	ADD	R6,R6,#88
	ADD	R0,R6,R5,LSL#5		; icon address
	LDMIA	R0,{R4-R7}		; get icon rectangle
	MOV	R8,R6			; save end of icon
	AND	R2,R2,#&FF		; scaling (0-255)
	CMP	R2,#&FF
	MOVCS	R2,#&100		; flush with end of box
	SUB	R0,R6,R4		; width of icon
	MUL	R0,R2,R0
	ADD	R6,R4,R0,LSR#8		; end of coloured bar
	SUB	R7,R7,#1		; reduce max y
	LDR	R0,[R1,#4]
	LDR	R14,[R1,#20]
	SUB	R0,R0,R14		; work area 0 xcol
	ADD	R4,R4,R0
	ADD	R6,R6,R0		; screen coords
	ADD	R8,R8,R0
	LDR	R0,[R1,#16]
	LDR	R14,[R1,#24]
	SUB	R0,R0,R14
	ADD	R5,R5,R0
	ADD	R7,R7,R0
	BL	redraw_fill_rectangle	; do the coloured bar bit of rectangle
	LDRVC	R3,white$l
	MOVVC	R4,R6
	MOVVC	R6,R8
	BLVC	redraw_fill_rectangle	; do remaining bit in white
	FNRTS
white$l DCD	&FFFFFF10


;E R1=redraw block R3=fill colour R4=minx R5=miny R6=maxx R7=maxy
;X rectangle drawn if it intersects the redraw area #
	FNAME	redraw_fill_rectangle
redraw_fill_rectangle
	FNJSR	"R1-R4"
	LDR	R0,[R1,#28]		; minx
	CMP	R0,R6
	LDRLT	R0,[R1,#32]		; min y
	CMPLT	R0,R7
	FNRTS	GE
	LDR	R0,[R1,#36]		; maxx
	CMP	R0,R4
	LDRGT	R0,[R1,#40]		; maxy
	CMPGT	R0,R5
	FNRTS	LE
	MOV	R0,#4			; move
	MOV	R1,R4
	MOV	R2,R5
	SWI	XOS_Plot
	MOVVC	R0,R3
	MOVVC	R3,#0
	MOVVC	R4,#0
	SWIVC	XColourTrans_SetGCOL
	MOVVC	R0,#96+5
	MOVVC	R1,R6
	MOVVC	R2,R7
	SWIVC	XOS_Plot
	FNRTS



 END
